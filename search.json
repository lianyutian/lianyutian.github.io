[{"title":"FastAPI基础","path":"/2025/04/17/FastAPI基础/","content":"简介FastAPI 是一个用于构建 API 的现代、快速（高性能）的 web 框架，使用 Python 并基于标准的 Python 类型提示。 关键特性: 快速：可与 NodeJS 和 Go 并肩的极高性能（归功于 Starlette 和 Pydantic）。最快的 Python web 框架之一。 高效编码：提高功能开发速度约 200％ 至 300％。* 更少 bug：减少约 40％ 的人为（开发者）导致错误。* 智能：极佳的编辑器支持。处处皆可自动补全，减少调试时间。 简单：设计的易于使用和学习，阅读文档的时间更短。 简短：使代码重复最小化。通过不同的参数声明实现丰富功能。bug 更少。 健壮：生产可用级别的代码。还有自动生成的交互式文档。 标准化：基于（并完全兼容）API 的相关开放标准：OpenAPI (以前被称为 Swagger) 和 JSON Schema。 可选依赖： 用于 Pydantic： email-validator - 用于 email 校验。 用于 Starlette： httpx - 使用 TestClient 时安装。 jinja2 - 使用默认模板配置时安装。 python-multipart - 需要通过 request.form() 对表单进行「解析」时安装。 itsdangerous - 需要 SessionMiddleware 支持时安装。 pyyaml - 使用 Starlette 提供的 SchemaGenerator 时安装（有 FastAPI 你可能并不需要它）。 graphene - 需要 GraphQLApp 支持时安装。 用于 FastAPI Starlette： uvicorn - 用于加载和运行你的应用程序的服务器。 orjson - 使用 ORJSONResponse 时安装。 ujson - 使用 UJSONResponse 时安装。 你可以通过 pip install fastapi[all] 命令来安装以上所有依赖。 安装pip install fastapi[standard] 当您使用 pip install fastapi[standard] 进行安装时，它会附带一些默认的可选标准依赖项。 如果您不想安装这些可选依赖，可以选择安装 pip install fastapi。 第一步启动FastAPI main.py #!/user/bin/env python# -*- coding: utf-8 -*-@Time : 2025/4/17 14:19@Author : lianyutian@File : test.pyfrom fastapi import FastAPIapp = FastAPI()@app.get(/)async def root(): return message: Hello World # 执行(.venv) PS D:\\work\\example_workspace\\example_python\\example_FastAPI\\1.basic fastapi dev main.py FastAPI Starting development server 🚀 Searching for package file structure from directories with __init__.py files Importing from D:\\work\\example_workspace\\example_python\\example_FastAPI\\1.basic module 🐍 main.py code Importing the FastAPI app object from the module with the following code: from main import app app Using import string: main:app server Server started at http://127.0.0.1:8000 server Documentation at http://127.0.0.1:8000/docs tip Running in development mode, for production use: fastapi run Logs: INFO Will watch for changes in these directories: [D:\\\\work\\\\example_workspace\\\\example_python\\\\example_FastAPI\\\\1.basic] INFO Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) INFO Will watch for changes in these directories: [D:\\\\work\\\\example_workspace\\\\example_python\\\\example_FastAPI\\\\1.basic] INFO Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) INFO Started reloader process [9924] using WatchFiles INFO Started server process [34056] INFO Waiting for application startup. INFO Application startup complete. INFO 127.0.0.1:1250 - GET / HTTP/1.1 200 INFO 127.0.0.1:1250 - GET /favicon.ico HTTP/1.1 404 INFO 127.0.0.1:1251 - GET /docs HTTP/1.1 200 INFO 127.0.0.1:1251 - GET /openapi.json HTTP/1.1 200 INFO 127.0.0.1:1260 - GET / HTTP/1.1 200 在输出行中，会有一行信息如下： INFO Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) 该行显示了你的应用在本机所提供服务的 URL 地址。 分步概括步骤1：导入Fast APIfrom fastapi import FastAPI FastAPI 是一个为你的 API 提供了所有功能的 Python 类。 FastAPI 是直接从 Starlette 继承的类。 你可以通过 FastAPI 使用所有的 Starlette 的功能。 步骤2：创建一个 FastAPI【实例】app = FastAPI() 这里的变量 app 会是 FastAPI 类的一个「实例」。 这个实例将是创建你所有 API 的主要交互对象。 步骤 3：创建一个【路径操作】路径这里的「路径」指的是 URL 中从第一个 / 起的后半部分。 所以，在一个这样的 URL 中： https://example.com/items/foo 路径会是： /items/foo 「路径」也通常被称为「端点」或「路由」。 开发 API 时，「路径」是用来分离「关注点」和「资源」的主要手段。 操作这里的「操作」指的是一种 HTTP「方法」。 下列之一： POST GET PUT DELETE 以及更少见的几种： OPTIONS HEAD PATCH TRACE 在 HTTP 协议中，你可以使用以上的其中一种（或多种）「方法」与每个路径进行通信。 在开发 API 时，你通常使用特定的 HTTP 方法去执行特定的行为。 通常使用： POST：创建数据。 GET：读取数据。 PUT：更新数据。 DELETE：删除数据。 因此，在 OpenAPI 中，每一个 HTTP 方法都被称为「操作」。 我们也打算称呼它们为「操作」。 定义一个【路径操作装饰器】@app.get(/) @app.get(/) 告诉 FastAPI 在它下方的函数负责处理如下访问请求： 请求路径为 / 使用 get 操作 你也可以使用其他的操作： @app.post() @app.put() @app.delete() 以及更少见的： @app.options() @app.head() @app.patch() @app.trace() 步骤4：定义【路径操作函数】async def root(): 这是一个 Python 函数。 每当 FastAPI 接收一个使用 GET 方法访问 URL「/」的请求时这个函数会被调用。 在这个例子中，它是一个 async 函数。 你也可以将其定义为常规函数而不使用 async def: def root(): 步骤5：返回内容return message: Hello World 你可以返回一个 dict、list，像 str、int 一样的单个值，等等。 你还可以返回 Pydantic 模型（稍后你将了解更多）。 还有许多其他将会自动转换为 JSON 的对象和模型（包括 ORM 对象等）。 总结 导入 FastAPI。 创建一个 app 实例。 编写一个路径操作装饰器，如 @app.get(/)。 定义一个路径操作函数，如 def root(): ...。 使用命令 fastapi dev 运行开发服务器。 交互式API文档跳转到 http://127.0.0.1:8000/docs。 你将会看到自动生成的交互式 API 文档（由 Swagger UI 提供）： 路径参数概念FastAPI 支持使用 Python 字符串格式化语法声明路径参数（变量）： from fastapi import FastAPIapp = FastAPI()@app.get(/items/item_id)async def read_item(item_id): return item_id: item_id 这段代码把路径参数 item_id 的值传递给路径函数的参数 item_id。 运行示例并访问 http://127.0.0.1:8000/items/hello，可获得如下响应： 声明路径参数类型from fastapi import FastAPIapp = FastAPI()@app.get(/items_with_type/item_id)async def read_item_with_type(item_id: int): return item_id: item_id 本例把 item_id 的类型声明为 int。 当我们输入参数不为 int 类型时，会抛出如下错误： detail: [ type: int_parsing, loc: [ path, item_id ], msg: Input should be a valid integer, unable to parse string as an integer, input: ff ] FastAPI 使用 Python 类型声明实现了数据校验。 注意，上面的错误清晰地指出了未通过校验的具体原因。 这在开发调试与 API 交互的代码时非常有用。 方法定义顺序有时，路径操作中的路径是写死的。 比如要使用 /users/me 获取当前用户的数据。 然后还要使用 /users/user_id，通过用户 ID 获取指定用户的数据。 由于路径操作是按顺序依次运行的，因此，一定要在 /users/user_id 之前声明 /users/me ： from fastapi import FastAPIapp = FastAPI()@app.get(/users/me)async def read_user_me(): return user_id: the current user@app.get(/users/user_id)async def read_user(user_id: str): return user_id: user_id 此时输入 http://127.0.0.1:8000/users/me 输出如下结果： 如果方法定义顺序相反，/users/user_id 将匹配 /users/me，FastAPI 会认为正在接收值为 me 的 user_id 参数。 from fastapi import FastAPIapp = FastAPI()@app.get(/users/user_id)async def read_user(user_id: str): return user_id: user_id@app.get(/users/me)async def read_user_me(): return user_id: the current user 此时再输入 http://127.0.0.1:8000/users/me 输出如下结果： 预设值使用 Python 的 Enum 类型接收预设的路径参数。 Enum预设路径导入 Enum 并创建继承自 str 和 Enum 的子类。 通过从 str 继承，API 文档就能把值的类型定义为字符串，并且能正确渲染。 然后，创建包含固定值的类属性，这些固定值是可用的有效值： from enum import Enumclass ModelName(str, Enum): alexnet = alexnet resnet = resnet lenet = lenet 声明路径参数from enum import Enumfrom fastapi import FastAPIclass ModelName(str, Enum): alexnet = alexnet resnet = resnet lenet = lenetapp = FastAPI()@app.get(/models/model_name)async def get_model(model_name: ModelName): if model_name is ModelName.alexnet: return model_name: model_name, message: Deep Learning FTW! if model_name.value == lenet: return model_name: model_name, message: LeCNN all the images return model_name: model_name, message: Have some residuals API 文档会显示预定义路径参数的可用值： 包含路径的路径参数假设路径操作的路径为 /files/file_path。 但需要 file_path 中也包含路径，比如，home/johndoe/myfile.txt。 此时，该文件的 URL 是这样的：/files/home/johndoe/myfile.txt。 路径转换器或者使用 Starlette 的选项声明包含路径的路径参数： /files/file_path:path 本例中，参数名为 file_path，结尾部分的 :path 说明该参数应匹配路径。 用法如下： from fastapi import FastAPIapp = FastAPI()@app.get(/files/file_path:path)async def read_file(file_path: str): return file_path: file_path 注意，包含 /home/johndoe/myfile.txt 的路径参数要以斜杠（/）开头。 本例中的 URL 是 /files//home/johndoe/myfile.txt。注意，files 和 home 之间要使用双斜杠（//）。 查询参数默认值当声明的函数中【函数参数】不是【路径参数】中的一部分时，函数中的参数会被自动解释为【查询参数】 from fastapi import FastAPIapp = FastAPI()fake_items_db = [item_name: Foo, item_name: Bar, item_name: Baz]@app.get(/items/)async def read_item(skip: int = 0, limit: int = 10): return fake_items_db[skip : skip + limit] 可以看到参数默认值skip为0，limit为10。 这些值都是 URL 的组成部分，因此，它们的类型本应是字符串。 但声明 Python 类型（上例中为 int）之后，这些值就会转换为声明的类型，并进行类型校验。 可选参数from fastapi import FastAPIapp = FastAPI()@app.get(/items/item_id)async def read_item(item_id: str, q: str | None = None): if q: return item_id: item_id, q: q return item_id: item_id 本例中，查询参数 q 是可选的，默认值为 None。 注意，FastAPI 可以识别出 item_id 是路径参数，q 不是路径参数，而是查询参数。因为默认值为 = None，FastAPI 把 q 识别为可选参数。 FastAPI 不使用 Optional[str] 中的 Optional（只使用 str），但 Optional[str] 可以帮助编辑器发现代码中的错误。 查询参数类型转换from fastapi import FastAPIapp = FastAPI()@app.get(/items)async def read_item(short: bool = False): item = short: short if not short: item = short: not short return item 当short值非空 或 非False时，FastAPI 会自动转换参数类型。 多个路径和查询参数from fastapi import FastAPIapp = FastAPI()@app.get(/users/user_id/items/item_id)async def read_user_item( user_id: int, item_id: str, q: str): item = item_id: item_id, owner_id: user_id if q: item.update(q: q) return item 必选查询参数查询参数不设置默认值，那么该查询参数就是必选的。 from fastapi import FastAPIapp = FastAPI()@app.get(/items)async def read_item(item_id: int): return item_id: item_id 这里的查询参数 item_id 是类型为 int 的必选查询参数。 在浏览器中输入如下URL： http://127.0.0.1:8000/items 因为路径中没有必选参数 item_id， 返回的响应中会显示如下错误信息： detail: [ type: missing, loc: [ query, item_id ], msg: Field required, input: null ] 输入正确URL： http://127.0.0.1:8000/items?item_id=1 得到正确的返回结果： item_id: 1 请求体请求体概念FastAPI 使用请求体从客户端（例如浏览器）向 API 发送数据。 请求体是客户端发送给 API 的数据。响应体是 API 发送给客户端的数据。 API 基本上肯定要发送响应体，但是客户端不一定发送请求体。 使用 Pydantic 模型声明请求体，能充分利用它的功能和优点。 创建数据模型导入 BaseModelfrom pydantic import BaseModelclass Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None 与声明查询参数一样，包含默认值的模型属性是可选的，否则就是必选的。默认值为 None 的模型属性也是可选的。 上述模型声明如下 JSON 对象（即 Python 字典）： name: Foo, description: An optional description, price: 45.2, tax: 3.5 由于 description 和 tax 是可选的（默认值为 None），下面的 JSON 对象也有效： name: Foo, price: 45.2 声明请求体参数@app.post(/items/)async def create_item(item: Item): return item 此处，请求体参数的类型为 Item 模型。 请求体总结仅使用 Python 类型声明，FastAPI 就可以： 以 JSON 形式读取请求体 （在必要时）把请求体转换为对应的类型 校验数据： 数据无效时返回错误信息，并指出错误数据的确切位置和内容 把接收的数据赋值给参数 item 把函数中请求体参数的类型声明为 Item，还能获得代码补全等编辑器支持 使用模型from fastapi import FastAPIfrom pydantic import BaseModelclass Item(BaseModel): name: str description: str | None = None price: float tax: float | None = Noneapp = FastAPI()@app.post(/items/)async def create_item(item: Item): item_dict = item.model_dump() if item.tax is not None: price_with_tax = item.price + item.tax item_dict.update(price: price_with_tax) return item_dict if __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 入参： name: 箱子, description: 一个大箱子, price: 10, tax: 10 返回： name: 箱子, description: 一个大箱子, price: 20, tax: 10 请求体 + 路径参数from fastapi import FastAPIfrom pydantic import BaseModelclass Item(BaseModel): name: str description: str | None = None price: float tax: float | None = Noneapp = FastAPI()@app.put(/items/item_id)async def update_item(item_id: int, item: Item): return item_id: item_id, **item.model_dump() 入参： 返回： item_id: 1, name: 箱子, description: 一个大箱子, price: 10, tax: 10 请求体 + 路径参数 + 查询参数import uvicornfrom fastapi import FastAPIfrom pydantic import BaseModelclass Item(BaseModel): name: str description: str | None = None price: float tax: float | None = Noneapp = FastAPI()@app.put(/items/item_id)async def update_item(item_id: int, item: Item, q: str | None = None): result = item_id: item_id, **item.dict() if q: result.update(q: q) return resultif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 入参： 返回： item_id: 1, name: 箱子, description: 一个大箱子, price: 10, tax: 10, q: 嘎嘎 函数参数按如下规则进行识别： 路径中声明了相同参数的参数，是路径参数。类型是（int、float、str、bool 等）单类型的参数，是查询参数。类型是 Pydantic 模型的参数，是请求体。 查询参数和字符串校验FastAPI 允许我们为参数声明额外的信息和校验。以下面程序为例： import uvicornfrom fastapi import FastAPI, Queryapp = FastAPI()@app.get(/items/)async def read_items(q: str | None = Query(default=None, min_length=3, max_length=50)): results = items: [item_id: Foo, item_id: Bar] if q: results.update(q: q) return resultsif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 查询参数 q 的类型为 str，默认值为 None，因此它是可选的。 Query检验from fastapi import Queryq: str | None = Query(default=None, min_length=3, max_length=50) 将 Query 作为参数 q 的默认值。Query 显式地将 q 声明为查询参数，并设置校验条件。 无效入参： 返回： detail: [ type: string_too_short, loc: [ query, q ], msg: String should have at least 3 characters, input: 12, ctx: min_length: 3 ] 正常入参： 返回： items: [ item_id: Foo , item_id: Bar ], q: 123 正则校验from typing import Unionimport uvicornfrom fastapi import FastAPI, Queryapp = FastAPI()@app.get(/items/)async def read_items( q: Union[str, None] = Query( default=None, min_length=3, max_length=50, pattern=^fixedquery$ ),): results = items: [item_id: Foo, item_id: Bar] if q: results.update(q: q) return resultsif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 使用 pattern 设置正则表达式校验参数。 这个指定的正则表达式通过以下规则检查接收到的参数值： ^：以该符号之后的字符开头，符号之前没有字符。 fixedquery: 值精确地等于 fixedquery。 $: 到此结束，在 fixedquery 之后没有更多字符。 无效入参： 返回： detail: [ type: string_pattern_mismatch, loc: [ query, q ], msg: String should match pattern ^fixedquery$, input: 123, ctx: pattern: ^fixedquery$ ] 正常入参： 返回： items: [ item_id: Foo , item_id: Bar ], q: fixedquery Query 默认值你可以向 Query 的第一个参数传入 None 用作查询参数的默认值，以同样的方式你也可以传递其他默认值。 假设你想要声明查询参数 q，使其 min_length 为 3，并且默认值为 fixedquery： from fastapi import FastAPI, Queryapp = FastAPI()@app.get(/items/)async def read_items(q: str = Query(default=fixedquery, min_length=3)): results = items: [item_id: Foo, item_id: Bar] if q: results.update(q: q) return results 具有默认值会使该参数成为可选参数。 声明必需参数当你在使用 Query 且需要声明一个值是必需的时，只需不声明默认参数： from fastapi import FastAPI, Queryapp = FastAPI()@app.get(/items/)async def read_items(q: str = Query(min_length=3)): results = items: [item_id: Foo, item_id: Bar] if q: results.update(q: q) return results 使用 None 声明必需参数你可以声明一个参数可以接收 None 值，但它仍然是必需的。这将强制客户端发送一个值，即使该值是 None。 import uvicornfrom fastapi import FastAPI, Queryapp = FastAPI()@app.get(/items/)async def read_items(q: str | None = Query(min_length=3)): results = items: [item_id: Foo, item_id: Bar] if q: results.update(q: q) return resultsif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 入参： http://127.0.0.1:8000/items/ 返回： detail: [ type: missing, loc: [ query, q ], msg: Field required, input: null ] 查询参数列表当你使用 Query 显式地定义查询参数时，你还可以声明它去接收一组值，或换句话来说，接收多个值。 例如，要声明一个可在 URL 中出现多次的查询参数 q，你可以这样写： from typing import Listimport uvicornfrom fastapi import FastAPIfrom fastapi import Queryapp = FastAPI()@app.get(/items/)async def read_items(query: List[str] | None = Query(default=None)): query_items = query: query return query_itemsif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 然后，输入如下网址： http://localhost:8000/items/?query=123query=321 你会在路径操作函数的函数参数 q 中以一个 Python list 的形式接收到查询参数 q 的多个值。 因此，该 URL 的响应将会是： query: [ 123, 321 ] 要声明类型为 list 的查询参数，如上例所示，你需要显式地使用 Query，否则该参数将被解释为请求体。 带默认值的查询参数列表from typing import Annotatedimport uvicornfrom fastapi import FastAPI, Queryapp = FastAPI()@app.get(/items/)async def read_items(q: Annotated[list[str], Query()] = [123, 321]): query_items = q: q return query_itemsif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 输入参数包含默认值： 声明更多元数据你可以添加更多有关该参数的信息。 这些信息将包含在生成的 OpenAPI 模式中，并由文档用户界面和外部工具所使用。 from typing import Annotatedimport uvicornfrom fastapi import FastAPI, Queryapp = FastAPI()@app.get(/items/)async def read_items( q: Annotated[ str | None, Query( title=Query string, description=Query string for the items to search in the database that have a good match, min_length=3, ), ] = None,): results = items: [item_id: Foo, item_id: Bar] if q: results.update(q: q) return resultsif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 别名参数假设你想要查询参数为 item-query。 像下面这样： http://127.0.0.1:8000/items/?item-query=foobaritems 但是 item-query 不是一个有效的 Python 变量名称。 最接近的有效名称是 item_query。 但是你仍然要求它在 URL 中必须是 item-query。 这时你可以用 alias 参数声明一个别名，该别名将用于在 URL 中查找查询参数值： from typing import Annotatedfrom fastapi import FastAPI, Queryapp = FastAPI()@app.get(/items/)async def read_items(q: Annotated[str | None, Query(alias=item-query)] = None): results = items: [item_id: Foo, item_id: Bar] if q: results.update(q: q) return results 弃用参数现在假设你不再喜欢此参数。 你不得不将其保留一段时间，因为有些客户端正在使用它，但你希望文档清楚地将其展示为已弃用。 那么将参数 deprecated=True 传入 Query： from typing import Annotatedimport uvicornfrom fastapi import FastAPI, Queryapp = FastAPI()@app.get(/items/)async def read_items( q: Annotated[ str | None, Query( alias=item-query, title=Query string, description=Query string for the items to search in the database that have a good match, min_length=3, max_length=50, pattern=^fixedquery$, deprecated=True, ), ] = None,): results = items: [item_id: Foo, item_id: Bar] if q: results.update(q: q) return resultsif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 文档将会像下面这样展示它： 查询参数和字符串校验总结你可以为查询参数声明额外的校验和元数据。 通用的校验和元数据： alias title description deprecated 特定于字符串的校验： min_length max_length regex 路径参数和数值校验与使用 Query 为查询参数声明更多的校验和元数据的方式相同，你也可以使用 Path 为路径参数声明相同类型的校验和元数据。 导入 Pathfrom typing import Annotated, Unionfrom fastapi import FastAPI, Path, Queryapp = FastAPI()@app.get(/items/item_id)async def read_items( item_id: Annotated[int, Path(title=The ID of the item to get)], q: Annotated[Union[str, None], Query(alias=item-query)] = None,): results = item_id: item_id if q: results.update(q: q) return results 按需对参数排序在 Python 中，将带有默认值的参数放在不带有默认值的参数之前 Python 会报错。 在 FastAPI 中这无关紧要。它将通过参数的名称、类型和默认值声明（Query、Path 等）来检测参数，而不在乎参数的顺序。 from typing import Annotatedfrom fastapi import FastAPI, Pathapp = FastAPI()@app.get(/items/item_id)async def read_items( q: str, item_id: Annotated[int, Path(title=The ID of the item to get)]): results = item_id: item_id if q: results.update(q: q) return results 如果你想使用 Path 声明路径参数 item_id，并使它们的顺序与上面不同，Python 对此有一些特殊的语法。 传递 * 作为函数的第一个参数。 Python 不会对该 * 做任何事情，但是它将知道之后的所有参数都应作为关键字参数（键值对），也被称为 kwargs，来调用。即使它们没有默认值。 from typing import Annotatedimport uvicornfrom fastapi import FastAPI, Pathapp = FastAPI()@app.get(/items/item_id)async def red_items(*, item_id: Annotated[int, Path(title=The ID of the item to get)] = None, q: str): results = item_id: item_id if q: results.update(q: q) return resultsif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 数值校验：大于等于使用 Query 和 Path 可以声明字符串约束，但也可以声明数值约束。 像下面这样，添加 ge=1 后，item_id 将必须是一个大于（greater than）或等于（equal）1 的整数。 from typing import Annotatedfrom fastapi import FastAPI, Pathapp = FastAPI()@app.get(/items/item_id)async def read_items( item_id: Annotated[int, Path(title=The ID of the item to get, ge=1)], q: str): results = item_id: item_id if q: results.update(q: q) return results 数值校验：大于和小于等于同样的规则适用于： gt：大于（greater than） le：小于等于（less than or equal） from typing import Annotatedfrom fastapi import FastAPI, Pathapp = FastAPI()@app.get(/items/item_id)async def read_items( item_id: Annotated[int, Path(title=The ID of the item to get, gt=0, le=1000)], q: str,): results = item_id: item_id if q: results.update(q: q) return results 数值校验：浮点数、大于和小于数值校验同样适用于 float 值。 能够声明 gt 而不仅仅是 ge 在这个前提下变得重要起来。例如，你可以要求一个值必须大于 0，即使它小于 1。 因此，0.5 将是有效值。但是 0.0 或 0 不是。 对于 lt 也是一样的。 from typing import Annotatedfrom fastapi import FastAPI, Path, Queryapp = FastAPI()@app.get(/items/item_id)async def read_items( *, item_id: Annotated[int, Path(title=The ID of the item to get, ge=0, le=1000)], q: str, size: Annotated[float, Query(gt=0, lt=10.5)],): results = item_id: item_id if q: results.update(q: q) if size: results.update(size: size) return results 数值校验总结你能够以与 查询参数和字符串校验 相同的方式使用 Query、Path 声明元数据和字符串校验。 而且你还可以声明数值校验： gt：大于（greater than） ge：大于等于（greater than or equal） lt：小于（less than） le：小于等于（less than or equal） 查询参数模型如果你有一组具有相关性的查询参数，你可以创建一个 Pydantic 模型来声明它们。 这将允许你在多个地方去复用模型，并且一次性为所有参数声明验证和元数据。 使用 Pydantic 模型的查询参数在一个 Pydantic 模型中声明你需要的查询参数，然后将参数声明为 Query： from idlelib.query import Queryimport uvicorn在 Python 中，Literal 是 typing 模块提供的一个特殊类型注解，用于表示一个变量或参数只能是特定的字面量值（即具体的值，而不是类型）。它通常用于类型检查工具（如 mypy）来增强代码的类型安全性。Literal 的作用‌1.‌限制变量或参数的取值范围‌： 使用 Literal 可以明确指定某个变量或参数只能是某些特定的值，而不是任意值。 例如，一个函数参数只能是 red、green 或 blue，而不能是其他字符串。2.‌提高代码可读性和类型安全性‌： 通过 Literal，开发者可以更清晰地表达意图，类型检查器也能在编译时或静态分析时发现潜在的错误。from typing import Literal, Annotatedfrom fastapi import FastAPIfrom pydantic import BaseModel, Fieldapp = FastAPI()class FilterParams(BaseModel): limit: int = Field(100, gt=0, le=100) offset: int = Field(0, ge=0) order_by: Literal[created_at, updated_at] = created_at targs: list[str] = []@app.get(/items/)async def read_items(filter_query: Annotated[FilterParams, Query]): return filter_queryif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) FastAPI 将会从请求的查询参数中提取出每个字段的数据，并将其提供给你定义的 Pydantic 模型。 在 doc 文档中，Schema 列可以查看参数约束： 禁止额外的查询参数在一些特殊的使用场景中，你可能希望限制你要接收的查询参数。 你可以使用 Pydantic 的模型配置来 forbid（意为禁止）任何 extra（意为额外的）字段： from typing import Annotated, Literalfrom fastapi import FastAPI, Queryfrom pydantic import BaseModel, Fieldapp = FastAPI()class FilterParams(BaseModel): model_config = extra: forbid limit: int = Field(100, gt=0, le=100) offset: int = Field(0, ge=0) order_by: Literal[created_at, updated_at] = created_at tags: list[str] = []@app.get(/items/)async def read_items(filter_query: Annotated[FilterParams, Query()]): return filter_query 假设有一个客户端尝试在查询参数中发送一些额外的数据，它将会收到一个错误响应。 例如，如果客户端尝试发送一个值为 plumbus 的 tool 查询参数，如： https://example.com/items/?limit=10tool=plumbus 他们将收到一个错误响应，告诉他们查询参数 tool 是不允许的： detail: [ type: extra_forbidden, loc: [query, tool], msg: Extra inputs are not permitted, input: plumbus ] 请求体-多个参数混合使用 Path、Query 和请求体参数首先，毫无疑问地，你可以随意地混合使用 Path、Query 和请求体参数声明，FastAPI 会知道该如何处理。 你还可以通过将默认值设置为 None 来将请求体参数声明为可选参数： from typing import Annotatedfrom fastapi import FastAPI, Pathfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None print: float tax: float | None = None@app.put(/items/item_id)async def update_item( item_id: Annotated[int, Path(title=item_id, ge=0, le=1000)], q: str | None = None, item: Item | None = None): results = item_id: item_id if q: results.update(q: q) if item: results.update(item: item) return results 请注意，在这种情况下，将从请求体获取的 item 是可选的。因为它的默认值为 None。 多个请求体参数在上面的示例中，路径操作将期望一个具有 Item 的属性的 JSON 请求体，就像： name: Foo, description: The pretender, price: 42.0, tax: 3.2 但是你也可以声明多个请求体参数，例如 item 和 user： from fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None print: float tax: float | None = Noneclass User(BaseModel): username: str full_name: str | None = None@app.put(/items/item_id)async def update_item(item_id: int, item: Item, user: User): results = item_id: item_id, item: item, user: user return results 在这种情况下，FastAPI 将注意到该函数中有多个请求体参数（两个 Pydantic 模型参数）。 因此，它将使用参数名称作为请求体中的键（字段名称），并期望一个类似于以下内容的请求体： item: name: Foo, description: The pretender, price: 42.0, tax: 3.2 , user: username: dave, full_name: Dave Grohl FastAPI 将自动对请求中的数据进行转换，因此 item 参数将接收指定的内容，ßuser 参数也是如此，它将执行对复合数据的校验。 请求体当中的单一值与使用 Query 和 Path 为查询参数和路径参数定义额外数据的方式相同，FastAPI 提供了一个同等的 Body。 例如，为了扩展先前的模型，你可能决定除了 item 和 user 之外，还想在同一请求体中具有另一个键 importance。 如果你就按原样声明它，因为它是一个单一值，FastAPI 将假定它是一个查询参数。 但是你可以使用 Body 指示 FastAPI 将其作为请求体的另一个键进行处理。 from typing import Annotatedfrom fastapi import Body, FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = Noneclass User(BaseModel): username: str full_name: str | None = None@app.put(/items/item_id)async def update_item(item_id: int, item: Item, user: User, importance: Annotated[int, Body()]): return dict(item_id=item_id, item=item, user=user, importance=importance) 在这种情况下，FastAPI 将期望像这样的请求体： item: name: Foo, description: The pretender, price: 42.0, tax: 3.2 , user: username: dave, full_name: Dave Grohl , importance: 5 多个请求体参数和查询参数当然，除了请求体参数外，你还可以在任何需要的时候声明额外的查询参数。 由于默认情况下单一值被解释为查询参数，因此你不必显式地添加 Query，你可以仅执行以下操作： q: str = None 例如： from typing import Annotatedfrom fastapi import Body, FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = Noneclass User(BaseModel): username: str full_name: str | None = None@app.put(/items/item_id)async def update_item( *, item_id: int, item: Item, user: User, importance: Annotated[int, Body(gt=0)], q: str | None = None,): results = item_id: item_id, item: item, user: user, importance: importance if q: results.update(q: q) return results Body 同样具有与 Query、Path 完全相同的额外校验和元数据参数。 嵌入单个请求体参数假设你只有一个来自 Pydantic 模型 Item 的请求体参数 item。 默认情况下，FastAPI 将直接期望这样的请求体。 但是，如果你希望它期望一个拥有 item 键并在值中包含模型内容的 JSON，就像在声明额外的请求体参数时所做的那样，则可以使用一个特殊的 Body 参数 embed： item: Item = Body(embed=True) 例如： from typing import Annotatedfrom fastapi import Body, FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None@app.put(/items/item_id)async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]): results = item_id: item_id, item: item return results 在这种情况下，FastAPI 将期望像这样的请求体： item: name: Foo, description: The pretender, price: 42.0, tax: 3.2 而不是： name: Foo, description: The pretender, price: 42.0, tax: 3.2 请求体-字段与在路径操作函数中使用 Query、Path 、Body 声明校验与元数据的方式一样，可以使用 Pydantic 的 Field 在 Pydantic 模型内部声明校验和元数据。 from typing import Annotatedimport uvicornfrom fastapi import FastAPI, Bodyfrom pydantic import BaseModel, Fieldapp = FastAPI()class Item(BaseModel): name: str description: str | None = Field( default=None, title=the description of the item, max_length=100 ) price: float = Field(gt=0, description=the price of the item, must be greater than zero) tax: float | None = None@app.put(/items/item_id)async def update_item(item_id: int, item: Annotated[Item, Body(embed=True)]): result = item_id: item_id, item: item return resultif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) Field 的工作方式和 Query、Path、Body 相同，参数也相同。 实际上，Query、Path 都是 Params 的子类，而 Params 类又是 Pydantic 中 FieldInfo 的子类。 Pydantic 的 Field 返回也是 FieldInfo 的类实例。 Body 直接返回的也是 FieldInfo 的子类的对象。后文还会介绍一些 Body 的子类。 注意，从 fastapi 导入的 Query、Path 等对象实际上都是返回特殊类的函数。 注意，模型属性的类型、默认值及 Field 的代码结构与路径操作函数的参数相同，只不过是用 Field 替换了Path、Query、Body。 请求体-嵌套模型List字段你可以将一个属性定义为拥有子元素的类型。例如 Python list： from fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: list = []@app.put(/items/item_id)async def update_item(item_id: int, item: Item): results = item_id: item_id, item: item return results 这将使 tags 成为一个由元素组成的列表。不过它没有声明每个元素的类型。 具有子类型的List字段tags: list[str] = [] from fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: list[str] = []@app.put(/items/item_id)async def update_item(item_id: int, item: Item): results = item_id: item_id, item: item return results 嵌套模型Pydantic 模型的每个属性都具有类型。 但是这个类型本身可以是另一个 Pydantic 模型。 因此，你可以声明拥有特定属性名称、类型和校验的深度嵌套的 JSON 对象。 上述这些都可以任意的嵌套。 from fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Image(BaseModel): url: str name: strclass Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set[str] = set() image: Image | None = None@app.put(/items/item_id)async def update_item(item_id: int, item: Item): results = item_id: item_id, item: item return results 这意味着 FastAPI 将期望类似于以下内容的请求体： name: Foo, description: The pretender, price: 42.0, tax: 3.2, tags: [rock, metal, bar], image: url: http://example.com/baz.jpg, name: The Foo live 特殊类型和校验除了普通的单一值类型（如 str、int、float 等）外，你还可以使用从 str 继承的更复杂的单一值类型。 要了解所有的可用选项，请查看关于 来自 Pydantic 的外部类型 的文档。 例如，在 Image 模型中我们有一个 url 字段，我们可以把它声明为 Pydantic 的 HttpUrl，而不是 str： from fastapi import FastAPIfrom pydantic import BaseModel, HttpUrlapp = FastAPI()class Image(BaseModel): url: HttpUrl name: strclass Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set[str] = set() image: Image | None = None@app.put(/items/item_id)async def update_item(item_id: int, item: Item): results = item_id: item_id, item: item return results 该字符串将被检查是否为有效的 URL，并在 JSON Schema OpenAPI 文档中进行记录。 带有一组子模型的属性还可以将 Pydantic 模型用作 list、set 等的子类型： from fastapi import FastAPIfrom pydantic import BaseModel, HttpUrlapp = FastAPI()class Image(BaseModel): url: HttpUrl name: strclass Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set[str] = set() images: list[Image] | None = None@app.put(/items/item_id)async def update_item(item_id: int, item: Item): results = item_id: item_id, item: item return results 这将期望（转换，校验，记录文档等）下面这样的 JSON 请求体： name: Foo, description: The pretender, price: 42.0, tax: 3.2, tags: [ rock, metal, bar ], images: [ url: http://example.com/baz.jpg, name: The Foo live , url: http://example.com/dave.jpg, name: The Baz ] 深度嵌套模型你可以定义任意深度的嵌套模型： from fastapi import FastAPIfrom pydantic import BaseModel, HttpUrlapp = FastAPI()class Image(BaseModel): url: HttpUrl name: strclass Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set[str] = set() images: list[Image] | None = Noneclass Offer(BaseModel): name: str description: str | None = None price: float items: list[Item]@app.post(/offers/)async def create_offer(offer: Offer): return offer 示例请求体： name: string, description: string, price: 0, items: [ name: string, description: string, price: 0, tax: 0, tags: [], images: [ url: https://example.com/, name: string ] ] 纯列表请求体如果你期望的 JSON 请求体的最外层是一个 JSON array（即 Python list），则可以在路径操作函数的参数中声明此类型，就像声明 Pydantic 模型一样： images: List[Image] from fastapi import FastAPIfrom pydantic import BaseModel, HttpUrlapp = FastAPI()class Image(BaseModel): url: HttpUrl name: str@app.post(/images/multiple/)async def create_multiple_images(images: list[Image]): return images 示例请求体： [ url: https://example.com/, name: string ] 任意 dict 构成的请求体你也可以将请求体声明为使用某类型的键和其他类型值的 dict。 无需事先知道有效的字段属性（在使用 Pydantic 模型的场景）名称是什么。 如果你想接收一些尚且未知的键，这将很有用。 from fastapi import FastAPIapp = FastAPI()@app.post(/index-weights/)async def create_index_weights(weights: dict[int, float]): return weights 请记住 JSON 仅支持将 str 作为键。 但是 Pydantic 具有自动转换数据的功能。 这意味着，即使你的 API 客户端只能将字符串作为键发送，只要这些字符串内容仅包含整数，Pydantic 就会对其进行转换并校验。 然后你接收的名为 weights 的 dict 实际上将具有 int 类型的键和 float 类型的值。 模式的额外信息可以在JSON模式中定义额外的信息。 一个常见的用例是添加一个将在文档中显示的example。 有几种方法可以声明额外的 JSON 模式信息。 Pydantic schema_extra可以使用 Config 和 schema_extra 为Pydantic模型声明一个示例，如: import uvicornfrom fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None model_config = json_schema_extra: examples: [ name: Foo, description: A very nice Item, price: 35.4, tax: 3.2, ] @app.put(/items/item_id)async def update_item(item_id: int, item: Item): results = item_id: item_id, item: item return resultsif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) doc 文档显示如下： Field 的附加参数在 Field, Path, Query, Body 和其他你之后将会看到的工厂函数，你可以为JSON 模式声明额外信息，你也可以通过给工厂函数传递其他的任意参数来给 JSON 模式声明额外信息，比如增加 example: import uvicornfrom fastapi import FastAPIfrom pydantic import BaseModel, Fieldapp = FastAPI()class Item(BaseModel): name: str = Field(examples=[Foo]) description: str | None = Field(default=None, examples=[A very nice Item]) price: float = Field(examples=[35.4]) tax: float | None = Field(default=None, examples=[3.2])@app.put(/items/item_id)async def update_item(item_id: int, item: Item): results = item_id: item_id, item: item return resultsif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) doc 文档显示如上图。 Body 额外参数你可以通过传递额外信息给 Field 同样的方式操作Path, Query, Body等。 比如，你可以将请求体的一个 example 传递给 Body: from typing import Annotatedimport uvicornfrom fastapi import Body, FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None@app.put(/items/item_id)async def update_item(item_id: int, item: Annotated[Item, Body( examples=[ name: Foo, description: A very nice Item, price: 35.4, tax: 3.2, ],)]): results = item_id: item_id, item: item return resultsif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) doc显示文档如上图。 额外数据类型下面是一些你可以使用的其他数据类型: UUID: 一种标准的 “通用唯一标识符” ，在许多数据库和系统中用作ID。 在请求和响应中将以 str 表示。 datetime.datetime: 一个 Python datetime.datetime. 在请求和响应中将表示为 ISO 8601 格式的 str ，比如: 2008-09-15T15:53:00+05:00. datetime.date: Python datetime.date. 在请求和响应中将表示为 ISO 8601 格式的 str ，比如: 2008-09-15. datetime.time: 一个 Python datetime.time. 在请求和响应中将表示为 ISO 8601 格式的 str ，比如: 14:23:55.003. datetime.timedelta: 一个 Python datetime.timedelta. 在请求和响应中将表示为 float 代表总秒数。 Pydantic 也允许将其表示为 “ISO 8601 时间差异编码”。 frozenset: 在请求和响应中，作为 set 对待： 在请求中，列表将被读取，消除重复，并将其转换为一个 set。 在响应中 set 将被转换为 list 。 产生的模式将指定那些 set 的值是唯一的 (使用 JSON 模式的 uniqueItems)。 bytes: 标准的 Python bytes。 在请求和响应中被当作 str 处理。 生成的模式将指定这个 str 是 binary “格式”。 Decimal: 标准的 Python Decimal。 在请求和响应中被当做 float 一样处理。 示例： from datetime import datetime, time, timedeltafrom typing import Annotatedfrom uuid import UUIDfrom fastapi import Body, FastAPIapp = FastAPI()@app.put(/items/item_id)async def read_items( item_id: UUID, start_datetime: Annotated[datetime, Body()], end_datetime: Annotated[datetime, Body()], process_after: Annotated[timedelta, Body()], repeat_at: Annotated[time | None, Body()] = None,): start_process = start_datetime + process_after duration = end_datetime - start_process return item_id: item_id, start_datetime: start_datetime, end_datetime: end_datetime, process_after: process_after, repeat_at: repeat_at, start_process: start_process, duration: duration, Cookie参数定义 Cookie 参数与定义 Query 和 Path 参数一样。 from typing import Annotatedimport uvicornfrom fastapi import FastAPI, Cookiefrom fastapi.responses import Responseapp = FastAPI()@app.get(/items/)async def read_items(ads_id: Annotated[str | None, Cookie()] = None): return ads_id: ads_id@app.post(/set-cookie/)async def set_cookie() - Response: res = message: Cookie set response = Response(content=str(res)) response.set_cookie(key=ads_id, value=gaga) return responseif __name__ == __main__: uvicorn.run(app) 必须使用 Cookie 声明 cookie 参数，否则该参数会被解释为查询参数。 请记住，由于浏览器以特殊方式处理 cookie，并在后台进行操作，因此它们不会轻易允许 JavaScript 访问这些 cookie。 如果您访问 docs 的 API 文档 UI，您将能够查看您路径操作的 cookie 文档。 但是即使您填写数据并点击“执行”，由于文档界面使用 JavaScript，cookie 将不会被发送。而您会看到一条错误消息，就好像您没有输入任何值一样。 Header 参数定义 Header 参数的方式与定义 Query、Path、Cookie 参数相同。 声明 Header 参数from typing import Annotatedimport uvicornfrom fastapi import FastAPI, Headerapp = FastAPI()@app.get(/items/)async def read_items(user_agent: Annotated[str | None, Header()] = None): return User-Agent: user_agentif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 必须使用 Header 声明 header 参数，否则该参数会被解释为查询参数。 自动转换Header 比 Path、Query 和 Cookie 提供了更多功能。 大部分标准请求头用连字符分隔，即减号（-）。 但是 user-agent 这样的变量在 Python 中是无效的。 因此，默认情况下，Header 会把参数名中的字符由下划线（_）改为连字符（-）来提取并保存请求头 。 同时，HTTP 的请求头不区分大小写，可以使用 Python 标准样式（即 snake_case）进行声明。 因此，可以像在 Python 代码中一样使用 user_agent ，无需把首字母大写为 User_Agent 等形式。 如需禁用下划线自动转换为连字符，可以把 Header 的 convert_underscores 参数设置为 False： from typing import Annotatedimport uvicornfrom fastapi import FastAPI, Headerapp = FastAPI()@app.get(/items/)async def read_items(user_agent: Annotated[str | None, Header()] = None): return User-Agent: user_agentif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 注意，使用 convert_underscores = False 要慎重，有些 HTTP 代理和服务器不支持使用带有下划线的请求头。 重复请求头有时，可能需要接收重复的请求头。即同一个请求头有多个值。 类型声明中可以使用 list 定义多个请求头。 使用 Python list 可以接收重复请求头所有的值。 例如，声明 X-Token 多次出现的请求头，可以写成这样： from typing import Annotatedimport uvicornfrom fastapi import FastAPI, Headerapp = FastAPI()@app.get(/items/)async def read_items(x_token: Annotated[list[str] | None, Header()] = None): return X-Token values: x_tokenif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) Cookie参数模型带有 Pydantic 模型的 Cookie如果您有一组相关的 cookie，您可以创建一个 Pydantic 模型来声明它们。 这将允许您在多个地方能够重用模型，并且可以一次性声明所有参数的验证方式和元数据。 import base64from typing import Annotatedimport uvicornfrom fastapi import FastAPI, Cookie, Responsefrom pydantic import BaseModelapp = FastAPI()class Cookies(BaseModel): session_id: str session_name: str | None = None session_age: int | None = None@app.post(/set-cookies/)async def read_items() - Response: cookie_data = Cookies(session_id=123, session_name=老王, session_age=18) # 创建响应对象 response = Response(content=Cookies have been set) # 对可能包含非 latin-1 字符的值进行 Base64 编码 encoded_session_name = base64.urlsafe_b64encode( (cookie_data.session_name or ).encode(utf-8) ).decode(utf-8) # 设置多个 Cookie response.set_cookie(key=session_id, value=cookie_data.session_id) response.set_cookie(key=session_name, value=encoded_session_name) response.set_cookie(key=session_age, value=str(cookie_data.session_age) if cookie_data.session_age else ) return response@app.get(/items/)async def read_items(cookies: Annotated[Cookies, Cookie()]): return cookiesif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) FastAPI 将从请求中接收到的 cookie 中提取出每个字段的数据，并提供您定义的 Pydantic 模型。 禁止额外的 Cookie在某些特殊使用情况下（可能并不常见），您可能希望限制您想要接收的 cookie。 您可以使用 Pydantic 的模型配置来禁止（ forbid ）任何额外（ extra ）字段： from typing import Annotated, Unionfrom fastapi import Cookie, FastAPIfrom pydantic import BaseModelapp = FastAPI()class Cookies(BaseModel): model_config = extra: forbid session_id: str fatebook_tracker: Union[str, None] = None googall_tracker: Union[str, None] = None@app.get(/items/)async def read_items(cookies: Annotated[Cookies, Cookie()]): return cookies 如果客户尝试发送一些额外的 cookie，他们将收到错误响应。 例如，如果客户端尝试发送一个值为 good-list-please 的 santa_tracker cookie，客户端将收到一个错误响应，告知他们 santa_tracker cookie 是不允许的： detail: [ type: extra_forbidden, loc: [cookie, santa_tracker], msg: Extra inputs are not permitted, input: good-list-please, ] Header参数模型如果您有一组相关的 header 参数，您可以创建一个 Pydantic 模型来声明它们。 这将允许您在多个地方能够重用模型，并且可以一次性声明所有参数的验证和元数据。 使用 Pydantic 模型的 Header 参数在 Pydantic 模型中声明所需的 header 参数，然后将参数声明为 Header : from typing import Annotatedfrom fastapi import FastAPI, Headerfrom pydantic import BaseModelapp = FastAPI()class CommonHeaders(BaseModel): host: str save_data: bool if_modified_since: str | None = None traceparent: str | None = None x_tag: list[str] = []@app.get(/items/)async def read_items(headers: Annotated[CommonHeaders, Header()]): return headers FastAPI 将从请求中接收到的 headers 中提取出每个字段的数据，并提供您定义的 Pydantic 模型。 禁止额外的 Headers在某些特殊使用情况下（可能并不常见），您可能希望限制您想要接收的 headers。 您可以使用 Pydantic 的模型配置来禁止（ forbid ）任何额外（ extra ）字段： from typing import Annotatedfrom fastapi import FastAPI, Headerfrom pydantic import BaseModelapp = FastAPI()class CommonHeaders(BaseModel): model_config = extra: forbid host: str save_data: bool if_modified_since: str | None = None traceparent: str | None = None x_tag: list[str] = []@app.get(/items/)async def read_items(headers: Annotated[CommonHeaders, Header()]): return headers 如果客户尝试发送一些额外的 headers，他们将收到错误响应。 例如，如果客户端尝试发送一个值为 plumbus 的 tool header，客户端将收到一个错误响应，告知他们 header 参数 tool 是不允许的： detail: [ type: extra_forbidden, loc: [header, tool], msg: Extra inputs are not permitted, input: plumbus, ] 响应模型你可以在任意的路径操作中使用 response_model 参数来声明用于响应的模型： @app.get()@app.post()@app.put()@app.delete()等等。 from typing import Anyimport uvicornfrom fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: list[str] = []@app.get(/items/, response_model=Item)async def read_items() - Any: return name: Portal Gun, price: 42.0@app.get(/items1/)async def read_items() - Any: return [ name: Portal Gun, price: 42.0, name: Plumbus, price: 32.0, ]@app.get(/items2/, response_model=list[Item])async def read_items() - Any: return [ name: Portal Gun, price: 42.0, name: Plumbus, price: 32.0, ]if __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 注意，response_model 是「装饰器」方法（get，post 等）的一个参数。不像之前的所有参数和请求体，它不属于路径操作函数。 它接收的类型与你将为 Pydantic 模型属性所声明的类型相同，因此它可以是一个 Pydantic 模型，但也可以是一个由 Pydantic 模型组成的 list，例如 List[Item]。 FastAPI 将使用此 response_model 来： 将输出数据转换为其声明的类型。 校验数据。 在 OpenAPI 的路径操作中为响应添加一个 JSON Schema。 并在自动生成文档系统中使用。 但最重要的是：会将输出数据限制在该模型定义内。 返回与输入相同现在我们声明一个 UserIn 模型，它将包含一个明文密码属性。 from typing import Unionfrom fastapi import FastAPIfrom pydantic import BaseModel, EmailStrapp = FastAPI()class UserIn(BaseModel): username: str password: str email: EmailStr full_name: Union[str, None] = None# Dont do this in production!@app.post(/user/)async def create_user(user: UserIn) - UserIn: return userif __name__ == __main__: uvicorn.run(app) 我们正在使用此模型声明输入数据，并使用同一模型声明输出数据：现在，每当浏览器使用一个密码创建用户时，API 都会在响应中返回相同的密码。 在这个案例中，这可能不算是问题，因为用户自己正在发送密码。 但是，如果我们在其他的路径操作中使用相同的模型，则可能会将用户的密码发送给每个客户端。 相反，我们可以创建一个有明文密码的输入模型和一个没有明文密码的输出模型： from typing import Anyfrom fastapi import FastAPIfrom pydantic import BaseModel, EmailStrapp = FastAPI()class UserIn(BaseModel): username: str password: str email: EmailStr full_name: str | None = Noneclass UserOut(BaseModel): username: str email: EmailStr full_name: str | None = None@app.post(/user/, response_model=UserOut)async def create_user(user: UserIn) - Any: return user 将 response_model 声明为了不包含密码的 UserOut 模型, 因此 FastAPI 将会负责过滤掉未在输出模型中声明的所有数据（使用 Pydantic）。 响应模型默认值可以为你的响应模型设置默认值，例如： from typing import List, Unionfrom fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: Union[str, None] = None price: float tax: float = 10.5 tags: List[str] = []items = foo: name: Foo, price: 50.2, bar: name: Bar, description: The bartenders, price: 62, tax: 20.2, baz: name: Baz, description: None, price: 50.2, tax: 10.5, tags: [],@app.get(/items/item_id, response_model=Item, response_model_exclude_unset=True)async def read_item(item_id: str): return items[item_id] 但如果响应模型并没有存储实际的值，你可能想从结果中忽略它们的默认值。 举个例子，当你在 NoSQL 数据库中保存了具有许多可选属性的模型，但你又不想发送充满默认值的很长的 JSON 响应。 可以使用 response_model_exclude_unset 参数： @app.get(/items/item_id, response_model=Item, response_model_exclude_unset=True)async def read_item(item_id: str): return items[item_id] 然后响应中将不会包含那些默认值，而是仅有实际设置的值。 因此，如果你向路径操作发送 ID 为 foo 的商品的请求，则响应（不包括默认值）将为： name: Foo, price: 50.2 排除属性如果你只有一个 Pydantic 模型，并且想要从输出中移除一些数据，则可以使用这种快捷方法。 但是依然建议你使用上面提到的主意，使用多个类而不是这些参数。 这是因为即使使用 response_model_include 或 response_model_exclude 来省略某些属性，在应用程序的 OpenAPI 定义（和文档）中生成的 JSON Schema 仍将是完整的模型。 这也适用于作用类似的 response_model_by_alias。 from typing import Unionfrom fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: Union[str, None] = None price: float tax: float = 10.5items = foo: name: Foo, price: 50.2, bar: name: Bar, description: The Bar fighters, price: 62, tax: 20.2, baz: name: Baz, description: There goes my baz, price: 50.2, tax: 10.5, ,@app.get( /items/item_id/name, response_model=Item, response_model_include=name, description,)async def read_item_name(item_id: str): return items[item_id]@app.get(/items/item_id/public, response_model=Item, response_model_exclude=tax)async def read_item_public_data(item_id: str): return items[item_id] 更多模型多个关联模型这种情况很常见。 特别是用户模型，因为： 输入模型应该含密码 输出模型不应含密码 数据库模型需要加密的密码 下面的代码展示了不同模型处理密码字段的方式，及使用位置的大致思路： from fastapi import FastAPIfrom pydantic import BaseModel, EmailStrapp = FastAPI()class UserIn(BaseModel): username: str password: str email: EmailStr full_name: str | None = Noneclass UserOut(BaseModel): username: str email: EmailStr full_name: str | None = Noneclass UserInDB(BaseModel): username: str hashed_password: str email: EmailStr full_name: str | None = Nonedef fake_password_hasher(raw_password: str): return supersecret + raw_passworddef fake_save_user(user_in: UserIn): hashed_password = fake_password_hasher(user_in.password) user_in_db = UserInDB(**user_in.model_dump(), hashed_password=hashed_password) print(User saved! ..not really) return user_in_db@app.post(/user/, response_model=UserOut)async def create_user(user_in: UserIn): user_saved = fake_save_user(user_in) return user_saved 返回多个模型响应可以声明为两种类型的 Union 类型，即该响应可以是两种类型中的任意类型。 import uvicornfrom fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class BaseItem(BaseModel): description: str type: strclass CarItem(BaseItem): type: str = carclass PlaneItem(BaseItem): type: str = plane size: intitems = item1: description: All my friends drive a low rider, type: car, item2: description: Music is my aeroplane, its my aeroplane, type: plane, size: 5, ,@app.get(/items/item_id, response_model=PlaneItem | CarItem)async def read_item(item_id: str): return items[item_id]if __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 定义 Union 类型时，要把详细的类型写在前面，然后是不太详细的类型。例中，更详细的 PlaneItem 位于 Union[PlaneItem，CarItem] 中的 CarItem 之前。 此时参数 item1 匹配返回的是类型 CarItem： 参数 item2 匹配返回的是类型 PlaneItem： 任意 dict 构成响应任意的 dict 都能用于声明响应，只要声明键和值的类型，无需使用 Pydantic 模型。 事先不知道可用的字段 属性名时（Pydantic 模型必须知道字段是什么），这种方式特别有用。 此时，可以使用 typing.Dict： import uvicornfrom fastapi import FastAPIapp = FastAPI()@app.get(/keyword-weights/, response_model=dict[str, float])async def read_keyword_weights(): return foo: 2.3, bar: 3.4@app.get(/keyword-weights2/)async def read_keyword_weights(): return foo: 2.3, bar: 3.4if __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 响应状态码与指定响应模型的方式相同，在以下任意路径操作中，可以使用 status_code 参数声明用于响应的 HTTP 状态码： @app.get() @app.post() @app.put() @app.delete() 等…… import uvicornfrom fastapi import FastAPI, statusapp = FastAPI()@app.post(/items/, status_code=201)async def create_item(name: str): return name: name@app.post(/items2/, status_code=status.HTTP_200_OK)async def create_item2(name: str): return name: nameif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 注意，status_code 是（get、post 等）装饰器方法中的参数。与之前的参数和请求体不同，不是路径操作函数的参数。 status_code 参数接收表示 HTTP 状态码的数字。 更改状态码例如，假设你想默认返回一个HTTP状态码为“OK”200。 但如果数据不存在，你想创建它，并返回一个HTTP状态码为“CREATED”201。 但你仍然希望能够使用 response_model 过滤和转换你返回的数据。 对于这些情况，你可以使用一个 Response 参数。 from typing import Anyimport uvicornfrom fastapi import FastAPI, Response, statusfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: list[str] = []@app.get(/items/, response_model=Item)async def read_items() - Any: return name: Portal Gun, price: 42.0@app.get(/items2/, response_model=Item)async def read_items2(response: Response) - Any: response.status_code = status.HTTP_201_CREATED return name: Portal Gun, price: 42.0if __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 然后你可以像平常一样返回任何你需要的对象（例如一个dict或者一个数据库模型）。如果你声明了一个 response_model，它仍然会被用来过滤和转换你返回的对象。 FastAPI将使用这个临时响应来提取状态码（也包括cookies和头部），并将它们放入包含你返回的值的最终响应中，该响应由任何 response_model 过滤。 你也可以在依赖项中声明Response参数，并在其中设置状态码。但请注意，最后设置的状态码将会生效。 表单数据接收的数据不是 JSON，而是表单字段时，要使用 Form。 import uvicornfrom fastapi import FastAPI, Formfrom pydantic import BaseModelapp = FastAPI()class LoginData(BaseModel): username: str password: str@app.post(/login/)async def login(username: str = Form(...), password: str = Form(...)): return message: Login successful, username: usernameif __name__ == __main__: uvicorn.run(app) 创建表单（Form）参数的方式与 Body 和 Query 一样： async def login(username: str = Form(...), password: str = Form(...)): 使用 Form 可以声明与 Body （及 Query、Path、Cookie）相同的元数据和验证。 与 JSON 不同，HTML 表单（form/form）向服务器发送数据通常使用「特殊」的编码。 FastAPI 要确保从正确的位置读取数据，而不是读取 JSON。 表单模型你可以使用 Pydantic 模型在 FastAPI 中声明表单字段。 只需声明一个 Pydantic 模型，其中包含您希望接收的表单字段，然后将参数声明为 Form : from typing import Annotatedimport uvicornfrom fastapi import FastAPI, Formfrom pydantic import BaseModelapp = FastAPI()class FormData(BaseModel): username: str password: str@app.post(/login/)async def login(loginForm: Annotated[FormData, Form()]): return loginFormif __name__ == __main__: uvicorn.run(app) 禁止额外的表单字段在某些特殊使用情况下（可能并不常见），你可能希望将表单字段限制为仅在 Pydantic 模型中声明过的字段，并禁止任何额外的字段。 可以使用 Pydantic 的模型配置来禁止（ forbid ）任何额外（ extra ）字段： from typing import Annotatedfrom fastapi import FastAPI, Formfrom pydantic import BaseModelapp = FastAPI()class FormData(BaseModel): username: str password: str model_config = extra: forbid@app.post(/login/)async def login(data: Annotated[FormData, Form()]): return data 如果客户端尝试发送一些额外的数据，他们将收到错误响应。 例如，如果客户端尝试发送这样的表单字段： username: Rick password: Portal Gun extra: Mr. Poopybutthole 他们将收到一条错误响应，表明字段 extra 是不被允许的： detail: [ type: extra_forbidden, loc: [body, extra], msg: Extra inputs are not permitted, input: Mr. Poopybutthole ] 请求文件File 用于定义客户端的上传文件。 创建文件（File）参数的方式与 Body 和 Form 一样： from fastapi import FastAPI, File, UploadFileapp = FastAPI()@app.post(/files/)async def create_file(file: bytes = File()): return file_size: len(file)@app.post(/uploadfile/)async def create_upload_file(file: UploadFile): return filename: file.filename 声明文件体必须使用 File，否则，FastAPI 会把该参数当作查询参数或请求体（JSON）参数。 文件作为「表单数据」上传。 如果把路径操作函数参数的类型声明为 bytes，FastAPI 将以 bytes 形式读取和接收文件内容。 这种方式把文件的所有内容都存储在内存里，适用于小型文件。 不过，很多情况下，UploadFile 更好用。 UploadFile定义文件参数时使用 UploadFile： from fastapi import FastAPI, File, UploadFileapp = FastAPI()@app.post(/files/)async def create_file(file: bytes = File()): return file_size: len(file)@app.post(/uploadfile/)async def create_upload_file(file: UploadFile): return filename: file.filename UploadFile 与 bytes 相比有更多优势： 使用 spooled 文件：存储在内存的文件超出最大上限时，FastAPI 会把文件存入磁盘； 这种方式更适于处理图像、视频、二进制文件等大型文件，好处是不会占用所有内存； 可获取上传文件的元数据； 自带 file-like async 接口； 暴露的 Python SpooledTemporaryFile 对象，可直接传递给其他预期「file-like」对象的库。 UploadFile 的属性如下： filename：上传文件名字符串（str），例如， myimage.jpg； content_type：内容类型（MIME 类型 媒体类型）字符串（str），例如，image/jpeg； file： SpooledTemporaryFile（ file-like 对象）。其实就是 Python文件，可直接传递给其他预期 file-like 对象的函数或支持库。 UploadFile 支持以下 async 方法，（使用内部 SpooledTemporaryFile）可调用相应的文件方法。 write(data)：把 data （str 或 bytes）写入文件； read(size)：按指定数量的字节或字符（size (int)）读取文件内容； seek(offset)：移动至文件 offset （int）字节处的位置；例如，await myfile.seek(0) 移动到文件开头；执行 await myfile.read() 后，需再次读取已读取内容时，这种方法特别好用； close()：关闭文件。 因为上述方法都是 async 方法，要搭配「await」使用。 例如，在 async 路径操作函数 内，要用以下方式读取文件内容： contents = await myfile.read() 在普通 def 路径操作函数 内，则可以直接访问 UploadFile.file，例如： contents = myfile.file.read() 可选文件上传可以通过使用标准类型注解并将 None 作为默认值的方式将一个文件参数设为可选: from typing import Annotatedfrom fastapi import FastAPI, File, UploadFileapp = FastAPI()@app.post(/files/)async def create_file(file: Annotated[bytes | None, File()] = None): if not file: return message: No file sent else: return file_size: len(file)@app.post(/uploadfile/)async def create_upload_file(file: UploadFile | None = None): if not file: return message: No upload file sent else: return filename: file.filename 带有额外元数据的 UploadFile也可以将 File() 与 UploadFile 一起使用，例如，设置额外的元数据: from typing import Annotatedfrom fastapi import FastAPI, File, UploadFileapp = FastAPI()@app.post(/files/)async def create_file(file: Annotated[bytes, File(description=A file read as bytes)]): return file_size: len(file)@app.post(/uploadfile/)async def create_upload_file( file: Annotated[UploadFile, File(description=A file read as UploadFile)],): return filename: file.filename 多文件上传FastAPI 支持同时上传多个文件。 可用同一个「表单字段」发送含多个文件的「表单数据」。 上传多个文件时，要声明含 bytes 或 UploadFile 的列表（List）： from typing import Annotatedfrom fastapi import FastAPI, File, UploadFilefrom fastapi.responses import HTMLResponseapp = FastAPI()@app.post(/files/)async def create_files(files: Annotated[list[bytes], File()]): return file_sizes: [len(file) for file in files]@app.post(/uploadfiles/)async def create_upload_files(files: list[UploadFile]): return filenames: [file.filename for file in files]@app.get(/)async def main(): content = bodyform action=/files/ enctype=multipart/form-data method=postinput name=files type=file multipleinput type=submit/formform action=/uploadfiles/ enctype=multipart/form-data method=postinput name=files type=file multipleinput type=submit/form/body return HTMLResponse(content=content) 接收的也是含 bytes 或 UploadFile 的列表（list）。 带有额外元数据的多文件上传和之前的方式一样, 可以为 File() 设置额外参数, 即使是 UploadFile: from typing import Annotatedfrom fastapi import FastAPI, File, UploadFilefrom fastapi.responses import HTMLResponseapp = FastAPI()@app.post(/files/)async def create_files( files: Annotated[list[bytes], File(description=Multiple files as bytes)],): return file_sizes: [len(file) for file in files]@app.post(/uploadfiles/)async def create_upload_files( files: Annotated[ list[UploadFile], File(description=Multiple files as UploadFile) ],): return filenames: [file.filename for file in files]@app.get(/)async def main(): content = bodyform action=/files/ enctype=multipart/form-data method=postinput name=files type=file multipleinput type=submit/formform action=/uploadfiles/ enctype=multipart/form-data method=postinput name=files type=file multipleinput type=submit/form/body return HTMLResponse(content=content) 请求表单与文件FastAPI 支持同时使用 File 和 Form 定义文件和表单字段。 from fastapi import FastAPI, File, Form, UploadFileapp = FastAPI()@app.post(/files/)async def create_file( file: bytes = File(), fileb: UploadFile = File(), token: str = Form()): return file_size: len(file), token: token, fileb_content_type: fileb.content_type, 错误处理某些情况下，需要向客户端返回错误提示。 这里所谓的客户端包括前端浏览器、其他应用程序、物联网设备等。 需要向客户端返回错误提示的场景主要如下： 客户端没有执行操作的权限 客户端没有访问资源的权限 客户端要访问的项目不存在 等等 … 遇到这些情况时，通常要返回 4XX（400 至 499）HTTP 状态码。 4XX 状态码与表示请求成功的 2XX（200 至 299） HTTP 状态码类似。 只不过，4XX 状态码表示客户端发生的错误。 HTTPException向客户端返回 HTTP 错误响应，可以使用 HTTPException。 from fastapi import FastAPI, HTTPExceptionapp = FastAPI()items = foo: The Foo Wrestlers@app.get(/items/item_id)async def read_item(item_id: str): if item_id not in items: raise HTTPException(status_code=404, detail=Item not found) return item: items[item_id]if __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) HTTPException 是额外包含了和 API 有关数据的常规 Python 异常。 因为是 Python 异常，所以不能 return，只能 raise。 如在调用路径操作函数里的工具函数时，触发了 HTTPException，FastAPI 就不再继续执行路径操作函数中的后续代码，而是立即终止请求，并把 HTTPException 的 HTTP 错误发送至客户端。 本例中，客户端用 ID 请求的 item 不存在时，触发状态码为 404 的异常。 请求为 http://example.com/items/foo（item_id 为 foo）时，客户端会接收到 HTTP 状态码 - 200 及如下 JSON 响应结果： item: The Foo Wrestlers 但如果客户端请求 http://example.com/items/bar（item_id 为 bar 不存在时），则会接收到 HTTP 状态码 - 404（「未找到」错误）及如下 JSON 响应结果： detail: Item not found 添加自定义响应头有些场景下要为 HTTP 错误添加自定义响应头。例如，出于某些方面的安全需要。 一般情况下可能不会需要在代码中直接使用响应头。 但对于某些高级应用场景，还是需要添加自定义响应头： import uvicornfrom fastapi import FastAPI, HTTPExceptionapp = FastAPI()items = foo: The Foo @app.get(/items-header/item_id)async def read_items_header(item_id: str): if item_id not in items: raise HTTPException(status_code=404, detail=Item not found, headers=X-Error: There goes my error) return item: items[item_id]if __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 自定义异常处理添加自定义处理器，要使用 Starlette 的异常工具。 假设要触发的自定义异常叫作 UnicornException。 且需要 FastAPI 实现全局处理该异常。 此时，可以用 @app.exception_handler() 添加自定义异常控制器： import uvicornfrom fastapi import FastAPI, Requestfrom fastapi.responses import JSONResponseclass UnicornException(Exception): def __init__(self, name: str): self.name = nameapp = FastAPI()@app.exception_handler(UnicornException)async def unicorn_exception_handler(request: Request, exc: UnicornException): return JSONResponse( status_code=418, content=message: fOps! exc.name did something. There goes a rainbow..., )@app.get(/unicorns/name)async def read_unicorn(name: str): if name == yolo: raise UnicornException(name=name) return unicorn_name: nameif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 请求 /unicorns/yolo 时，路径操作会触发 UnicornException。 但该异常将会被 unicorn_exception_handler 处理。 接收到的错误信息清晰明了，HTTP 状态码为 418，JSON 内容如下： message: Oops! yolo did something. There goes a rainbow... 覆盖默认异常处理器FastAPI 自带了一些默认异常处理器。 触发 HTTPException 或请求无效数据时，这些处理器返回默认的 JSON 响应结果。 不过，也可以使用自定义处理器覆盖默认异常处理器。 覆盖请求验证异常请求中包含无效数据时，FastAPI 内部会触发 RequestValidationError。 该异常也内置了默认异常处理器。 覆盖默认异常处理器时需要导入 RequestValidationError，并用 @app.excption_handler(RequestValidationError) 装饰异常处理器。 这样，异常处理器就可以接收 Request 与异常。 import uvicornfrom fastapi import FastAPI, HTTPExceptionfrom fastapi.exceptions import RequestValidationErrorfrom fastapi.responses import PlainTextResponseapp = FastAPI()@app.exception_handler(RequestValidationError)async def validation_exception_handler(request, exc): return PlainTextResponse(str(exc), status_code=400)@app.get(/items/item_id)async def read_item(item_id: int): if item_id == 3: raise HTTPException(status_code=418, detail=Nope! I dont like 3.) return item_id: item_idif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 访问 itemsfoo，可以看到默认的 JSON 错误信息： detail: [ type: int_parsing, loc: [ path, item_id ], msg: Input should be a valid integer, unable to parse string as an integer, input: foo ] 被替换为了以下文本格式的错误信息： [type: int_parsing, loc: (path, item_id), msg: Input should be a valid integer, unable to parse string as an integer, input: foo] 使用 RequestValidationError 的请求体RequestValidationError 包含其接收到的无效数据请求的 body。 开发时，可以用这个请求体生成日志、调试错误，并返回给用户。 import uvicornfrom fastapi import FastAPI, Request, statusfrom fastapi.encoders import jsonable_encoderfrom fastapi.exceptions import RequestValidationErrorfrom openai import BaseModelfrom starlette.responses import JSONResponseapp = FastAPI()@app.exception_handler(RequestValidationError)async def validation_exception_handler(request: Request, exc: RequestValidationError): return JSONResponse( status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, content=jsonable_encoder(detail: exc.errors(), body: exc.body) )class Item(BaseModel): title: str size: int@app.post(/items/)async def create_item(item: Item): return itemif __name__ == __main__: uvicorn.run(app) 现在试着发送一个无效的 item，例如： title: towel, size: XL 收到的响应包含 body 信息，并说明数据是无效的： detail: [ type: int_parsing, loc: [ body, size ], msg: Input should be a valid integer, unable to parse string as an integer, input: XL ], body: title: towel, size: XL 覆盖 HTTPException 错误处理器import uvicornfrom fastapi import FastAPI, HTTPExceptionfrom fastapi.responses import PlainTextResponsefrom starlette.exceptions import HTTPException as StarletteHTTPExceptionapp = FastAPI()@app.exception_handler(StarletteHTTPException)async def http_exception_handler(request, exc): return PlainTextResponse(str(exc.detail), status_code=exc.status_code)@app.get(/items/item_id)async def read_item(item_id: int): if item_id == 3: raise HTTPException(status_code=418, detail=Nope! I dont like 3.) return item_id: item_idif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) FastAPI 也提供了自有的 HTTPException。 FastAPI 的 HTTPException 继承自 Starlette 的 HTTPException 错误类。 它们之间的唯一区别是，FastAPI 的 HTTPException 可以在响应中添加响应头。 OAuth 2.0 等安全工具需要在内部调用这些响应头。 因此你可以继续像平常一样在代码中触发 FastAPI 的 HTTPException 。 但注册异常处理器时，应该注册到来自 Starlette 的 HTTPException。 这样做是为了，当 Starlette 的内部代码、扩展或插件触发 Starlette HTTPException 时，处理程序能够捕获、并处理此异常。 注意，本例代码中同时使用了这两个 HTTPException，此时，要把 Starlette 的 HTTPException 命名为 StarletteHTTPException： from starlette.exceptions import HTTPException as StarletteHTTPException 复用 FastAPI 异常处理器FastAPI 支持先对异常进行某些处理，然后再使用 FastAPI 中处理该异常的默认异常处理器。 从 fastapi.exception_handlers 中导入要复用的默认异常处理器： from fastapi import FastAPI, HTTPExceptionfrom fastapi.exception_handlers import ( http_exception_handler, request_validation_exception_handler,)from fastapi.exceptions import RequestValidationErrorfrom starlette.exceptions import HTTPException as StarletteHTTPExceptionapp = FastAPI()@app.exception_handler(StarletteHTTPException)async def custom_http_exception_handler(request, exc): print(fOMG! An HTTP error!: repr(exc)) return await http_exception_handler(request, exc)@app.exception_handler(RequestValidationError)async def validation_exception_handler(request, exc): print(fOMG! The client sent invalid data!: exc) return await request_validation_exception_handler(request, exc)@app.get(/items/item_id)async def read_item(item_id: int): if item_id == 3: raise HTTPException(status_code=418, detail=Nope! I dont like 3.) return item_id: item_id 路径操作配置路径操作装饰器支持多种配置参数。 状态码from typing import Set, Unionfrom fastapi import FastAPI, statusfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: Union[str, None] = None price: float tax: Union[float, None] = None tags: Set[str] = set()@app.post(/items/, response_model=Item, status_code=status.HTTP_201_CREATED)async def create_item(item: Item): return item tags 参数tags 参数的值是由 str 组成的 list （一般只有一个 str ），tags 用于为路径操作添加标签： from typing import Set, Unionimport uvicornfrom fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: Union[str, None] = None price: float tax: Union[float, None] = None tags: Set[str] = set()@app.post(/items/, response_model=Item, tags=[items])async def create_item(item: Item): return item@app.get(/items/, tags=[items])async def read_items(): return [name: Foo, price: 42]@app.get(/users/, tags=[users])async def read_users(): return [username: johndoe]if __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) summary 和 description 参数from typing import Set, Unionimport uvicornfrom fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: Union[str, None] = None price: float tax: Union[float, None] = None tags: Set[str] = set()@app.post( /items/, response_model=Item, summary=Create an item, description=Create an item with all the information, name, description, price, tax and a set of unique tags,)async def create_item(item: Item): return itemif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 文档字符串描述内容比较长且占用多行时，可以在函数的 docstring 中声明路径操作的描述，FastAPI 支持从文档字符串中读取描述内容。 文档字符串支持 Markdown，能正确解析和显示 Markdown 的内容，但要注意文档字符串的缩进。 from typing import Set, Unionimport uvicornfrom fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: Union[str, None] = None price: float tax: Union[float, None] = None tags: Set[str] = set()@app.post(/items/, response_model=Item, summary=Create an item)async def create_item(item: Item): Create an item with all the information: - **name**: each item must have a name - **description**: a long description - **price**: required - **tax**: if the item doesnt have tax, you can omit this - **tags**: a set of unique tag strings for this item return itemif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 响应描述response_description 参数用于定义响应的描述说明： from typing import Set, Unionimport uvicornfrom fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class Item(BaseModel): name: str description: Union[str, None] = None price: float tax: Union[float, None] = None tags: Set[str] = set()@app.post( /items/, response_model=Item, summary=Create an item, response_description=The created item,)async def create_item(item: Item): Create an item with all the information: - **name**: each item must have a name - **description**: a long description - **price**: required - **tax**: if the item doesnt have tax, you can omit this - **tags**: a set of unique tag strings for this item return itemif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 弃用路径操作deprecated 参数可以把路径操作标记为弃用，无需直接删除： import uvicornfrom fastapi import FastAPIapp = FastAPI()@app.get(/items/, tags=[items])async def read_items(): return [name: Foo, price: 42]@app.get(/users/, tags=[users])async def read_users(): return [username: johndoe]@app.get(/elements/, tags=[items], deprecated=True)async def read_elements(): return [item_id: Foo]if __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) JSON 兼容编码器在某些情况下，可能需要将数据类型（如Pydantic模型）转换为与JSON兼容的数据类型（如dict、list等）。 比如，如果您需要将其存储在数据库中。 对于这种要求，FastAPI提供了 jsonable_encoder() 函数。 我们假设你有一个数据库名为fake_db，它只能接收与JSON兼容的数据。 例如，它不接收datetime这类的对象，因为这些对象与JSON不兼容。 因此，datetime对象必须将转换为包含ISO格式化的str类型对象。 同样，这个数据库也不会接收Pydantic模型（带有属性的对象），而只接收dict。 对此你可以使用jsonable_encoder。 它接收一个对象，比如Pydantic模型，并会返回一个JSON兼容的版本： from datetime import datetimefrom fastapi import FastAPIfrom fastapi.encoders import jsonable_encoderfrom pydantic import BaseModelfake_db = class Item(BaseModel): title: str timestamp: datetime description: str | None = Noneapp = FastAPI()@app.put(/items/id)def update_item(id: str, item: Item): json_compatible_item_data = jsonable_encoder(item) fake_db[id] = json_compatible_item_data@app.get(/items/id)def get_item(id: str): return fake_db[id]if __name__ == __main__: import uvicorn uvicorn.run(app) 依赖项编程中的「依赖注入」是声明代码运行所需的，或要使用的「依赖」的一种方式。 然后，由系统（本文中为 FastAPI）负责执行任意需要的逻辑，为代码提供这些依赖（「注入」依赖项）。 依赖注入常用于以下场景： 共享业务逻辑（复用相同的代码逻辑） 共享数据库连接 实现安全、验证、角色权限 等…… 上述场景均可以使用依赖注入，将代码重复最小化。 首先，要关注的是依赖项。依赖项就是一个函数，且可以使用与路径操作函数相同的参数： import uvicornfrom fastapi import FastAPIfrom fastapi.params import Dependsapp = FastAPI()async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100): return skip: skip, limit: limit, q: q@app.get(/items/)async def read_items(commons: dict = Depends(common_parameters)): return commons@app.get(/users/)async def read_users(commons: dict = Depends(common_parameters)): return commonsif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 依赖项函数的形式和结构与路径操作函数一样。因此，可以把依赖项当作没有「装饰器」（即，没有 @app.get(/some-path) ）的路径操作函数。依赖项可以返回各种内容。本例中的依赖项预期接收如下参数： 类型为 str 的可选查询参数 q 类型为 int 的可选查询参数 skip，默认值是 0 类型为 int 的可选查询参数 limit，默认值是 100 然后，依赖项函数返回包含这些值的 dict。声明依赖项需要使用 Depends 和一个新的参数，这里只能传给 Depends 一个参数。且该参数必须是可调用对象，比如函数。 接收到新的请求时，FastAPI 执行如下操作： 用正确的参数调用依赖项函数（「可依赖项」） 获取函数返回的结果 把函数返回的结果赋值给路径操作函数的参数 这样，只编写一次代码，FastAPI 就可以为多个路径操作共享这段代码 。 使用非依赖项： import uvicornfrom fastapi import FastAPIapp = FastAPI()async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100): return skip: skip, limit: limit, q: q@app.get(/items/)async def read_items(q: str | None = None, skip: int = 0, limit: int = 100): commons = await common_parameters(q, skip, limit) return commons@app.get(/users/)async def read_users(q: str | None = None, skip: int = 0, limit: int = 100): commons = await common_parameters(q, skip, limit) return commonsif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) **移除了 Depends**：我们将 函数的调用直接放在了每个路由处理器中。 common_parameters 手动传递参数：在每个路由中手动传递 、 和 参数给 函数。 q、skip、limit、common_parameters 类作为依赖项在上个例子中我们从中返回了一个 dict,我们知道编辑器不能为 dict 提供很多支持(比如补全)，因为编辑器不知道 dict 的键和值类型。所以，我们可以将上面的依赖项 “可依赖对象” common_parameters 更改为类 CommonQueryParams: import uvicornfrom fastapi import FastAPI, Dependsapp = FastAPI()fake_items_db = [item_name: Foo, item_name: Bar, item_name: Baz]class CommonQueryParams: def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100): self.q = q self.skip = skip self.limit = limit@app.get(/items/)async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)): response = if commons.q: response.update(q: commons.q) items = fake_items_db[commons.skip: commons.skip + commons.limit] response.update(items: items) return responseif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 子依赖项FastAPI 支持创建含子依赖项的依赖项。 并且，可以按需声明任意深度的子依赖项嵌套层级。 FastAPI 负责处理解析不同深度的子依赖项。 import uvicornfrom fastapi import FastAPI, Cookie, Dependsapp = FastAPI()def query_extractor(q: str | None = None): return qdef query_or_cookie_extractor( q: str = Depends(query_extractor), last_query: str | None = Cookie(default=None),): if not q: return last_query return q@app.get(/items/)async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)): return q_or_cookie: query_or_defaultif __name__ == __main__: uvicorn.run(app, host=0.0.0.0, port=8000) 注意，这里在路径操作函数中只声明了一个依赖项，即 query_or_cookie_extractor 。 但 FastAPI 必须先处理 query_extractor，以便在调用 query_or_cookie_extractor 时使用 query_extractor 返回的结果。 如果在同一个 路径操作 多次声明了同一个依赖项，例如，多个依赖项共用一个子依赖项，FastAPI 在处理同一请求时，只调用一次该子依赖项。 FastAPI 不会为同一个请求多次调用同一个依赖项，而是把依赖项的返回值进行「缓存」，并把它传递给同一请求中所有需要使用该返回值的「依赖项」。 在高级使用场景中，如果不想使用「缓存」值，而是为需要在同一请求的每一步操作（多次）中都实际调用依赖项，可以把 Depends 的参数 use_cache 的值设置为 False : async def needy_dependency(fresh_value: str = Depends(get_value, use_cache=False)): return fresh_value: fresh_value 路径操作装饰器依赖项有时，我们并不需要在路径操作函数中使用依赖项的返回值。 或者说，有些依赖项不返回值。 但仍要执行或解析该依赖项。 对于这种情况，不必在声明路径操作函数的参数时使用 Depends，而是可以在路径操作装饰器中添加一个由 dependencies 组成的 list。 import uvicornfrom fastapi import FastAPI, Header, HTTPException, Dependsapp = FastAPI()async def verify_token(x_token: str = Header()): if x_token != fake-super-secret-token: raise HTTPException(status_code=400, detail=X-Token header invalid)async def verify_key(x_key: str = Header()): if x_key != fake-super-secret-key: raise HTTPException(status_code=400, detail=X-Key header invalid) return x_key@app.get(/items/, dependencies=[Depends(verify_token), Depends(verify_key)])async def read_items(): return [item: Foo, item: Bar]if __name__ == __main__: uvicorn.run(app) 路径操作装饰器依赖项（以下简称为“路径装饰器依赖项”）的执行或解析方式和普通依赖项一样，但就算这些依赖项会返回值，它们的值也不会传递给路径操作函数。 全局依赖项有时，我们要为整个应用添加依赖项。 通过与定义路径装饰器依赖项 类似的方式，可以把依赖项添加至整个 FastAPI 应用。 这样一来，就可以为所有路径操作应用该依赖项： import uvicornfrom fastapi import Depends, FastAPI, Header, HTTPExceptionasync def verify_token(x_token: str = Header()): if x_token != fake-super-secret-token: raise HTTPException(status_code=400, detail=X-Token header invalid)async def verify_key(x_key: str = Header()): if x_key != fake-super-secret-key: raise HTTPException(status_code=400, detail=X-Key header invalid) return x_keyapp = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)])@app.get(/items/)async def read_items(): return [item: Portal Gun, item: Plumbus]@app.get(/users/)async def read_users(): return [username: Rick, username: Morty]if __name__ == __main__: uvicorn.run(app) 安全性","tags":["Web框架"]},{"title":"Docker","path":"/2025/04/08/Docker/","content":"Docker 简介 ‌什么是 Docker？ Docker 是一个开源的应用容器引擎，而一个容器 containers 其实是一个虚拟化的独立的环境，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 ‌Docker 的应用场景 开发环境标准化 持续集成持续部署（CICD） 微服务架构 快速扩展与弹性伸缩 Docker 核心概念 ‌镜像（Image）‌ 只读模板，包含应用和运行环境 分层存储结构 ‌容器（Container） 镜像的运行实例 容器生命周期管理 ‌仓库（Registry） Docker Hub 公共仓库 私有仓库搭建（如 Harbor） ‌Docker 引擎（Docker Engine） 客户端-服务器架构 组件：Docker Daemon、CLI、REST API Docker 安装与配置Docker 从 1.13 版本之后采用时间线的方式作为版本号，分为社区版 CE 和企业版 EE，社区版是免费提供给个人开发者和小型团体使用的，企业版会提供额外的收费服务，比如经过官方测试认证过的基础设施、容器、插件等。 CentOS 7（使用 yum 进行安装） # step 1: 安装必要的一些系统工具sudo yum install -y yum-utils device-mapper-persistent-data lvm2## 这步如果拉取超时可以添加yum源# docker 官方源#sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo# 阿里云源#sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# Step 2: 添加软件源信息sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# PS:如果出现如下错误信息Loaded plugins: fastestmirroradding repo from: https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repograbbing file https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.repoCould not fetch/save url https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo to file /etc/yum.repos.d/docker-ce.repo: [Errno 14] curl#60 - Peers Certificate issuer is not recognized.# 编辑 /etc/yum.conf 文件, 在 [main] 下面添加 sslverify=0 参数vi /etc/yum.conf# 配置如下----------------------[main]sslverify=0# -----------------------------# Step 3: 更新并安装Docker-CEsudo yum makecache fastsudo yum -y install docker-ce# Step 4: 开启Docker服务sudo service docker start# Step 5: 设置开机启动systemctl start dockersystemctl enable docker# Step 6：运行 hello-world 镜像，验证是否正确安装了 docker。docker run hello-world# 注意：# 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，您可以通过以下方式开启。同理可以开启各种测试版本等。# vim /etc/yum.repos.d/docker-ee.repo# 将[docker-ce-test]下方的enabled=0修改为enabled=1## 安装指定版本的Docker-CE:# Step 1: 查找Docker-CE的版本:# yum list docker-ce.x86_64 --showduplicates | sort -r# Loading mirror speeds from cached hostfile# Loaded plugins: branch, fastestmirror, langpacks# docker-ce.x86_64 17.03.1.ce-1.el7.centos docker-ce-stable# docker-ce.x86_64 17.03.1.ce-1.el7.centos @docker-ce-stable# docker-ce.x86_64 17.03.0.ce-1.el7.centos docker-ce-stable# Available Packages# Step2: 安装指定版本的Docker-CE: (VERSION例如上面的17.03.0.ce.1-1.el7.centos)# sudo yum -y install docker-ce-[VERSION] 命令介绍基础命令$ docker --help管理命令: container 管理容器 image 管理镜像 network 管理网络命令： attach 介入到一个正在运行的容器 build 根据 Dockerfile 构建一个镜像 commit 根据容器的更改创建一个新的镜像 cp 在本地文件系统与容器中复制 文件/文件夹 create 创建一个新容器 exec 在容器中执行一条命令 images 列出镜像 kill 杀死一个或多个正在运行的容器 logs 取得容器的日志 pause 暂停一个或多个容器的所有进程 ps 列出所有容器 pull 拉取一个镜像或仓库到 registry push 推送一个镜像或仓库到 registry rename 重命名一个容器 restart 重新启动一个或多个容器 rm 删除一个或多个容器 rmi 删除一个或多个镜像 run 在一个新的容器中执行一条命令 search 在 Docker Hub 中搜索镜像 start 启动一个或多个已经停止运行的容器 stats 显示一个容器的实时资源占用 stop 停止一个或多个正在运行的容器 tag 为镜像创建一个新的标签 top 显示一个容器内的所有进程 unpause 恢复一个或多个容器内所有被暂停的进程 服务管理service docker start # 启动 docker 服务，守护进程service docker stop # 停止 docker 服务service docker status # 查看 docker 服务状态 Docker 基础操作 ‌镜像操作‌ 拉取镜像：docker pull image 查看镜像：docker images 删除镜像：docker rmi image ‌容器操作 启动容器： docker run [options] image 常用参数：-d（后台运行）、-p（端口映射）、-v（数据卷） 查看容器：docker ps -a 进入容器：docker exec -it container /bin/bash 停止删除容器：docker stop/rm container ‌日志与状态 docker logs container docker stats Dockerfile 与镜像构建 ‌ Dockerfile 语法 ‌ 基础指令：FROM、RUN、COPY、CMD、ENTRYPOINT 优化指令：WORKDIR、EXPOSE、ENV ‌ 构建自定义镜像 ‌ docker build -t image-name . ‌ 镜像优化实践 ‌ 减少层数（合并 RUN 指令） 使用多阶段构建（Multi-stage Builds） 选择轻量基础镜像（如 Alpine） 数据管理与持久化 ‌ 数据卷（Volumes） ‌ 创建数据卷：docker volume create volume-name 挂载数据卷：-v volume-name:container-path ‌ 绑定挂载（Bind Mounts） ‌ 本地目录与容器目录映射 ‌ 数据卷容器 ‌ 通过容器共享数据 Docker 网络 ‌ 网络模式 ‌ bridge（默认桥接网络） host（共享主机网络） none（无网络） 自定义网络 ‌ 容器间通信 ‌ 通过容器名称或 IP 地址连接 ‌ 端口映射 ‌ -p host-port:container-port Docker Compose ‌ YAML 文件结构 ‌ version、services、volumes、networks ‌ 常用命令 ‌ docker-compose up -d docker-compose down ‌ 应用案例 ‌ 部署多容器应用（如 Web + DB） 环境变量配置（.env 文件） 最佳实践与常见问题 ‌ 最佳实践 ‌ 避免以 root 用户运行容器 定期清理无用镜像和容器 ‌ 常见问题 ‌ 容器启动失败排查（日志、端口冲突） 网络连接问题 数据卷权限问题 实战案例 ‌ 部署一个 Web 应用 ‌ 使用 Nginx + Node.js + MySQL ‌ 搭建微服务环境 ‌ 多个容器通过 Docker Compose 编排 ‌ 集成 CICD 流程 ‌ 结合 GitLab CI 或 GitHub Actions 学习资源 官方文档：https://docs.docker.com/ 推荐书籍：《Docker 实战》《Kubernetes 权威指南》 社区论坛：Stack Overflow、Docker 官方论坛","tags":["Docker"]},{"title":"区块链","path":"/2025/03/28/区块链/","content":"比特币密码学中 Hash 函数性质本质属性‌ ‌固定输出长度‌无论输入数据大小，哈希函数始终生成固定长度的摘要（如 SHA-256 输出 256 位）。 ‌确定性‌相同输入必定产生相同哈希值。 ‌高效性‌可快速计算任意输入的哈希值，满足实时应用需求。 安全特性‌ ‌单向性（抗原像攻击）‌给定哈希值 h，无法通过计算推导出原始输入 M（数学不可逆）。 ‌弱抗碰撞性（抗第二原像攻击）‌给定 M1 和 H(M1)，难以找到另一消息 M2≠M1 使得 H(M1)H(M2)。 ‌强抗碰撞性‌难以找到任意两个不同消息 M1≠M2 满足 H(M1)H(M2)。 ‌雪崩效应‌输入数据的微小改动（如 1 比特变化）会导致输出哈希值显著变化（平均 50% 比特翻转）。 密码学中的数字签名机制解析一、核心原理 非对称加密体系 基于公钥密码学，每个用户拥有私钥（保密）和公钥（公开）的密钥对。 私钥用于生成签名，公钥用于验证签名可信性。 签名生成流程 信息哈希化：对待签名数据计算哈希值（如SHA-256）。 私钥加密：用私钥加密哈希值生成数字签名（包含r,s参数）。 绑定传输：将原始数据与签名共同发送。 签名验证流程 哈希计算：接收方独立计算原始数据哈希值。 签名解密：用签名者公钥解密签名获得哈希值。 对比验证：比对两个哈希值，一致则验证通过。 二、关键特性 特性 实现机制 安全价值 不可伪造性 私钥唯一控制签名生成权 防止身份冒充 不可抵赖性 签名与私钥强绑定 追溯责任主体 数据完整性 哈希值变化导致验证失败 防内容篡改 身份认证 公钥可公开验证签名来源 确认发送方身份 三、主流算法实现 ECDSA（椭圆曲线签名） 比特币采用 secp256k1 曲线，以160位密钥实现高安全性。 优势：计算量小、签名长度短（典型65字节）。 多重签名技术 需多个私钥共同授权交易（如M-of-N模式）。 应用场景：联合账户、资金托管。 四、工作模型图解graph LRA[原始数据] -- B(哈希运算)B -- C[数据摘要]D[私钥] -- E(加密签名)C -- EE -- F[数字签名]F -- G传输G -- H[接收方]H -- I[公钥验证]I -- J[签名有效性] 比特币中使用到的 Hash 函数性质比特币系统主要依赖密码学哈希函数的三个核心性质确保其安全性与功能性，具体应用及技术依据如下： 一、核心安全性质 抗碰撞性（Collision Resistance） 确保交易数据不可篡改，任何修改都会导致区块哈希值变化，破坏区块链连续性。 典型应用：区块头通过存储前一区块哈希值形成链式结构。 单向性隐秘性（Hiding） 保护用户隐私，比特币地址由公钥经 SHA-256 和 RIPEMD-160 双重哈希生成，无法逆向推导。 典型应用：交易仅公开哈希后的地址，隐藏真实身份。 谜题友好性（Puzzle Friendly） 支撑工作量证明（PoW），矿工需暴力枚举 Nonce 使区块头哈希满足难度目标。 典型应用：挖矿过程必须通过 SHA-256(SHA-256(BlockHeader)) 计算。 二、辅助功能性质 性质 应用场景 技术价值 雪崩效应 交易微小改动导致哈希值剧变，触发分叉检测机制 增强数据完整性验证灵敏度 固定输出长度 SHA-256统一输出256位哈希，简化区块头结构（80字节） 提升网络传输与存储效率 确定性 相同交易始终生成相同哈希值，保障全节点验证一致性 维护分布式账本共识基础 三、算法实现扩展 双重SHA-256：区块头经过两次哈希运算降低碰撞概率，增强挖矿安全性。 Merkle树结构：交易哈希逐层聚合生成Merkle Root，利用抗碰撞性实现高效验证。 注：比特币通过经济激励机制（如PoW消耗资源）将哈希性质转化为去中心化信任基石。 比特币签名机制详解一、核心组件 非对称加密体系 采用椭圆曲线数字签名算法(ECDSA)，基于 secp256k1 曲线。 每个用户拥有私钥(保密)和公钥(公开)的密钥对。 签名生成流程 私钥签名：用私钥对交易哈希值加密生成数字签名。 公钥验证：通过公钥解密签名验证交易真实性。 二、完整签名过程 交易构造 包含发送方地址、接收方地址、转账金额等数据。 系统自动生成唯一交易ID防止重复。 哈希计算 对交易内容进行 SHA-256 哈希运算。 确保任何微小修改都会导致哈希值剧变。 签名生成 使用私钥加密交易哈希值。 生成包含(r,s)两个参数的ECDSA签名。 广播验证 将原始交易、签名和公钥广播至网络。 节点通过公钥验证签名与交易哈希的匹配性。 三、安全特性 特性 实现方式 防护目标 不可伪造性 只有私钥持有者能生成有效签名 防止交易伪造 不可抵赖性 签名与私钥强绑定 防止发送方否认交易 数据完整性 哈希值变化导致验证失败 防止交易内容篡改 四、技术优势 去中心化验证：任何节点都可使用公钥独立验证签名。 隐私保护：地址由公钥哈希生成，实现伪匿名性。 抗量子计算：secp256k1 曲线提供较高算法强度。 通俗版比特币签名流程（类比寄信） 准备信件（交易构造）写清楚：谁给你转账（输入）、转给谁（输出）、转多少钱（金额）。→ 就像填写汇款单：汇款人、收款人、金额。 按指纹（生成签名） 浓缩内容：把整张“汇款单”压成一道防伪码（SHA-256哈希）。→ 类似把文件塞进防篡改信封。 盖私章：用只有你有的印章（私钥）在信封封口处盖章（ECDSA签名）。→ 这个章包含特殊密码（r,s参数），别人仿不了。 寄出信件（广播交易）把“盖好章的信封”（签名交易）+ 你的公开印章模（公钥）一起寄到邮局（区块链网络）。 邮局验真伪（节点验证） 拆开信封重新计算防伪码（哈希值）。 用你的公开印章模核对封口章（公钥解密签名）。 核对成功 → 交易有效，钱可转出 ✅ 。 防伪码对不上或章不对 → 当场作废 ❌。 关键点秒懂 概念 生活比喻 作用 私钥 你的专属印章 只有你能盖章（签名） 公钥 印章的公开模子 任何人都能核对你盖的章 交易哈希 信封里的防伪码 保证内容没被掉包 签名 盖在封口的章 证明是你本人寄的信 💡 本质：不用暴露印章（私钥）就能向全网证明“这是我同意的交易” 比特币的数据结构一、核心数据结构组件 ‌哈希指针（Hash Pointer） ‌结构‌：包含指向数据块的指针 + 该数据块的哈希值（如 SHA-256）。 ‌作用‌： 检测数据篡改（哈希值不匹配即触发警报）。 实现区块间链式连接（后一区块存前一区块的哈希指针）。 ‌区块（Block） ‌区块头（80字节） 字段 长度 作用 版本号 4字节 协议版本标识（如 BIP9 软分叉） 前驱区块哈希 32字节 指向上一个区块的哈希值 Merkle树根哈希 32字节 本区块交易的指纹摘要 时间戳 4字节 区块生成时间（UNIX秒级） 难度目标 4字节 PoW 挖矿目标值（压缩格式） 随机数（Nonce） 4字节 动态调整以满足哈希条件 ‌区块体‌：存储交易列表，含 1~4MB 交易数据。 区块结构： graph LR A[区块头] -- B[版本号] A -- C[前驱区块哈希] A -- D[Merkle根哈希] A -- E[时间戳] A -- F[难度目标] A -- G[Nonce] H[区块体] -- I[交易列表] ‌默克尔树（Merkle Tree） ‌结构‌：二叉树，叶子节点为交易哈希，非叶节点为子节点哈希的组合。 ‌生成逻辑： ‌作用‌： 快速验证交易存在性（只需 O(log n) 量级路径）。 防篡改：修改任意交易将导致根哈希变化。 二、全局链式结构 ‌区块链（Blockchain） 由区块通过哈希指针串联的链表，首个区块为 ‌创世区块（Genesis Block） 特性： ‌防篡改链‌：修改任一区块将引发后续所有区块哈希值连锁失效 ‌轻节点验证‌：只需保存最近区块哈希值即可验证历史数据完整性 链式结构： graph LR Genesis[创世区块] -- Block1[区块1] Block1 -- Block2[区块2] Block2 -- Block3[...] ‌交易数据结构‌ ‌输入（Input）：引用前序交易的输出（UTXO：Unspent Transaction Output，未花费交易输出）及解锁脚本 ‌输出（Output）：包含接收方地址、转账金额及锁定脚本 ‌CoinBase交易‌：矿工奖励交易（无输入来源，2025年 3.125 BTC区块） 交易结构： graph TD T[交易] -- V[版本号] T -- IN[输入列表] T -- OUT[输出列表] T -- L[锁定时间] IN -- PREV[前序交易哈希] IN -- INDEX[输出索引] IN -- SCRIPT[解锁脚本] OUT -- VALUE[金额] OUT -- SCRIPT[锁定脚本] 三、关键特性与优化 ‌特性‌ ‌实现方式‌ ‌技术价值‌ 数据完整性 哈希指针 + Merkle树 任何篡改可被节点快速侦测 高效验证 Merkle Proof 路径验证 轻节点无需下载完整交易历史 扩容能力 区块大小动态调整（SegWit升级） 提升交易吞吐量 💡 ‌示例‌：若攻击者篡改区块N的交易，将导致： 区块N的哈希值改变 → 区块N+1的“前驱哈希”失效 Merkle树根哈希变化 → 区块头数据无效 全网节点拒绝该链，攻击失败 比特币通过哈希指针、区块头元数据及默克尔树的嵌套设计，构建了去中心化、抗篡改且可高效验证的分布式账本系统。 比特币的分布式共识比特币通过‌工作量证明（PoW）共识机制‌实现分布式共识，结合最长链原则和激励机制，确保全网节点对账本状态达成一致。以下是核心流程与技术要点： 一、共识机制核心流程 ‌交易广播与打包‌用户发起交易后向全网广播，节点收集交易并验证合法性（如签名有效性、UTXO未重复支出）。验证通过的交易进入‌内存池（mempool），等待矿工打包‌。 ‌工作量证明（PoW）竞争‌矿工将交易打包成候选区块，通过计算寻找满足特定条件的‌Nonce值‌（即区块头的哈希值需小于目标值，如以多个0开头）。此过程需大量算力，最快解出Nonce的矿工获得记账权‌。‌数学本质‌：SHA256(SHA256(区块头 + Nonce)) [9][12 Target ‌区块广播与验证‌成功挖矿的节点将新区块广播至全网，其他节点验证： Nonce值是否满足难度要求 区块内所有交易是否合法（如UTXO有效性） 区块是否链接到当前最长链的末端。 ‌最长链原则‌若出现临时分叉（如两个矿工同时解出Nonce），节点默认在‌最先收到的有效区块‌后继续挖矿。当某一分叉后续区块更多（链更长）时，全网节点将切换至最长链，丢弃短链上的区块‌。 ‌确认与不可逆性‌交易被打包进区块视为‌1次确认‌，后续每新增一个区块增加1次确认。6次确认后（约1小时），交易被视作不可逆——因攻击者需重构超过6个区块，算力成本极高‌。 二、关键支撑技术 ‌PoW的安全设计‌ ‌51%攻击防御‌：恶意节点需掌控全网51%以上算力才可能篡改历史交易，但实际成本远超收益（电力、硬件投入）‌。 ‌难度动态调整‌：每2016个区块（约两周）根据全网算力调整哈希目标值，维持平均10分钟出块速度‌。 ‌经济激励机制‌ ‌区块奖励‌：成功挖矿的矿工获得新生成的比特币（初始12.5 BTC，每4年减半）及区块内交易手续费‌。 ‌成本约束‌：矿工投入的硬件与电力成本形成“沉没成本”，激励其维护系统而非破坏‌。 三、对比其他共识机制 ‌机制‌ ‌核心逻辑‌ ‌比特币适用性‌ ‌局限性‌ PoW 算力竞争解题 高安全性，去中心化最佳 能耗巨大，效率低‌13 PoS 持币数量与时长决定 节能，但易导致中心化垄断 无利益攻击风险‌13 DPoS 持币者选举代理节点 效率高，适合高频交易场景 弱化去中心化特性‌19 四、共识挑战与应对 ‌分叉处理‌硬分叉（如BCH）需社区共识支持；软分叉（如SegWit）保持向后兼容，通过节点升级实现‌。 ‌女巫攻击防御‌PoW要求节点付出真实算力成本，防止恶意创建大量虚假节点‌。 总结比特币通过‌PoW算力竞争+最长链原则+经济激励‌的三元框架达成分布式共识，在去中心化与安全性间取得平衡。尽管存在能耗问题，但其51%攻击防御机制和链上数据的不可篡改性，使其成为当前最稳健的公有链共识模型‌。 防范双花攻击及验证交易合法性一、防范双花攻击的关键机制 ‌UTXO模型（未花费交易输出）比特币采用UTXO而非账户余额模型。每笔交易的输入必须引用先前未花费的输出，并生成新的UTXO。系统实时校验UTXO集合，确保同一笔资金无法被重复引用，从数据结构上杜绝“广播冲突型双花” ‌。 ‌工作量证明（PoW）与最长链原则‌ 矿工通过算力竞争将交易打包入区块，6次确认后交易视为不可逆（因攻击者需重构超6个区块，算力成本极高）。 节点默认接受‌最长有效链‌作为主链。攻击者需控制51%算力才可能构造替代链实施“交易回滚型双花”，但实际成本远超收益 ‌。 ‌交易确认延迟策略‌商家建议等待6个区块确认（约1小时）再交付商品。未确认交易池（mempool）会检测冲突交易，仅传播首个有效交易，后续冲突交易自动失效 ‌。 二、交易合法性验证流程 ‌密码学签名验证‌每笔交易需提供发送者对‌前序UTXO的合法签名‌，通过椭圆曲线数字签名算法（ECDSA）验证所有权，防止伪造交易 ‌。 ‌双重校验规则‌ ‌UTXO存在性‌：检查交易输入是否引用有效的未花费输出。 ‌无重复支出‌：确保同一UTXO未被其他已确认交易使用。 ‌脚本执行‌：解锁脚本（签名）需满足锁定脚本（接收方条件）要求，例如OP_CHECKSIG指令验证签名有效性 ‌。 ‌区块级共识验证‌矿工打包交易前需验证： 交易数据结构合规性（如输入输出数量） 输入总额 ≥ 输出总额（防超额支出） 时间戳符合网络规则。 比特币的挖矿比特币挖矿是比特币网络运行的核心机制，本质上是矿工通过算力竞争验证交易、生成新区块并获取奖励的过程。以下是其关键原理与流程： 一、核心目的与作用 ‌交易验证与防双花‌矿工收集未确认交易，检查签名有效性、UTXO（未花费交易输出）状态，确保无重复支付，维护交易可信度。‌ ‌区块生成与链式存储‌将合法交易打包成区块（约1MB，含4000条交易），链接到已有区块链上，形成不可篡改的分布式账本。‌ ‌激励维护网络安全‌成功挖矿的矿工获得区块奖励（新发行比特币）及交易手续费，驱动算力投入保障系统稳定。‌ 二、运作机制详解 ‌工作量证明（PoW）竞争 矿工需计算区块头的哈希值（通过SHA-256算法），使其满足网络设定的目标值（如以多个0开头）。 通过不断调整‌随机数（Nonce）‌ 反复尝试，直到找到有效解，消耗巨大算力与电力。‌ ‌最长链原则与共识达成‌ 首个解出有效Nonce的矿工将新区块广播至全网，其他节点验证后加入本地链。 若出现分叉（多个矿工同时解出），节点选择后续区块更长的链作为主链，确保全局一致。‌ ‌难度动态调整‌比特币网络每2016个区块（约两周）根据全网算力自动调整哈希目标值，维持平均10分钟出块速度。‌ 三、矿工角色与收益 ‌环节‌ ‌矿工行为‌ ‌奖励机制‌ 交易收集 筛选内存池（mempool）中未确认交易 无直接收益 区块打包与计算 耗费算力求解Nonce 成功者获区块奖励（2025年3.125 BTC）‌ 交易手续费 优先打包高手续费交易 区块内所有交易手续费归矿工所有‌ ‌总量控制‌ 区块奖励每4年减半 2140年达2100万枚上限后仅靠手续费‌ 初始区块奖励50 BTC，经历三次减半后2025年为3.125 BTC。 四、硬件演进与挑战 ‌设备专业化 ‌早期‌：普通CPUGPU即可参与（2009-2012年）‌。 ‌当前‌：ASIC矿机（专为哈希计算优化）主导，效率远超通用设备，个人矿工难竞争‌。 ‌高成本壁垒 ‌电力消耗‌：全球年耗电量超部分中小国家，引发环保争议‌。 ‌集中化风险‌：大型矿场与矿池（如Antpool、F2Pool）控制多数算力‌。 五、关键意义总结 ‌安全性保障‌：PoW机制使篡改历史交易需掌控51%算力，成本远超收益‌。 ‌去中心化基石‌：全球节点共同验证，避免单一机构控制货币系统‌。 ‌经济模型闭环‌：通过发行机制与手续费平衡矿工激励与货币稀缺性‌。 挖矿的难度比特币挖矿难度是比特币网络的核心调节机制，用于确保新区块平均每 ‌10 分钟‌ 稳定生成，其本质是控制矿工计算哈希值的“解题门槛”。以下是其关键原理及运行逻辑的综合说明。 一、挖矿难度的技术原理 ‌目标阈值（Target）决定难度‌ 矿工需寻找一个随机数（Nonce），使区块头的哈希值 ‌低于目标阈值‌（Target）。 ‌目标阈值越小‌，有效哈希值的范围越窄，矿工需尝试的计算次数越多，难度越高。 挖矿难度（Difficulty）与目标阈值成反比：$ \\text{Difficulty} \\frac{\\text{difficulty_1_target}}{\\text{target}} $其中 difficulty_1_target 是难度为 1 时的最大目标值。 ‌难度调整触发条件‌ 比特币协议每产生 ‌2016 个区块‌（约 ‌14 天‌）自动调整一次难度。 调整依据是过去 2016 个区块的实际生成时间与理论时间（20,160 分钟）的偏差：新目标值 旧目标值 × $\\frac{\\text{实际用时}}{20,160 \\text{分钟}}$若实际用时缩短（算力上升），目标值减小，难度升高；反之则难度降低。 二、难度调整的核心目的 ‌维持出块速率稳定‌ 避免算力增长导致出块过快（如＜10分钟）：防止交易确认时间缩短、分叉风险增加。 避免算力下降导致出块过慢（如＞10分钟）：确保交易处理效率及网络可用性。 ‌保障网络安全与经济平衡‌ 高难度要求攻击者需控制全网 ‌51% 以上算力‌才可能篡改交易，大幅提升攻击成本。 通过调节难度匹配当前算力水平，避免矿工因收益过低大规模退出，维护去中心化。 三、难度变化的影响因素与市场关联 ‌因素‌ ‌对难度的影响‌ ‌实例（2024–2025年） ‌全网算力变化‌ 正相关（算力↑→难度↑） 2025年4月算力达884 EHs，难度升至123.23T历史峰值 ‌比特币价格波动‌ 间接影响（价格↓→矿工退出→算力↓） 2025年1月价格暴跌致难度下调 ‌**2.12%**（110.45T→108.11T） ‌极端事件冲击‌ 短期算力骤降引发难度下调 2025年6月因高温停电事件，难度单次下调 ‌**7.48%**（创四年最大跌幅） 四、挖矿难度演变趋势（2009–2025） ‌指数级增长‌：2009年难度为 ‌1‌ → 2021年达 ‌24万亿‌ → 2024年突破 ‌100万亿‌（100T），2025年最高达 ‌123.23T‌。 ‌矿机技术迭代驱动‌：CPU挖矿（2009）→ GPU（2010）→ FPGA（2011）→ ASIC矿机（2013至今）。 💡 ‌当前现状（2025年7月）‌：比特币挖矿已进入 ‌超高门槛阶段‌，个人电脑无法参与，需依赖专业矿场与低电价资源（如伊朗、美国德州）维持盈利性。若考虑入局，需谨慎评估设备折旧（ASIC矿机）、电力成本及政策风险（如中国禁止挖矿）。 比特币脚本比特币脚本（Bitcoin Script）是比特币交易的核心验证机制，通过基于堆栈的编程语言实现交易条件的设定与验证。以下是其技术原理、功能分类及实际应用的系统解析。 一、比特币脚本的技术原理 ‌基于堆栈的执行模型‌ 脚本通过后进先出（LIFO）的堆栈结构执行操作，仅支持确定性操作（如哈希运算、签名验证），禁止循环和递归以防止死循环攻击‌。 执行流程分为两步：先运行解锁脚本（ScriptSig），再运行锁定脚本（ScriptPubKey），最终栈顶结果为 TRUE 则交易有效‌。 ‌非图灵完备性‌ 脚本语言设计为无状态、无跳转指令，无法实现复杂逻辑循环，但支持条件判断（如 OP_IF），平衡了安全性与功能性‌。 ‌脚本与UTXO的绑定关系‌ 每个未花费交易输出（UTXO）通过锁定脚本定义花费条件，而解锁脚本需提供满足条件的参数（如签名、公钥）才能解锁资金‌。 二、脚本类型与功能实现标准脚本类型 ‌P2PKH（支付到公钥哈希） ‌锁定脚本‌：OP_DUP OP_HASH160 公钥哈希 OP_EQUALVERIFY OP_CHECKSIG（转帐给谁） ‌解锁脚本‌：签名 公钥（谁来转帐） 验证流程：公钥需哈希后匹配锁定脚本中的地址，签名需验证有效性‌。 ‌P2SH（支付到脚本哈希） 将复杂脚本（如多重签名）哈希后嵌入锁定脚本，实际执行时再还原，降低交易数据量‌。 ‌多重签名（Multisig） 要求多个私钥中的指定数量（如23）签名才能解锁，常用于企业资金管理‌。 高级脚本应用 ‌时间锁（Timelock） 通过 OP_CHECKLOCKTIMEVERIFY 实现资金在特定时间后可用‌。 ‌销毁证明（Proof of Burn） 将比特币发送到不可花费的地址（如 OP_RETURN 输出），用于销毁代币或存储数据‌。 三、脚本执行示例一、基础支付脚本：P2PKH（支付到公钥哈希）‌场景‌：Alice 向 Bob 转账 1 BTC ‌锁定脚本（Bob的收款条件） OP_DUP OP_HASH160 Bob的公钥哈希 OP_EQUALVERIFY OP_CHECKSIG Bob的公钥哈希：由 Bob 的公钥经 RIPEMD160(SHA256) 生成，如 3a4b...c8d9‌ ‌解锁脚本（Bob花费时提供） Bob的签名 Bob的原始公钥 签名：Bob 用私钥对交易数据生成的一次性密码‌ ‌验证流程‌： 步骤1：将 Bob的原始公钥 哈希化 → 对比锁定脚本中的公钥哈希（OP_EQUALVERIFY） 步骤2：输入脚本中用公钥验证签名的有效性（OP_CHECKSIG） 若两步均通过，资金解锁成功‌ version: 1, // 交易协议版本 locktime: 0, // 立即生效 vin: [ txid: a1b2...c3d4, // 输入引用的前序交易ID vout: 0, // 引用前序交易的第0个输出 scriptSig: Alice签名 Alice公钥, // 解锁脚本 sequence: 0xFFFFFFFF ], vout: [ value: 1, // 输出金额（BTC） scriptPubKey: OP_DUP OP_HASH160 Bob公钥哈希 OP_EQUALVERIFY OP_CHECKSIG // 锁定脚本 ] 二、多签账户脚本：23 多重签名‌场景‌：公司资金需任意两名高管（ABC）共同签署生效 ‌锁定脚本（定义花费规则） 2 A的公钥 B的公钥 C的公钥 3 OP_CHECKMULTISIG 2/3 表示需提供至少 2 个有效签名‌ ‌解锁脚本（实际花费时提供） OP_0 A的签名 C的签名 OP_0：因历史遗留问题需前置无效占位符‌ ‌验证流程‌： 系统按公钥顺序匹配签名（A 和 C 的签名有效即通过） 若只提供 1 个签名或签名无效则失败‌ vin: [ txid: e5f6...g7h8, vout: 1, scriptSig: OP_0 A签名 C签名 redeemScript, // 提供2个签名 sequence: 0xFFFFFFFE ], vout: [ value: 2.0, scriptPubKey: OP_HASH160 redeemScript哈希 OP_EQUAL // P2SH锁定脚本 ], witness: [] // SegWit扩展字段（可选） 三、进阶脚本实例 时间锁支付（HTLC） ‌场景‌：跨链原子交换，要求 Bob 在 48 小时内提供哈希原像 ‌锁定脚本‌： OP_IF OP_SHA256 哈希值 OP_EQUALVERIFY OP_ELSE 48小时后时间戳 OP_CHECKLOCKTIMEVERIFY OP_ENDIF ‌执行逻辑‌： 若 Bob 在时限内提供正确原像（匹配哈希），立即解锁； 超时后 Alice 可自行取回资金‌ Taproot 优化脚本（P2TR） ‌场景‌：隐私增强型交易 ‌锁定脚本‌：OP_1 聚合公钥的默克尔根哈希 ‌解锁方式‌：提供单一签名 ‌或‌ 满足默克尔树中的复杂条件（如多签时间锁） ‌优势‌：链上仅显示单签交易，隐藏真实逻辑‌ 比特币分叉比特币分叉是指比特币区块链因协议规则变更或社区分歧而分裂为两条独立链的现象，本质上是区块链技术升级或社区治理矛盾的体现。 硬分叉一、硬分叉的技术定义硬分叉是指区块链协议发生‌不兼容升级‌，导致未升级节点无法验证新区块，最终分裂为两条独立运行的链。其核心特征包括： ‌协议不兼容‌：新旧节点遵循不同规则，旧节点会拒绝新节点产生的区块‌（新挖出的旧协议的节点不认可新协议的节点还是链到之前的链上）。 ‌永久性分裂‌：分叉后两条链完全独立，拥有各自的交易历史和代币‌。 ‌需全网升级‌：若部分节点拒绝升级，则必然产生分叉‌。 二、硬分叉触发条件与流程 触发条件 ‌重大协议变更‌：如修改区块大小、共识算法等底层规则‌14。 ‌社区分歧‌：开发者或矿工对升级方案无法达成共识‌67。 执行流程 ‌代码分叉‌：复制原链代码并修改协议规则（如将区块从1MB扩容至8MB）。 ‌设定激活点‌：指定区块高度或时间点触发分叉（如BCH在区块高度478558分叉）。 ‌链分裂‌：升级节点与未升级节点分别延续自己认可的链‌。 三、典型硬分叉案例 ‌比特币现金（BCH）分叉（2017） ‌背景‌：比特币1MB区块限制导致交易拥堵，社区对扩容方案产生分歧‌。 ‌分叉内容： BCH支持者将区块扩容至8MB，取消隔离见证（SegWit）‌。 分叉后持有BTC的用户1:1获得BCH‌。 ‌结果‌：BCH成为市值最高的比特币分叉币，但后续因内部矛盾再次分裂（如BCH ABC与BSV）。 ‌以太坊经典（ETC）分叉（2016） ‌背景‌：DAO黑客攻击后，以太坊社区投票决定回滚交易挽回损失‌。 ‌分叉内容： 主链（ETH）执行回滚，反对者坚持原链（ETC）以维护”代码即法律”原则‌。 ‌结果‌：ETC成为少数派链，但保留了”不可篡改”的意识形态象征‌。 四、硬分叉的影响 ‌用户资产‌：分叉前持币者自动获得新链代币，但价值取决于市场认可（如BCH曾达BTC价格的20%）。 ‌生态风险： 算力分散可能导致安全性下降（如BCH曾遭51%攻击）。 社区分裂削弱网络效应（如BTC与BCH长期竞争）。 ‌技术演进‌：推动区块链扩容方案创新（如BCH后续升级至32MB区块）。 五、与软分叉的关键区别 ‌对比维度‌ ‌硬分叉‌ ‌软分叉‌ 兼容性 不兼容旧节点 向下兼容旧节点 链分裂 必然分裂 可能避免分裂 升级要求 强制全网升级 多数算力支持即可 典型案例 BCH、ETC 比特币SegWit升级 硬分叉本质是区块链去中心化治理的体现，既是技术升级手段，也是社区共识危机的产物‌。 软分叉软分叉是区块链协议升级的一种方式，其核心特点是‌向后兼容‌，即新规则设计的交易或区块仍能被旧节点接受，通常不会导致区块链永久分裂。 ‌一、软分叉的核心机制 ‌规则子集原则‌新规则是旧规则的子集，意味着新版本认为合法的交易区块，旧版本也会认可（尽管可能不理解新规则的具体含义）。例如，比特币的隔离见证（SegWit）通过将签名数据移出主区块，旧节点仍能验证交易，但无法识别新功能。 ‌临时性分叉‌若部分节点未升级，可能短暂出现分叉，但新节点算力占优时，旧节点产生的无效区块会被抛弃，最终回归单链。 二‌、典型软分叉示例 ‌比特币SegWit升级（2017） ‌改动内容‌：将交易签名数据从区块主体移至扩展区域，间接扩容区块。 ‌兼容性‌：旧节点仍能验证交易，但无法识别 SegWit 格式的新功能。 ‌BIP34升级（区块高度嵌入） ‌改动内容‌：要求矿工在区块中必须包含高度信息。 ‌分叉处理‌：旧节点忽略该字段，新节点逐步强制校验，最终推动全网升级。 ‌三、与硬分叉的关键区别 ‌兼容性‌：软分叉新旧节点可共存，硬分叉必然分裂。 ‌升级成本‌：软分叉无需强制全网升级，硬分叉需所有节点更新。 软分叉通过温和升级平衡创新与稳定性，是区块链演化的重要工具。","tags":["区块链、比特币、ETH"],"categories":["区块链"]},{"title":"'社区商城'","path":"/2025/03/27/社区商城/","content":"项目概述项目简介主界面主要功能项目特点需求分析功能需求用户注册用户登录验证码图形验证码短信验证码上传用户头像非功能需求用户角色系统架构设计技术选型本地存储与 OSS 维度 本地存储 OSS（对象存储服务） 成本 初期投资大，硬件购买和运维成本高。 按需付费，按存储量和流量计费，初期无大额投资。 可扩展性 扩展有限，增加存储空间和带宽需要硬件投入。 弹性扩展，按需扩展，无需手动干预。 可靠性 容错能力有限，需要自行处理冗余和备份。 高可用性，数据冗余自动处理，支持多数据中心。 安全性 需要自行管理访问控制、加密和备份等。 提供强大的加密、访问控制、身份验证和审计日志。 维护与运维 需要投入人力进行硬件和软件的维护、修复。 由云厂商负责硬件和软件的维护，自动修复故障。 数据访问 局域网访问较快，跨地域访问较慢。 全球分布，低延迟，适合跨地域、大规模访问。 灵活性 配置和扩展复杂，灵活性较低。 高灵活性，支持不同类型的数据存储和生命周期管理。 合规性 需要自行管理合规要求和审计。 云厂商提供合规支持，如 GDPR、ISO 等。 使用复杂度 配置和管理复杂，需要专业技术人员。 使用简单，通过 Web 控制台或 API 进行管理。 灾难恢复 需要自行设计备份和恢复方案。 自动化备份和恢复，支持异地灾难恢复。 总结： 本地存储 适合对数据控制、性能有高度要求的场景，但成本、运维、扩展等方面存在一定的挑战。 OSS 提供了更高的弹性、可扩展性和便捷性，适合存储量大、需要全球访问或云计算集成的应用，成本相对较低，运维压力小。 根据对比存储推荐使用阿里云 OSS。 系统架构图模块划分数据库设计ER 图表结构设计接口文档接口规范接口列表项目部署项目环境部署文档开发进度项目创建初始化 创建 Maven 聚合工程 circle-shoppom.xml ?xml version=1.0 encoding=UTF-8?project xmlns=http://maven.apache.org/POM/4.0.0 xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation=http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion4.0.0/modelVersion groupIdgithub.lianyutian.cshop/groupId artifactIdcircle-shop/artifactId version1.0-SNAPSHOT/version packagingpom/packaging modules modulecshop-common/module modulecshop-user/module /modules properties java.version17/java.version maven.compiler.source17/maven.compiler.source maven.compiler.target17/maven.compiler.target project.build.sourceEncodingUTF-8/project.build.sourceEncoding !-- 版本匹配说明 -- !-- https://sca.aliyun.com/docs/2023/overview/version-explain/?spm=5176.29160081.0.0.74805c72WoVfdt -- !-- 指定 SpringBoot 版本 -- spring.boot.version3.2.4/spring.boot.version !-- 指定 SpringCloud 版本 -- spring.cloud.version2023.0.1/spring.cloud.version !-- 指定 SpringCloudAlibaba 版本 -- alibaba.cloud.version2023.0.1.0/alibaba.cloud.version !-- 指定 lombok 版本 -- lombok.version1.18.26/lombok.version !-- 通用工具包版本 -- commons-lang3.version3.14.0/commons-lang3.version !-- gson 版本 -- gson.version2.10.1/gson.version /properties dependencyManagement dependencies dependency groupIdorg.springframework.boot/groupId artifactIdspring-boot-dependencies/artifactId version$spring.boot.version/version typepom/type scopeimport/scope /dependency dependency groupIdorg.springframework.cloud/groupId artifactIdspring-cloud-dependencies/artifactId version$spring.cloud.version/version typepom/type scopeimport/scope /dependency dependency groupIdcom.alibaba.cloud/groupId artifactIdspring-cloud-alibaba-dependencies/artifactId version$alibaba.cloud.version/version typepom/type scopeimport/scope /dependency dependency groupIdorg.projectlombok/groupId artifactIdlombok/artifactId version$lombok.version/version /dependency dependency groupIdorg.apache.commons/groupId artifactIdcommons-lang3/artifactId version$commons-lang3.version/version /dependency dependency groupIdcom.google.code.gson/groupId artifactIdgson/artifactId version$gson.version/version /dependency /dependencies /dependencyManagement !-- 加快代码库下载， 这里使用阿里云镜像仓库-- repositories repository idmaven-ali/id urlhttp://maven.aliyun.com/nexus/content/groups/public///url releases enabledtrue/enabled /releases snapshots enabledtrue/enabled updatePolicyalways/updatePolicy checksumPolicyfail/checksumPolicy /snapshots /repository /repositories pluginRepositories pluginRepository idpublic/id namealiyun nexus/name urlhttp://maven.aliyun.com/nexus/content/groups/public//url releases enabledtrue/enabled /releases snapshots enabledfalse/enabled /snapshots /pluginRepository /pluginRepositories !-- springboot 打包 docker 镜像使用 -- build plugins plugin groupIdorg.springframework.boot/groupId artifactIdspring-boot-maven-plugin/artifactId version$spring.boot.version/version configuration addResourcestrue/addResources /configuration /plugin /plugins /build/project 创建子模块通用工程 cshop-commoncshop-commonpom.xml ?xml version=1.0 encoding=UTF-8?project xmlns=http://maven.apache.org/POM/4.0.0 xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation=http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion4.0.0/modelVersion parent groupIdgithub.lianyutian.cshop/groupId artifactIdcircle-shop/artifactId version1.0-SNAPSHOT/version /parent groupIdgithub.lianyutian.cshop.common/groupId artifactIdcshop-common/artifactId properties maven.compiler.source17/maven.compiler.source maven.compiler.target17/maven.compiler.target project.build.sourceEncodingUTF-8/project.build.sourceEncoding /properties dependencies dependency groupIdorg.projectlombok/groupId artifactIdlombok/artifactId /dependency dependency groupIdorg.springframework.boot/groupId artifactIdspring-boot-starter-web/artifactId /dependency dependency groupIdorg.apache.commons/groupId artifactIdcommons-lang3/artifactId /dependency dependency groupIdcom.google.code.gson/groupId artifactIdgson/artifactId /dependency /dependencies/project 统一工具类业务状态码枚举 cshop-commonsrcmainJavagithublianyutiancshopcommonenumsBizCodeEnum.Java package github.lianyutian.cshop.common.enums;import lombok.Getter;/** * 统一业务枚举状态码 * * @author lianyutian * @since 2024-12-13 13:27:13 * @version 1.0 * p 整个状态码总共 7 位，前 3 位表示「业务微服务」状态码，后 4 位表示「服务内部接口」状态码，后续需要再进行拆分。 * 公共操作：110。 * 用户服务：210， */@Getterpublic enum BizCodeEnum /** 通用操作码 */ COMMON_OP_REPEAT(110001, 重复操作), COMMON_PARAM_ERROR(110002, 参数错误), COMMON_SERVER_ERROR(110003, 服务异常), COMMON_TOO_MANY_TRY(110004, 当前访问人数过多，请稍候再试...), /** 用户微服务验证码相关 2101 开头 */ USER_PHONE_ERROR(2101001, 手机号不合法), USER_CODE_FAST_LIMITED(2101002, 验证码已发送，请稍后再发), USER_CODE_PHONE_ERROR(2101003, 手机验证码错误), USER_CODE_CAPTCHA_ERROR(2101004, 图形验证码错误), USER_CODE_EMAIL_ERROR(2101005, 邮箱验证码错误), USER_CODE_SMS_ERROR(2101006, 短信验证码错误), USER_CODE_SMS_SEND_ERROR(2101006, 短信发送失败请稍后重试), USER_CODE_SMS_SEND_REPLICATE_ERROR(2101007, 短信验证码已发送请稍后重试), USER_CODE_SEND_ERROR(2101008, 验证码发送失败，请稍后重试), /** 用户微服务账号相关 2102 开头 */ USER_ACCOUNT_EXIST(2102001, 用户已存在), USER_ACCOUNT_UNREGISTER(2102002, 用户不存在), USER_ACCOUNT_PWD_ERROR(2102003, 用户账号或密码错误), USER_REFRESH_TOKEN_EMPTY(2102004, 请重新登录), USER_ACCOUNT_UNLOGIN(2102005, 用户账号未登录), USER_LOGIN_SUCCESS(0, 用户登录成功), USER_UPDATE_LOCK_FAIL(2102006, 修改用户信息获取锁失败), USER_INFO_SHOW_LOCK_FAIL(2102007, 读取用户信息获取锁失败), /** 用户微服务上传相关 2103 开头 */ USER_AVATAR_FILE_UPLOAD_ERROR(2103001, 用户头像上传失败), /** 用户微服务收货地址相关 2104 开头 */ USER_ADDRESS_NOT_EXITS(2104001, 收货地址不存在), USER_ADDRESS_ADD_FAIL(2104002, 新增收货地址失败), USER_ADDRESS_DEL_FAIL(2104003, 删除收货地址失败), /** 用户关注、取消 2105 开头 博主关注、取消 */ USER_FOLLOWER_NOT_SELF(2105001, 不能关注自己哦), USER_UN_FOLLOWER_NOT_SELF(2105002, 不能取关自己哦), USER_FOLLOWED(2105003, 已经关注过了哦), USER_UN_FOLLOWED(2105004, 已经取关过了哦), USER_ATTENTION_NOT_SELF(2105005, 博主不能关注自己哦), USER_UN_ATTENTION_NOT_SELF(2105006, 博主不能取关自己哦), USER_ATTENTED(2105007, 已经关注过了哦), USER_UN_ATTENTED(2105008, 已经取关过了哦), USER_FOLLOWER_SUCCESS(0, 关注成功), USER_UN_FOLLOWER_SUCCESS(0, 取关成功), USER_ATTENTION_SUCCESS(0, 关注成功), USER_UN_ATTENTION_SUCCESS(0, 取关成功), USER_FOLLOWER_INFO_LOCK_FAIL(2105009, 查询用户是否关注锁失败), /** 用户笔记相关 2106 开头 */ NOTE_NOT_EXITS(2106001, 笔记不存在), NOTE_ADD_FAIL(2104002, 新增笔记失败), NOTE_DEL_FAIL(2104003, 删除笔记失败), NOTE_UPDATE_FAIL(2102004, 笔记更新失败), NOTE_UPDATE_LOCK_FAIL(2104006, 修改笔记信息获取锁失败), NOTE_INFO_LOCK_FAIL(2102007, 读取笔记信息获取锁失败); /** 错误信息 */ private final String message; /** 状态码 */ private final int code; /** * 编码 * * @param code 状态码 * @param message 错误信息 */ BizCodeEnum(int code, String message) this.code = code; this.message = message; 统一接口响应 cshop-commonsrcmainJavagithublianyutiancshopcommonmodelApiResult.Java package github.lianyutian.cshop.common.model;import github.lianyutian.cshop.common.enums.BizCodeEnum;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;/** * 接口统一响应封装 * * @author lianyutian * @since 2024-12-13 13:40:47 * @version 1.0 */@Data@AllArgsConstructor@NoArgsConstructorpublic class ApiResultT /** 接口响应状态码 0 表示成功 其他表示失败 */ private Integer code; /** 数据 */ private T data; /** 描述 */ private String msg; /** * 成功响应 * * @return @see ApiResult */ public static T ApiResultT success() return new ApiResult(0, null, null); /** * 成功响应，传入数据 * * @param data 接口数据 * @return @see ApiResult */ public static T ApiResultT success(T data) return new ApiResult(0, data, null); /** * 失败响应 * * @param code 状态码 * @return @see ApiResult */ public static T ApiResultT error(Integer code, String msg) return new ApiResult(code, null, msg); /** * 自定义状态码和错误信息 * * @param code 状态码 * @param msg 错误信息 * @return @see ApiResult */ public static T ApiResultT buildResult(int code, String msg) return new ApiResult(code, null, msg); /** * 通过枚举返回 * * @param bizCodeEnum 业务枚举状态码 * @return @see ApiResult */ public static T ApiResultT result(BizCodeEnum bizCodeEnum) return ApiResult.buildResult(bizCodeEnum.getCode(), bizCodeEnum.getMessage()); 业务异常类 cshop-commonsrcmainJavagithublianyutiancshopcommonexceptionBizException.Java package github.lianyutian.cshop.common.exception;import github.lianyutian.cshop.common.enums.BizCodeEnum;import lombok.Data;import lombok.EqualsAndHashCode;/** * 业务异常 * * @author lianyutian * @since 2024-12-13 13:54:35 * @version 1.0 */@EqualsAndHashCode(callSuper = false)@Datapublic class BizException extends RuntimeException /** 默认错误码 */ private static final int DEFAULT_ERROR_CODE = -1; /** 异常 code 码 */ private int code; /** 异常消息 */ private String message; /** * 根据 code、message 返回异常信息 * * @param code 错误码 * @param message 异常消息 */ public BizException(int code, String message) super(message); this.code = code; this.message = message; /** 根据 BizCode 返回异常信息 */ public BizException(BizCodeEnum bizCodeEnum) super(bizCodeEnum.getMessage()); this.code = bizCodeEnum.getCode(); this.message = bizCodeEnum.getMessage(); /** * 根据 errMsg 返回异常信息 * * @param errorMsg 错误信息 */ public BizException(String errorMsg) super(errorMsg); this.code = DEFAULT_ERROR_CODE; this.message = errorMsg; 全局异常处理 cshop-commonsrcmainJavagithublianyutiancshopcommonexceptionGlobalExceptionHandler.Java package github.lianyutian.cshop.common.exception;import github.lianyutian.cshop.common.model.ApiResult;import lombok.extern.slf4j.Slf4j;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;/** * 全局异常处理 * * @author lianyutian * @since 2024-12-13 14:04:58 * @version 1.0 */@ControllerAdvice@Slf4jpublic class GlobalExceptionHandler @ExceptionHandler(value = Exception.class) @ResponseBody public ApiResultString handle(Exception e) // 判断是否是业务异常还是非业务异常 if (e instanceof BizException bizException) log.error([这里是业务异常信息]，具体内容如下: , e.getMessage(), e); return ApiResult.error(bizException.getCode(), bizException.getMessage()); else log.info([这里是系统异常信息，具体内容如下: ], e.getMessage(), e); return ApiResult.error(HttpStatus.INTERNAL_SERVER_ERROR.value(), 服务异常请稍后重试); 通用工具类JsonUtil cshop-commonsrcmainJavagithublianyutiancshopcommonutilsJsonUtil.Java package github.lianyutian.cshop.common.utils;import com.google.gson.Gson;import com.google.gson.JsonSyntaxException;import lombok.extern.slf4j.Slf4j;/** * Json 工具类 * * @author lianyutian * @since 2024-12-27 14:25:42 * @version 1.0 */@Slf4jpublic class JsonUtil private static final Gson GSON = new Gson(); /** * 将对象转换为 JSON 字符串 * * @param object 需要转换的对象 * @return JSON 字符串 * @throws IllegalArgumentException 如果输入对象为 null */ public static String toJson(Object object) if (object == null) throw new IllegalArgumentException(Input object cannot be null); return GSON.toJson(object); /** * 将 JSON 字符串转换为指定类型的对象 * * @param json JSON 字符串 * @param clazz 目标类型 * @param T 泛型类型 * @return 转换后的对象 * @throws IllegalArgumentException 如果输入 JSON 字符串为 null 或空 * @throws JsonSyntaxException 如果 JSON 字符串格式不正确 */ public static T T fromJson(String json, ClassT clazz) if (json == null || json.trim().isEmpty()) throw new IllegalArgumentException(Input JSON string cannot be null or empty); try return GSON.fromJson(json, clazz); catch (JsonSyntaxException e) log.error(Failed to parse JSON string: , json, e); throw e; CommonUtil cshop-commonsrcmainJavagithublianyutiancshopcommonutilsCommonUtil.Java package github.lianyutian.cshop.common.utils;import github.lianyutian.cshop.common.exception.BizException;import github.lianyutian.cshop.common.model.ApiResult;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.net.InetAddress;import java.net.UnknownHostException;import java.nio.charset.StandardCharsets;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.Random;import java.util.UUID;import lombok.extern.slf4j.Slf4j;/** * 通用工具类 * * @author lianyutian * @since 2024-12-17 14:57:04 * @version 1.0 */@Slf4jpublic class CommonUtil /** 加密串 */ private static final String SECRET_STRING = ./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz; /** * 获取客户端 ip * * @param request HTTP 请求对象，用于获取客户端 IP 地址 * @return 客户端的 IP 地址 * @throws RuntimeException 如果获取 IP 地址失败 */ public static String getRemoteIpAddr(HttpServletRequest request) String ipAddress; try // 尝试从请求头中获取客户端 IP 地址 ipAddress = request.getHeader(x-forwarded-for); if (ipAddress == null || ipAddress.isEmpty() || unknown.equalsIgnoreCase(ipAddress)) ipAddress = request.getHeader(Proxy-Client-IP); if (ipAddress == null || ipAddress.isEmpty() || unknown.equalsIgnoreCase(ipAddress)) ipAddress = request.getHeader(WL-Proxy-Client-IP); if (ipAddress == null || ipAddress.isEmpty() || unknown.equalsIgnoreCase(ipAddress)) // 如果请求头中没有 IP 地址信息，则直接获取远程地址 ipAddress = request.getRemoteAddr(); if (127.0.0.1.equals(ipAddress)) // 如果是本地地址，则尝试获取本地主机的 IP 地址 InetAddress inet = InetAddress.getLocalHost(); ipAddress = inet.getHostAddress(); // 处理通过多个代理的情况，提取出真实的客户端 IP 地址 if (ipAddress != null ipAddress.length() 15) if (ipAddress.indexOf(,) 0) ipAddress = ipAddress.substring(0, ipAddress.indexOf(,)); if (ipAddress == null || ipAddress.isEmpty()) throw new RuntimeException(Failed to get remote IP address); catch (UnknownHostException e) log.error(e.getMessage(), e); throw new RuntimeException(Failed to get local host IP address, e); catch (Exception e) log.error(e.getMessage(), e); throw new RuntimeException(Failed to get remote IP address, e); return ipAddress; /** * MD5 加密 * * @param data 需要加密的数据 * @return 加密后的数据 * @throws RuntimeException 如果加密失败 */ public static String MD5(String data) try // 创建 MD5 加密器实例 MessageDigest md = MessageDigest.getInstance(MD5); // 对数据进行加密处理 byte[] array = md.digest(data.getBytes(StandardCharsets.UTF_8)); StringBuilder sb = new StringBuilder(); for (byte item : array) // 将加密后的字节数组转换为十六进制字符串 sb.append(Integer.toHexString((item 0xFF) | 0x100), 1, 3); // 返回加密后的字符串 return sb.toString().toUpperCase(); catch (NoSuchAlgorithmException e) log.error(e.getMessage(), e); throw new RuntimeException(Failed to create MD5 digest, e); /** * 生成指定长度的数字验证码 * * @param length 验证码的长度 * @return 生成的数字验证码 */ public static String getRandomCode(int length) String numbers = 0123456789; StringBuilder sb = new StringBuilder(); for (int i = 0; i length; i++) int index = (int) (Math.random() * numbers.length()); sb.append(numbers.charAt(index)); return sb.toString(); /** * 获取当前时间戳 * * @return 当前时间戳 */ public static long getCurrentTimestamp() return System.currentTimeMillis(); /** * 生成 UUID * * @return 生成的 UUID 字符串 */ public static String generateUUID() return UUID.randomUUID().toString().replace(-, ); /** * 向客户端发送 HTTP 响应 此方法用于将给定的 ApiResult 对象序列化为 JSON 格式 * * p 并通过 HttpServletResponse 对象将其作为 HTTP 响应返回给客户端 它处理响应的序列化和发送过程，并记录相关日志 * * @param response 用于发送响应的 HttpServletResponse 对象 * @param result 要序列化并发送的 ApiResult 对象 */ public static void sendResponse(HttpServletResponse response, ApiResultVoid result) // 设置响应头 response.setContentType(application/json; charset=utf-8); String jsonResponse; try // 将 ApiResult 对象序列化为 JSON 字符串 jsonResponse = JsonUtil.toJson(result); catch (Exception e) // 记录序列化异常信息 log.warn(序列化响应数据异常：, e.getMessage(), e); // 如果序列化失败，抛出自定义异常 throw new BizException(序列化响应数据失败); try (PrintWriter writer = response.getWriter()) // 写出响应 writer.print(jsonResponse); // 刷新响应缓冲区，确保响应被发送 response.flushBuffer(); catch (IOException e) // 记录发送响应异常信息 log.warn(返回响应给前端异常：, e.getMessage(), e); // 如果发送响应失败，抛出自定义异常 throw new BizException(返回响应给前端失败); // 如果启用了信息级别日志记录，记录发送的响应数据 if (log.isInfoEnabled()) log.info(返回响应给前端数据：, jsonResponse); /** * 生成区间范围内的随机数 * * @param min min * @param max max * @return 随机数 */ public static int genRandomInt(int min, int max) return genRandomInt(max - min) + min; /** * 生成随机数 * * @param bound bound * @return 随机数 */ public static int genRandomInt(int bound) return new Random().nextInt(bound); CheckUtil cshop-commonsrcmainJavagithublianyutiancshopcommonutilsCheckUtil.Java package github.lianyutian.cshop.common.utils;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 校验工具类 * * @author lianyutian * @since 2024-12-19 13:38:22 * @version 1.0 */public class CheckUtil /** 手机号正则 */ private static final Pattern PHONE_PATTERN = Pattern.compile(^((13[0-9])|(15[^4,\\\\D])|(18[0,5-9]))\\\\d8$); /** * 检测是否是手机号 * * @param phone 手机号 * @return boolean */ public static boolean isPhone(String phone) if (null == phone || .equals(phone)) return false; Matcher m = PHONE_PATTERN.matcher(phone); return m.matches(); BeanUtil cshop-commonsrcmainJavagithublianyutiancshopcommonutilsBeanUtil.Java package github.lianyutian.cshop.common.utils;import java.lang.reflect.Constructor;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.BeanUtils;/** * Bean 拷贝工具类 * * @author lianyutian * @since 2025-01-03 15:09:31 * @version 1.0 */@Slf4jpublic class BeanUtil private static final ConstructorCache CONSTRUCTOR_CACHE = new ConstructorCache(); public static T T copy(Object source, ClassT targetClass) if (source == null) return null; T target; try ConstructorT constructor = CONSTRUCTOR_CACHE.getConstructor(targetClass); target = constructor.newInstance(); BeanUtils.copyProperties(source, target); catch (ReflectiveOperationException e) log.error( Failed to copy properties from to , source.getClass().getName(), targetClass.getName(), e); throw new BeanCopyException(Failed to copy properties, e); return target; public static T ListT copyList(List? sourceList, ClassT targetClass) if (sourceList == null || sourceList.isEmpty()) return null; ListT targetList = new ArrayList(sourceList.size()); for (Object source : sourceList) T target = copy(source, targetClass); if (target != null) targetList.add(target); return targetList; private static class ConstructorCache private final MapClass?, Constructor? cache = new ConcurrentHashMap(); @SuppressWarnings(unchecked) public T ConstructorT getConstructor(ClassT clazz) throws ReflectiveOperationException ConstructorT constructor = (ConstructorT) cache.get(clazz); if (constructor == null) synchronized (cache) constructor = (ConstructorT) cache.get(clazz); if (constructor == null) try constructor = clazz.getDeclaredConstructor(); constructor.setAccessible(true); cache.put(clazz, constructor); catch (NoSuchMethodException e) throw new ReflectiveOperationException(e); return constructor; public static class BeanCopyException extends RuntimeException public BeanCopyException(String message, Throwable cause) super(message, cause); Redis pom.xml !-- redisson 版本 --redisson.version3.41.0/redisson.version!-- https://mvnrepository.com/artifact/org.redisson/redisson --dependency groupIdorg.redisson/groupId artifactIdredisson/artifactId version$redisson.version/version/dependency cshop-commonpom.xml dependency groupIdorg.springframework.boot/groupId artifactIdspring-boot-starter-data-redis/artifactId/dependency!-- https://mvnrepository.com/artifact/org.redisson/redisson --dependency groupIdorg.redisson/groupId artifactIdredisson/artifactId/dependencydependencygroupIdorg.springframework.boot/groupIdartifactIdspring-boot-starter-data-redis/artifactId/dependency RedisConfig cshop-commonsrcmainJavagithublianyutiancshopcommonredisRedisConfig.Java package github.lianyutian.cshop.common.redis;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.redisson.Redisson;import org.redisson.api.RedissonClient;import org.redisson.client.codec.StringCodec;import org.redisson.config.Config;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;/** * redis 客户端配置 * * @author lianyutian * @since 2024-12-17 14:36:40 * @version 1.0 */@Configuration@ConditionalOnClass(RedisConnectionFactory.class)// 配置是否使用 redis (enable = true 时需要配置 redis，否则服务启动时会报错)@ConditionalOnProperty(prefix = spring.data.redis, name = enable, havingValue = true)public class RedisConfig @Value($spring.data.redis.host) private String redisHost; @Value($spring.data.redis.port) private String redisPort; @Value($spring.data.redis.password) private String redisPwd; @Value($spring.data.redis.timeout) private int redisTimeout; /** * 配置 RedisTemplate 用于操作 Redis 数据库 * * @param redisConnectionFactory Redis 连接工厂，用于创建 Redis 连接 * @return 配置好的 RedisTemplate 实例 */ @Bean public RedisTemplateObject, Object redisTemplate( RedisConnectionFactory redisConnectionFactory) // 实例化 RedisTemplate RedisTemplateObject, Object redisTemplate = new RedisTemplate(); // 设置连接 redisTemplate.setConnectionFactory(redisConnectionFactory); // 配置 Redis 序列化规则 // 使用 Jackson 作为 JSON 处理库。该序列化器可以用于将 Java 对象存储到 Redis 中时，自动转换为 JSON 字符串 ObjectMapper objectMapper = new ObjectMapper(); Jackson2JsonRedisSerializerObject jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(objectMapper, Object.class); // 设置 ObjectMapper 的可见性，以便它可以序列化和反序列化所有访问级别的属性 objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); // 设置 key-value 序列化规则 // 使用 StringRedisSerializer 序列化 key，以确保 key 是字符串形式存储 // 使用 Jackson2JsonRedisSerializer 序列化 value，将 Java 对象转换为 JSON 字符串存储 redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(jackson2JsonRedisSerializer); // 设置 hash-value 序列化规则 // 同样地，使用 StringRedisSerializer 序列化 hash 的 key，使用 Jackson2JsonRedisSerializer 序列化 hash 的 value redisTemplate.setHashKeySerializer(new StringRedisSerializer()); redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer); return redisTemplate; /** * 实例化 redissonClient * * @return RedissonClient */ @Bean public RedissonClient redissonClient() Config config = new Config(); config .useSingleServer() .setAddress(redis:// + redisHost + : + redisPort) .setPassword(redisPwd) // 设置连接池最小空闲大小 .setConnectionMinimumIdleSize(10) // 设置连接池大小 .setConnectionPoolSize(100) // 设置空闲链接超时时间 .setIdleConnectionTimeout(600000) .setSubscriptionConnectionMinimumIdleSize(10) .setSubscriptionConnectionPoolSize(100) // 设置超时时间 .setTimeout(redisTimeout); config.setCodec(new StringCodec()); // 设置线程数 config.setThreads(5); // 设置 netty 线程数 config.setNettyThreads(5); // 实例化 redisson 客户端 return Redisson.create(config); RedisCache cshop-commonsrcmainJavagithublianyutiancshopcommonredisRedisCache.Java package github.lianyutian.cshop.common.redis;import github.lianyutian.cshop.common.utils.CommonUtil;import github.lianyutian.cshop.common.utils.JsonUtil;import java.util.concurrent.TimeUnit;import lombok.extern.slf4j.Slf4j;import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.stereotype.Component;/** * Redis 缓存工具类 * * @author lianyutian * @since 2024-12-27 11:30:30 * @version 1.0 */@Component@ConditionalOnBean(RedisConfig.class)@Slf4jpublic class RedisCache private final RedisTemplateString, String redisTemplate; /** 缓存空数据 */ public static final String EMPTY_CACHE = ; /** 分布式锁加锁时间 200 毫秒 */ public static final long UPDATE_LOCK_TIMEOUT = 200; /** 一小时有效期 */ public static final Integer ONE_HOUR_SECONDS = 60 * 60; /** 两天有效期 */ public static final Integer TWO_DAYS_SECONDS = 2 * 24 * 60 * 60; /** 一天有效期 */ public static final Integer ONE_DAY_SECONDS = 24 * 60 * 60; public RedisCache(RedisTemplateString, String redisTemplate) this.redisTemplate = redisTemplate; /** * 生成缓存过期时间：2 天加上随机几小时，防止缓存雪崩，穿透数据库 * * @return 返回过期时间 */ public static Integer generateCacheExpire() return TWO_DAYS_SECONDS + CommonUtil.genRandomInt(0, 10) * 60 * 60; /** * 生成缓存穿透过期时间，单位 秒 * * @return 随机 30 - 100 秒 */ public static Integer generateCachePenetrationExpire() return CommonUtil.genRandomInt(30, 100); /** * 写入缓存 * * @param key key * @param value value * @param seconds 设置过期时间 */ public void set(String key, String value, int seconds) ValueOperationsString, String op = redisTemplate.opsForValue(); try if (seconds 0) // 设置缓存时间 op.set(key, value, seconds, TimeUnit.SECONDS); else if (seconds == 0) // 永不过期 op.set(key, value); else throw new IllegalArgumentException(Expiration time must be a non-negative integer); catch (Exception e) log.error(写入缓存失败, key: , value: [REDACTED], key, e); throw new RedisCacheException(写入缓存失败, e); /** * 写入缓存 value 为 Object 类型 * * @param key key * @param value value * @param seconds 过期时间 */ public void set(String key, Object value, int seconds) try // 先将 Object 转成 Json 字符串再进行存储 this.set(key, JsonUtil.toJson(value), seconds); catch (Exception e) log.error(写入缓存失败, key: , value: [REDACTED], key, e); throw new RedisCacheException(写入缓存失败, e); /** * 读取缓存 * * @param key key * @return 缓存数据 */ public String get(String key) try ValueOperationsString, String op = redisTemplate.opsForValue(); return op.get(key); catch (Exception e) log.error(读取缓存失败, key: , key, e); throw new RedisCacheException(读取缓存失败, e); /** * 删除缓存 * * @param key key * @return 删除成功返回 true，否则返回 false */ public boolean delete(String key) try return Boolean.TRUE.equals(redisTemplate.delete(key)); catch (Exception e) log.error(删除缓存失败, key: , key, e); throw new RedisCacheException(删除缓存失败, e); /** * 设置缓存过期时间 * * @param key key * @param seconds 过期时间 */ public void expire(String key, Integer seconds) if (key == null || key.isEmpty()) throw new IllegalArgumentException(Key cannot be null or empty); if (seconds == null || seconds 0) throw new IllegalArgumentException(Expiration time must be a non-negative integer); try redisTemplate.expire(key, seconds, TimeUnit.SECONDS); catch (Exception e) log.error(Failed to set expiration for key: , key, e); throw new RedisCacheException(Failed to set expiration for key: + key, e); /** * 获取缓存过期时间 * * @param key key * @param timeUnit 时间类型 * @return 过期时间 */ public Long getExpire(String key, TimeUnit timeUnit) if (key == null || key.isEmpty()) throw new IllegalArgumentException(Key cannot be null or empty); try return redisTemplate.getExpire(key, timeUnit); catch (Exception e) log.error(Failed to get expiration for key: , key, e); throw new RedisCacheException(Failed to get expiration for key: + key, e); /** * 获取整数值 * * @param key key * @return 缓存数据 */ public Long getLong(String key) if (key == null || key.isEmpty()) throw new IllegalArgumentException(Key cannot be null or empty); try ValueOperationsString, String op = redisTemplate.opsForValue(); String value = op.get(key); return value != null ? Long.parseLong(value) : null; catch (NumberFormatException e) log.error(Failed to parse integer value for key: , key, e); throw new RedisCacheException(Failed to parse integer value for key: + key, e); catch (Exception e) log.error(Failed to get integer value for key: , key, e); throw new RedisCacheException(Failed to get integer value for key: + key, e); /** * 增加缓存值 * * @param key key * @param delta 增加的值 */ public void increment(String key, int delta) try ValueOperationsString, String op = redisTemplate.opsForValue(); op.increment(key, delta); catch (Exception e) log.error(Failed to increment value for key: , key, e); throw new RedisCacheException(Failed to increment value for key: + key, e); class RedisCacheException extends RuntimeException public RedisCacheException(String message, Throwable cause) super(message, cause); RedisLock cshop-commonsrcmainJavagithublianyutiancshopcommonredisRedisLock.Java package github.lianyutian.cshop.common.redis;import java.util.concurrent.TimeUnit;import org.redisson.api.RLock;import org.redisson.api.RedissonClient;import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;import org.springframework.stereotype.Component;/** * Redis 分布式锁 * * @author lianyutian * @since 2024-12-27 11:30:30 * @version 1.0 */@Component@ConditionalOnBean(RedissonClient.class)public class RedisLock /** 分布式锁加锁时间 200 毫秒 */ public static final long UPDATE_LOCK_TIMEOUT = 200; private final RedissonClient redissonClient; public RedisLock(RedissonClient redissonClient) this.redissonClient = redissonClient; /** * redisson 互斥锁，等待 seconds 秒后自动失效 * * @param key key * @param seconds 秒 * @return 加锁结果 */ public boolean lock(String key, int seconds) // 先获取分布式锁 RLock rLock = redissonClient.getLock(key); // 如果已经加锁了返回 false if (rLock.isLocked()) return false; // 加锁，如果在指定时间内没释放锁，它会自动在底层把锁释放掉 rLock.lock(seconds, TimeUnit.SECONDS); // 加锁成功返回 true return true; /** * redisson 互斥锁，自动续期 * * @param key key * @return 加锁结果 */ public boolean lock(String key) // 先获取分布式锁 RLock rLock = redissonClient.getLock(key); // 如果已经加锁了返回 false if (rLock.isLocked()) return false; // 加锁 rLock.lock(); // 加锁成功返回 true return true; /** * 尝试加锁 * * @param key key * @param timeout 超时时间 * @return 加锁结果 */ public boolean tryLock(String key, long timeout) throws InterruptedException // 先获取分布式锁 RLock rLock = redissonClient.getLock(key); // 尝试加锁 return rLock.tryLock(timeout, TimeUnit.MILLISECONDS); /** * 手动释放锁 * * @param key key */ public void unlock(String key) // 先获取分布式锁 RLock rLock = redissonClient.getLock(key); // 如果已锁定，则释放锁 if (rLock.isLocked()) rLock.unlock(); 用户模块新建 cshop-userpom.xml ?xml version=1.0 encoding=UTF-8?project xmlns=http://maven.apache.org/POM/4.0.0 xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation=http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion4.0.0/modelVersion parent groupIdgithub.lianyutian.cshop/groupId artifactIdcircle-shop/artifactId version1.0-SNAPSHOT/version /parent groupIdgithub.lianyutian.cshop.user/groupId artifactIdcshop-user/artifactId properties maven.compiler.source17/maven.compiler.source maven.compiler.target17/maven.compiler.target project.build.sourceEncodingUTF-8/project.build.sourceEncoding /properties dependencies dependency groupIdgithub.lianyutian.cshop.common/groupId artifactIdcshop-common/artifactId version1.0-SNAPSHOT/version /dependency /dependencies/project cshop-usersrcmainJavagithublianyutiancshopuserUserApplication.Java package github.lianyutian.cshop.user;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;/** * 用户服务启动类 * * @author lianyutian * @since 2024-12-13 14:14:31 * @version 1.0 */@SpringBootApplication@ComponentScan(basePackages = github.lianyutian.cshop.user, github.lianyutian.cshop.common)public class UserApplication public static void main(String[] args) SpringApplication.run(UserApplication.class, args); cshop-usersrcmainresourcesapplication.yml # 服务端口server: port: 9001 spring: application: name: cshop-user # 设置日志级别：ERROR/WARN/INFO/DEBUG,默认是 INFO 以上才显示logging: level: root: INFO 测试 cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserController.Java package github.lianyutian.cshop.user.controller;import github.lianyutian.cshop.common.utils.ApiResult;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * UserController * * @author lianyutian * @since 2024-12-13 14:19:30 * @version 1.0 */@RestController@RequestMapping(/api/user/v1)public class UserController @PostMapping(test) public ApiResultString test() int i = 1 / 0; return ApiResult.success(hello circle-shop); 用户验证码图形验证码基础功能Kaptcha 是一个开源的 Java 图形验证码生成库，常用于在 Web 应用中生成验证码图片。 https://github.com/penggle/kaptcha pom.xml !-- 图形验证码 kaptcha 版本 --kaptcha.version2.3.2/kaptcha.version dependency\tgroupIdcom.github.penggle/groupId\tartifactIdkaptcha/artifactId\tversion$kaptcha.version/version/dependency cshop-userpom.xml dependency\tgroupIdcom.github.penggle/groupId\tartifactIdkaptcha/artifactId/dependency cshop-usersrcmainJavagithublianyutiancshopuserconfigKaptchaConfig.Java package github.lianyutian.cshop.user.config;import com.google.code.kaptcha.Constants;import com.google.code.kaptcha.impl.DefaultKaptcha;import com.google.code.kaptcha.util.Config;import java.util.Properties;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Kaptcha 配置类 * * @author lianyutian * @since 2024-12-17 11:15:02 * @version 1.0 */@Configurationpublic class KaptchaConfig @Bean @Qualifier(captchaProducer) public DefaultKaptcha producer() Properties properties = new Properties(); // 设置 Kaptcha 生成的图片宽度(像素) properties.setProperty(Constants.KAPTCHA_IMAGE_WIDTH, 200); // 设置 Kaptcha 生成的图片高度(像素) properties.setProperty(Constants.KAPTCHA_IMAGE_HEIGHT, 50); // 设置 Kaptcha 文本字体大小 properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_FONT_SIZE, 40); // 设置 Kaptcha 文本字体颜色 properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_FONT_COLOR, black); // 设置 Kaptcha 文本字符长度 properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_CHAR_LENGTH, 5); // 设置 Kaptcha 文本字符集为英文字母（大小写）和数字 properties.setProperty( Constants.KAPTCHA_TEXTPRODUCER_CHAR_STRING, abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890); // 设置 Kaptcha 文本字体 properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_FONT_NAMES, Arial); // NoNoise 类表示不添加任何噪声，即生成的验证码图片将不会有任何干扰线或点。 // 通过设置 Constants.KAPTCHA_NOISE_IMPL 属性，可以控制验证码图片的样式和复杂度 properties.setProperty(Constants.KAPTCHA_NOISE_IMPL, com.google.code.kaptcha.impl.NoNoise); Config config = new Config(properties); DefaultKaptcha defaultKaptcha = new DefaultKaptcha(); defaultKaptcha.setConfig(config); return defaultKaptcha; cshop-usersrcmainJavagithublianyutiancshopusercontrollerCaptchaController.Java package github.lianyutian.cshop.user.controller;import com.google.code.kaptcha.impl.DefaultKaptcha;import github.lianyutian.cshop.common.utils.CommonUtil;import jakarta.servlet.ServletOutputStream;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import lombok.AllArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.imageio.ImageIO;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.concurrent.TimeUnit;/** * 验证码前端控制器 * * @author lianyutian * @since 2024-12-17 11:17:12 * @version 1.0 */@RestController@RequestMapping(/api/captcha/v1)@AllArgsConstructor@Slf4jpublic class CaptchaController /** * 验证码生成器 */ private final DefaultKaptcha captchaProducer; /** * 获取图形验证码 * * @param response response */ @RequestMapping(getImgCaptcha) public void getImgCaptcha(HttpServletResponse response) // 1、先生成图形验证码文本 String captchaText = captchaProducer.createText(); log.info(验证码模块-获取图形验证码文本:, captchaText); // 2、根据验证码文本生成图形验证码图片 BufferedImage bufferedImage = captchaProducer.createImage(captchaText); try (ServletOutputStream outputStream = response.getOutputStream(); ) ImageIO.write(bufferedImage, jpg, outputStream); outputStream.flush(); catch (IOException e) log.error(验证码模块-获取图形验证码异常:, e.getMessage(), e); 接入 Redis在分布式系统中，有多个实例运行服务时，验证码的存储和验证涉及到跨实例的数据一致性问题。 通常，验证码是存储在用户会话（Session）中，而如果服务是分布式的，那么每个服务实例可能有自己的独立会话存储，将会导致验证失败。为了解决这个问题，我们接入 Redis 存储验证码。 在 common 模块中已经引入了 redis 所以 user 模块不用重复引入，直接配置 redis 就可以。 cshop-usersrcmainresourcesapplication.yml spring: # redis配置 data: redis: enable: true host: 116.198.217.158 port: 6379 password: MIIEowIBAAKCAQEAwG90ULRHmAXFXQzZSwleoYts2+bCzUvqhhqtGiv/F5kUsETY # 如果有密码 database: 0 # 默认数据库 timeout: 60000 # 读取 redis 超时时间 lettuce: pool: max-active: 100 # 最大连接数 max-idle: 100 # 最大空闲连接数 min-idle: 100 # 最小空闲连接数 max-wait: 60000 # 最大等待时间，单位是毫秒 cshop-usersrcmainJavagithublianyutiancshopuserconstantUserCacheKeyConstant.Java package github.lianyutian.cshop.user.constant;/** * 缓存常量 * * @author lianyutian * @since 2024-12-24 13:46:37 * @version 1.0 */public class UserCacheKeyConstant /** 图形验证码缓存 key 前缀 */ public static final String CAPTCHA_IMG_KEY_PREFIX = cshop-user:img-captcha:; /** 注册验证码缓存 key 前缀 */ public static final String CAPTCHA_REGISTER_KEY_PREFIX = cshop-user:register-captcha:; /** 用户信息更新锁前缀 */ public static final String USER_UPDATE_LOCK_KEY_PREFIX = cshop-user:update:lock:; /** 用户详细信息缓存前缀 */ public static final String USER_DETAIL_KEY_PREFIX = cshop-user:detail:; /** 用户展示信息缓存前缀 */ public static final String USER_SHOW_KEY_PREFIX = cshop-user:show:; cshop-usersrcmainJavagithublianyutiancshopusercontrollerCaptchaController.Java package github.lianyutian.cshop.user.controller;import com.google.code.kaptcha.impl.DefaultKaptcha;import github.lianyutian.cshop.common.enums.BizCodeEnum;import github.lianyutian.cshop.common.model.ApiResult;import github.lianyutian.cshop.common.redis.RedisCache;import github.lianyutian.cshop.common.utils.CheckUtil;import github.lianyutian.cshop.common.utils.CommonUtil;import github.lianyutian.cshop.user.constant.UserCacheKeyConstant;import github.lianyutian.cshop.user.service.captcha.CaptchaService;import jakarta.servlet.ServletOutputStream;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.awt.image.BufferedImage;import java.io.IOException;import javax.imageio.ImageIO;import lombok.AllArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;/** * CaptchaController * * @author lianyutian * @since 2024-12-17 11:17:12 * @version 1.0 */@RestController@RequestMapping(/api/captcha/v1)@AllArgsConstructor@Slf4jpublic class CaptchaController /** 图形验证码过期时间 */ private static final long CAPTCHA_EXPIRE_TIME = 60 * 1000 * 5; /** 验证码生成器 */ private final DefaultKaptcha captchaProducer; private final RedisCache redisCache; private final CaptchaService captchaService; /** * 获取图形验证码 * * @param request request * @param response response */ @PostMapping(getImgCaptcha) public void getImgCaptcha(HttpServletRequest request, HttpServletResponse response) // 1、先生成图形验证码文本 String captchaText = captchaProducer.createText(); log.info(验证码模块-获取图形验证码文本:, captchaText); // 2、存储到 redis 中，并设置过期时间 redisCache.set(getImgCaptchaKey(request), captchaText, CAPTCHA_EXPIRE_TIME); // 3、根据验证码文本生成图形验证码图片 BufferedImage bufferedImage = captchaProducer.createImage(captchaText); try (ServletOutputStream outputStream = response.getOutputStream(); ) ImageIO.write(bufferedImage, jpg, outputStream); outputStream.flush(); catch (IOException e) log.error(验证码模块-获取图形验证码异常:, e.getMessage(), e); private String getImgCaptchaKey(HttpServletRequest request) // 获取客户端用户的 IP 地址 String ip = CommonUtil.getRemoteIpAddr(request); // 获取请求头中的 User-Agent 属性值 String userAgent = request.getHeader(User-Agent); // 根据 ip + userAgent 生成对应的 key return UserCacheKeyConstant.CAPTCHA_IMG_KEY_PREFIX + CommonUtil.MD5(ip + userAgent); 短信发送阿里云短信https://www.alibabacloud.com/help/zh/sms/?spm a2c63.p38356.0.0.5d031637kOTDrA https://dysms.console.aliyun.com/quickstart 前置步骤 申请资质 资质是申请签名的实名化信息，可复用 前往查看 申请签名 签名是短信中能代表发送者属性的字段。 前往查看 申请模板 模板即具体发送的短信内容。 前往查看 安全设置https://dysms.console.aliyun.com/msgsetting/safe 创建 RAM 用户 创建用户 https://ram.console.aliyun.com/users/create 添加短信授权 API 详细 API 文档 https://api.aliyun.com/document/Dysmsapi/2017-05-25/SendSms 示例 https://api.aliyun.com/api-tools/sdk/Dysmsapi?version 2017-05-25language Java-async-teatab primer-doc 开发 pom.xml !-- 阿里云短信 sdk 版本 --alibabacloud.dysmsapi.version3.0.1/alibabacloud.dysmsapi.versiondependency groupIdcom.aliyun/groupId artifactIdalibabacloud-dysmsapi20170525/artifactId version$alibabacloud.dysmsapi.version/version/dependency cshop-userpom.xml dependency groupIdcom.aliyun/groupId artifactIdalibabacloud-dysmsapi20170525/artifactId/dependency cshop-usersrcmainJavagithublianyutiancshopuserservicesmsSmsCodeService.Java /** 短信服务接口 提供短信验证码发送功能 */package github.lianyutian.cshop.user.service.sms;/** * 短信服务接口 * * @author lianyutian * @since 2024-12-18 14:39:43 * @version 1.0 */public interface SmsCodeService /** * 发送短信验证码 * * @param phone 接收短信的手机号码 * @param templateId 短信模板 ID，用于指定短信的内容格式 * @param templateParam 短信模板参数，用于替换短信模板中的占位符 * @return 发送结果，通常为成功或失败的标识 */ boolean sendSmsCode(String phone, String templateId, String[] templateParam); cshop-usersrcmainJavagithublianyutiancshopuserservicesmsimplAliyunSmsCodeServiceImpl.Java package github.lianyutian.cshop.user.service.sms.impl;import com.aliyun.auth.credentials.Credential;import com.aliyun.auth.credentials.provider.StaticCredentialProvider;import com.aliyun.sdk.service.dysmsapi20170525.AsyncClient;import com.aliyun.sdk.service.dysmsapi20170525.models.SendSmsRequest;import com.aliyun.sdk.service.dysmsapi20170525.models.SendSmsResponse;import darabonba.core.client.ClientOverrideConfiguration;import github.lianyutian.cshop.common.utils.JsonUtil;import github.lianyutian.cshop.user.service.sms.SmsCodeService;import java.time.Duration;import java.util.Objects;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;/** * 阿里云短信服务实现类 * * @author lianyutian * @since 2024-12-19 08:42:48 * @version 1.0 */@Service@Slf4jpublic class AliyunSmsCodeServiceImpl implements SmsCodeService @Value($sms.aliyun.secretId) private String secretId; @Value($sms.aliyun.secretKey) private String secretKey; @Value($sms.aliyun.signName) private String signName; @Override public boolean sendSmsCode(String phone, String templateId, String[] templateParam) // 配置认证信息，包括访问密钥 ID、访问密钥密钥 StaticCredentialProvider provider = StaticCredentialProvider.create( Credential.builder().accessKeyId(secretId).accessKeySecret(secretKey).build()); try (AsyncClient client = AsyncClient.builder() // .httpClient(httpClient) // 使用配置的 HttpClient，否则使用默认的 HttpClient (Apache HttpClient) .credentialsProvider(provider) // .serviceConfiguration(Configuration.create()) // 服务级别配置 // 客户端级别配置重写，可以设置 Endpoint、HTTP 请求参数等 .overrideConfiguration( ClientOverrideConfiguration.create() // Endpoint 请参考 https://api.aliyun.com/product/Dysmsapi .setEndpointOverride(dysmsapi.aliyuncs.com) .setConnectTimeout(Duration.ofSeconds(30))) .build()) // 设置 API 请求参数 SendSmsRequest sendSmsRequest = SendSmsRequest.builder() .phoneNumbers(phone) .signName(signName) .templateCode(templateId) .templateParam(\\code\\:\\ + templateParam[0] + \\) // 请求级别配置重写，可以设置 HTTP 请求参数等 // .requestConfiguration(RequestConfiguration.create().setHttpHeaders(new // HttpHeaders())) .build(); // 异步获取 API 请求的返回值 CompletableFutureSendSmsResponse response = client.sendSms(sendSmsRequest); // 同步获取 API 请求的返回值 SendSmsResponse resp = response.get(); log.info(短信模块-短信发送结果：, JsonUtil.toJson(resp)); String code = resp.getBody().getCode(); if (Objects.equals(code, OK)) return true; catch (ExecutionException | InterruptedException e) log.error(e.getMessage(), e); return false; return false; cshop-usersrcmainJavagithublianyutiancshopuserservicesmsSmsSender.Java 因为短信服务提供商有多家，为方便可以自由选择提供商所以使用策略模式 package github.lianyutian.cshop.user.service.sms;import github.lianyutian.cshop.user.service.sms.impl.AliyunSmsCodeServiceImpl;import github.lianyutian.cshop.user.service.sms.impl.TencentcloudSmsCodeServiceImpl;import java.util.concurrent.atomic.AtomicInteger;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;/** * 短信发送管理 * * @author lianyutian * @since 2024-12-19 09:50:10 * @version 1.0 */@Service@Slf4jpublic class SmsSender /** 当前使用的短信服务 */ private SmsCodeService currentService; /** 当前短信模板 ID */ private String currentTemplateId; /** 失败计数 */ private final AtomicInteger failureCount = new AtomicInteger(0); /** 阿里云短信服务实现 */ private final AliyunSmsCodeServiceImpl aliyunSmsCodeService; /** 腾讯云短信服务实现 */ private final TencentcloudSmsCodeServiceImpl tencentcloudSmsCodeService; /** 最大失败次数 */ private final int maxFailures; private final String aliyunTemplateId; private final String tencentcloudTemplateId; /** 构造方法，默认使用阿里云短信服务 */ public SmsSender( @Value($sms.send.fail) int maxFailures, @Value($sms.send.templateId.aliyun) String aliyunTemplateId, @Value($sms.send.templateId.tencentcloud) String tencentcloudTemplateId, AliyunSmsCodeServiceImpl aliyunSmsCodeService, TencentcloudSmsCodeServiceImpl tencentcloudSmsCodeService) if (maxFailures = 0) throw new IllegalArgumentException(最大失败次数必须大于0); this.maxFailures = maxFailures; this.aliyunTemplateId = aliyunTemplateId; this.tencentcloudTemplateId = tencentcloudTemplateId; this.aliyunSmsCodeService = aliyunSmsCodeService; this.tencentcloudSmsCodeService = tencentcloudSmsCodeService; this.currentService = aliyunSmsCodeService; this.currentTemplateId = aliyunTemplateId; /** * 发送短信 * * @param phoneNumber 接收短信的电话号码 * @param templateParam 短信模板参数 * @return 短信发送结果，true 表示发送成功，false 表示发送失败 */ public boolean send(String phoneNumber, String[] templateParam) try boolean result = currentService.sendSmsCode(phoneNumber, currentTemplateId, templateParam); // 发送成功时，重置失败次数 failureCount.set(0); return result; catch (Exception e) log.error(短信模块-短信发送失败, , e.getMessage(), e); int currentFailureCount = failureCount.incrementAndGet(); if (currentFailureCount = maxFailures) // 切换到另一个厂商 switchVendor(currentFailureCount); return false; /** 切换短信服务供应商 */ private void switchVendor(int currentFailureCount) if (currentService instanceof AliyunSmsCodeServiceImpl) log.info(短信模块-切换到腾讯云, 当前失败次数: , currentFailureCount); currentService = tencentcloudSmsCodeService; currentTemplateId = tencentcloudTemplateId; else log.info(短信模块-切换到阿里云, 当前失败次数: , currentFailureCount); currentService = aliyunSmsCodeService; currentTemplateId = aliyunTemplateId; cshop-usersrcmainresourcesapplication.yml sms: aliyun: secretId: xxx secretKey: xxx signName: CircleShop商城 tencent: secretId: xxx secretKey: xxx signName: xxx send: fail: 10 templateId: aliyun: SMS_476800055 tencentcloud: xxx 腾讯云短信开通腾讯云短信（签名不通过暂缓）https://console.cloud.tencent.com/smsv2 https://blog.csdn.net/mjl1125/article/details/122047618 https://blog.csdn.net/huixi_aa/article/details/124687445 注册验证码 cshop-usersrcmainJavagithublianyutiancshopusercontrollerCaptchaController.Java private final CaptchaService captchaService;/** * 发送注册验证码 * * @param to 接收方 */@PostMapping(sendRegisterCode)public ApiResultVoid sendRegisterCode(@RequestParam(value = to) String to) if (!CheckUtil.isPhone(to)) return ApiResult.result(BizCodeEnum.USER_PHONE_ERROR); // 先从缓存中获取验证码 // key:cshop-user:register-captcha: 电话 // value: 电话_发送时间戳 String cacheKey = UserCacheKeyConstant.CAPTCHA_REGISTER_KEY_PREFIX + to; String registerCode = redisCache.get(cacheKey); // 如果不为空，则判断是否 60 秒内重复发送 if (StringUtils.isNotBlank(registerCode)) // 从缓存中取出验证码发送时间戳 long cacheCheckTtl = Long.parseLong(registerCode.split(_)[1]); // 当前时间 - 验证码发送时间戳，如果小于 60 秒，则不给重复发送 if (CommonUtil.getCurrentTimestamp() - cacheCheckTtl 1000 * 60) log.info( 验证码模块-请不要重复发送验证码，时间间隔：, (CommonUtil.getCurrentTimestamp() - cacheCheckTtl) / 1000); return ApiResult.result(BizCodeEnum.USER_CODE_FAST_LIMITED); // 发送注册验证码 boolean res = captchaService.sendCode(cacheKey, to); return res ? ApiResult.success() : ApiResult.result(BizCodeEnum.USER_CODE_SEND_ERROR); cshop-usersrcmainJavagithublianyutiancshopuserservicecaptchaCaptchaService.Java package github.lianyutian.cshop.user.service.captcha;/** * 验证码服务接口 * * @author lianyutian * @since 2024-12-17 17:17:03 * @version 1.0 */public interface CaptchaService /** * 发送验证码 * * @param cacheKey 缓存 key * @param to 接收者 * @return 发送结果 */ boolean sendCode(String cacheKey, String to); cshop-usersrcmainJavagithublianyutiancshopuserservicecaptchaimplCaptchaServiceImpl.Java package github.lianyutian.cshop.user.service.captcha.impl;import github.lianyutian.cshop.common.redis.RedisCache;import github.lianyutian.cshop.common.utils.CommonUtil;import github.lianyutian.cshop.user.service.captcha.CaptchaService;import github.lianyutian.cshop.user.service.sms.SmsSender;import java.util.concurrent.TimeUnit;import lombok.AllArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Service;/** * 验证码服务实现类 * * @author lianyutian * @since 2024-12-17 17:35:10 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class CaptchaServiceImpl implements CaptchaService /** 短信验证码过期时间 */ private static final long CAPTCHA_EXPIRE_TIME = 60 * 1000 * 5; private final RedisCache redisCache; private final SmsSender smsSender; @Override public boolean sendCode(String cacheKey, String to) // 获取随机验证码 String code = CommonUtil.getRandomCode(6); // 拼接验证码 格式：验证码_时间戳 String newCode = code + _ + CommonUtil.getCurrentTimestamp(); log.info(验证码模块-写入 Redis 验证码：, newCode); redisCache.set(cacheKey, newCode, CAPTCHA_EXPIRE_TIME, TimeUnit.MILLISECONDS); // 发送短信 boolean sendRes = smsSender.send(to, new String[] code); if (!sendRes) // 发送失败删除缓存 redisCache.delete(cacheKey); return sendRes; 用户头像上传https://www.alibabacloud.com/help/zh/oss/?spm a2c63.p38356.0.0.47cb60deEkjUPk https://www.alibabacloud.com/help/zh/oss/developer-reference/getting-started?spm a2c63.p38356.help-menu-31815.d_3_2_0_0.59105a1abcz5t5 pom.xml !-- 阿里云 OSS sdk 版本 --aliyun-sdk-oss.version3.18.1/aliyun-sdk-oss.version!-- https://mvnrepository.com/artifact/com.aliyun.oss/aliyun-sdk-oss --dependency groupIdcom.aliyun.oss/groupId artifactIdaliyun-sdk-oss/artifactId version$aliyun-sdk-oss.version/version/dependency cshop-usersrcmainresourcesapplication.yml oss: aliyun: secretId: xxx secretKey: xxx bucketName: xxx endPoint: oss-cn-shenzhen.aliyuncs.com cshop-usersrcmainJavagithublianyutiancshopuserserviceossOssService.Java package github.lianyutian.cshop.user.service.oss;import org.springframework.web.multipart.MultipartFile;/** * 对象存储服务 * * @author lianyutian * @since 2024-12-23 14:04:03 * @version 1.0 */public interface OssService /** * 上传用户头像 * * @param file 头像文件 * @return 头像地址 */ String uploadUserAvatar(MultipartFile file); cshop-usersrcmainJavagithublianyutiancshopuserserviceossimplOssServiceImpl.Java package github.lianyutian.cshop.user.service.oss.impl;import com.aliyun.oss.OSS;import com.aliyun.oss.OSSClientBuilder;import com.aliyun.oss.model.PutObjectResult;import github.lianyutian.cshop.common.utils.CommonUtil;import github.lianyutian.cshop.user.service.oss.OssService;import java.io.IOException;import java.io.InputStream;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.util.Objects;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;import org.springframework.web.multipart.MultipartFile;/** * 对象存储实现 * * @author lianyutian * @since 2024-12-23 14:06:09 * @version 1.0 */@Slf4j@Servicepublic class OssServiceImpl implements OssService @Value($oss.aliyun.secretId) private String secretId; @Value($oss.aliyun.secretKey) private String secretKey; @Value($oss.aliyun.bucketName) private String bucketName; @Value($oss.aliyun.endPoint) private String endPoint; @Override public String uploadUserAvatar(MultipartFile file) // 获取原始文件名 String originalFilename = Objects.requireNonNullElse(file.getOriginalFilename(), default_filename); // 获取日期格式，上传时作为目录名使用 LocalDateTime localDateTime = LocalDateTime.now(); DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(yyyy/MM/dd); // OSS 上传存储路径：user/2024/12/23/xxx.jpg String folder = dateTimeFormatter.format(localDateTime); // 获取扩展名 String extension = originalFilename.substring(originalFilename.lastIndexOf(.)); // 新文件名，通过 uuid 生成文件名， String fileName = user + / + folder + / + CommonUtil.generateUUID() + extension; OSS ossClient = new OSSClientBuilder().build(endPoint, secretId, secretKey); try (InputStream inputStream = file.getInputStream()) // 写入 OSS PutObjectResult putObjectResult = ossClient.putObject(bucketName, fileName, inputStream); // 返回图片路径 if (putObjectResult != null) return https:// + bucketName + . + endPoint + / + fileName; else log.error(用户微服务-上传模块-文件上传失败，putObjectResult 为空); return null; catch (IOException e) log.error(用户微服务-上传模块-文件上传失败：, e.getMessage(), e); return null; finally ossClient.shutdown(); cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserController.Java package github.lianyutian.cshop.user.controller;import github.lianyutian.cshop.common.enums.BizCodeEnum;import github.lianyutian.cshop.common.model.ApiResult;import github.lianyutian.cshop.user.model.param.UserEditParam;import github.lianyutian.cshop.user.model.param.UserLoginParam;import github.lianyutian.cshop.user.model.param.UserRegisterParam;import github.lianyutian.cshop.user.model.vo.UserDetailVO;import github.lianyutian.cshop.user.model.vo.UserShowVO;import github.lianyutian.cshop.user.service.UserService;import github.lianyutian.cshop.user.service.oss.OssService;import java.util.Map;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RequestPart;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;/** * UserController * * @author lianyutian * @since 2024-12-13 14:19:30 * @version 1.0 */@RestController@RequestMapping(/api/user/v1)@Slf4j@RequiredArgsConstructorpublic class UserController @Value($oss.aliyun.maxFileSize:1048576) // 新增文件大小限制配置 private long maxFileSize; @Value($oss.aliyun.allowedFileTypes:image/jpeg,image/png) // 新增允许的文件类型配置 private String[] allowedFileTypes; private final OssService ossService; private final UserService userService; /** * 上传用户头像 * * @param file 头像文件 * @return 上传结果 */ @PostMapping(uploadUserAvatar) public ApiResultString uploadUserAvatar(@RequestPart(file) MultipartFile file) // 验证文件是否为空 if (file == null || file.isEmpty()) log.warn(用户微服务-上传模块-文件为空); return ApiResult.result(BizCodeEnum.USER_AVATAR_FILE_UPLOAD_ERROR); // 验证文件大小 if (file.getSize() maxFileSize) log.warn(用户微服务-上传模块-文件超出最大限制: , file.getSize()); return ApiResult.result(BizCodeEnum.USER_AVATAR_FILE_UPLOAD_ERROR); // 验证文件类型 String contentType = file.getContentType(); if (!isFileTypeAllowed(contentType)) log.warn(用户微服务-上传模块-不允许的文件类型: , contentType); return ApiResult.result(BizCodeEnum.USER_AVATAR_FILE_UPLOAD_ERROR); String result = ossService.uploadUserAvatar(file); return result != null ? ApiResult.success(result) : ApiResult.result(BizCodeEnum.USER_AVATAR_FILE_UPLOAD_ERROR); 用户注册创建用户表 cshop-userdocSQLuser.SQL create table user( id bigint unsigned auto_increment primary key, name varchar(32) null comment 用户昵称, pwd varchar(64) null comment 用户密码, avatar varchar(524) null comment 用户头像, sex tinyint(1) default 1 null comment 0 女，1 男, phone varchar(11) default null comment 用户手机号, create_time datetime default CURRENT_TIMESTAMP null comment 创建时间, update_time datetime default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP comment 更新时间, constraint phone_idx unique (phone)) comment 用户表 row_format = DYNAMIC; 配置 pom.xml !-- mybatis-plus 版本 --mybatis-plus.version3.5.9/mybatis-plus.version!-- mysql 驱动 版本 --mysql-connector-java.version8.0.33/mysql-connector-java.versiondependency groupIdcom.baomidou/groupId artifactIdmybatis-plus-bom/artifactId version$mybatis-plus.version/version typepom/type scopeimport/scope/dependencydependency groupIdmysql/groupId artifactIdmysql-connector-java/artifactId version$mysql-connector-java.version/version/dependency cshop-userpom.xml dependency groupIdcom.baomidou/groupId artifactIdmybatis-plus-spring-boot3-starter/artifactId/dependencydependency groupIdmysql/groupId artifactIdmysql-connector-java/artifactId/dependency!-- 密码加密 --dependency groupIdorg.springframework.security/groupId artifactIdspring-security-crypto/artifactId/dependency cshop-usersrcmainresourcesapplication.yml spring: # mysql配置 datasource: username: root password: MIIEowIBAAKCAQEAwG90ULRHmAXFXQzZSwleoYts2+bCzUvqhhqtGiv/F5kUsETY url: jdbc:mysql://116.198.217.158:3306/cshop-user?useUnicode=truecharacterEncoding=utf-8useSSL=falseserverTimezone=Asia/Shanghai driver-class-name: com.mysql.cj.jdbc.Driver# 配置 mybatis plus 打印 sql 日志mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 注册功能开发BCryptPasswordEncoder cshop-usersrcmainJavagithublianyutiancshopuserconfigSecurityConfig.Java package github.lianyutian.cshop.user.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;/** * 密码加密 * * @author lianyutian * @since 2024-12-24 15:16:39 * @version 1.0 */@Configurationpublic class SecurityConfig @Bean public PasswordEncoder passwordEncoder() return new BCryptPasswordEncoder(); cshop-usersrcmainJavagithublianyutiancshopusermodelparamUserRegisterParam.Java package github.lianyutian.cshop.user.model.param;import lombok.Data;/** * 用户注册参数 * * @author lianyutian * @since 2024-12-24 13:30:19 * @version 1.0 */@Datapublic class UserRegisterParam /** 用户名 */ private String name; /** 密码 */ private String password; /** 用户头像 */ private String avatar; /** 性别 0 女，1 男 */ private String sex; /** 手机号 */ private String phone; /** 验证码 */ private String code; cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserController.Java /** * 用户注册 * * @param userRegisterVO 注册信息 * @return 注册结果 */@PostMapping(register)public ApiResultVoid register(@RequestBody UserRegisterParam userRegisterParam) return userService.register(userRegisterVO); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserService.Java package github.lianyutian.cshop.user.service;import github.lianyutian.cshop.common.model.ApiResult;import github.lianyutian.cshop.user.model.param.UserRegisterParam;/** * 用户服务接口 * * @author lianyutian * @since 2024-12-24 08:41:57 * @version 1.0 */public interface UserService /** * 用户注册 * * @param userRegisterParam 用户注册入参 * @return 注册结果 */ ApiResultVoid register(UserRegisterParam userRegisterParam); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserServiceImpl.Java package github.lianyutian.cshop.user.service.impl;import github.lianyutian.cshop.common.enums.BizCodeEnum;import github.lianyutian.cshop.common.exception.BizException;import github.lianyutian.cshop.common.model.ApiResult;import github.lianyutian.cshop.common.redis.RedisCache;import github.lianyutian.cshop.common.utils.BeanUtil;import github.lianyutian.cshop.user.mapper.UserMapper;import github.lianyutian.cshop.user.model.param.UserRegisterParam;import github.lianyutian.cshop.user.model.po.User;import github.lianyutian.cshop.user.service.UserService;import java.util.concurrent.TimeUnit;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.BeanUtils;import org.springframework.dao.DuplicateKeyException;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.springframework.util.CollectionUtils;/** * 用户服务实现类 * * @author lianyutian * @since 2024-12-24 08:44:49 * @version 1.0 */@Service@Slf4j@RequiredArgsConstructorpublic class UserServiceImpl implements UserService private final UserMapper userMapper; private final PasswordEncoder passwordEncoder; private final RedisCache redisCache; private final RedisLock redisLock; @Override @Transactional public ApiResultVoid register(UserRegisterParam userRegisterParam) // 1. 校验注册验证码是否正确 boolean checked = checkCode(userRegisterParam.getPhone(), userRegisterParam.getCode()); if (!checked) return ApiResult.result(BizCodeEnum.USER_CODE_PHONE_ERROR); // 1.2 通过手机号唯一索引实现唯一 User user = new User(); BeanUtils.copyProperties(userRegisterParam, user); // 密码加密 String secretPwd = passwordEncoder.encode(userRegisterParam.getPassword()); user.setPwd(secretPwd); try userMapper.insert(user); catch (DuplicateKeyException e) log.warn(用户微服务-注册模块-用户已存在 , userRegisterParam.getPhone()); return ApiResult.result(BizCodeEnum.USER_ACCOUNT_EXIST); return ApiResult.success(); private boolean checkCode(String phone, String code) // 先从缓存中获取验证码 key - cshop-user:register-captcha:电话 String cacheKey = UserCacheKeyConstant.CAPTCHA_REGISTER_KEY_PREFIX + phone; String codeVal = redisCache.get(cacheKey); if (StringUtils.isBlank(codeVal)) return false; String[] parts = codeVal.split(_); String registerCode = parts[0]; if (registerCode.equals(code)) // 删除验证码，确保验证码不可以重复使用 redisCache.delete(cacheKey); return true; return false; cshop-usersrcmainJavagithublianyutiancshopusermapperUserMapper.Java package github.lianyutian.cshop.user.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import github.lianyutian.cshop.user.model.po.User;import org.apache.ibatis.annotations.Mapper;/** * UserMapper * * @author lianyutian * @since 2024-12-24 14:19:30 * @version 1.0 */@Mapperpublic interface UserMapper extends BaseMapperUser 用户登录pom 配置 pom.xml !-- jwt 版本 --jwt.version0.12.6/jwt.version!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt --dependency groupIdio.jsonwebtoken/groupId artifactIdjjwt/artifactId version$jwt.version/version/dependency cshop-commonpom.xml dependency groupIdio.jsonwebtoken/groupId artifactIdjjwt/artifactId/dependency 功能开发 cshop-usersrcmainJavagithublianyutiancshopusermodelvoUserLoginParam.Java package github.lianyutian.cshop.user.model.param;import lombok.Data;/** * 用户登录参数 * * @author lianyutian * @since 2024-12-24 08:40:33 * @version 1.0 */@Datapublic class UserLoginParam /** 手机号 */ private String phone; /** 密码 */ private String password; cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserController.Java /** * 用户登录 * * @param userLoginParam 用户登录入参 * @return 登录结果 */@PostMapping(login)public ApiResultMapString, Object login(@RequestBody UserLoginParam userLoginParam) return userService.login(userLoginParam); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserService.Java /** * 用户登录 * * @param userLoginParam 用户登录入参 * @return 登录结果 */ApiResultMapString, Object login(UserLoginParam userLoginParam); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserServiceImpl.Java @Overridepublic ApiResultMapString, Object login(UserLoginParam userLoginParam) // 根据手机号查询是否存在 LambdaQueryWrapperUser queryWrapper = new LambdaQueryWrapper(); queryWrapper.eq(User::getPhone, userLoginParam.getPhone()); User user = userMapper.selectOne(queryWrapper); if (user == null) // 未注册 return ApiResult.result(BizCodeEnum.USER_ACCOUNT_PWD_ERROR); // 校验密码 if (passwordEncoder.matches(userLoginParam.getPassword(), user.getPwd())) // TODO 登录成功，生成 jwt return null; else return ApiResult.result(BizCodeEnum.USER_ACCOUNT_PWD_ERROR); 鉴权与刷新JWT JWT（JSON Web Token）鉴权与传统鉴权在技术实现、使用场景和性能等方面存在显著区别，以下是两者的主要对比： 1. 数据存储与状态管理 传统鉴权 使用 会话机制，服务器会在内存（或数据库）中维护用户状态。 通常通过 Session ID 标识用户，Session ID 存储在 Cookie 中，由客户端随每个请求发送给服务器。 需要在服务器端维护会话状态，因此会话管理的扩展性较差（如分布式部署时需要额外解决会话共享问题）。 JWT 鉴权 基于 无状态 的设计，服务器不需要保存任何会话信息。 用户的认证信息（如用户 ID、角色等）被编码为一个加密后的 Token，由客户端存储（如 Cookie 或 Local Storage）并在每次请求时发送给服务器。 适用于分布式系统，因为不需要依赖服务器的会话存储。 2. 安全性 传统鉴权 Session ID 本身通常没有用户信息，仅用来索引服务器存储的用户数据。 需要防范 会话劫持 和 跨站点伪造请求（CSRF）。 JWT 鉴权 Token 自包含用户数据，且通过签名（如 HMAC 或 RSA）防篡改。 如果密钥泄露，攻击者可能伪造 Token，因此密钥的安全性尤为重要。 需要额外注意 Token 的生命周期和刷新策略，避免被窃取后长期有效。 3. 扩展性和性能 传统鉴权 需要服务器处理和存储每个用户的会话状态，随着用户数量增加，扩展性有限。 每次用户请求都会涉及服务器端状态的读取操作，增加了服务器的负担。 JWT 鉴权 不需要在服务器端存储状态信息，所有信息都在 Token 中携带，服务器只需验证 Token。 减少了服务器负担，尤其适合高并发场景。 4. 生命周期和刷新机制 传统鉴权 Session 通常有明确的过期时间，可以通过服务器端直接失效（删除会话数据）。 提供较简单的会话管理和用户退出机制。 JWT 鉴权 JWT 一旦签发，在过期之前无法直接使其失效（除非引入额外的黑名单机制）。 通常使用 短期 Token + 刷新 Token 的组合，短期 Token 过期后用刷新 Token 获取新 Token。 5. 使用场景 传统鉴权 更适合需要频繁交互的小型或单体应用。 当安全性要求较高时，可以借助服务器管理会话来更灵活地控制用户权限。 JWT 鉴权 更适合微服务架构、移动应用、单页应用（SPA）等分布式场景。 跨域支持更友好，因为可以使用 HTTP 标头传递 Token。 总结 特性 传统鉴权 JWT 鉴权 状态管理 有状态，需要服务器存储 无状态，所有信息在 Token 中 扩展性 低，需处理会话共享 高，适合分布式系统 安全性 依赖服务器控制 密钥管理和 Token 安全性关键 生命周期 服务端可随时控制会话失效 生命周期控制复杂（需刷新机制） 适用场景 小型或单体应用 分布式系统、移动前后端分离应用 JWT（JSON Web Token）自动刷新机制主要用于提升用户体验和安全性。以下是具体原因： 提升用户体验： 减少登录频率：通过自动刷新机制，用户不需要频繁重新登录。当用户的访问令牌（Access Token）过期时，系统可以使用刷新令牌（Refresh Token）自动获取新的访问令牌，从而保持用户会话的连续性。 增强安全性： 短期有效的访问令牌：访问令牌通常设置较短的有效期（例如 15 分钟），这样即使访问令牌被泄露，攻击者也无法长时间使用它。 长期有效的刷新令牌：刷新令牌通常设置较长的有效期（例如 30 天），但只能用于获取新的访问令牌，不能直接访问受保护的资源。这样即使刷新令牌被泄露，攻击者也无法直接访问用户数据。 撤销机制：如果怀疑刷新令牌被泄露，可以立即撤销该令牌，从而防止进一步的未授权访问。 灵活性： 动态调整令牌有效期：可以根据业务需求动态调整访问令牌和刷新令牌的有效期，以平衡安全性和用户体验。 实现 JWT 自动刷新的步骤: 生成访问令牌和刷新令牌： 当用户登录成功时，生成一个短期有效的访问令牌和一个长期有效的刷新令牌。 将访问令牌返回给客户端，并将刷新令牌存储在安全的地方（如服务器端的数据库或缓存中）。 客户端存储令牌： 客户端通常将访问令牌存储在内存中（如浏览器的 localStorage 或 sessionStorage），并在每次请求时将其附加到请求头中。 刷新令牌通常存储在更安全的地方，如 HTTP-only Cookie，以防止 XSS 攻击。 访问令牌过期处理： 当访问令牌过期时，客户端会尝试使用刷新令牌获取新的访问令牌。 客户端发送一个请求到服务器，请求中包含刷新令牌。 服务器验证刷新令牌的有效性，如果有效，则生成一个新的访问令牌并返回给客户端。 刷新令牌的安全性： 刷新令牌应该存储在安全的地方，防止被窃取。 可以设置刷新令牌的过期时间，并在用户登出时立即撤销刷新令牌。 可以限制每个刷新令牌只能使用一次，使用后立即失效。 7.8.1 pom 配置 pom.xml !-- jwt 版本 --jwt.version0.12.6/jwt.version!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt --dependency groupIdio.jsonwebtoken/groupId artifactIdjjwt/artifactId version$jwt.version/version/dependency cshop-commonpom.xml dependency groupIdio.jsonwebtoken/groupId artifactIdjjwt/artifactId/dependency 7.8.2 功能开发7.8.2.1 jwt 生成 cshop-commonsrcmainJavagithublianyutiancshopcommonutilsJWTUtil.Java package github.lianyutian.cshop.common.utils;import github.lianyutian.cshop.common.model.LoginUserInfo;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jws;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.security.Keys;import java.util.Date;import java.util.HashMap;import java.util.Map;import lombok.extern.slf4j.Slf4j;/** * jwt 工具类 * * @author lianyutian * @since 2024-12-24 10:01:54 * @version 1.0 */@Slf4jpublic class JWTUtil /** AccessToken 过期时间，正常过期时间 7 天 */ private static final long EXPIRE = 1000L * 60 * 60 * 24 * 7; /** RefreshToken 过期时间，正常过期时间 30 天 */ public static final long REFRESH_EXPIRE = 1000L * 60 * 60 * 24 * 30; /** 加密的密钥，从环境变量或配置文件中读取 */ private static final String SECRET = MIIEowIBAAKCAQEAwG90ULRHmAXFXQzZSwleoYts2+bCzUvqhhqtGiv/F5kUsETY; /** token 前缀 */ private static final String TOKEN_PREFIX = circle-shop.; /** SUBJECT */ private static final String SUBJECT = circle-shop; public static final String KEY_PREFIX = circle-shop:refresh-token:; /** * 根据用户信息，生成 JWT 令牌 * * @return JWT 令牌 */ public static MapString, Object createJwt(LoginUserInfo loginUserInfo) if (loginUserInfo == null) throw new NullPointerException(登录对象为空); // 过期时间 Date expireTime = new Date(System.currentTimeMillis() + EXPIRE); // 生成 JWT TOKEN String token = Jwts.builder() .subject(SUBJECT) // payload .claim(id, loginUserInfo.getId()) .claim(name, loginUserInfo.getName()) .claim(avatar, loginUserInfo.getAvatar()) .issuedAt(new Date()) .expiration(expireTime) // 加密算法 .signWith(Keys.hmacShaKeyFor(SECRET.getBytes()), Jwts.SIG.HS256) .compact(); // 加前缀区分业务 token = TOKEN_PREFIX + token; MapString, Object result = new HashMap(); result.put(AccessToken, token); result.put(AccessTokenExpireTime, expireTime); result.put(RefreshToken, CommonUtil.generateUUID()); log.info(公共服务-生成 token，过期时间：, expireTime); return result; /** * 校验 token 是否正确 * * @param token token * @return Claims */ public static Claims parserToken(String token) if (token == null || !token.startsWith(TOKEN_PREFIX)) log.warn(公共服务-解析 token 失败：无效的 token 格式); return null; try // 去除前缀后解析 String cleanToken = token.replace(TOKEN_PREFIX, ); // jws 解析 JwsClaims claims = Jwts.parser() .verifyWith(Keys.hmacShaKeyFor(SECRET.getBytes())) .build() .parseSignedClaims(cleanToken); log.info(公共服务-解析 token 成功); return claims.getPayload(); catch (Exception e) log.error(公共服务-解析 token 失败：, e.getMessage(), e); return null; 7.8.2.2 登录成功生成 jwt cshop-usersrcmainJavagithublianyutiancshopuserserviceUserServiceImpl.Java @Overridepublic ApiResultMapString, Object login(UserLoginParam userLoginParam) // 根据手机号查询是否存在 LambdaQueryWrapperUser queryWrapper = new LambdaQueryWrapper(); queryWrapper.eq(User::getPhone, userLoginParam.getPhone()); User user = userMapper.selectOne(queryWrapper); if (user == null) // 未注册 return ApiResult.result(BizCodeEnum.USER_ACCOUNT_PWD_ERROR); // 校验密码 if (passwordEncoder.matches(userLoginParam.getPassword(), user.getPwd())) // 登录成功，生成 jwt MapString, Object jwt = createNewJwt(user); return ApiResult.success(jwt); else return ApiResult.result(BizCodeEnum.USER_ACCOUNT_PWD_ERROR); private MapString, Object createNewJwt(User user) // 登录成功，生成 Token LoginUserInfo loginUserInfo = BeanUtil.copy(user, LoginUserInfo.class); BeanUtils.copyProperties(user, loginUserInfo); // 生成 JWT Token，过期时间 MapString, Object jwt = JWTUtil.createJwt(loginUserInfo); // 4、设置 RefreshToken 到 Redis 中，过期时间为 30 天 String newRefreshToken = (String) jwt.get(RefreshToken); String key = JWTUtil.KEY_PREFIX + newRefreshToken; redisCache.set(key, 1, JWTUtil.REFRESH_EXPIRE, TimeUnit.MILLISECONDS); return jwt; 7.8.2.3 刷新 token cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserController.Java /** * 刷新 token * * @param refreshToken refreshToken * @param accessToken accessToken * @return 新的 token */@PostMapping(refreshToken)public ApiResultMapString, Object refreshToken( @RequestParam(value = refreshToken) String refreshToken, @RequestParam(value = accessToken) String accessToken) return userService.refreshToken(refreshToken, accessToken); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserService.Java /** * 刷新 token * * @param refreshToken 刷新 token * @param accessToken 访问 token */ApiResultMapString, Object refreshToken(String refreshToken, String accessToken); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserServiceImpl.Java @Overridepublic ApiResultMapString, Object refreshToken(String refreshToken, String accessToken) String refreshTokenVal = redisCache.get(JWTUtil.KEY_PREFIX + refreshToken); // refreshToken 过期 if (StringUtils.isBlank(refreshTokenVal)) return ApiResult.result(BizCodeEnum.USER_REFRESH_TOKEN_EMPTY); // 2、如果 refreshToken 存在，解密 accessToken Claims claims = JWTUtil.parserToken(accessToken); if (claims == null) // 无法解密提示未登录 return ApiResult.result(BizCodeEnum.USER_ACCOUNT_UNLOGIN); // 3、如果可以解密 accessToken， 则重新生成 accessToken 等信息返回 long userId = Long.parseLong(claims.get(id).toString()); LambdaQueryWrapperUser queryWrapper = new LambdaQueryWrapper(); queryWrapper.eq(User::getId, userId); User user = userMapper.selectOne(queryWrapper); if (user != null) MapString, Object jwt = createNewJwt(user); // 删除旧的 refreshToken redisCache.delete(JWTUtil.KEY_PREFIX + refreshToken); return ApiResult.success(jwt); else // 无法解密提示未登录 return ApiResult.result(BizCodeEnum.USER_ACCOUNT_UNLOGIN); 7.9 登录拦截在用户登录时可以获取到 token 信息，在访问一些接口时需要判断用户是否登录。此时可以在使用 Interceptor 拦截器拦截请求接口解析 token 判断用户是否登录。 cshop-commonsrcmainJavagithublianyutiancshopcommoninterceptorLoginInterceptor.Java package github.lianyutian.cshop.common.interceptor;import github.lianyutian.cshop.common.enums.BizCodeEnum;import github.lianyutian.cshop.common.model.ApiResult;import github.lianyutian.cshop.common.model.LoginUserInfo;import github.lianyutian.cshop.common.utils.CommonUtil;import github.lianyutian.cshop.common.utils.JWTUtil;import github.lianyutian.cshop.common.utils.JsonUtil;import io.jsonwebtoken.Claims;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.web.servlet.HandlerInterceptor;/** * 登录拦截 * * @author lianyutian * @since 2024-12-25 15:47:02 * @version 1.0 */@Slf4jpublic class LoginInterceptor implements HandlerInterceptor public static final ThreadLocalLoginUserInfo USER_THREAD_LOCAL = new ThreadLocal(); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception String token = request.getHeader(token); if (StringUtils.isBlank(token)) token = request.getParameter(token); Claims claims = JWTUtil.parserToken(token); if (claims == null) // 解密失败，登录过期，提示账号未登录 CommonUtil.sendResponse(response, ApiResult.result(BizCodeEnum.USER_ACCOUNT_UNLOGIN)); return false; long id = Long.parseLong(claims.get(id).toString()); String avatar = (String) claims.get(avatar); String name = (String) claims.get(name); LoginUserInfo loginUserInfo = LoginUserInfo.builder().id(id).avatar(avatar).name(name).build(); USER_THREAD_LOCAL.set(loginUserInfo); log.info(登录拦截器--用户信息：, JsonUtil.toJson(loginUserInfo)); return true; 配置拦截路径 cshop-commonsrcmainJavagithublianyutiancshopcommoninterceptorconfigInterceptorConfig.Java package github.lianyutian.cshop.common.interceptor.config;import github.lianyutian.cshop.common.interceptor.LoginInterceptor;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;/** * 登录拦截配置 * * @author lianyutian * @since 2024-12-25 16:17:31 * @version 1.0 */@Configuration@Slf4jpublic class InterceptorConfig implements WebMvcConfigurer public LoginInterceptor loginInterceptor() return new LoginInterceptor(); @Override public void addInterceptors(InterceptorRegistry registry) registry // 添加拦截器 .addInterceptor(loginInterceptor()) // 不需要拦截的路径 .excludePathPatterns( /api/user/*/getImgCaptcha, /api/user/*/sendRegisterCode, /api/user/*/register, /api/user/*/login, /api/user/*/uploadUserAvatar, /api/user/*/detailShow/*); 7.10 获取用户详细信息 cshop-usersrcmainJavagithublianyutiancshopusermodelvoUserDetailVO.Java package github.lianyutian.cshop.user.model.vo;import lombok.Data;/** * 用户信息 VO * * @author lianyutian * @since 2024-12-25 16:22:40 * @version 1.0 */@Datapublic class UserDetailVO private Long id; /** 用户名 */ private String name; /** 用户头像 */ private String avatar; /** 0 女，1 男 */ private Integer sex; /** 用户手机号 */ private String phone; cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserController.Java /** * 用户账号信息查询 * * @return 用户信息 */@GetMapping(detail)public ApiResultUserDetailVO detail() UserDetailVO userDetailVO = userService.getUserDetail(); return ApiResult.success(userDetailVO); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserService.Java /** * 获取用户详情 * * @return 用户详情 */UserDetailVO getUserDetail(); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserServiceImpl.Java @Overridepublic UserDetailVO getUserDetail() // 通过登录拦截器中 ThreadLocal 进行了用户信息传递 LoginUserInfo loginUserInfo = LoginInterceptor.USER_THREAD_LOCAL.get(); User user = userMapper.selectOne(new LambdaQueryWrapperUser().eq(User::getId, loginUserInfo.getId())); UserDetailVO userDetailVO = new UserDetailVO(); BeanUtils.copyProperties(user, userDetailVO); return userDetailVO; 无 token 访问用户信息 有效 token 访问用户信息 7.11 用户地址相关 cshop-userdocSQLuser.SQL create table user_address( id bigint unsigned auto_increment primary key, user_id bigint null comment 用户id, default_status tinyint(1) default 0 null comment 是否默认收货地址：0否 1是, receive_name varchar(64) null comment 收发货人姓名, phone varchar(64) null comment 收货人电话, province varchar(64) null comment 省/直辖市, city varchar(64) null comment 市, region varchar(64) null comment 区, detail_address varchar(200) null comment 详细地址, create_time datetime default CURRENT_TIMESTAMP null comment 创建时间, update_time datetime default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP comment 更新时间) comment 用户收货地址表 row_format = DYNAMIC;create index uid on user_address (user_id); 7.11.1 新增用户地址 cshop-usersrcmainJavagithublianyutiancshopusermodelparamAddressAddParam.Java package github.lianyutian.cshop.user.model.param;import lombok.Data;/** * 添加用户收货地址 VO * * @author lianyutian * @since 2024-12-26 10:18:32 * @version 1.0 */@Datapublic class AddressAddParam /** 是否默认收货地址：0 否 1 是 */ private Integer defaultStatus; /** 收发货人姓名 */ private String receiveName; /** 收货人电话 */ private String phone; /** 省/直辖市 */ private String province; /** 市 */ private String city; /** 区 */ private String region; /** 详细地址 */ private String detailAddress; cshop-usersrcmainJavagithublianyutiancshopuserenumsAddressStatusEnum.Java package github.lianyutian.cshop.user.enums;import lombok.Getter;/** * 收货地址状态枚举 * * @author lianyutian * @since 2024-12-26 17:34:38 * @version 1.0 */@Getterpublic enum AddressStatusEnum DEFAULT_STATUS(0, 默认地址), NOT_DEFAULT_STATUS(1, 非默认地址); private final Integer code; private final String message; AddressStatusEnum(Integer code, String message) this.code = code; this.message = message; cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserAddressController.Java package github.lianyutian.cshop.user.controller;/** * UserAddressController * * @author lianyutian * @since 2024-12-26 09:42:18 * @version 1.0 */@AllArgsConstructor@RestController@RequestMapping(/api/address/v1)public class UserAddressController private final UserAddressService userAddressService; /** * 新增收货地址 * * @param addressAddParam 收货地址 * @return 新增结果 */ @PostMapping(add) public ApiResultVoid add(@RequestBody AddressAddParam addressAddParam) userAddressService.addUserAddress(addressAddParam); return ApiResult.success(); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserAddressService.Java package github.lianyutian.cshop.user.service;/** * 用户地址服务接口 * * @author lianyutian * @since 2024-12-26 09:54:49 * @version 1.0 */public interface UserAddressService /** * 新增用户地址 * * @param addressAddParam 新增用户地址参数 */ void addUserAddress(AddressAddParam addressAddParam); cshop-usersrcmainJavagithublianyutiancshopuserserviceimplUserAddressServiceImpl.Java package github.lianyutian.cshop.user.service.impl;/** * 用户地址服务接口实现类 * * @author lianyutian * @since 2024-12-26 09:55:13 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class UserAddressServiceImpl implements UserAddressService private final UserAddressMapper userAddressMapper; @Override @Transactional(rollbackFor = Exception.class) public void addUserAddress(AddressAddParam addressAddParam) LoginUserInfo loginUserInfo = getLoginUserInfo(); UserAddress userAddress = BeanUtil.copy(addressAddParam, UserAddress.class); userAddress.setUserId(loginUserInfo.getId()); setDefaultStatusIfRequired(userAddress); int affectedRows = userAddressMapper.insert(userAddress); log.info( 用户收货地址模块-新增收货地址：affectedRows=，data=, affectedRows, formatUserAddressForLog(userAddress)); private LoginUserInfo getLoginUserInfo() LoginUserInfo loginUserInfo = LoginInterceptor.USER_THREAD_LOCAL.get(); if (loginUserInfo == null) throw new IllegalStateException(LoginUserInfo not found in ThreadLocal); return loginUserInfo; private void setDefaultStatusIfRequired(UserAddress userAddress) if (Objects.equals( userAddress.getDefaultStatus(), AddressStatusEnum.DEFAULT_STATUS.getCode())) // 设置默认的为非默认状态 userAddressMapper.update( null, new LambdaUpdateWrapperUserAddress() .set(UserAddress::getDefaultStatus, AddressStatusEnum.NOT_DEFAULT_STATUS.getCode()) .eq(UserAddress::getUserId, userAddress.getUserId()) .eq(UserAddress::getDefaultStatus, AddressStatusEnum.DEFAULT_STATUS.getCode())); private String formatUserAddressForLog(UserAddress userAddress) // 只打印必要的字段，避免泄露敏感信息 return id= + userAddress.getId() + , userId= + userAddress.getUserId() + , defaultStatus= + userAddress.getDefaultStatus(); cshop-usersrcmainJavagithublianyutiancshopusermapperUserAddressMapper.Java package github.lianyutian.cshop.user.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import github.lianyutian.cshop.user.model.po.UserAddress;import org.apache.ibatis.annotations.Mapper;/** * UserAddressMapper * * @author lianyutian * @since 2024-12-26 14:19:30 * @version 1.0 */@Mapperpublic interface UserAddressMapper extends BaseMapperUserAddress cshop-usersrcmainresourcesmapperUserAddressMapper.xml ?xml version=1.0 encoding=UTF-8?!DOCTYPE mapper PUBLIC -//mybatis.org//DTD Mapper 3.0//EN http://mybatis.org/dtd/mybatis-3-mapper.dtdmapper namespace=github.lianyutian.cshop.user.mapper.UserAddressMapper resultMap id=BaseResultMap type=github.lianyutian.cshop.user.model.po.UserAddress id property=id column=id jdbcType=BIGINT/ result property=userId column=user_id jdbcType=BIGINT/ result property=defaultStatus column=default_status jdbcType=TINYINT/ result property=receiveName column=receive_name jdbcType=VARCHAR/ result property=phone column=phone jdbcType=VARCHAR/ result property=province column=province jdbcType=VARCHAR/ result property=city column=city jdbcType=VARCHAR/ result property=region column=region jdbcType=VARCHAR/ result property=detailAddress column=detail_address jdbcType=VARCHAR/ result property=createTime column=create_time jdbcType=TIMESTAMP/ result property=updateTime column=update_time jdbcType=TIMESTAMP/ /resultMap sql id=Base_Column_List id,user_id,default_status, receive_name,phone,province, city,region,detail_address, create_time,update_time /sql/mapper 7.11.2 根据 id 查询收货地址详情 cshop-usersrcmainJavagithublianyutiancshopusermodelvoUserAddressVO.Java package github.lianyutian.cshop.user.model.vo;import lombok.Data;/** * 用户地址 VO 界面展示 * * @author lianyutian * @since 2024-12-26 09:59:44 * @version 1.0 */@Datapublic class UserAddressVO private Long id; /** 用户 id */ private Long userId; /** 是否默认收货地址：0 否 1 是 */ private Integer defaultStatus; /** 收发货人姓名 */ private String receiveName; /** 收货人电话 */ private String phone; /** 省/直辖市 */ private String province; /** 市 */ private String city; /** 区 */ private String region; /** 详细地址 */ private String detailAddress; cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserAddressController.Java /** * 根据 id 查询收货地址详情 * * @param addressId 收货地址 id * @return 收获地址详情 */@GetMapping(detail/addressId)public ApiResultUserAddressVO detail(@PathVariable(addressId) Long addressId) UserAddressVO userAddressVo = userAddressService.getUserAddressDetail(addressId); return userAddressVo == null ? ApiResult.result(BizCodeEnum.USER_ADDRESS_NOT_EXITS) : ApiResult.success(userAddressVo); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserAddressService.Java /** * 根据用户地址 id 获取用户地址详情 * * @param addressId 地址 ID * @return 用户地址详情 */UserAddressVO getUserAddressDetail(Long addressId); cshop-usersrcmainJavagithublianyutiancshopuserserviceimplUserAddressServiceImpl.Java @Overridepublic UserAddressVO getUserAddressDetail(Long addressId) if (addressId == null || addressId = 0) throw new IllegalArgumentException(Invalid addressId); UserAddress userAddress = userAddressMapper.selectById(addressId); if (userAddress == null) return null; return BeanUtil.copy(userAddress, UserAddressVO.class); 7.11.3 获取用户地址列表 cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserAddressController.Java /** * 获取用户地址列表 * * @return 用户地址列表 */@GetMapping(list)public ApiResultListUserAddressVO list() ListUserAddressVO allUserAddressList = userAddressService.getAllUserAddressList(); return ApiResult.success(allUserAddressList); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserAddressService.Java /** * 获取用户地址列表 * * @return 用户地址列表 */ListUserAddressVO getAllUserAddressList(); cshop-usersrcmainJavagithublianyutiancshopuserserviceimplUserAddressServiceImpl.Java @Overridepublic ListUserAddressVO getAllUserAddressList() LoginUserInfo loginUserInfo = getLoginUserInfo(); ListUserAddress userAddressList = userAddressMapper.selectList( new LambdaQueryWrapperUserAddress() .eq(UserAddress::getUserId, loginUserInfo.getId())); return userAddressList.stream().map(this::convertToUserAddressVO).collect(Collectors.toList());private UserAddressVO convertToUserAddressVO(UserAddress userAddress) return BeanUtil.copy(userAddress, UserAddressVO.class); 7.11.4 修改指定收货地址 cshop-usersrcmainJavagithublianyutiancshopusermodelparamAddressEditParam.Java package github.lianyutian.cshop.user.model.param;import lombok.Data;/** * 修改指定收货地址入参 * * @author lianyutian * @since 2024-12-26 11:02:20 * @version 1.0 */@Datapublic class AddressEditParam /** 地址 id */ private Long id; /** 是否默认收货地址：0 否 1 是 */ private Integer defaultStatus; /** 收发货人姓名 */ private String receiveName; /** 收货人电话 */ private String phone; /** 省/直辖市 */ private String province; /** 市 */ private String city; /** 区 */ private String region; /** 详细地址 */ private String detailAddress; cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserAddressController.Java /** * 修改指定收货地址 * * @param addressEditParam 收货地址 * @return 修改结果 */@PostMapping(edit)public ApiResultVoid edit(@RequestBody AddressEditParam addressEditParam) boolean updated = userAddressService.updateUserAddress(addressEditParam); return updated ? ApiResult.success() : ApiResult.result(BizCodeEnum.USER_ADDRESS_NOT_EXITS); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserAddressService.Java /** * 修改用户地址 * * @param addressEditParam 修改用户地址参数 */boolean updateUserAddress(AddressEditParam addressEditParam); cshop-usersrcmainJavagithublianyutiancshopuserserviceimplUserAddressServiceImpl.Java @Override@Transactional(rollbackFor = Exception.class)public boolean updateUserAddress(AddressEditParam addressEditParam) UserAddress oldUserAddress = userAddressMapper.selectById(addressEditParam.getId()); if (oldUserAddress == null) return false; LoginUserInfo loginUserInfo = getLoginUserInfo(); UserAddress userAddress = BeanUtil.copy(addressEditParam, UserAddress.class); userAddress.setUserId(loginUserInfo.getId()); setDefaultStatusIfRequired(userAddress); int affectedRows = userAddressMapper.update( userAddress, new LambdaUpdateWrapperUserAddress() .eq(UserAddress::getId, addressEditParam.getId())); if (affectedRows == 0) log.warn(用户收货地址模块-更新收货地址失败：id=, addressEditParam.getId()); return false; log.info( 用户收货地址模块-更新收货地址：affectedRows=，data=, affectedRows, formatUserAddressForLog(userAddress)); return true; 7.11.5 删除用户地址 cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserAddressController.Java /** * 删除指定收货地址 * * @param addressId 收货地址 id * @return 删除结果 */@GetMapping(delete/addressId)public ApiResultVoid delete(@PathVariable(addressId) Long addressId) return userAddressService.deleteUserAddress(addressId) == 1 ? ApiResult.success() : ApiResult.result(BizCodeEnum.USER_ADDRESS_NOT_EXITS); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserAddressService.Java /** * 删除用户地址 * * @param addressId 地址 ID * @return 删除结果 */int deleteUserAddress(Long addressId); cshop-usersrcmainJavagithublianyutiancshopuserserviceimplUserAddressServiceImpl.Java @Override@Transactional(rollbackFor = Exception.class)public int deleteUserAddress(Long addressId) return userAddressMapper.deleteById(addressId); 7.12 用户详情引入 Redis用户点击自身详情时会显示 用户名、头像、性别、手机号 等信息，这些信息很少变动，可以考虑写入缓存中。 cshop-usersrcmainJavagithublianyutiancshopuserconstantUserCacheKeyConstant.Java package github.lianyutian.cshop.user.constant;/** * 缓存常量 * * @author lianyutian * @since 2024-12-24 13:46:37 * @version 1.0 */public class UserCacheKeyConstant /** 图形验证码缓存 key 前缀 */ public static final String CAPTCHA_IMG_KEY_PREFIX = cshop-user:img-captcha:; /** 注册验证码缓存 key 前缀 */ public static final String CAPTCHA_REGISTER_KEY_PREFIX = cshop-user:register-captcha:; /** 用户信息更新锁前缀 */ public static final String USER_UPDATE_LOCK_KEY_PREFIX = cshop-user:update:lock:; /** 用户信息缓存前缀 */ public static final String USER_DETAIL_KEY_PREFIX = cshop-user:detail:; /** 用户展示信息缓存前缀 */ public static final String USER_SHOW_KEY_PREFIX = cshop-user:show:; cshop-usersrcmainJavagithublianyutiancshopuserserviceimplUserServiceImpl.Java private final RedisCache redisCache;@Overridepublic UserDetailVO getUserDetail() // 通过登录拦截器中 ThreadLocal 进行了用户信息传递 LoginUserInfo loginUserInfo = LoginInterceptor.USER_THREAD_LOCAL.get(); UserDetailVO userDetailVO = getUserDetailFromCache(loginUserInfo.getId()); if (userDetailVO != null) return userDetailVO; // 不存在才去查库 User user = userMapper.selectOne(new LambdaQueryWrapperUser().eq(User::getId, loginUserInfo.getId())); userDetailVO = BeanUtil.copy(user, UserDetailVO.class); redisCache.set( UserCacheKeyConstant.USER_DETAIL_KEY_PREFIX + loginUserInfo.getId(), userDetailVO, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); log.info(用户模块-缓存用户信息：, JsonUtil.toJson(user)); return userDetailVO;private UserDetailVO getUserDetailFromCache(long userId) String key = UserCacheKeyConstant.USER_DETAIL_KEY_PREFIX + userId; String userDetail = redisCache.get(key); log.info(用户模块-从缓存中获取用户信息：, userDetail); if (StringUtils.isNotBlank(userDetail)) // 缓存延期 redisCache.expire(key, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); return JsonUtil.fromJson(userDetail, UserDetailVO.class); return null; 7.13 用户信息展示 点击进入用户主页可以显示用户 用户名、id、性别 等主要信息 7.13.1 V1 版本 cshop-usersrcmainJavagithublianyutiancshopusermodelvoUserShowVO.Java package github.lianyutian.cshop.user.model.vo;import lombok.Data;/** * 用户展示信息 VO 展示给他人看的信息 * * @author lianyutian * @since 2024-12-27 17:11:22 * @version 1.0 */@Datapublic class UserShowVO /** 用户 id */ private Long id; /** 用户名 */ private String name; /** 用户头像 */ private String avatar; cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserController.Java /** * 获取用户展示信息 * * @param userId 用户 ID * @return 用户展示信息 */@GetMapping(detail/show/userId)public ApiResultUserShowVO getUserShow(@PathVariable(userId) Long userId) UserShowVO userShowVO = userService.getUserShow(userId); return ApiResult.success(userShowVO); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserService.Java /** * 获取用户展示详情 * * @param userId 用户 id * @return 用户展示详情 */UserShowDetailVO getUserShow(Long userId); cshop-usersrcmainJavagithublianyutiancshopuserserviceimplUserServiceImpl.Java public UserShowVO getUserShow_V1(Long userId) User user = userMapper.selectOne(new LambdaQueryWrapperUser().eq(User::getId, userId)); UserShowVO userShowVO = new UserShowVO(); return BeanUtil.copy(user, userShowVO); 优点 查询用户信息都直接查数据库，没有数据一致性问题 缺点 所有请求都查库，性能不高 如果并发量大可能直接打崩数据库 7.12.2 V2 版本因为用户信息展示是个读多写少的场景，用户信息自身很少变更但是用户展示信息会有较多的查询展示。非常适合缓存，所以这里引入 Redis 缓存用户的展示信息。 cshop-usersrcmainJavagithublianyutiancshopuserserviceimplUserServiceImpl.Java public UserShowVO getUserShow_V2(Long userId) UserShowVO userShowVO = getUserShowFromCache(userId); if (userShowVO != null) UserShowVO userShowVO = new UserShowVO(); return BeanUtil.copy(userShowVO, UserShowVO.class); User user = userMapper.selectOne(new LambdaQueryWrapperUser().eq(User::getId, userId)); UserShowVO userShowVO = new UserShowVO(); return BeanUtil.copy(userShowVO, UserShowVO.class);private UserShowVO getUserShowFromCache(long userId) String key = UserCacheKeyConstant.USER_SHOW_KEY_PREFIX + userId; String userShow = redisCache.get(key); log.info(用户模块-从缓存中获取用户展示信息：, userShow); if (StringUtils.isNotBlank(userShow)) // 缓存延期 redisCache.expire(key, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); return JsonUtil.fromJson(userShow, UserShowVO.class); return null; 优点 缓存存在时所有查询走缓存，性能高 缺点 缓存不存在时，如果有超高并发进入还是会直接打进数据库 当查询不存在的 userId 时会直接穿透缓存打到数据库，同时高并发查询不存在的 userId 也可能打崩数据库 7.12.3 V3 版本public UserShowVO getUserShow_V3(Long userId) UserShowVO userShowVO = getUserShowFromCache(userId); if (userShowVO != null) return BeanUtil.copy(userShowVO, UserShowVO.class); boolean tryLocked = false; try // 解决高并发查库的问题 tryLocked = redisLock.tryLock(cshop-user:user-show:lock: + userId, 200); if (!tryLocked) return null; User user = userMapper.selectOne(new LambdaQueryWrapperUser().eq(User::getId, userId)); if (user == null) // 解决缓存穿透问题 redisCache.set( UserCacheKeyConstant.USER_SHOW_KEY_PREFIX + userId, , RedisCache.generateCachePenetrationExpire(), TimeUnit.MILLISECONDS); return null; return BeanUtil.copy(user, UserShowVO.class); catch (InterruptedException e) log.info(【getUserShow】获取锁失败, userId , userId); return null; finally if (tryLocked) redisLock.unlock(cshop-user:info:lock: + userId); 优点 解决高并发下查数据库问题 解决高并发下查不存在 userId 问题 缺点 用户同时更新信息时存在缓存和数据库不一致问题 7.12.4 V4 版本** * 用户展示信息 * * p1.假如 用户Z 发布了一篇内容突然爆火，同一时刻有上万用户来查看 用户Z 的个人信息，此时就会存在同一时刻会有超大并发流量进入该接口 * * p2.如果有恶意用户大批量使用不存在的 用户id 来查询，就会造成缓存穿透，大量请求击穿的 DB 层。 * * p3.如果 用户Z 在这个时刻修改了自己的信息，怎么保证其他用户查询到的是最新的信息，怎么保证缓存和数据库的数据一致性 * * p场景：例如 线程A 来查询 用户Z 的信息，同时 线程B 修改 用户Z 信息且此时缓存中 用户Z 信息刚好过期。 * * p那么此时 线程A 会去查数据库，这个时候 线程B 还没将 用户Z 修改后的信息保存到数据库中。 * * p所以 线程A 拿到的是旧的数据，再假设此时 线程A 没抢到 CPU 资源阻塞住了。 * * p这个时候 线程B 已经修改完自身信息并保存入数据库，同时会将新数据刷新到缓存中。 * * p再执行完成这一步后，线程A 才继续执行，此时 线程A 拿到的还是旧的数据，也会去刷新缓存。 * * p那么此时缓存中的数据是 线程A 在 线程B 更新前的旧数据，数据库中是 线程B 更新的新数据。 * * p解决方案：更新用户接口也加 同 一把分布式锁，保证读写串行。用户更新自身信息是占比很少的写操作，这里考虑的是极端场景 * * @param userId 用户id * @return 用户展示信息 */@Overridepublic UserShowVO getUserShow(Long userId) UserShowVO userShowVO = getUserShowFromCache(userId); if (userShowVO != null) return userShowVO; // 2、缓存为空再从数据库中获取 return getUserShowFromDB(userId);private UserDetailVO getUserDetailFromCache(long userId) String key = UserCacheKeyConstant.USER_DETAIL_KEY_PREFIX + userId; String userDetail = redisCache.get(key); log.info(用户模块-从缓存中获取用户信息：, userDetail); if (StringUtils.isNotBlank(userDetail)) // 缓存延期 redisCache.expire(key, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); return JsonUtil.fromJson(userDetail, UserDetailVO.class); return null;private UserShowVO getUserShowFromCache(long userId) String key = UserCacheKeyConstant.USER_SHOW_KEY_PREFIX + userId; String userShow = redisCache.get(key); log.info(用户模块-从缓存中获取用户展示信息：, userShow); if (StringUtils.isNotBlank(userShow)) // 缓存延期 redisCache.expire(key, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); return JsonUtil.fromJson(userShow, UserShowVO.class); return null;private UserShowVO getUserShowFromDB(Long userId) String userUpdateLockKey = UserCacheKeyConstant.USER_UPDATE_LOCK_KEY_PREFIX + userId; // 设置分布式锁 boolean tryLocked = false; try // TODO 解释 tryLocked = redisLock.tryLock(userUpdateLockKey, RedisCache.UPDATE_LOCK_TIMEOUT); if (!tryLocked) // 加锁超时 /* 尝试加锁时间有 RedisCache.UPDATE_LOCK_TIMEOUT 有可能其他线程已经获取数据并写入缓存了所以这里再尝试去读下缓存 */ UserShowVO userShowFromCache = getUserShowFromCache(userId); if (userShowFromCache != null) return userShowFromCache; log.warn(【getUserShowFromDB】用户缓存为空，查询用户信息获取锁失败 , userId); return null; User user = userMapper.selectById(userId); if (user == null) // 如果为空先在缓存中设置一个空值，防止缓存穿透（解决 2） redisCache.set( UserCacheKeyConstant.USER_SHOW_KEY_PREFIX + userId, RedisCache.EMPTY_CACHE, RedisCache.generateCachePenetrationExpire(), TimeUnit.MILLISECONDS); return null; UserShowVO userShowVO = BeanUtil.copy(user, UserShowVO.class); log.info(【getUserShowFromDB】用户缓存为空，从数据库获取用户信息 , JsonUtil.toJson(userShowVO)); redisCache.set( UserCacheKeyConstant.USER_SHOW_KEY_PREFIX + userId, userShowVO, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); return userShowVO; catch (InterruptedException e) // 加锁失败 // 这里再去尝试获取下缓存-双重检查 UserShowVO userShowFromCache = getUserShowFromCache(userId); if (userShowFromCache != null) return userShowFromCache; log.error(【getUserShowFromDB】尝试加锁异常，异常信息：, e.getMessage(), e); throw new BizException(BizCodeEnum.USER_INFO_SHOW_LOCK_FAIL); finally if (tryLocked) redisLock.unlock(userUpdateLockKey); 7.13 用户信息更新 cshop-usersrcmainJavagithublianyutiancshopusermodelparamUserEditParam.Java package github.lianyutian.cshop.user.model.param;import lombok.Data;/** * 用户信息修改入参 * * @author lianyutian * @since 2024-12-27 13:23:04 * @version 1.0 */@Datapublic class UserEditParam /** 用户 id */ private Long id; /** 手机号 */ private String phone; /** 用户名 */ private String name; /** 头像 */ private String avatar; /** 性别 */ private int sex; cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserController.Java /** * 用户信息修改 * * @param userEditParam 用户信息 * @return 修改结果 */@PostMapping(edit)public ApiResultVoid edit(@RequestBody UserEditParam userEditParam) userService.updateUser(userEditParam); return ApiResult.success(); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserService.Java /** * 更新用户信息 * * @param userEditParam 用户编辑参数 */void updateUserInfo(UserEditParam userEditParam); cshop-usersrcmainJavagithublianyutiancshopuserserviceimplUserServiceImpl.Java @Override@Transactional(rollbackFor = Exception.class)public void updateUser(UserEditParam userEditParam) LoginUserInfo loginUserInfo = LoginInterceptor.USER_THREAD_LOCAL.get(); userEditParam.setId(loginUserInfo.getId()); boolean locked = false; try // 这里加分布式锁是为了保证高并发下有其他用户查询该用户信息时保证数据库和缓存的一致性 locked = redisLock.lock(UserCacheKeyConstant.USER_UPDATE_LOCK_KEY_PREFIX + loginUserInfo.getId()); if (!locked) log.error(用户模块-修改用户信息：用户 获取锁失败, loginUserInfo.getId()); throw new BizException(BizCodeEnum.USER_DETAIL_UPDATE_FAIL); // 先删掉缓存，防止出现数据库更新成功但是更新缓存失败，获取用户信息时一直都是缓存的数据 redisCache.delete(UserCacheKeyConstant.USER_SHOW_KEY_PREFIX + loginUserInfo.getId()); redisCache.delete(UserCacheKeyConstant.USER_DETAIL_KEY_PREFIX + loginUserInfo.getId()); User user = BeanUtil.copy(userEditParam, User.class); int rows = userMapper.update( user, new LambdaUpdateWrapperUser().eq(User::getId, loginUserInfo.getId())); log.info(用户模块-修改用户信息：rows=，data=, rows, userEditParam); User newUser = userMapper.selectOne( new LambdaQueryWrapperUser().eq(User::getId, loginUserInfo.getId())); UserShowVO userShowVO = BeanUtil.copy(newUser, UserShowVO.class); // 这里存在数据库更新后，缓存更新失败的场景（这里不去强制保证数据库更新完成后一定更新成功缓存） redisCache.set( UserCacheKeyConstant.USER_SHOW_KEY_PREFIX + loginUserInfo.getId(), userShowVO, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); UserDetailVO userDetailVO = BeanUtil.copy(newUser, UserDetailVO.class); redisCache.set( UserCacheKeyConstant.USER_DETAIL_KEY_PREFIX + loginUserInfo.getId(), userDetailVO, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); finally if (locked) redisLock.unlock(UserCacheKeyConstant.USER_UPDATE_LOCK_KEY_PREFIX + loginUserInfo.getId()); 7.14 笔记服务https://nginx.org/en/download.html 7.14.1 新建笔记服务 cshop-commonpom.xml !-- mybatis-plus 分页插件 --dependency groupIdcom.baomidou/groupId artifactIdmybatis-plus-jsqlparser/artifactId/dependency cshop-notepom.xml ?xml version=1.0 encoding=UTF-8?project xmlns=http://maven.apache.org/POM/4.0.0 xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation=http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion4.0.0/modelVersion parent groupIdgithub.lianyutian.cshop/groupId artifactIdcircle-shop/artifactId version1.0-SNAPSHOT/version /parent groupIdgithub.lianyutian.cshop.note/groupId artifactIdcshop-note/artifactId description笔记服务/description properties maven.compiler.source17/maven.compiler.source maven.compiler.target17/maven.compiler.target project.build.sourceEncodingUTF-8/project.build.sourceEncoding /properties dependencies dependency groupIdgithub.lianyutian.cshop.common/groupId artifactIdcshop-common/artifactId version1.0-SNAPSHOT/version /dependency dependency groupIdorg.springframework.boot/groupId artifactIdspring-boot-starter-web/artifactId /dependency dependency groupIdmysql/groupId artifactIdmysql-connector-java/artifactId /dependency dependency groupIdcom.baomidou/groupId artifactIdmybatis-plus-spring-boot3-starter/artifactId /dependency dependency groupIdorg.apache.rocketmq/groupId artifactIdrocketmq-client/artifactId /dependency /dependencies/project cshop-notesrcmainresourcesapplication.yml # 服务端口server: port: 9003spring: application: name: cshop-note # mysql配置 datasource: username: root password: MIIEowIBAAKCAQEAwG90ULRHmAXFXQzZSwleoYts2+bCzUvqhhqtGiv/F5kUsETY url: jdbc:mysql://116.198.217.158:3306/cshop-user?useUnicode=truecharacterEncoding=utf-8useSSL=falseserverTimezone=Asia/Shanghai driver-class-name: com.mysql.cj.jdbc.Driver # redis配置 data: redis: host: 116.198.217.158 port: 6379 password: MIIEowIBAAKCAQEAwG90ULRHmAXFXQzZSwleoYts2+bCzUvqhhqtGiv/F5kUsETY # 如果有密码 database: 0 # 默认数据库 timeout: 60000 # 读取 redis 超时时间 lettuce: pool: max-active: 100 # 最大连接数 max-idle: 100 # 最大空闲连接数 min-idle: 100 # 最小空闲连接数 max-wait: 60000 # 最大等待时间，单位是毫秒# 设置日志级别：ERROR/WARN/INFO/DEBUG,默认是 INFO 以上才显示logging: level: root: INFO# 配置 mybatis plus 打印 sql 日志mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl# rocketmq配置rocketmq: accessKey: mqadmin secretKey: MIIEowIBAAKCAQEAwG90ULRHmAXFXQzZSwleoYts2+bCzUvqhhqtGiv/F5kUsETY nameServer: 116.198.217.158:9876 cshop-notesrcmainJavagithublianyutiancshopnoteNoteApplication.Java package github.lianyutian.cshop.note;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;/** * 笔记服务启动类 * * @author lianyutian * @since 2025-01-02 14:55:33 * @version 1.0 */@SpringBootApplication@ComponentScan(basePackages = github.lianyutian.cshop.note, github.lianyutian.cshop.common)public class NoteApplication public static void main(String[] args) SpringApplication.run(NoteApplication.class, args); 7.14.2 新增笔记 cshop-notesrcmainJavagithublianyutiancshopnotemodelparamNoteAddParam.Java package github.lianyutian.cshop.note.model.param;import com.fasterxml.jackson.annotation.JsonFormat;import java.util.Date;import lombok.Data;/** * 添加笔记入参 * * @author lianyutian * @since 2025-01-02 17:16:18 * @version 1.0 */@Datapublic class NoteAddParam /** 笔记图片链接 */ private String imgUrls; /** 笔记标题 */ private String title; /** 正文内容 */ private String content; /** 笔记视频链接 */ private String videoUrl; /** 自主声明 */ private String declaration; /** 1 公开可见，2 仅自己可见，3 仅互关好友可见，4 部分人可见 5 部分人不可见 */ private Integer visibleRange; /** 发布时间 */ @JsonFormat(pattern = yyyy-MM-dd HH:mm:ss, timezone = GMT+8) private Date publishTime; cshop-notesrcmainJavagithublianyutiancshopnotecontrollerNoteController.Java package github.lianyutian.cshop.note.controller;import github.lianyutian.cshop.common.enums.BizCodeEnum;import github.lianyutian.cshop.common.model.ApiResult;import github.lianyutian.cshop.note.model.param.NoteAddParam;import github.lianyutian.cshop.note.model.param.NoteEditParam;import github.lianyutian.cshop.note.model.vo.NoteDetailVO;import github.lianyutian.cshop.note.service.NoteService;import lombok.AllArgsConstructor;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * NoteController * * @author lianyutian * @since 2025-01-02 17:14:17 * @version 1.0 */@RestController@RequestMapping(/api/note/v1)@AllArgsConstructorpublic class NoteController private final NoteService noteService; /** * 添加笔记 * * @param noteAddParam 笔记入参 * @return 添加结果 */ @PostMapping(add) public ApiResultVoid addNote(@RequestBody NoteAddParam noteAddParam) int added = noteService.addNote(noteAddParam); return added 0 ? ApiResult.success() : ApiResult.result(BizCodeEnum.NOTE_ADD_FAIL); cshop-notesrcmainJavagithublianyutiancshopnoteserviceNoteService.Java package github.lianyutian.cshop.note.service;import github.lianyutian.cshop.note.model.param.NoteAddParam;import github.lianyutian.cshop.note.model.param.NoteEditParam;import github.lianyutian.cshop.note.model.vo.NoteDetailVO;/** * 笔记服务 * * @author lianyutian * @since 2025-01-03 10:53:40 * @version 1.0 */public interface NoteService /** * 添加笔记 * * @param noteAddParam 笔记入参 */ int addNote(NoteAddParam noteAddParam); cshop-notesrcmainJavagithublianyutiancshopnoteserviceimplNoteServiceImpl.Java package github.lianyutian.cshop.note.service.impl;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;import github.lianyutian.cshop.common.enums.BizCodeEnum;import github.lianyutian.cshop.common.exception.BizException;import github.lianyutian.cshop.common.interceptor.LoginInterceptor;import github.lianyutian.cshop.common.model.LoginUserInfo;import github.lianyutian.cshop.common.redis.RedisCache;import github.lianyutian.cshop.common.redis.RedisLock;import github.lianyutian.cshop.common.utils.BeanUtil;import github.lianyutian.cshop.common.utils.JsonUtil;import github.lianyutian.cshop.note.constant.NoteCacheKeyConstant;import github.lianyutian.cshop.note.constant.NoteRocketMQConstant;import github.lianyutian.cshop.note.enums.NoteMessageType;import github.lianyutian.cshop.note.enums.NoteStatusEnum;import github.lianyutian.cshop.note.mapper.NoteMapper;import github.lianyutian.cshop.note.model.param.NoteAddParam;import github.lianyutian.cshop.note.model.param.NoteEditParam;import github.lianyutian.cshop.note.model.po.Note;import github.lianyutian.cshop.note.model.vo.NoteDetailVO;import github.lianyutian.cshop.note.model.vo.NoteShowVO;import github.lianyutian.cshop.note.mq.message.NoteAddMessage;import github.lianyutian.cshop.note.mq.message.NoteUpdateMessage;import github.lianyutian.cshop.note.mq.producer.NoteTransactionProducer;import github.lianyutian.cshop.note.service.NoteService;import java.util.Date;import java.util.concurrent.TimeUnit;import lombok.AllArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;/** * 笔记服务实现类 * * @author lianyutian * @since 2025-01-03 10:54:31 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class NoteServiceImpl implements NoteService private final NoteMapper noteMapper; @Override @Transactional(rollbackFor = Exception.class) public int addNote(NoteAddParam noteAddParam) LoginUserInfo loginUserInfo = LoginInterceptor.USER_THREAD_LOCAL.get(); Note note = BeanUtil.copy(noteAddParam, Note.class); note.setUserId(loginUserInfo.getId()); note.setStatus(NoteStatusEnum.AUDITING); note.setPublishTime(new Date()); int row; try row = noteMapper.insert(note); catch (Exception e) log.error(db addNote error , e.getMessage(), e); throw new BizException(BizCodeEnum.NOTE_ADD_FAIL); log.info(笔记服务-新增笔记：rows=，data=, row, JsonUtil.toJson(noteAddParam)); return row; 7.14.3 修改笔记 cshop-notesrcmainJavagithublianyutiancshopnotemodelparamNoteEditParam.Java package github.lianyutian.cshop.note.model.param;import com.fasterxml.jackson.annotation.JsonFormat;import java.util.Date;import lombok.Data;/** * 笔记修改入参 * * @author lianyutian * @since 2025-01-03 11:07:53 * @version 1.0 */@Datapublic class NoteEditParam /** 笔记 id */ private Long id; /** 笔记图片链接 */ private String imgUrls; /** 笔记标题 */ private String title; /** 正文内容 */ private String content; /** 笔记视频链接 */ private String videoUrl; /** 自主声明 */ private String declaration; /** 1 公开可见，2 仅自己可见，3 仅互关好友可见，4 部分人可见 5 部分人不可见 */ private Integer visibleRange; /** 发布时间 */ @JsonFormat(pattern = yyyy-MM-dd HH:mm:ss, timezone = GMT+8) private Date publishTime; package github.lianyutian.cshop.note.controller;/** * NoteController * * @author lianyutian * @since 2025-01-02 17:14:17 * @version 1.0 */@RestController@RequestMapping(/api/note/v1)@AllArgsConstructorpublic class NoteController private final NoteService noteService; /** * 更新我的笔记 * * @param noteAddParam 更新笔记入参 * @return 更新结果 */ @PostMapping(edit) public ApiResultVoid updateNote(@RequestBody NoteEditParam noteAddParam) int updated = noteService.updateNote(noteAddParam); return updated 0 ? ApiResult.success() : ApiResult.result(BizCodeEnum.NOTE_UPDATE_FAIL); package github.lianyutian.cshop.note.service;/** * 笔记服务 * * @author lianyutian * @since 2025-01-03 10:53:40 * @version 1.0 */public interface NoteService /** * 更新笔记 * * @param noteAddParam 笔记更新入参 */ int updateNote(NoteEditParam noteAddParam); package github.lianyutian.cshop.note.service.impl;/** * 笔记服务实现类 * * @author lianyutian * @since 2025-01-03 10:54:31 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class NoteServiceImpl implements NoteService private final NoteMapper noteMapper; @Override @Transactional(rollbackFor = Exception.class) public int updateNote(NoteEditParam noteEditParam) // 1.查询笔记是否存在 LoginUserInfo loginUserInfo = LoginInterceptor.USER_THREAD_LOCAL.get(); Note updateNote = BeanUtil.copy(noteEditParam, Note.class); int row = 0; try row = noteMapper.update( updateNote, new LambdaUpdateWrapperNote() .eq(Note::getId, noteEditParam.getId()) .eq(Note::getUserId, loginUserInfo.getId())); log.info(笔记服务-更新笔记：row=, data=, row, JsonUtil.toJson(noteEditParam)); return row; catch (Exception e) log.error(updateNote error , e.getMessage(), e); throw new BizException(BizCodeEnum.NOTE_UPDATE_FAIL); 7.14.4 删除笔记package github.lianyutian.cshop.note.controller;/** * NoteController * * @author lianyutian * @since 2025-01-02 17:14:17 * @version 1.0 */@RestController@RequestMapping(/api/note/v1)@AllArgsConstructorpublic class NoteController private final NoteService noteService; /** * 删除我的笔记 * * @param noteId noteId * @return 删除结果 */ @GetMapping(delete/noteId) public ApiResultVoid delete(@PathVariable(noteId) long noteId) int deleted = noteService.deleteNote(noteId); return deleted 0 ? ApiResult.success() : ApiResult.result(BizCodeEnum.NOTE_DEL_FAIL); package github.lianyutian.cshop.note.service;/** * 笔记服务 * * @author lianyutian * @since 2025-01-03 10:53:40 * @version 1.0 */public interface NoteService /** * 删除笔记 * * @param id 笔记 id */ int deleteNote(long id); package github.lianyutian.cshop.note.service.impl;/** * 笔记服务实现类 * * @author lianyutian * @since 2025-01-03 10:54:31 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class NoteServiceImpl implements NoteService private final NoteMapper noteMapper; @Override @Transactional(rollbackFor = Exception.class) public int deleteNote(long id) return noteMapper.deleteById(id); 7.14.5 获取我的笔记详情 cshop-notesrcmainJavagithublianyutiancshopnotemodelvoNoteDetailVO.Java package github.lianyutian.cshop.note.model.vo;import java.util.Date;import lombok.Data;/** * 笔记 VO * * @author lianyutian * @since 2025-01-03 11:06:30 * @version 1.0 */@Datapublic class NoteDetailVO /** 笔记 id */ private long id; /** 笔记图片链接 */ private String imgUrls; /** 笔记标题 */ private String title; /** 正文内容 */ private String content; /** 笔记视频链接 */ private String videoUrl; /** 自主声明 */ private String declaration; /** 1 公开可见，2 仅自己可见，3 仅互关好友可见，4 部分人可见 5 部分人不可见 */ private Integer visibleRange; /** 发布时间 */ private Date publishTime; package github.lianyutian.cshop.note.controller;import github.lianyutian.cshop.common.enums.BizCodeEnum;import github.lianyutian.cshop.common.model.ApiResult;import github.lianyutian.cshop.note.model.param.NoteAddParam;import github.lianyutian.cshop.note.model.param.NoteEditParam;import github.lianyutian.cshop.note.model.vo.NoteDetailVO;import github.lianyutian.cshop.note.service.NoteService;import lombok.AllArgsConstructor;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * NoteController * * @author lianyutian * @since 2025-01-02 17:14:17 * @version 1.0 */@RestController@RequestMapping(/api/note/v1)@AllArgsConstructorpublic class NoteController private final NoteService noteService; /** * 获取我的笔记详情 * * @param noteId noteId * @return 笔记详情信息 */ @GetMapping(/detail/noteId) public ApiResultNoteDetailVO detail(@PathVariable(noteId) Long noteId) return ApiResult.success(noteService.getNoteDetail(noteId)); package github.lianyutian.cshop.note.service;/** * 笔记服务 * * @author lianyutian * @since 2025-01-03 10:53:40 * @version 1.0 */public interface NoteService /** * 获取笔记详情 * * @param noteId 笔记 id */ NoteDetailVO getNoteDetail(Long noteId); package github.lianyutian.cshop.note.service.impl;/** * 笔记服务实现类 * * @author lianyutian * @since 2025-01-03 10:54:31 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class NoteServiceImpl implements NoteService private final NoteMapper noteMapper; @Override public NoteDetailVO getNoteDetail(Long noteId) LoginUserInfo loginUserInfo = LoginInterceptor.USER_THREAD_LOCAL.get(); Note note = noteMapper.selectOne( new LambdaQueryWrapperNote() .eq(Note::getId, noteId) .eq(Note::getUserId, loginUserInfo.getId())); if (note == null) return null; return BeanUtil.copy(note, NoteDetailVO.class); 7.14.6 查看他人笔记详情 cshop-notesrcmainJavagithublianyutiancshopnotemodelvoNoteShowVO.Java package github.lianyutian.cshop.note.model.vo;import java.util.Date;import lombok.Data;/** * 笔记展示 VO * * @author lianyutian * @since 2025-01-03 11:06:30 * @version 1.0 */@Datapublic class NoteShowVO /** 笔记 id */ private long id; /** 笔记图片链接 */ private String imgUrls; /** 笔记标题 */ private String title; /** 正文内容 */ private String content; /** 笔记视频链接 */ private String videoUrl; /** 自主声明 */ private String declaration; /** 发布时间 */ private Date publishTime; cshop-notesrcmainJavagithublianyutiancshopnotecontrollerNoteShowController.Java package github.lianyutian.cshop.note.controller;/** * 用户笔记展示 * * @author lianyutian * @since 2025-01-09 10:12:54 * @version 1.0 */@RestController@RequestMapping(/api/note/v1)@AllArgsConstructorpublic class NoteShowController private final NoteShowService noteShowService; /** * 获取笔记详情 * * @param noteId 笔记 ID * @return 笔记详情 */ @PostMapping(detail/show) public ApiResultNoteShowVO getNoteShow(@RequestBody Long noteId) if (noteId == null) return ApiResult.result(BizCodeEnum.COMMON_PARAM_ERROR); NoteShowVO noteShowVO = noteShowService.getNoteShow(noteId); return noteShowVO == null ? ApiResult.result(BizCodeEnum.NOTE_NOT_EXITS) : ApiResult.success(noteShowVO); cshop-notesrcmainJavagithublianyutiancshopnoteserviceNoteShowService.Java package github.lianyutian.cshop.note.service;/** * 用户笔记展示 * * @author lianyutian * @since 2025-01-09 10:15:18 * @version 1.0 */public interface NoteShowService /** * 获取笔记展示详情 * * @param noteId 笔记 ID * @return 笔记详情 */ NoteShowVO getNoteShow(Long noteId); cshop-notesrcmainJavagithublianyutiancshopnoteserviceimplNoteShowServiceImpl.Java package github.lianyutian.cshop.note.service.impl;/** * 用户笔记展示实现 * * @author lianyutian * @since 2025-01-09 10:18:39 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class NoteShowServiceImpl implements NoteShowService private final NoteMapper noteMapper; @Override public NoteShowVO getNoteShow(Long noteId) Note note = noteMapper.selectOne( new LambdaQueryWrapperNote() .eq(Note::getId, noteId) .eq(Note::getStatus, NoteStatusEnum.PUBLISHED.getCode())); if (note == null) log.info(【getNoteShow】笔记不存在 , noteId); return null; return BeanUtil.copy(note, NoteShowVO.class); 7.14.7 查看笔记分页列表 cshop-notesrcmainJavagithublianyutiancshopnoteconfigMybatisPlusConfig.Java package github.lianyutian.cshop.note.config;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * MybatisPlus 插件配置 * * @author lianyutian * @since 2025-01-03 13:46:12 * @version 1.0 */@Configurationpublic class MybatisPlusConfig /** 添加分页插件 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; cshop-commonsrcmainJavagithublianyutiancshopcommonmodelvoPageVO.Java package github.lianyutian.cshop.common.model.vo;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import com.fasterxml.jackson.annotation.JsonIgnore;import java.util.Collections;import java.util.List;import java.util.Objects;import lombok.AllArgsConstructor;import lombok.Data;/** * 分页返回结果 * * @author lianyutian * @since 2025-01-03 14:19:25 * @version 1.0 */@Data@AllArgsConstructorpublic class PageVOT /** 总条数 */ protected Long total; /** 总页码数 */ protected Long pages; /** 当前页数据 */ protected ListT list; public static T PageVOT empty(Page? page) return new PageVO( Objects.requireNonNull(page, Page cannot be null).getTotal(), page.getPages(), Collections.emptyList()); public static T PageVOT of(Page? page, ListT list) if (page == null) throw new IllegalArgumentException(Page cannot be null); if (list == null) throw new IllegalArgumentException(List cannot be null); return new PageVO(page.getTotal(), page.getPages(), Collections.unmodifiableList(list)); @JsonIgnore public boolean isEmpty() return list.isEmpty(); cshop-commonsrcmainJavagithublianyutiancshopcommonmodelparamPageParam.Java package github.lianyutian.cshop.common.model.param;import com.baomidou.mybatisplus.core.metadata.OrderItem;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import jakarta.validation.constraints.Min;import lombok.Data;import org.apache.commons.lang3.StringUtils;/** * 分页查询入参 * * @author lianyutian * @since 2025-01-03 14:53:29 * @version 1.0 */@Datapublic class PageParam public static final Integer DEFAULT_PAGE_SIZE = 20; public static final Integer DEFAULT_PAGE_NUM = 1; /** 页码 */ @Min(value = 1, message = 页码不能小于1) private final Integer pageNo = DEFAULT_PAGE_NUM; /** 每页大小 */ @Min(value = 1, message = 每页查询数量不能小于1) private final Integer pageSize = DEFAULT_PAGE_SIZE; /** 是否升序 */ private Boolean isAsc = true; /** 排序字段 */ private String sortBy; public int from() return (pageNo - 1) * pageSize; public T PageT toMpPage(OrderItem... orderItems) PageT page = new Page(pageNo, pageSize); // 是否手动指定排序方式 if (orderItems != null orderItems.length 0) for (OrderItem orderItem : orderItems) page.addOrder(orderItem); return page; // 前端是否有排序字段 if (StringUtils.isNotEmpty(sortBy)) OrderItem orderItem = new OrderItem(); orderItem.setAsc(isAsc); orderItem.setColumn(sortBy); page.addOrder(orderItem); return page; public T PageT toMpPage(String defaultSortBy, boolean isAsc) if (StringUtils.isBlank(sortBy)) sortBy = defaultSortBy; this.isAsc = isAsc; PageT page = new Page(pageNo, pageSize); OrderItem orderItem = new OrderItem(); orderItem.setAsc(this.isAsc); orderItem.setColumn(sortBy); page.addOrder(orderItem); return page; public T PageT toMpPageDefaultSortByCreateTimeDesc() return toMpPage(create_time, false); cshop-notesrcmainJavagithublianyutiancshopnotemodelparamNotePageParam.Java package github.lianyutian.cshop.note.model.param;import github.lianyutian.cshop.common.model.param.PageParam;import lombok.Data;import lombok.EqualsAndHashCode;/** * 分页查询笔记入参 * * @author lianyutian * @since 2025-01-03 13:51:14 * @version 1.0 */@EqualsAndHashCode(callSuper = true)@Datapublic class NotePageParam extends PageParam /** 博主 ID */ private Long userId; package github.lianyutian.cshop.note.controller;/** * 用户笔记展示 * * @author lianyutian * @since 2025-01-09 10:12:54 * @version 1.0 */@RestController@RequestMapping(/api/note/v1)@AllArgsConstructorpublic class NoteShowController private final NoteShowService noteShowService; /** * 分页查询用户笔记列表 * * @param notePageParam 笔记列表入参 * @return 我的笔记列表 */ @PostMapping(list/show) public ApiResultPageVONoteShowVO getNoteShowList(@RequestBody NotePageParam notePageParam) return ApiResult.success(noteShowService.getNoteShowList(notePageParam)); package github.lianyutian.cshop.note.service;/** * 用户笔记展示 * * @author lianyutian * @since 2025-01-09 10:15:18 * @version 1.0 */public interface NoteShowService /** * 获取笔记展示列表 * * @param notePageParam 查询入参 * @return 笔记列表 */ PageVONoteShowVO getNoteShowList(NotePageParam notePageParam); package github.lianyutian.cshop.note.service.impl;/** * 用户笔记展示实现 * * @author lianyutian * @since 2025-01-09 10:18:39 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class NoteShowServiceImpl implements NoteShowService private final NoteMapper noteMapper; @Override public PageVONoteShowVO getNoteShowList(NotePageParam notePageParam) Long userId = notePageParam.getUserId(); // 查询数据库 LambdaQueryWrapperNote lambdaQueryWrapper = new LambdaQueryWrapper(); lambdaQueryWrapper .eq(Note::getUserId, userId) .eq(Note::getStatus, NoteStatusEnum.PUBLISHED) .orderByAsc(Note::getCreateTime); PageNote notePage = noteMapper.selectPage( notePageParam.toMpPageDefaultSortByCreateTimeDesc(), lambdaQueryWrapper); ListNoteShowVO noteShowList = BeanUtil.copyList(notePage.getRecords(), NoteShowVO.class); if (CollectionUtils.isEmpty(noteShowList)) return PageVO.empty(notePage); log.info(从数据库获取笔记信息 , JsonUtil.toJson(noteShowList)); return PageVO.of(notePage, noteShowList); 7.14.8 引入缓存7.14.8.1 获取我的笔记详情 获取我的笔记详情是一个读多写少的场景，笔记的更新频率是很少的。一般都是读操作，且获取自己笔记详情是没有并发场景只存在自己调该接口不需要锁。 cshop-notesrcmainJavagithublianyutiancshopnoteconstantNoteCacheKeyConstant.Java package github.lianyutian.cshop.note.constant;/** * 笔记缓存常量 * * @author lianyutian * @since 2025-01-08 14:06:12 * @version 1.0 */public class NoteCacheKeyConstant /** 笔记信息更新锁前缀 */ public static final String NOTE_UPDATE_LOCK_KEY_PREFIX = cshop-note:update:lock:; /** 笔记展示信息缓存前缀 */ public static final String NOTE_SHOW_KEY_PREFIX = cshop-note:show:; /** 笔记信息缓存前缀 */ public static final String NOTE_DETAIL_KEY_PREFIX = cshop-note:detail:; /** 笔记信息分页缓存前缀 */ public static final String NOTE_SHOW_PAGE_KEY_PREFIX = cshop-note:show-page:; /** 用户笔记信息总数缓存前缀 */ public static final String NOTE_TOTAL_KEY_PREFIX = cshop-note:total:; package github.lianyutian.cshop.note.service.impl;/** * 笔记服务实现类 * * @author lianyutian * @since 2025-01-03 10:54:31 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class NoteServiceImpl implements NoteService private final NoteMapper noteMapper; private final RedisCache redisCache; @Override public NoteDetailVO getNoteDetail(Long noteId) LoginUserInfo loginUserInfo = LoginInterceptor.USER_THREAD_LOCAL.get(); String noteDetailKey = NoteCacheKeyConstant.NOTE_DETAIL_KEY_PREFIX + noteId; NoteDetailVO noteDetailFromCache = getNoteDetailFromCache(noteDetailKey); if (noteDetailFromCache != null) return noteDetailFromCache; Note note = noteMapper.selectOne( new LambdaQueryWrapperNote() .eq(Note::getId, noteId) .eq(Note::getUserId, loginUserInfo.getId())); if (note == null) return null; return BeanUtil.copy(note, NoteDetailVO.class); private NoteDetailVO getNoteDetailFromCache(String noteDetailKey) String noteDetailFromCache = redisCache.get(noteDetailKey); if (StringUtils.isNotBlank(noteDetailFromCache)) Long expire = redisCache.getExpire(noteDetailKey, TimeUnit.SECONDS); // 如果过期时间已经在 1 小时内了就自动延期 if (expire RedisCache.ONE_HOUR_SECONDS) // 缓存精准自动延期 2 天 + 随机几个小时 redisCache.expire(noteDetailKey, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); return JsonUtil.fromJson(noteDetailFromCache, NoteDetailVO.class); return null; 7.14.8.2 查看他人笔记详情 查看他人笔记详情就需要考虑并发问题了。 场景 1：A 用户的某篇笔记爆火，此时就可能会存在成千或上万用户同时来查看这一篇笔记，所以需要使用缓存来抗住这些并发请求。 场景 2：在场景 1 的基础上，A 用户发现笔记有描述错误去更新了笔记。这个时候需要考虑笔记缓存和数据库中数据一致性问题。例如 B 用户线程请求笔记详情时，缓存刚好过期。这个时候去查询数据库获取到了笔记数据，接下来要更新缓存但是此时线程时间片用完被暂停。这时用户 A 线程去修改笔记，并更新数据库同时更新缓存。在用户 A 线程更新完缓存后，用户 B 线程才继续执行再去更新缓存，这个时候缓存中就是旧数据，数据库中是新数据。 package github.lianyutian.cshop.note.service.impl;/** * 用户笔记展示实现 * * @author lianyutian * @since 2025-01-09 10:18:39 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class NoteShowServiceImpl implements NoteShowService private final RedisCache redisCache; private final RedisLock redisLock; private final NoteMapper noteMapper; @Override public NoteShowVO getNoteShow(Long noteId) String noteShowKey = NoteCacheKeyConstant.NOTE_SHOW_KEY_PREFIX + noteId; NoteShowVO noteDetailFromCache = getNoteShowFromCache(noteShowKey); if (noteDetailFromCache != null) return noteDetailFromCache; return getNoteShowFromDB(noteShowKey, noteId); private NoteShowVO getNoteShowFromCache(String noteShowKey) String noteDetailFromCache = redisCache.get(noteShowKey); if (StringUtils.isNotBlank(noteDetailFromCache)) Long expire = redisCache.getExpire(noteShowKey, TimeUnit.SECONDS); // 如果过期时间已经在 1 小时内了就自动延期 if (expire RedisCache.ONE_HOUR_SECONDS) // 缓存精准自动延期 2 天 + 随机几个小时 redisCache.expire(noteShowKey, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); return JsonUtil.fromJson(noteDetailFromCache, NoteShowVO.class); return null; private NoteShowVO getNoteShowFromDB(String noteDetailKey, Long noteId) /* 1.设置分布式锁防止超高并发请求打到数据库 2.保证笔记数据更新时缓存和数据库的数据一致性 */ String noteUpdateLockKey = NoteCacheKeyConstant.NOTE_UPDATE_LOCK_KEY_PREFIX + noteId; boolean locked = false; try locked = redisLock.tryLock(noteUpdateLockKey, RedisLock.UPDATE_LOCK_TIMEOUT); if (!locked) // 加锁超时时间有 200ms, 所以再次尝试获取缓存 NoteShowVO noteDetailFromCache = getNoteShowFromCache(noteDetailKey); if (noteDetailFromCache != null) return noteDetailFromCache; log.warn(【getNoteShowDetail】笔记缓存为空，查询笔记信息获取锁失败 , noteId); throw new BizException(BizCodeEnum.NOTE_INFO_LOCK_FAIL); // 获取锁成功，查询数据库 Note note = noteMapper.selectOne( new LambdaQueryWrapperNote() .eq(Note::getId, noteId) .eq(Note::getStatus, NoteStatusEnum.PUBLISHED.getCode())); if (note == null) log.warn(【getNoteShowDetail】笔记不存在 , noteId); // 防止同时间大量无效 noteId 穿透缓存打到数据库造成缓存穿透 redisCache.set( noteDetailKey, RedisCache.EMPTY_CACHE, RedisCache.generateCachePenetrationExpire(), TimeUnit.MILLISECONDS); return null; return BeanUtil.copy(note, NoteShowVO.class); catch (InterruptedException e) NoteShowVO noteDetailFromCache = getNoteShowFromCache(noteDetailKey); if (noteDetailFromCache != null) return noteDetailFromCache; log.error(【getNoteShow】尝试加锁异常，异常信息：, e.getMessage(), e); throw new BizException(BizCodeEnum.NOTE_INFO_LOCK_FAIL); finally if (locked) redisLock.unlock(noteUpdateLockKey); 7.14.8.3 查看笔记分页列表package github.lianyutian.cshop.note.service.impl;/** * 用户笔记展示实现 * * @author lianyutian * @since 2025-01-09 10:18:39 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class NoteShowServiceImpl implements NoteShowService private final RedisCache redisCache; private final RedisLock redisLock; private final NoteMapper noteMapper; @Override public PageVONoteShowVO getNoteShowList(NotePageParam notePageParam) // 从缓存查询分页数据 ListNoteShowVO noteListFromCache = getNoteShowListFromCache( NoteCacheKeyConstant.NOTE_SHOW_PAGE_KEY_PREFIX + notePageParam.getUserId() + : + notePageParam.getPageNo()); if (!CollectionUtils.isEmpty(noteListFromCache)) return getNotePage(notePageParam, noteListFromCache); ListNoteShowVO noteListFromDB = getNoteShowListFromDB(notePageParam); if (!CollectionUtils.isEmpty(noteListFromDB)) return getNotePage(notePageParam, noteListFromDB); return null; /** * 获取缓存的分页笔记信息 * * @param notePageInfoKey 分页缓存 key * @return 分页笔记信息 */ @SuppressWarnings(unchecked) private ListNoteShowVO getNoteShowListFromCache(String notePageInfoKey) String cachePageInfo = redisCache.get(notePageInfoKey); if (StringUtils.isNotBlank(cachePageInfo)) Long expire = redisCache.getExpire(notePageInfoKey, TimeUnit.SECONDS); // 如果过期时间已经在 1 小时内了就自动延期 if (expire RedisCache.ONE_HOUR_SECONDS) // 缓存精准自动延期 2 天 + 随机几个小时 redisCache.expire(notePageInfoKey, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); return JsonUtil.fromJson(cachePageInfo, List.class); return null; private ListNoteShowVO getNoteShowListFromDB(NotePageParam notePageParam) Long userId = notePageParam.getUserId(); // 分布式锁 key String noteUpdateLockKey = NoteCacheKeyConstant.NOTE_UPDATE_LOCK_KEY_PREFIX + userId; boolean tryLocked = false; // 笔记分页缓存 key String notePageKey = NoteCacheKeyConstant.NOTE_SHOW_PAGE_KEY_PREFIX + userId + : + notePageParam.getPageNo(); try tryLocked = redisLock.tryLock(noteUpdateLockKey, RedisCache.UPDATE_LOCK_TIMEOUT); if (!tryLocked) /* 尝试加锁时间有 RedisCache.UPDATE_LOCK_TIMEOUT 有可能其他线程已经获取数据并写入缓存了所以这里再尝试去读下缓存 */ ListNoteShowVO noteListFromCache = getNoteShowListFromCache(notePageKey); if (!CollectionUtils.isEmpty(noteListFromCache)) return noteListFromCache; log.info(【getNoteListFromDB】笔记缓存为空，查询笔记信息获取锁失败 , userId); return null; // 查询数据库 LambdaQueryWrapperNote lambdaQueryWrapper = new LambdaQueryWrapper(); lambdaQueryWrapper .eq(Note::getUserId, userId) .eq(Note::getStatus, NoteStatusEnum.PUBLISHED) .orderByAsc(Note::getCreateTime); PageNote notePage = noteMapper.selectPage( notePageParam.toMpPageDefaultSortByCreateTimeDesc(), lambdaQueryWrapper); ListNoteShowVO noteShowList = BeanUtil.copyList(notePage.getRecords(), NoteShowVO.class); if (CollectionUtils.isEmpty(noteShowList)) // 防止缓存穿透 redisCache.set( notePageKey, RedisCache.EMPTY_CACHE, RedisCache.generateCachePenetrationExpire(), TimeUnit.MILLISECONDS); return null; redisCache.set( notePageKey, noteShowList, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); log.info(【getNoteListFromDB】笔记缓存为空，从数据库获取笔记信息 , JsonUtil.toJson(noteShowList)); return noteShowList; catch (InterruptedException e) // 加锁失败 // 这里再去尝试获取下缓存-双重检查 ListNoteShowVO noteListFromCache = getNoteShowListFromCache(notePageKey); if (!CollectionUtils.isEmpty(noteListFromCache)) return noteListFromCache; log.error(【getNoteListFromDB】尝试加锁异常，异常信息：, e.getMessage(), e); throw new BizException(BizCodeEnum.NOTE_INFO_LOCK_FAIL); finally if (tryLocked) redisLock.unlock(noteUpdateLockKey); private PageVONoteShowVO getNotePage(NotePageParam notePageParam, ListNoteShowVO noteList) // 计算我的笔记列表总数 String userNoteTotalKey = NoteCacheKeyConstant.NOTE_TOTAL_KEY_PREFIX + notePageParam.getUserId(); // 笔记总条数 Long total = redisCache.getLong(userNoteTotalKey); // 计算总页数 double totalPages = Math.ceil((double) total / notePageParam.getPageSize()); return new PageVO(total, (long) totalPages, Collections.unmodifiableList(noteList)); 7.14.9 重建分页缓存 用户查询笔记分页时，会从数据库根据分页数查询分页记录并把结果写入到缓存。如果用户添加更新了一篇新笔记，那么整个分页缓存记录都需要重新构建。重建缓存是个耗时的过程，所以引入 RocketMq 做一个异步更新操作。添加更新一篇笔记后会发送 MQ 消息，消费端监听消息，重建缓存。 pom.xml !-- rocketmq 版本 --rocketmq-starter.version2.2.1/rocketmq-starter.versiondependency groupIdorg.apache.rocketmq/groupId artifactIdrocketmq-spring-boot-starter/artifactId version$rocketmq-starter.version/version/dependency cshop-commonpom.xml dependency groupIdorg.apache.rocketmq/groupId artifactIdrocketmq-spring-boot-starter/artifactId/dependency cshop-notepom.xml dependency groupIdorg.apache.rocketmq/groupId artifactIdrocketmq-client/artifactId/dependency cshop-commonsrcmainJavagithublianyutiancshopcommonmqRocketMQConfig.Java package github.lianyutian.cshop.common.mq;import lombok.Data;import org.apache.rocketmq.acl.common.AclClientRPCHook;import org.apache.rocketmq.acl.common.SessionCredentials;import org.apache.rocketmq.remoting.RPCHook;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * rocketmq 配置类 * * @author lianyutian * @since 2025-01-15 10:26:51 * @version 1.0 */@Data@Configuration@ConditionalOnProperty(prefix = rocketmq, value = nameServer)public class RocketMQConfig @Value($rocketmq.nameServer) private String nameServer; @Value($rocketmq.accessKey) private String accessKey; @Value($rocketmq.secretKey) private String secretKey; /** * 鉴权 hook * * @return RPCHook */ @Bean public RPCHook rpcHook() return new AclClientRPCHook(new SessionCredentials(accessKey, secretKey)); cshop-notesrcmainresourcesapplication.yml # rocketmq配置rocketmq: accessKey: mqadmin secretKey: MIIEowIBAAKCAQEAwG90ULRHmAXFXQzZSwleoYts2+bCzUvqhhqtGiv/F5kUsETY nameServer: 116.198.217.158:9876 cshop-notesrcmainJavagithublianyutiancshopnoteconstantNoteRocketMQConstant.Java package github.lianyutian.cshop.note.constant;/** * MQ 常量类 * * @author lianyutian * @since 2025-01-14 14:53:14 * @version 1.0 */public class NoteRocketMQConstant public static final String NOTE_UPDATE_PRODUCER_GROUP = note-update-producer-group; public static final String NOTE_UPDATE_TOPIC = note-update-topic; cshop-notesrcmainJavagithublianyutiancshopnoteenumsNoteMessageType.Java package github.lianyutian.cshop.note.enums;import lombok.Getter;/** * 笔记 MQ 消息类型枚举 * * @author lianyutian * @since 2025-01-15 14:26:26 * @version 1.0 */@Getterpublic enum NoteMessageType /** 笔记新增消息 */ ADD_NOTE(ADD, 新增笔记消息), /** 笔记更新消息 */ UPDATE_NOTE(UPDATE, 更新笔记消息); private final String type; private final String message; NoteMessageType(String type, String message) this.type = type; this.message = message; cshop-notesrcmainJavagithublianyutiancshopnotemqmessageNoteUpdateMessage.Java package github.lianyutian.cshop.note.mq.message;import java.io.Serializable;import lombok.Builder;import lombok.Getter;import lombok.Setter;/** * 笔记更新消息 * * @author lianyutian * @since 2025-01-14 16:16:40 * @version 1.0 */@Getter@Setter@Builderpublic class NoteUpdateMessage implements Serializable /** 笔记 ID */ private Long noteId; /** 博主 ID */ private Long userId; cshop-notesrcmainJavagithublianyutiancshopnotemqproducerNoteTransactionProducer.Java package github.lianyutian.cshop.note.mq.producer;/** * 笔记事务消息生产者 * * @author lianyutian * @since 2025-01-14 14:52:03 * @version 1.0 */@Getter@Component@Slf4jpublic class NoteTransactionProducer private final TransactionMQProducer producer; @Autowired public NoteTransactionProducer( RocketMQConfig rocketMQConfig, RPCHook rpcHook, NoteAddListener noteAddListener) // 初始化事务生产者客户端，设置对应的生产者组 producer = new TransactionMQProducer(NoteRocketMQConstant.NOTE_UPDATE_PRODUCER_GROUP, rpcHook); // 设置 nameserver producer.setNamesrvAddr(rocketMQConfig.getNameServer()); producer.setTransactionListener(noteAddListener); // 启动生产者服务 start(); /** 启动 rocketmq 生产者服务 该对象在使用之前必须要调用一次，只能初始化一次 */ public void start() try this.producer.start(); catch (MQClientException e) log.error(rocketmq producer start error, e); /** 关闭 rocketmq 生产者 */ public void shutdown() this.producer.shutdown(); /** * 发送事务消息 * * @param topic topic * @param tag tag * @param message 消息 * @param arg 额外参数 * @param type 消息类型 */ public void sendTransactionMessage( String topic, String tag, String message, Object arg, NoteMessageType type) Message msg = new Message(topic, tag, message.getBytes(StandardCharsets.UTF_8)); try SendResult send = producer.sendMessageInTransaction(msg, arg); if (SendStatus.SEND_OK == send.getSendStatus()) log.info(发送 MQ 消息成功, type:, message:, arg:, type.getMessage(), message, arg); else throw new BizException(send.getSendStatus().toString()); catch (Exception e) log.error(发送 MQ 消息失败：, e); throw new BizException(发送 MQ 消息失败); /** * 同步发送单条消息 * * @param topic 主题 * @param tag tag * @param message 消息 * @param type 类型 */ public void sendMessage(String topic, String tag, String message, NoteMessageType type) sendDelayMessage(topic, tag, message, DelayLevel.LEVEL_0, type); /** * 发送单条延迟消息 * * @param topic topic * @param tag tag * @param message 消息 * @param delayTimeLevel 延迟等级 * @param type 类型 */ public void sendDelayMessage( String topic, String tag, String message, DelayLevel delayTimeLevel, NoteMessageType type) Message msg = new Message(topic, tag, message.getBytes(StandardCharsets.UTF_8)); try if (delayTimeLevel.getValue() 0) msg.setDelayTimeLevel(delayTimeLevel.getValue()); SendResult send = producer.send(msg); if (SendStatus.SEND_OK == send.getSendStatus()) log.info(发送 MQ 消息成功, type:, message:, type.getMessage(), message); else throw new BizException(send.getSendStatus().toString()); catch (Exception e) log.error(发送 MQ 消息失败：, e); throw new BizException(发送 MQ 消息失败); /** * 批量发送延迟消息 * * @param topic topic * @param tag tag * @param messages 多个消息 * @param delayTimeLevel 延迟等级 * @param type 类型 */ public void sendDelayMessages( String topic, String tag, ListString messages, DelayLevel delayTimeLevel, NoteMessageType type) ListMessage list = new ArrayList(); for (String message : messages) Message msg = new Message(topic, tag, message.getBytes(StandardCharsets.UTF_8)); if (delayTimeLevel.getValue() 0) msg.setDelayTimeLevel(delayTimeLevel.getValue()); list.add(msg); try SendResult send = producer.send(list); if (SendStatus.SEND_OK == send.getSendStatus()) log.info(发送 MQ 消息成功, type:, type.getMessage()); else throw new BizException(send.getSendStatus().toString()); catch (Exception e) log.error(发送 MQ 消息失败：, e); throw new BizException(发送 MQ 消息失败); cshop-notesrcmainJavagithublianyutiancshopnotemqproducerlistenerNoteAddListener.Java package github.lianyutian.cshop.note.mq.producer.listener;/** * 笔记添加消息监听 * * @author lianyutian * @since 2025-01-16 10:59:25 * @version 1.0 */@Slf4j@Component@AllArgsConstructorpublic class NoteAddListener implements TransactionListener private final NoteMapper noteMapper; @Override public LocalTransactionState executeLocalTransaction(Message msg, Object arg) return LocalTransactionState.UNKNOW; @Override public LocalTransactionState checkLocalTransaction(MessageExt msg) return checkNoteAddStatus(msg); private LocalTransactionState checkNoteAddStatus(Message msg) try String messageBody = new String(msg.getBody(), StandardCharsets.UTF_8); NoteUpdateMessage noteAddMessage = JsonUtil.fromJson(messageBody, NoteUpdateMessage.class); if (noteAddMessage == null) log.error(Failed to parse NoteAddMessage from message body: , messageBody); return LocalTransactionState.ROLLBACK_MESSAGE; Long noteId = noteAddMessage.getNoteId(); if (noteId == null) log.error(NoteId is null in NoteAddMessage: , noteAddMessage); return LocalTransactionState.ROLLBACK_MESSAGE; Note note = noteMapper.selectById(noteId); if (note != null) log.info(Note with id found, committing message, noteId); return LocalTransactionState.COMMIT_MESSAGE; else log.warn(Note with id not found, returning unknown state, noteId); return LocalTransactionState.UNKNOW; catch (Exception e) log.error(Error processing message: , e.getMessage(), e); return LocalTransactionState.ROLLBACK_MESSAGE; cshop-notesrcmainJavagithublianyutiancshopnotemqconsumerNoteUpdateConsumerConfig.Java package github.lianyutian.cshop.note.mq.consumer;/** * 默认消费者 * * @author lianyutian * @since 2025-01-15 10:32:28 * @version 1.0 */@Componentpublic class NoteUpdateConsumerConfig @Bean public DefaultMQPushConsumer noteUpdateConsumer( RocketMQConfig rocketMQConfig, NoteUpdateListener noteUpdateListener, NoteAddListener noteAddListener, RPCHook rpcHook) throws MQClientException DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(null, NoteRocketMQConstant.NOTE_UPDATE_PRODUCER_GROUP, rpcHook); consumer.setNamesrvAddr(rocketMQConfig.getNameServer()); consumer.subscribe(NoteRocketMQConstant.NOTE_UPDATE_TOPIC, *); consumer.registerMessageListener(noteUpdateListener); consumer.start(); return consumer; cshop-notesrcmainJavagithublianyutiancshopnotemqconsumerlistenerNoteUpdateListener.Java package github.lianyutian.cshop.note.mq.consumer.listener;/** * 笔记更新消息监听器 * * @author lianyutian * @since 2025-01-15 10:34:58 * @version 1.0 */@Slf4j@Component@AllArgsConstructorpublic class NoteUpdateListener implements MessageListenerConcurrently /** 每页 20 条 */ private static final int PAGE_SIZE = 2; private final RedisCache redisCache; private final RedisLock redisLock; private final NoteMapper noteMapper; @Override public ConsumeConcurrentlyStatus consumeMessage( ListMessageExt noteMessageList, ConsumeConcurrentlyContext context) try for (MessageExt noteMessage : noteMessageList) String msg = new String(noteMessage.getBody()); Long userId; NoteUpdateMessage noteUpdateMessage = JsonUtil.fromJson(msg, NoteUpdateMessage.class); userId = noteUpdateMessage.getUserId(); log.info(笔记 MQ 异步更新-执行博主笔记分页缓存数据异步更新，消息内容：, JsonUtil.toJson(noteUpdateMessage)); // 这里增加分布式锁，同一个用户同时间只能操作一次，避免重复请求 String noteUpdateLockKey = NoteCacheKeyConstant.NOTE_UPDATE_LOCK_KEY_PREFIX + userId; boolean locked = false; try // 这里通过阻塞的方式进行加锁，跟新增/更新笔记操作互斥，并发操作时进行阻塞 locked = redisLock.blockedLock(noteUpdateLockKey); updateCache(userId); finally if (locked) redisLock.unlock(noteUpdateLockKey); catch (Exception e) // 本次消费失败，下次重新消费 log.error(笔记 MQ 异步更新 consume error, 更新博主笔记缓存数据消费失败, e); return ConsumeConcurrentlyStatus.RECONSUME_LATER; log.info(笔记 MQ 异步更新-博主笔记缓存数据消费成功, result: , ConsumeConcurrentlyStatus.CONSUME_SUCCESS); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; private void updateCache(Long userId) // 此时我们需要对博主的笔记列表进行分页缓存重新构建 // 新增需要构建所有笔记分页缓存 // 1、计算我的笔记列表总数 String userNoteTotalKey = NoteCacheKeyConstant.NOTE_TOTAL_KEY_PREFIX + userId; Long size = redisCache.getLong(userNoteTotalKey); log.info(笔记 MQ 异步更新-key:, value:, userNoteTotalKey, size); // 计算总分页数 int pageTotal = (int) Math.ceil((double) size / PAGE_SIZE) + 1; for (int pageNum = 1; pageNum = pageTotal; pageNum++) buildPageCache(userId, pageNum); private void buildPageCache(Long userId, int pageNum) // 笔记分页缓存 key String notePageKey = NoteCacheKeyConstant.NOTE_SHOW_PAGE_KEY_PREFIX + userId + : + pageNum; // 先从缓存中获取一下 String notePageCache = redisCache.get(notePageKey); // 如果分页缓存为空，跳过 if (StringUtils.isBlank(notePageCache)) return; // 只有缓存中存在这一页的数据才会去数据库读取最新的笔记信息去更新 // 查询我的未删除笔记列表 LambdaQueryWrapperNote lambdaQueryWrapper = new LambdaQueryWrapper(); lambdaQueryWrapper .eq(Note::getUserId, userId) .eq(Note::getStatus, NoteStatusEnum.PUBLISHED) .orderByDesc(Note::getUpdateTime); PageNote notePageParam = new Page(pageNum, PAGE_SIZE); PageNote notePage = noteMapper.selectPage(notePageParam, lambdaQueryWrapper); ListNote noteList = notePage.getRecords(); log.info( 笔记 MQ 异步更新-从数据库获取我的笔记列表，pageNum:, total:, size：, userId: , notePage.getPages(), notePage.getTotal(), notePage.getSize(), userId); ListNoteShowVO noteShowVOList = BeanUtil.copyList(noteList, NoteShowVO.class); // 写入分页缓存数据 redisCache.set( notePageKey, noteShowVOList, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); package github.lianyutian.cshop.note.service.impl;/** * 笔记服务实现类 * * @author lianyutian * @since 2025-01-03 10:54:31 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class NoteServiceImpl implements NoteService private final NoteMapper noteMapper; private final RedisLock redisLock; private final RedisCache redisCache; private final NoteTransactionProducer noteTransactionProducer; @Override @Transactional(rollbackFor = Exception.class) public int addNote(NoteAddParam noteAddParam) LoginUserInfo loginUserInfo = LoginInterceptor.USER_THREAD_LOCAL.get(); Note note = BeanUtil.copy(noteAddParam, Note.class); note.setUserId(loginUserInfo.getId()); // note.setStatus(NoteStatusEnum.AUDITING); note.setStatus(NoteStatusEnum.PUBLISHED); note.setPublishTime(new Date()); int row; try row = noteMapper.insert(note); if (row 0) try redisCache.increment( NoteCacheKeyConstant.NOTE_TOTAL_KEY_PREFIX + loginUserInfo.getId(), 1); // 不能因为消息发送失败导致笔记新增失败 // TODO 需要定时任务扫描新增笔记来兜底分页刷新 publishNoteAddedEvent(note.getId(), loginUserInfo.getId()); catch (Exception e) log.error(redis or mq error , e.getMessage(), e); catch (Exception e) log.error(db addNote error , e.getMessage(), e); throw new BizException(BizCodeEnum.NOTE_ADD_FAIL); log.info(笔记服务-新增笔记：rows=，data=, row, JsonUtil.toJson(noteAddParam)); return row; @Override @Transactional(rollbackFor = Exception.class) public int updateNote(NoteEditParam noteEditParam) // 1.查询笔记是否存在 LoginUserInfo loginUserInfo = LoginInterceptor.USER_THREAD_LOCAL.get(); // 这里增加分布式锁是为了保证 Redis 中缓存的笔记数据和 DB 中的笔记数据一致 /* 存在这种场景：假设当前缓存为空，用户 A 更新自己的笔记，同时用户 B 查询用户 A 的笔记。如果这时用户 A 还未更新数据库，用户 B 已经从数据库查询到了数据 同时用户 B 所在线程 CPU 执行时间消耗完被挂起。此时用户 A 再更新数据库成功并将新数据写入缓存。用户 B 线程才继续执行，此时用户 B 查询到的数据是旧的。 又去写入了缓存那么此时的缓存数据就是旧的。 */ String noteUpdateLockKey = NoteCacheKeyConstant.NOTE_UPDATE_LOCK_KEY_PREFIX + noteEditParam.getId(); boolean locked = false; try locked = redisLock.lock(noteUpdateLockKey); if (!locked) log.info(笔记模块-用户修改笔记信息：用户 获取锁失败, 笔记 , loginUserInfo.getId(), noteEditParam.getId()); throw new BizException(BizCodeEnum.NOTE_UPDATE_LOCK_FAIL); Note updateNote = BeanUtil.copy(noteEditParam, Note.class); int row = noteMapper.update( updateNote, new LambdaUpdateWrapperNote() .eq(Note::getId, noteEditParam.getId()) .eq(Note::getUserId, loginUserInfo.getId())); if (row 0) updateNoteCache(noteEditParam.getId()); publishNoteUpdatedEvent(noteEditParam.getId(), loginUserInfo.getId()); log.info(笔记服务-更新笔记：row=, data=, row, JsonUtil.toJson(noteEditParam)); return row; catch (Exception e) log.error(updateNote error , e.getMessage(), e); // 删掉缓存 redisCache.delete(NoteCacheKeyConstant.NOTE_SHOW_KEY_PREFIX + noteEditParam.getId()); redisCache.delete(NoteCacheKeyConstant.NOTE_DETAIL_KEY_PREFIX + noteEditParam.getId()); throw new BizException(BizCodeEnum.NOTE_UPDATE_FAIL); finally if (locked) redisLock.unlock(noteUpdateLockKey); private void publishNoteAddedEvent(Long noteId, Long userId) noteTransactionProducer.sendTransactionMessage( NoteRocketMQConstant.NOTE_UPDATE_TOPIC, NoteMessageType.ADD_NOTE.getType(), JsonUtil.toJson(NoteUpdateMessage.builder().noteId(noteId).userId(userId).build()), null, NoteMessageType.ADD_NOTE); private void publishNoteUpdatedEvent(Long noteId, Long userId) noteTransactionProducer.sendMessage( NoteRocketMQConstant.NOTE_UPDATE_TOPIC, NoteMessageType.UPDATE_NOTE.getType(), JsonUtil.toJson(NoteUpdateMessage.builder().noteId(noteId).userId(userId).build()), NoteMessageType.UPDATE_NOTE); 社交服务优惠券服务测试计划测试范围测试用例性能测试运维计划日志管理异常处理备份策略附录术语表参考文献常见问题","tags":["Java","商城","分布式"]},{"title":"云环境","path":"/2025/03/27/云环境/","content":"基于京东云2c8g服务器搭建 登录密码：2+bCzUvqhhqtGivF5kUsETY 1. 切换docker镜像源sudo tee /etc/docker/daemon.json -EOF registry-mirrors: [https://c58uc66a.mirror.aliyuncs.com]EOFsudo systemctl daemon-reloadsudo systemctl restart docker 2. 安装Docker-Portainerdocker run -d --restart=always -p 9000:9000 -v /home/run/docker.sock:/var/run/docker.sock --name portainer portainer/portainer 连接时，如果你的远程docker没有开启2375端口是连接不上的，下面是配置docker端口的方法： 1.编辑docker.servicecd /usr/lib/systemd/system/vim /usr/lib/systemd/system/docker.service# 找到 ExecStart字段修改如下ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock2.重启docker重新读取配置文件，重新启动docker服务systemctl daemon-reloadsystemctl restart docker3.防火墙规则添加2375端口 3. 安装Mysql# 安装镜像docker run -d -p 3306:3306 --name mysql \\-e MYSQL_ROOT_PASSWORD=MIIEowIBAAKCAQEAwG90ULRHmAXFXQzZSwleoYts2+bCzUvqhhqtGiv/F5kUsETY \\-d mysql:latest# 进入容器docker exec -it mysql /bin/bash# 添加用户mysql -uroot -pli.ming9518create user cloud@% identified by MIIEowIBAAKCAQEAwG90ULRHmAXFXQzZSwleoYts2+bCzUvqhhqtGiv/F5kUsETY;grant all privileges on *.* to cloud@% with grant option;flush privileges; 4. 安装Redisdocker run \\-p 6379:6379 \\--name redis \\-d redis redis-server \\--appendonly yes \\--requirepass MIIEowIBAAKCAQEAwG90ULRHmAXFXQzZSwleoYts2+bCzUvqhhqtGiv/F5kUsETY 5. 安装nacos1.创建挂载目录 mkdir -p /var/lib/docker/volumes/nacos/confmkdir -p /var/lib/docker/volumes/nacos/datamkdir -p /var/lib/docker/volumes/nacos/logschmod a+w /var/lib/docker/volumes/nacoscd /var/lib/docker/volumes/nacos/confvi application.properties 2.添加application.properties # springserver.servlet.contextPath=/nacosserver.contextPath=/nacosserver.port=8848# server.tomcat.accesslog.max-days=30# server.tomcat.accesslog.pattern=%h %l %u %t %r %s %b %D %User-Agenti %Request-Sourcei# server.tomcat.accesslog.enabled=false# default current work dir# server.tomcat.basedir=file:.#*************** Config Module Related Configurations ***************#### Deprecated configuration property, it is recommended to use `spring.sql.init.platform` replaced.spring.datasource.platform=mysqlspring.sql.init.platform=mysqlnacos.cmdb.dumpTaskInterval=3600nacos.cmdb.eventTaskInterval=10nacos.cmdb.labelTaskInterval=300nacos.cmdb.loadDataAtStart=falsedb.num=1# 这里必须为公网或服务器内网地址，我这里是服务器的内网地址，容器内部没有mysql，绝对不能使用 127.0.0.1和localhost# 如果nacos启动失败，Nacos Server did not start because dumpservice bean construction failure : No DataSource set# 加上 serverTimezone=UTC ，再不行就加上 allowPublicKeyRetrieval=true# 将connectTimeout 和 socketTimeout 分别加个0，避免出现超时异常db.url.0=jdbc:mysql://116.198.217.158:3306/nacos?characterEncoding=utf8connectTimeout=10000socketTimeout=30000autoReconnect=trueuseUnicode=trueuseSSL=falsedb.user.0=clouddb.password.0=liming9518### The auth system to use, currently only nacos and ldap is supported:# 鉴权类型，默认为nacosnacos.core.auth.system.type=nacos# 是否开启鉴权功能，默认为falsenacos.core.auth.enabled=true# Base64加密前密码 TcmxJw05k$-_zcx.)8EtFC^D^F1W!IPr# Base64加密后密码 VGNteEp3MDVrJC1femN4Lik4RXRGQ15EXkYxVyFJUHI=# 加密网站：https://www.qqxiuzi.cn/bianma/base64.htm# 自定义密钥，在自定义密钥时，推荐将配置项设置为Base64编码的字符串，且原始密钥长度不得低于32字符。同nacos.core.auth.plugin.nacos.token.secret.keynacos.core.auth.default.token.secret.key=VGNteEp3MDVrJC1femN4Lik4RXRGQ15EXkYxVyFJUHI=### worked when nacos.core.auth.system.type=nacos### The token expiration in seconds:# 用户登陆临时accessToken的过期时间，默认18000nacos.core.auth.plugin.nacos.token.expire.seconds=18000### The default token:# 默认鉴权插件用于生成用户登陆临时accessToken所使用的密钥，在2.2.0.1后无默认值，必须执行此变更，否则无法启动；其他版本为建议设置。nacos.core.auth.plugin.nacos.token.secret.key=VGNteEp3MDVrJC1femN4Lik4RXRGQ15EXkYxVyFJUHI=### Turn on/off caching of auth information. By turning on this switch, the update of auth information would have a 15 seconds delay.# nacos.core.auth.caching.enabled=$NACOS_AUTH_CACHE_ENABLE:false# 关闭使用user-agent判断服务端请求并放行鉴权的功能nacos.core.auth.enable.userAgentAuthWhite=false# 用于替换useragent白名单的身份识别key，不可为空，2.2.1后无默认值nacos.core.auth.server.identity.key=nacosKey# 用于替换useragent白名单的身份识别value，不可为空，2.2.1后无默认值nacos.core.auth.server.identity.value=nacosValue## spring security config### turn off securitynacos.security.ignore.urls=/,/error,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/v1/auth/**,/v1/console/health/**,/actuator/**,/v1/console/server/**# metrics for elastic searchmanagement.metrics.export.elastic.enabled=falsemanagement.metrics.export.influx.enabled=falsenacos.naming.distro.taskDispatchThreadCount=10nacos.naming.distro.taskDispatchPeriod=200nacos.naming.distro.batchSyncKeyCount=1000nacos.naming.distro.initDataRatio=0.9nacos.naming.distro.syncRetryDelay=5000nacos.naming.data.warmup=true 3.添加nacos相关表 CREATE TABLE `config_info` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT id, `data_id` varchar(255) NOT NULL COMMENT data_id, `group_id` varchar(128) DEFAULT NULL, `content` longtext NOT NULL COMMENT content, `md5` varchar(32) DEFAULT NULL COMMENT md5, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 创建时间, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 修改时间, `src_user` text COMMENT source user, `src_ip` varchar(50) DEFAULT NULL COMMENT source ip, `app_name` varchar(128) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT COMMENT 租户字段, `c_desc` varchar(256) DEFAULT NULL, `c_use` varchar(64) DEFAULT NULL, `effect` varchar(64) DEFAULT NULL, `type` varchar(64) DEFAULT NULL, `c_schema` text, `encrypted_data_key` text NOT NULL COMMENT 秘钥, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=config_info;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_aggr *//******************************************/CREATE TABLE `config_info_aggr` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT id, `data_id` varchar(255) NOT NULL COMMENT data_id, `group_id` varchar(128) NOT NULL COMMENT group_id, `datum_id` varchar(255) NOT NULL COMMENT datum_id, `content` longtext NOT NULL COMMENT 内容, `gmt_modified` datetime NOT NULL COMMENT 修改时间, `app_name` varchar(128) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT COMMENT 租户字段, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=增加租户字段;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_beta *//******************************************/CREATE TABLE `config_info_beta` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT id, `data_id` varchar(255) NOT NULL COMMENT data_id, `group_id` varchar(128) NOT NULL COMMENT group_id, `app_name` varchar(128) DEFAULT NULL COMMENT app_name, `content` longtext NOT NULL COMMENT content, `beta_ips` varchar(1024) DEFAULT NULL COMMENT betaIps, `md5` varchar(32) DEFAULT NULL COMMENT md5, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 创建时间, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 修改时间, `src_user` text COMMENT source user, `src_ip` varchar(50) DEFAULT NULL COMMENT source ip, `tenant_id` varchar(128) DEFAULT COMMENT 租户字段, `encrypted_data_key` text NOT NULL COMMENT 秘钥, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=config_info_beta;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_tag *//******************************************/CREATE TABLE `config_info_tag` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT id, `data_id` varchar(255) NOT NULL COMMENT data_id, `group_id` varchar(128) NOT NULL COMMENT group_id, `tenant_id` varchar(128) DEFAULT COMMENT tenant_id, `tag_id` varchar(128) NOT NULL COMMENT tag_id, `app_name` varchar(128) DEFAULT NULL COMMENT app_name, `content` longtext NOT NULL COMMENT content, `md5` varchar(32) DEFAULT NULL COMMENT md5, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 创建时间, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 修改时间, `src_user` text COMMENT source user, `src_ip` varchar(50) DEFAULT NULL COMMENT source ip, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=config_info_tag;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_tags_relation *//******************************************/CREATE TABLE `config_tags_relation` ( `id` bigint(20) NOT NULL COMMENT id, `tag_name` varchar(128) NOT NULL COMMENT tag_name, `tag_type` varchar(64) DEFAULT NULL COMMENT tag_type, `data_id` varchar(255) NOT NULL COMMENT data_id, `group_id` varchar(128) NOT NULL COMMENT group_id, `tenant_id` varchar(128) DEFAULT COMMENT tenant_id, `nid` bigint(20) NOT NULL AUTO_INCREMENT, PRIMARY KEY (`nid`), UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`), KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=config_tag_relation;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = group_capacity *//******************************************/CREATE TABLE `group_capacity` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT 主键ID, `group_id` varchar(128) NOT NULL DEFAULT COMMENT Group ID，空字符表示整个集群, `quota` int(10) unsigned NOT NULL DEFAULT 0 COMMENT 配额，0表示使用默认值, `usage` int(10) unsigned NOT NULL DEFAULT 0 COMMENT 使用量, `max_size` int(10) unsigned NOT NULL DEFAULT 0 COMMENT 单个配置大小上限，单位为字节，0表示使用默认值, `max_aggr_count` int(10) unsigned NOT NULL DEFAULT 0 COMMENT 聚合子配置最大个数，，0表示使用默认值, `max_aggr_size` int(10) unsigned NOT NULL DEFAULT 0 COMMENT 单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值, `max_history_count` int(10) unsigned NOT NULL DEFAULT 0 COMMENT 最大变更历史数量, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 创建时间, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 修改时间, PRIMARY KEY (`id`), UNIQUE KEY `uk_group_id` (`group_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=集群、各Group容量信息表;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = his_config_info *//******************************************/CREATE TABLE `his_config_info` ( `id` bigint(20) unsigned NOT NULL, `nid` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `data_id` varchar(255) NOT NULL, `group_id` varchar(128) NOT NULL, `app_name` varchar(128) DEFAULT NULL COMMENT app_name, `content` longtext NOT NULL, `md5` varchar(32) DEFAULT NULL, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP, `src_user` text, `src_ip` varchar(50) DEFAULT NULL, `op_type` char(10) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT COMMENT 租户字段, `encrypted_data_key` text NOT NULL COMMENT 秘钥, PRIMARY KEY (`nid`), KEY `idx_gmt_create` (`gmt_create`), KEY `idx_gmt_modified` (`gmt_modified`), KEY `idx_did` (`data_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=多租户改造;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = tenant_capacity *//******************************************/CREATE TABLE `tenant_capacity` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT 主键ID, `tenant_id` varchar(128) NOT NULL DEFAULT COMMENT Tenant ID, `quota` int(10) unsigned NOT NULL DEFAULT 0 COMMENT 配额，0表示使用默认值, `usage` int(10) unsigned NOT NULL DEFAULT 0 COMMENT 使用量, `max_size` int(10) unsigned NOT NULL DEFAULT 0 COMMENT 单个配置大小上限，单位为字节，0表示使用默认值, `max_aggr_count` int(10) unsigned NOT NULL DEFAULT 0 COMMENT 聚合子配置最大个数, `max_aggr_size` int(10) unsigned NOT NULL DEFAULT 0 COMMENT 单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值, `max_history_count` int(10) unsigned NOT NULL DEFAULT 0 COMMENT 最大变更历史数量, `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 创建时间, `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 修改时间, PRIMARY KEY (`id`), UNIQUE KEY `uk_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=租户容量信息表;CREATE TABLE `tenant_info` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT id, `kp` varchar(128) NOT NULL COMMENT kp, `tenant_id` varchar(128) default COMMENT tenant_id, `tenant_name` varchar(128) default COMMENT tenant_name, `tenant_desc` varchar(256) DEFAULT NULL COMMENT tenant_desc, `create_source` varchar(32) DEFAULT NULL COMMENT create_source, `gmt_create` bigint(20) NOT NULL COMMENT 创建时间, `gmt_modified` bigint(20) NOT NULL COMMENT 修改时间, PRIMARY KEY (`id`), UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`), KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=tenant_info;CREATE TABLE `users` ( `username` varchar(50) NOT NULL PRIMARY KEY, `password` varchar(500) NOT NULL, `enabled` boolean NOT NULL);CREATE TABLE `roles` ( `username` varchar(50) NOT NULL, `role` varchar(50) NOT NULL, UNIQUE INDEX `idx_user_role` (`username` ASC, `role` ASC) USING BTREE);CREATE TABLE `permissions` ( `role` varchar(50) NOT NULL, `resource` varchar(255) NOT NULL, `action` varchar(8) NOT NULL, UNIQUE INDEX `uk_role_permission` (`role`,`resource`,`action`) USING BTREE);INSERT INTO users (username, password, enabled) VALUES (nacos, $2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu, TRUE);INSERT INTO roles (username, role) VALUES (nacos, ROLE_ADMIN); 3.启动nacos docker run -d --name nacos \\--ip 0.0.0.0 \\-p 8848:8848 \\-p 9848:9848 \\-p 9849:9849 \\--env MODE=standalone \\--env NACOS_AUTH_ENABLE=true \\-e JVM_XMS=256m \\-e JVM_XMX=256m acos/nacos-server 6. 安装RocketMQ 拉取镜像 docker pull apache/rocketmq:4.9.4 启动nameserver # 启动NameServerdocker run -d \\--privileged=true \\--name rmqnamesrv \\-p 9876:9876 \\-e MAX_HEAP_SIZE=256M \\-e HEAP_NEWSIZE=128M \\-e MAX_POSSIBLE_HEAP=100000000 \\apache/rocketmq sh mqnamesrv# 验证NameServer是否启动成功docker logs -f rmqnamesrv 进入conf目录编辑broker.conf # 所属集群名称，如果节点较多可以配置多个brokerClusterName = DefaultCluster#broker名称，master和slave使用相同的名称，表明他们的主从关系brokerName = broker-a#0表示Master，大于0表示不同的slavebrokerId = 0#表示几点做消息删除动作，默认是凌晨4点deleteWhen = 04#在磁盘上保留消息的时长，单位是小时fileReservedTime = 48#有三个值：SYNC_MASTER，ASYNC_MASTER，SLAVE；同步和异步表示Master和Slave之间同步数据的机制；brokerRole = ASYNC_MASTER#刷盘策略，取值为：ASYNC_FLUSH，SYNC_FLUSH表示同步刷盘和异步刷盘；SYNC_FLUSH消息写入磁盘后才返回成功状态，ASYNC_FLUSH不需要；flushDiskType = ASYNC_FLUSH#设置broker节点所在服务器的ip地址（**这个非常重要,主从模式下，从节点会根据主节点的brokerIP2来同步数据，如果不配置，主从无法同步，brokerIP1设置为自己外网能访问的ip，服务器双网卡情况下必须配置，比如阿里云这种，主节点需要配置ip1和ip2，从节点只需要配置ip1即可）brokerIP1 = 116.198.217.158#nameServer地址，分号分割namesrvAddr=116.198.217.158:9876#Broker 对外服务的监听端口,#listenPort = 10911#是否允许Broker自动创建Topic 上线为false 测试可开启autoCreateTopicEnable = true#是否允许 Broker 自动创建订阅组 上线为false 测试可开启autoCreateSubscriptionGroup = true#开启鉴权aclEnable=true 编辑ACL权限配置文件plain_acl.yml accounts: - accessKey: mqadmin secretKey: MIIEowIBAAKCAQEAwG90ULRHmAXFXQzZSwleoYts2+bCzUvqhhqtGiv/F5kUsETY # if it is admin, it could access all resources admin: true 启动borker docker run -d --restart=always --name rocketmq-broker-a \\-p 10909:10909 -p 10911:10911 -p 10912:10912 \\-v /var/lib/docker/volumes/rocketmq/broker/logs:/root/logs \\-v /var/lib/docker/volumes/rocketmq/broker/store:/root/store \\-v /var/lib/docker/volumes/rocketmq/broker/conf/broker.conf:/home/rocketmq/rocketmq-4.9.2/conf/broker.conf \\-v /var/lib/docker/volumes/rocketmq/broker/conf/plain_acl.yml:/home/rocketmq/rocketmq-4.9.2/conf/plain_acl.yml \\-e NAMESRV_ADDR=116.198.217.158:9876 \\-e MAX_POSSIBLE_HEAP=200000000 \\-e MAX_HEAP_SIZE=512M \\-e HEAP_NEWSIZE=256M \\apache/rocketmq \\sh mqbroker -c ../conf/broker.conf# 验证 Broker 是否启动成功docker logs rmqbroker 测试 # 进入broker容器$ docker exec -it rmqbroker bash$ sh tools.sh org.apache.rocketmq.example.quickstart.Producer SendResult [sendStatus=SEND_OK, msgId= ...$ sh tools.sh org.apache.rocketmq.example.quickstart.Consumer ConsumeMessageThread_%d Receive New Messages: [MessageExt... 注意 客户端版本需要和服务端版本一致不然会出现各种问题 7. 安装RocketMQ Dashboard#建立配置目录cd /var/lib/docker/volumes/rocketmqmkdir -p console/data#新建users.properties文件并写入账号密码#用户名和密码规则「用户名=密码,权限」，这里的权限为1表示管理员，为0表示普通用户mqadmin=MIIEowIBAAKCAQEAwG90ULRHmAXFXQzZSwleoYts2+bCzUvqhhqtGiv/F5kUsETY,1docker run -d --restart=always --name rocketmq-console \\-v /var/lib/docker/volumes/rocketmq/console/data:/tmp/rocketmq-console/data \\-e JAVA_OPTS=-Drocketmq.namesrv.addr=116.198.217.158:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false -Drocketmq.config.loginRequired=true -Drocketmq.config.accessKey=mqadmin -Drocketmq.config.secretKey=MIIEowIBAAKCAQEAwG90ULRHmAXFXQzZSwleoYts2+bCzUvqhhqtGiv/F5kUsETY -p 8888:8080 apacherocketmq/rocketmq-dashboard:latestdocker exec -it rocketmq-dashboard bash 8. 安装xxl-jobCREATE database if NOT EXISTS `xxl-job` default character set utf8 collate utf8_general_ci;use `xxl-job`;CREATE TABLE XXL_JOB_QRTZ_JOB_DETAILS ( SCHED_NAME VARCHAR(120) NOT NULL, JOB_NAME VARCHAR(200) NOT NULL, JOB_GROUP VARCHAR(200) NOT NULL, DESCRIPTION VARCHAR(250) NULL, JOB_CLASS_NAME VARCHAR(250) NOT NULL, IS_DURABLE VARCHAR(1) NOT NULL, IS_NONCONCURRENT VARCHAR(1) NOT NULL, IS_UPDATE_DATA VARCHAR(1) NOT NULL, REQUESTS_RECOVERY VARCHAR(1) NOT NULL, JOB_DATA BLOB NULL, PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP));CREATE TABLE XXL_JOB_QRTZ_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, JOB_NAME VARCHAR(200) NOT NULL, JOB_GROUP VARCHAR(200) NOT NULL, DESCRIPTION VARCHAR(250) NULL, NEXT_FIRE_TIME BIGINT(13) NULL, PREV_FIRE_TIME BIGINT(13) NULL, PRIORITY INTEGER NULL, TRIGGER_STATE VARCHAR(16) NOT NULL, TRIGGER_TYPE VARCHAR(8) NOT NULL, START_TIME BIGINT(13) NOT NULL, END_TIME BIGINT(13) NULL, CALENDAR_NAME VARCHAR(200) NULL, MISFIRE_INSTR SMALLINT(2) NULL, JOB_DATA BLOB NULL, PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), FOREIGN KEY (SCHED_NAME,JOB_NAME,JOB_GROUP) REFERENCES XXL_JOB_QRTZ_JOB_DETAILS(SCHED_NAME,JOB_NAME,JOB_GROUP));CREATE TABLE XXL_JOB_QRTZ_SIMPLE_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, REPEAT_COUNT BIGINT(7) NOT NULL, REPEAT_INTERVAL BIGINT(12) NOT NULL, TIMES_TRIGGERED BIGINT(10) NOT NULL, PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) REFERENCES XXL_JOB_QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP));CREATE TABLE XXL_JOB_QRTZ_CRON_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, CRON_EXPRESSION VARCHAR(200) NOT NULL, TIME_ZONE_ID VARCHAR(80), PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) REFERENCES XXL_JOB_QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP));CREATE TABLE XXL_JOB_QRTZ_SIMPROP_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, STR_PROP_1 VARCHAR(512) NULL, STR_PROP_2 VARCHAR(512) NULL, STR_PROP_3 VARCHAR(512) NULL, INT_PROP_1 INT NULL, INT_PROP_2 INT NULL, LONG_PROP_1 BIGINT NULL, LONG_PROP_2 BIGINT NULL, DEC_PROP_1 NUMERIC(13,4) NULL, DEC_PROP_2 NUMERIC(13,4) NULL, BOOL_PROP_1 VARCHAR(1) NULL, BOOL_PROP_2 VARCHAR(1) NULL, PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) REFERENCES XXL_JOB_QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP));CREATE TABLE XXL_JOB_QRTZ_BLOB_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, BLOB_DATA BLOB NULL, PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) REFERENCES XXL_JOB_QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP));CREATE TABLE XXL_JOB_QRTZ_CALENDARS ( SCHED_NAME VARCHAR(120) NOT NULL, CALENDAR_NAME VARCHAR(200) NOT NULL, CALENDAR BLOB NOT NULL, PRIMARY KEY (SCHED_NAME,CALENDAR_NAME));CREATE TABLE XXL_JOB_QRTZ_PAUSED_TRIGGER_GRPS ( SCHED_NAME VARCHAR(120) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, PRIMARY KEY (SCHED_NAME,TRIGGER_GROUP));CREATE TABLE XXL_JOB_QRTZ_FIRED_TRIGGERS ( SCHED_NAME VARCHAR(120) NOT NULL, ENTRY_ID VARCHAR(95) NOT NULL, TRIGGER_NAME VARCHAR(200) NOT NULL, TRIGGER_GROUP VARCHAR(200) NOT NULL, INSTANCE_NAME VARCHAR(200) NOT NULL, FIRED_TIME BIGINT(13) NOT NULL, SCHED_TIME BIGINT(13) NOT NULL, PRIORITY INTEGER NOT NULL, STATE VARCHAR(16) NOT NULL, JOB_NAME VARCHAR(200) NULL, JOB_GROUP VARCHAR(200) NULL, IS_NONCONCURRENT VARCHAR(1) NULL, REQUESTS_RECOVERY VARCHAR(1) NULL, PRIMARY KEY (SCHED_NAME,ENTRY_ID));CREATE TABLE XXL_JOB_QRTZ_SCHEDULER_STATE ( SCHED_NAME VARCHAR(120) NOT NULL, INSTANCE_NAME VARCHAR(200) NOT NULL, LAST_CHECKIN_TIME BIGINT(13) NOT NULL, CHECKIN_INTERVAL BIGINT(13) NOT NULL, PRIMARY KEY (SCHED_NAME,INSTANCE_NAME));CREATE TABLE XXL_JOB_QRTZ_LOCKS ( SCHED_NAME VARCHAR(120) NOT NULL, LOCK_NAME VARCHAR(40) NOT NULL, PRIMARY KEY (SCHED_NAME,LOCK_NAME));CREATE TABLE `XXL_JOB_QRTZ_TRIGGER_INFO` ( `id` int(11) NOT NULL AUTO_INCREMENT, `job_group` int(11) NOT NULL COMMENT 执行器主键ID, `job_cron` varchar(128) NOT NULL COMMENT 任务执行CRON, `job_desc` varchar(255) NOT NULL, `add_time` datetime DEFAULT NULL, `update_time` datetime DEFAULT NULL, `author` varchar(64) DEFAULT NULL COMMENT 作者, `alarm_email` varchar(255) DEFAULT NULL COMMENT 报警邮件, `executor_route_strategy` varchar(50) DEFAULT NULL COMMENT 执行器路由策略, `executor_handler` varchar(255) DEFAULT NULL COMMENT 执行器任务handler, `executor_param` varchar(512) DEFAULT NULL COMMENT 执行器任务参数, `executor_block_strategy` varchar(50) DEFAULT NULL COMMENT 阻塞处理策略, `executor_timeout` int(11) NOT NULL DEFAULT 0 COMMENT 任务执行超时时间，单位秒, `executor_fail_retry_count` int(11) NOT NULL DEFAULT 0 COMMENT 失败重试次数, `glue_type` varchar(50) NOT NULL COMMENT GLUE类型, `glue_source` mediumtext COMMENT GLUE源代码, `glue_remark` varchar(128) DEFAULT NULL COMMENT GLUE备注, `glue_updatetime` datetime DEFAULT NULL COMMENT GLUE更新时间, `child_jobid` varchar(255) DEFAULT NULL COMMENT 子任务ID，多个逗号分隔, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `XXL_JOB_QRTZ_TRIGGER_LOG` ( `id` int(11) NOT NULL AUTO_INCREMENT, `job_group` int(11) NOT NULL COMMENT 执行器主键ID, `job_id` int(11) NOT NULL COMMENT 任务，主键ID, `executor_address` varchar(255) DEFAULT NULL COMMENT 执行器地址，本次执行的地址, `executor_handler` varchar(255) DEFAULT NULL COMMENT 执行器任务handler, `executor_param` varchar(512) DEFAULT NULL COMMENT 执行器任务参数, `executor_sharding_param` varchar(20) DEFAULT NULL COMMENT 执行器任务分片参数，格式如 1/2, `executor_fail_retry_count` int(11) NOT NULL DEFAULT 0 COMMENT 失败重试次数, `trigger_time` datetime DEFAULT NULL COMMENT 调度-时间, `trigger_code` int(11) NOT NULL COMMENT 调度-结果, `trigger_msg` text COMMENT 调度-日志, `handle_time` datetime DEFAULT NULL COMMENT 执行-时间, `handle_code` int(11) NOT NULL COMMENT 执行-状态, `handle_msg` text COMMENT 执行-日志, PRIMARY KEY (`id`), KEY `I_trigger_time` (`trigger_time`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `XXL_JOB_QRTZ_TRIGGER_LOGGLUE` ( `id` int(11) NOT NULL AUTO_INCREMENT, `job_id` int(11) NOT NULL COMMENT 任务，主键ID, `glue_type` varchar(50) DEFAULT NULL COMMENT GLUE类型, `glue_source` mediumtext COMMENT GLUE源代码, `glue_remark` varchar(128) NOT NULL COMMENT GLUE备注, `add_time` timestamp NULL DEFAULT NULL, `update_time` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE XXL_JOB_QRTZ_TRIGGER_REGISTRY ( `id` int(11) NOT NULL AUTO_INCREMENT, `registry_group` varchar(255) NOT NULL, `registry_key` varchar(255) NOT NULL, `registry_value` varchar(255) NOT NULL, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `XXL_JOB_QRTZ_TRIGGER_GROUP` ( `id` int(11) NOT NULL AUTO_INCREMENT, `app_name` varchar(64) NOT NULL COMMENT 执行器AppName, `title` varchar(12) NOT NULL COMMENT 执行器名称, `order` tinyint(4) NOT NULL DEFAULT 0 COMMENT 排序, `address_type` tinyint(4) NOT NULL DEFAULT 0 COMMENT 执行器地址类型：0=自动注册、1=手动录入, `address_list` varchar(512) DEFAULT NULL COMMENT 执行器地址列表，多地址逗号分隔, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO `XXL_JOB_QRTZ_TRIGGER_GROUP` ( `app_name`, `title`, `order`, `address_type`, `address_list`) values ( xxl-job-executor-sample, 示例执行器, 1, 0, null);commit; docker run -e PARAMS=--spring.datasource.url=jdbc:mysql://116.198.217.158:3306/xxl_job?useUnicode=truecharacterEncoding=UTF-8autoReconnect=trueserverTimezone=Asia/Shanghai --spring.datasource.username=cloud --spring.datasource.password=li.ming9518 \\-p 9999:8080 --name xxl-job-admin -d 116.198.217.158:5000/xxl-job-admin:2.4.1 docker exec -it xxl-job-admin bashcd /usr/local/tomcat/webapps/xxl-job-admin/WEB-INF/classesapt-get install vim MIIEowIBAAKCAQEAwG 9. docker composeversion: 3.8services: mysql: image: mysql:8.0 container_name: mysql environment: MYSQL_ROOT_PASSWORD: strong_root_password ports: - 3306:3306 volumes: - mysql_data:/var/lib/mysql networks: - backend deploy: resources: limits: cpus: 2 memory: 2G restart: always redis: image: redis:6.2 container_name: redis ports: - 6379:6379 volumes: - redis_data:/data networks: - backend deploy: resources: limits: cpus: 1 memory: 2G restart: always nacos: image: nacos/nacos-server:2.2.0 container_name: nacos environment: MODE: standalone SPRING_DATASOURCE_PLATFORM: mysql MYSQL_SERVICE_HOST: mysql MYSQL_SERVICE_PORT: 3306 MYSQL_SERVICE_DB_NAME: nacos_config MYSQL_SERVICE_USER: root MYSQL_SERVICE_PASSWORD: strong_root_password ports: - 8848:8848 - 9848:9848 networks: - backend volumes: - nacos_logs:/home/nacos/logs - nacos_data:/home/nacos/data deploy: resources: limits: cpus: 2 memory: 2G restart: always rocketmq: image: apache/rocketmq:4.9.4 container_name: rocketmq ports: - 9876:9876 networks: - backend volumes: - rocketmq_logs:/root/logs - rocketmq_store:/root/store deploy: resources: limits: cpus: 2 memory: 2G restart: always rocketmq-broker: image: apache/rocketmq:4.9.4 container_name: rocketmq-broker depends_on: - rocketmq environment: - NAMESRV_ADDR=rocketmq:9876 ports: - 10911:10911 - 10912:10912 - 10909:10909 networks: - backend volumes: - rocketmq_broker_logs:/root/logs - rocketmq_broker_store:/root/store deploy: resources: limits: cpus: 2 memory: 2G restart: always xxl-job: image: xuxueli/xxl-job-admin:2.3.0 container_name: xxl-job environment: XXL_JOB_DB_USERNAME: root XXL_JOB_DB_PASSWORD: strong_root_password XXL_JOB_DB_PORT: 3306 XXL_JOB_DB_URL: jdbc:mysql://mysql:3306/xxl_job?characterEncoding=UTF-8useSSL=true ports: - 8080:8080 networks: - backend deploy: resources: limits: cpus: 1 memory: 1G restart: always elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:7.17.0 container_name: elasticsearch environment: discovery.type: single-node ES_JAVA_OPTS: -Xms1g -Xmx1g ports: - 9200:9200 - 9300:9300 volumes: - es_data:/usr/share/elasticsearch/data networks: - backend deploy: resources: limits: cpus: 4 memory: 4G restart: always kibana: image: docker.elastic.co/kibana/kibana:7.17.0 container_name: kibana ports: - 5601:5601 networks: - backend depends_on: - elasticsearch deploy: resources: limits: cpus: 1 memory: 2G restart: always logstash: image: docker.elastic.co/logstash/logstash:7.17.0 container_name: logstash ports: - 5044:5044 - 9600:9600 volumes: - ./logstash.conf:/usr/share/logstash/pipeline/logstash.conf:ro networks: - backend depends_on: - elasticsearch deploy: resources: limits: cpus: 2 memory: 2G restart: always skywalking-oap: image: apache/skywalking-oap-server:9.0.0 container_name: skywalking-oap environment: SW_STORAGE: elasticsearch SW_STORAGE_ES_CLUSTER_NODES: elasticsearch:9200 SW_HEALTH_CHECKER: default ports: - 12800:12800 - 11800:11800 networks: - backend depends_on: - elasticsearch deploy: resources: limits: cpus: 2 memory: 4G restart: always skywalking-ui: image: apache/skywalking-ui:9.0.0 container_name: skywalking-ui ports: - 8088:8080 networks: - backend depends_on: - skywalking-oap deploy: resources: limits: cpus: 1 memory: 2G restart: always nginx: image: nginx:latest container_name: nginx ports: - 80:80 - 443:443 volumes: - ./nginx.conf:/etc/nginx/nginx.conf:ro - ./nginx_logs:/var/log/nginx networks: - backend - frontend # 可以为前端应用提供服务 restart: always deploy: resources: limits: cpus: 1 memory: 512M prometheus: image: prom/prometheus:latest container_name: prometheus ports: - 9090:9090 volumes: - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro - prometheus_data:/prometheus networks: - monitoring - backend restart: always deploy: resources: limits: cpus: 2 memory: 2G grafana: image: grafana/grafana:latest container_name: grafana ports: - 3000:3000 volumes: - grafana_data:/var/lib/grafana environment: - GF_SECURITY_ADMIN_PASSWORD=strong_grafana_password networks: - monitoring depends_on: - prometheus restart: always deploy: resources: limits: cpus: 1 memory: 1Gvolumes: mysql_data: redis_data: nacos_logs: nacos_data: rocketmq_logs: rocketmq_store: rocketmq_broker_logs: rocketmq_broker_store: es_data: nginx_logs: prometheus_data: grafana_data:networks: backend: driver: bridge frontend: driver: bridge monitoring: driver: bridge 安装weaviatedocker run –name weaviate-dev -d -p 8080:8080 -p 50051:50051 -e AUTHENTICATION_ANONYMOUS_ACCESS_ENABLED’true’ semitechnologiesweaviate:1.30.0 10. 环境搭建 修改yum源 http://mirrors.aliyun.com/repo/Centos-7.repocd /etc/yum.repos.dcp CentOS-Base.repo CentOS-Base.repo.bakmv Centos-7.repo CentOS-Base.repoyum clean all yum makecacheyum -y update 安装docker 添加镜像源 docker run \\ --rm \\ -u root \\ -p 8080:8080 \\ -v jenkins-data:/var/jenkins_home \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v $HOME:/home \\ -restart: always \\ jenkins:2.60.3"},{"title":"xxl-job基础","path":"/2025/03/25/xxl-job/","content":"XXL-JOB简介概述XXL-JOB 是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。 特性 1、简单：支持通过 Web 页面对任务进行 CRUD 操作，操作简单，一分钟上手； 2、动态：支持动态修改任务状态、启动停止任务，以及终止运行中任务，即时生效； 3、调度中心 HA（中心式）：调度采用中心式设计，“调度中心”自研调度组件并支持集群部署，可保证调度中心 HA； 4、执行器 HA（分布式）：任务分布式执行，任务”执行器”支持集群部署，可保证任务执行 HA； 5、注册中心: 执行器会周期性自动注册任务, 调度中心将会自动发现注册的任务并触发执行。同时，也支持手动录入执行器地址； 6、弹性扩容缩容：一旦有新执行器机器上线或者下线，下次调度时将会重新分配任务； 7、触发策略：提供丰富的任务触发策略，包括：Cron 触发、固定间隔触发、固定延时触发、API（事件）触发、人工触发、父子任务触发； 8、调度过期策略：调度中心错过调度时间的补偿处理策略，包括：忽略、立即补偿触发一次等； 9、阻塞处理策略：调度过于密集执行器来不及处理时的处理策略，策略包括：单机串行（默认）、丢弃后续调度、覆盖之前调度； 10、任务超时控制：支持自定义任务超时时间，任务运行超时将会主动中断任务； 11、任务失败重试：支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；其中分片任务支持分片粒度的失败重试； 12、任务失败告警；默认提供邮件方式失败告警，同时预留扩展接口，可方便的扩展短信、钉钉等告警方式； 13、路由策略：执行器集群部署时提供丰富的路由策略，包括：第一个、最后一个、轮询、随机、一致性 HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等； 14、分片广播任务：执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发集群中所有执行器执行一次任务，可根据分片参数开发分片任务； 15、动态分片：分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。 16、故障转移：任务路由策略选择”故障转移”情况下，如果执行器集群中某一台机器故障，将会自动 Failover 切换到一台正常的执行器发送调度请求。 17、任务进度监控：支持实时监控任务进度； 18、Rolling 实时日志：支持在线查看调度结果，并且支持以 Rolling 方式实时查看执行器输出的完整的执行日志； 19、GLUE：提供 Web IDE，支持在线开发任务逻辑代码，动态发布，实时编译生效，省略部署上线的过程。支持 30 个版本的历史版本回溯。 20、脚本任务：支持以 GLUE 模式开发和运行脚本任务，包括 Shell、Python、NodeJS、PHP、PowerShell 等类型脚本; 21、命令行任务：原生提供通用命令行任务 Handler（Bean 任务，”CommandJobHandler”）；业务方只需要提供命令行即可； 22、任务依赖：支持配置子任务依赖，当父任务执行结束且执行成功后将会主动触发一次子任务的执行, 多个子任务用逗号分隔； 23、一致性：“调度中心”通过 DB 锁保证集群分布式调度的一致性, 一次任务调度只会触发一次执行； 24、自定义任务参数：支持在线配置调度任务入参，即时生效； 25、调度线程池：调度系统多线程触发调度运行，确保调度精确执行，不被堵塞； 26、数据加密：调度中心和执行器之间的通讯进行数据加密，提升调度信息安全性； 27、邮件报警：任务失败时支持邮件报警，支持配置多邮件地址群发报警邮件； 28、推送 maven 中央仓库: 将会把最新稳定版推送到 maven 中央仓库, 方便用户接入和使用; 29、运行报表：支持实时查看运行数据，如任务数量、调度次数、执行器数量等；以及调度报表，如调度日期分布图，调度成功分布图等； 30、全异步：任务调度流程全异步化设计实现，如异步调度、异步运行、异步回调等，有效对密集调度进行流量削峰，理论上支持任意时长任务的运行； 31、跨语言OpenAPI：调度中心与执行器提供语言无关的 OpenApi（RESTful 格式），第三方任意语言可据此对接调度中心或者实现执行器，实现多语言支持。除此之外，还提供了 “多任务模式”和“httpJobHandler”等其他跨语言方案； 32、国际化：调度中心支持国际化设置，提供中文、英文两种可选语言，默认为中文； 33、容器化：提供官方 docker 镜像，并实时更新推送 dockerhub，进一步实现产品开箱即用； 34、线程池隔离：调度线程池进行隔离拆分，慢任务自动降级进入”Slow”线程池，避免耗尽调度线程，提高系统稳定性； 35、用户管理：支持在线管理系统用户，存在管理员、普通用户两种角色； 36、权限控制：执行器维度进行权限控制，管理员拥有全量权限，普通用户需要分配执行器权限后才允许相关操作； 安装源码部署下载地址 https://github.com/xuxueli/xxl-job/releases 环境要求 Maven3+ Jdk17+ (说明：版本 3.x 开始要求 Jdk17；版本 2.x 及以下支持 Jdk1.8。如对 Jdk 版本有诉求，可选择接入不同版本。) Mysql8.0+ 初始化数据库 xxl-jobdocdbtables_xxl_job.SQL 部署 xxl-job-admin调度中心配置文件说明： ### 调度中心JDBC链接spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?useUnicode=truecharacterEncoding=UTF-8autoReconnect=trueserverTimezone=Asia/Shanghaispring.datasource.username=rootspring.datasource.password=root_pwdspring.datasource.driver-class-name=com.mysql.jdbc.Driver### 报警邮箱spring.mail.host=smtp.qq.comspring.mail.port=25spring.mail.username=xxx@qq.comspring.mail.password=xxxspring.mail.properties.mail.smtp.auth=truespring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=truespring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory### 调度中心通讯TOKEN [选填]：非空时启用；xxl.job.accessToken=### 调度中心通讯超时时间[选填]，单位秒；默认3s；xxl.job.timeout=3### 调度中心国际化配置 [必填]： 默认为 zh_CN/中文简体, 可选范围为 zh_CN/中文简体, zh_TC/中文繁体 and en/英文；xxl.job.i18n=zh_CN## 调度线程池最大线程配置【必填】xxl.job.triggerpool.fast.max=200xxl.job.triggerpool.slow.max=100### 调度中心日志表数据保存天数 [必填]：过期日志自动清理；限制大于等于7时生效，否则, 如-1，关闭自动清理功能；xxl.job.logretentiondays=30 http://localhost: 8080xxl-job-admin 默认登陆账号密码：admin123456 docker 安装下载镜像#Docker地址：https://hub.docker.com/r/xuxueli/xxl-job-admin/ (建议指定版本号)docker pull xuxueli/xxl-job-admin 运行镜像#如需自定义 mysql 等配置，可通过 -e PARAMS 指定，参数格式 PARAMS=--key=value --key2=value2 ；#配置项参考文件：/xxl-job/xxl-job-admin/src/main/resources/application.properties#如需自定义 JVM内存参数 等配置，可通过 -e JAVA_OPTS 指定，参数格式 JAVA_OPTS=-Xmx512m ；docker run -e PARAMS=--spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?useUnicode=truecharacterEncoding=UTF-8autoReconnect=trueserverTimezone=Asia/Shanghai -p 8080:8080 -v /tmp:/data/applogs --name xxl-job-admin -d xuxueli/xxl-job-admin:指定版本 执行器部署新建项目 pom.xml ?xml version=1.0 encoding=UTF-8?project xmlns=http://maven.apache.org/POM/4.0.0 xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation=http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion4.0.0/modelVersion groupIdexample.java.xxl-job/groupId artifactIdexample_xxl-job/artifactId version1.0-SNAPSHOT/version properties maven.compiler.source17/maven.compiler.source maven.compiler.target17/maven.compiler.target project.build.sourceEncodingUTF-8/project.build.sourceEncoding /properties dependencyManagement dependencies dependency !-- Import dependency management from Spring Boot (依赖管理：继承一些默认的依赖，工程需要依赖的jar包的管理，申明其他dependency的时候就不需要version) -- groupIdorg.springframework.boot/groupId artifactIdspring-boot-starter-parent/artifactId version3.2.4/version typepom/type scopeimport/scope /dependency /dependencies /dependencyManagement dependencies !-- http://repo1.maven.org/maven2/com/xuxueli/xxl-job-core/ -- dependency groupIdcom.xuxueli/groupId artifactIdxxl-job-core/artifactId version3.0.0/version /dependency dependency groupIdorg.springframework.boot/groupId artifactIdspring-boot-starter-web/artifactId /dependency dependency groupIdorg.projectlombok/groupId artifactIdlombok/artifactId version1.18.34/version /dependency /dependencies/project srcmainresourcesapplication.properties # web portserver.port=8081# no web#spring.main.web-environment=false# log configlogging.config=classpath:logback.xml### xxl-job admin address list, such as http://address or http://address01,http://address02xxl.job.admin.addresses=http://127.0.0.1:8080/xxl-job-admin### xxl-job, access tokenxxl.job.admin.accessToken=default_token### xxl-job timeout by second, default 3sxxl.job.admin.timeout=3### xxl-job executor appnamexxl.job.executor.appname=xxl-job-executor-example### xxl-job executor registry-address: default use address to registry , otherwise use ip:port if address is nullxxl.job.executor.address=### xxl-job executor server-infoxxl.job.executor.ip=xxl.job.executor.port=9998### xxl-job executor log-pathxxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler### xxl-job executor log-retention-daysxxl.job.executor.logretentiondays=30 srcmainresourceslogback.xml ?xml version=1.0 encoding=UTF-8?configuration debug=false scan=true scanPeriod=1 seconds contextNamelogback/contextName property name=log.path value=/data/applogs/xxl-job/xxl-job-executor-sample-springboot.log/ appender name=console class=ch.qos.logback.core.ConsoleAppender encoder pattern%dHH:mm:ss.SSS %contextName [%thread] %-5level %logger36 - %msg%n/pattern /encoder /appender appender name=file class=ch.qos.logback.core.rolling.RollingFileAppender file$log.path/file rollingPolicy class=ch.qos.logback.core.rolling.TimeBasedRollingPolicy fileNamePattern$log.path.%dyyyy-MM-dd.zip/fileNamePattern /rollingPolicy encoder pattern%date %level [%thread] %logger36 [%file : %line] %msg%n /pattern /encoder /appender root level=info appender-ref ref=console/ appender-ref ref=file/ /root/configuration 执行器配置 srcmainJavaexampleJavaxxljobconfigXxlJobConfig.Java package example.java.xxljob.config;import com.xxl.job.core.executor.impl.XxlJobSpringExecutor;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.stereotype.Component;/** * * * @author lianyutian * @since 2025/3/25 * @version 1.0 */@Componentpublic class XxlJobConfig private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class); @Value($xxl.job.admin.addresses) private String adminAddresses; @Value($xxl.job.admin.accessToken) private String accessToken; @Value($xxl.job.admin.timeout) private int timeout; @Value($xxl.job.executor.appname) private String appname; @Value($xxl.job.executor.address) private String address; @Value($xxl.job.executor.ip) private String ip; @Value($xxl.job.executor.port) private int port; @Value($xxl.job.executor.logpath) private String logPath; @Value($xxl.job.executor.logretentiondays) private int logRetentionDays; @Bean public XxlJobSpringExecutor xxlJobExecutor() logger.info( xxl-job config init.); XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor(); xxlJobSpringExecutor.setAdminAddresses(adminAddresses); xxlJobSpringExecutor.setAppname(appname); xxlJobSpringExecutor.setAddress(address); xxlJobSpringExecutor.setIp(ip); xxlJobSpringExecutor.setPort(port); xxlJobSpringExecutor.setAccessToken(accessToken); xxlJobSpringExecutor.setTimeout(timeout); xxlJobSpringExecutor.setLogPath(logPath); xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays); return xxlJobSpringExecutor; /** * 针对多网卡、容器内部署等情况，可借助 spring-cloud-commons 提供的 InetUtils 组件灵活定制注册IP； * * 1、引入依赖： * dependency * groupIdorg.springframework.cloud/groupId * artifactIdspring-cloud-commons/artifactId * version$version/version * /dependency * * 2、配置文件，或者容器启动变量 * spring.cloud.inetutils.preferred-networks: xxx.xxx.xxx. * * 3、获取IP * String ip_ = inetUtils.findFirstNonLoopbackHostInfo().getIpAddress(); */ 添加执行器在调度界面手动新增执行器。 执行器属性说明： AppName: 是每个执行器集群的唯一标示AppName, 执行器会周期性以AppName为对象进行自动注册。可通过该配置自动发现注册成功的执行器, 供任务调度时使用;名称: 执行器的名称, 因为AppName限制字母数字等组成,可读性不强, 名称为了提高执行器的可读性;排序: 执行器的排序, 系统中需要执行器的地方,如任务新增, 将会按照该排序读取可用的执行器列表;注册方式：调度中心获取执行器地址的方式； 自动注册：执行器自动进行执行器注册，调度中心通过底层注册表可以动态发现执行器机器地址； 手动录入：人工手动录入执行器的地址信息，多地址逗号分隔，供调度中心使用；机器地址：注册方式为手动录入时有效，支持人工维护执行器的地址信息；注册地址格式可参考“http://127.0.0.1:9999/”，为执行器内嵌服务地址； 启动执行器服务可以查看到执行器服务注册成功。 任务管理GLUE 模式(Java)新建任务 任务开发点击任务右侧 GLUE IDE 按钮，进入 GLUE 编辑器开发界面 ，见下图。GLUE 模式(Java) 运行模式的任务默认已经初始化了示例任务代码，即打印 Hello World。 任务执行点击任务右侧 执行一次 按钮，可手动触发一次任务执行。 配置了 Cron 表达式的任务 点击 启动 时会根据 Cron 表达式自动执行。 调度日志点击任务右侧 日志 按钮，可前往任务日志界面查看任务日志。 在任务日志界面中，可查看该任务的历史调度记录以及每一次调度的任务调度信息、执行参数和执行信息。运行中的任务点击右侧的 执行日志 按钮，可进入日志控制台查看实时执行日志。 任务配置属性说明基础配置： - 执行器：任务的绑定的执行器，任务触发调度时将会自动发现注册成功的执行器, 实现任务自动发现功能; 另一方面也可以方便的进行任务分组。每个任务必须绑定一个执行器, 可在 执行器管理 进行设置; - 任务描述：任务的描述信息，便于任务管理； - 负责人：任务的负责人； - 报警邮件：任务调度失败时邮件通知的邮箱地址，支持配置多邮箱地址，配置多个邮箱地址时用逗号分隔；触发配置： - 调度类型： 无：该类型不会主动触发调度； CRON：该类型将会通过CRON，触发任务调度； 固定速度：该类型将会以固定速度，触发任务调度；按照固定的间隔时间，周期性触发； 固定延迟：该类型将会以固定延迟，触发任务调度；按照固定的延迟时间，从上次调度结束后开始计算延迟时间，到达延迟时间后触发下次调度； - CRON：触发任务执行的Cron表达式； - 固定速度：固定速度的时间间隔，单位为秒； - 固定延迟：固定延迟的时间间隔，单位为秒；任务配置： - 运行模式： BEAN模式：任务以JobHandler方式维护在执行器端；需要结合 JobHandler 属性匹配执行器中任务； GLUE模式(Java)：任务以源码方式维护在调度中心；该模式的任务实际上是一段继承自IJobHandler的Java类代码并 groovy 源码方式维护，它在执行器项目中运行，可使用@Resource/@Autowire注入执行器里中的其他服务； GLUE模式(Shell)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 shell 脚本； GLUE模式(Python)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 python 脚本； GLUE模式(PHP)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 php 脚本； GLUE模式(NodeJS)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 nodejs 脚本； GLUE模式(PowerShell)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 PowerShell 脚本； - JobHandler：运行模式为 BEAN模式 时生效，对应执行器中新开发的JobHandler类“@XxlJob”注解自定义的value值； - 执行参数：任务执行所需的参数； 高级配置： - 路由策略：当执行器集群部署时，提供丰富的路由策略，包括； FIRST（第一个）：固定选择第一个机器； LAST（最后一个）：固定选择最后一个机器； ROUND（轮询）：； RANDOM（随机）：随机选择在线的机器； CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。 LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举； LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举； FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度； BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度； SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务； - 子任务：每个任务都拥有一个唯一的任务ID(任务ID可以从任务列表获取)，当本任务执行结束并且执行成功时，将会触发子任务ID所对应的任务的一次主动调度。 - 调度过期策略： - 忽略：调度过期后，忽略过期的任务，从当前时间开始重新计算下次触发时间； - 立即执行一次：调度过期后，立即执行一次，并从当前时间开始重新计算下次触发时间； - 阻塞处理策略：调度过于密集执行器来不及处理时的处理策略； 单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行； 丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败； 覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务； - 任务超时时间：支持自定义任务超时时间，任务运行超时将会主动中断任务； - 失败重试次数；支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试； 调度日志属性说明调度时间：调度中心触发本次调度并向执行器发送任务执行信号的时间；调度结果：调度中心触发本次调度的结果，200表示成功，500或其他表示失败；调度备注：调度中心触发本次调度的日志信息；执行器地址：本次任务执行的机器地址运行模式：触发调度时任务的运行模式，运行模式可参考章节 三、任务详解；任务参数：本地任务执行的入参执行时间：执行器中本次任务执行结束后回调的时间；执行结果：执行器中本次任务执行的结果，200表示成功，500或其他表示失败；执行备注：执行器中本次任务执行的日志信息；操作： 执行日志按钮：点击可查看本地任务执行的详细日志信息；详见“4.8 查看执行日志”； 终止任务按钮：点击可终止本地调度对应执行器上本任务的执行线程，包括未执行的阻塞任务一并被终止； Bean 模式（类形式）Bean 模式任务，支持基于类的开发方式，每个任务对应一个 Java 类。 优点：不限制项目环境，兼容性好。即使是无框架项目，如 main 方法直接启动的项目也可以提供支持。 缺点： 每个任务需要占用一个 Java 类，造成类的浪费； 不支持自动扫描任务并注入到执行器容器，需要手动注入。 新建执行器 pom.xml ?xml version=1.0 encoding=UTF-8?project xmlns=http://maven.apache.org/POM/4.0.0 xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation=http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion4.0.0/modelVersion parent groupIdexample.java.xxl-job/groupId artifactIdexample_xxl-job/artifactId version1.0-SNAPSHOT/version /parent artifactIdexample_xxl-job_single/artifactId properties maven.compiler.source17/maven.compiler.source maven.compiler.target17/maven.compiler.target project.build.sourceEncodingUTF-8/project.build.sourceEncoding /properties dependencies dependency groupIdcom.xuxueli/groupId artifactIdxxl-job-core/artifactId version3.0.0/version /dependency dependency groupIdorg.slf4j/groupId artifactIdslf4j-api/artifactId version2.0.16/version /dependency dependency groupIdch.qos.logback/groupId artifactIdlogback-classic/artifactId version1.4.14/version /dependency /dependencies/project logback.xml ?xml version=1.0 encoding=UTF-8?configuration debug=false scan=true scanPeriod=1 seconds contextNamelogback/contextName property name=log.path value=/data/applogs/xxl-job/example_xxl-job_single.log/ appender name=console class=ch.qos.logback.core.ConsoleAppender encoder pattern%dHH:mm:ss.SSS %contextName [%thread] %-5level %logger36 - %msg%n/pattern /encoder /appender appender name=file class=ch.qos.logback.core.rolling.RollingFileAppender file$log.path/file rollingPolicy class=ch.qos.logback.core.rolling.TimeBasedRollingPolicy fileNamePattern$log.path.%dyyyy-MM-dd.zip/fileNamePattern /rollingPolicy encoder pattern%date %level [%thread] %logger36 [%file : %line] %msg%n /pattern /encoder /appender root level=info appender-ref ref=console/ appender-ref ref=file/ /root/configuration xxl-job-executor.properties ### xxl-job admin address list, such as http://address or http://address01,http://address02xxl.job.admin.addresses=http://127.0.0.1:8080/xxl-job-admin### xxl-job access-tokenxxl.job.admin.accessToken=default_token### xxl-job timeout by second, default 3sxxl.job.admin.timeout=3### xxl-job executor appnamexxl.job.executor.appname=xxl-job-executor-example-single### xxl-job executor registry-address: default use address to registry , otherwise use ip:port if address is nullxxl.job.executor.address=### xxl-job executor server-infoxxl.job.executor.ip=xxl.job.executor.port=9997### xxl-job executor log-pathxxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler### xxl-job executor log-retention-daysxxl.job.executor.logretentiondays=30 执行器配置 srcmainJavaexampleJavaxxljobsingleconfigJobConfig.Java package example.java.xxljob.single.config;import com.xxl.job.core.executor.XxlJobExecutor;import com.xxl.job.core.executor.impl.XxlJobSimpleExecutor;import example.java.xxljob.single.job.ExampleJob;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;import java.util.Properties;/** * * * @author lianyutian * @since 2025/3/26 * @version 1.0 */public class JobConfig private static Logger logger = LoggerFactory.getLogger(JobConfig.class); private static JobConfig instance = new JobConfig(); public static JobConfig getInstance() return instance; private XxlJobSimpleExecutor xxlJobExecutor = null; /** * init */ public void initXxlJobExecutor() // 加载 properties Properties xxlJobProp = loadProperties(xxl-job-executor.properties); // 初始化执行器 xxlJobExecutor = new XxlJobSimpleExecutor(); xxlJobExecutor.setAdminAddresses(xxlJobProp.getProperty(xxl.job.admin.addresses)); xxlJobExecutor.setAccessToken(xxlJobProp.getProperty(xxl.job.admin.accessToken)); xxlJobExecutor.setTimeout(Integer.valueOf(xxlJobProp.getProperty(xxl.job.admin.timeout))); xxlJobExecutor.setAppname(xxlJobProp.getProperty(xxl.job.executor.appname)); xxlJobExecutor.setAddress(xxlJobProp.getProperty(xxl.job.executor.address)); xxlJobExecutor.setIp(xxlJobProp.getProperty(xxl.job.executor.ip)); xxlJobExecutor.setPort(Integer.valueOf(xxlJobProp.getProperty(xxl.job.executor.port))); xxlJobExecutor.setLogPath(xxlJobProp.getProperty(xxl.job.executor.logpath)); xxlJobExecutor.setLogRetentionDays(Integer.valueOf(xxlJobProp.getProperty(xxl.job.executor.logretentiondays))); // 注册任务 XxlJobExecutor.registJobHandler(exampleJob, new ExampleJob()); // 运行执行器 try xxlJobExecutor.start(); catch (Exception e) logger.error(e.getMessage(), e); /** * destroy */ public void destroyXxlJobExecutor() if (xxlJobExecutor != null) xxlJobExecutor.destroy(); public static Properties loadProperties(String propertyFileName) InputStreamReader in = null; try ClassLoader loder = Thread.currentThread().getContextClassLoader(); in = new InputStreamReader(loder.getResourceAsStream(propertyFileName), UTF-8);; if (in != null) Properties prop = new Properties(); prop.load(in); return prop; catch (IOException e) logger.error(load error!, propertyFileName); finally if (in != null) try in.close(); catch (IOException e) logger.error(close error!, propertyFileName); return null; 编写任务 srcmainJavaexampleJavaxxljobsinglejobExampleJob.Java package example.java.xxljob.single.job;import com.xxl.job.core.context.XxlJobHelper;import com.xxl.job.core.handler.IJobHandler;/** * * * @author lianyutian * @since 2025/3/26 * @version 1.0 */public class ExampleJob extends IJobHandler @Override public void execute() throws Exception XxlJobHelper.log(EXAMPLEJOB, EXECUTE.); 启动执行器 srcmainJavaexampleJavaxxljobsingleMain.Java package example.java.xxljob.single;import example.java.xxljob.single.config.JobConfig;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.concurrent.TimeUnit;/** * * * @author lianyutian * @since 2025/3/26 * @version 1.0 */public class Main private static Logger logger = LoggerFactory.getLogger(Main.class); public static void main(String[] args) try // 初始话 xxl-job 配置 JobConfig.getInstance().initXxlJobExecutor(); // Blocks until interrupted while (true) try TimeUnit.HOURS.sleep(1); catch (InterruptedException e) break; catch (Exception e) logger.error(e.getMessage(), e); finally // 销毁执行器 JobConfig.getInstance().destroyXxlJobExecutor(); 调度平台运行任务新建执行器（同 3 章节）– 新建调度任务（同 4.1 章节执行步骤） 注意：任务配置中 JobHandler 的名称与注册任务时设置的名称需要一致 Bean 模式（方法）新建任务 srcmainJavaexampleJavaxxljobsinglejobExampleMethodJob.Java package example.java.xxljob.single.job;import com.xxl.job.core.context.XxlJobHelper;import com.xxl.job.core.handler.annotation.XxlJob;/** * @author lianyutian * @since 2025/3/26 * @version 1.0 */public class ExampleMethodJob /** * 1、简单任务示例（Bean模式） */ @XxlJob(exampleMethodJob) public void exampleMethodJob() throws Exception XxlJobHelper.log(exampleMethodJob execute); // default success 注册任务 srcmainJavaexampleJavaxxljobsingleconfigJobConfig.Java public void initXxlJobExecutor() // 加载 properties ... // 初始化执行器 ... // 注册任务 XxlJobExecutor.registJobHandler(exampleJob, new ExampleJob()); xxlJobExecutor.setXxlJobBeanList(Arrays.asList(new ExampleMethodJob())); // 运行执行器 try xxlJobExecutor.start(); catch (Exception e) logger.error(e.getMessage(), e); 调度中心新建任务 分片广播任务简介执行器集群部署时，任务路由策略选择 分片广播 情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务； 分片广播 以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。 分片广播 和普通任务开发流程一致，不同之处在于可以获取分片参数，获取分片参数进行分片业务处理。 分片参数获取// 分片序号int shardIndex = XxlJobHelper.getShardIndex();// 总分片数int shardTotal = XxlJobHelper.getShardTotal(); shardIndex：当前分片序号(从 0 开始)，执行器集群列表中当前执行器的序号； shardTotal：总分片数，执行器集群的总机器数量； 该特性适用场景如： 分片任务场景：10 个执行器的集群来处理 10w 条数据，每台机器只需要处理 1w 条数据，耗时降低 10 倍； 广播任务场景：广播执行器机器运行 shell 脚本、广播集群节点进行缓存更新等 分片任务package example.java.xxljob.springboot.job;import com.xxl.job.core.context.XxlJobHelper;import com.xxl.job.core.handler.annotation.XxlJob;import org.springframework.stereotype.Component;/** * @author lianyutian * @since 2025/3/26 * @version 1.0 */@Componentpublic class ExampleShardingBroadcastJob @XxlJob(exampleShardingBroadcastJob) public void exampleShardingBroadcastJob() // 分片参数 int shardIndex = XxlJobHelper.getShardIndex(); int shardTotal = XxlJobHelper.getShardTotal(); XxlJobHelper.log(分片参数：当前分片序号 = , 总分片数 = , shardIndex, shardTotal); // 业务逻辑 for (int i = 0; i shardTotal; i++) if (i == shardIndex) XxlJobHelper.log(第 片, 命中分片开始处理, i); else XxlJobHelper.log(第 片, 忽略, i); 调度任务 启动两个执行器 执行任务点击 执行一次 分片任务，可以看到两条调度日志。 广播会触发对应执行器集群中所有机器执行一次任务，同时系统自动传递分片参数；","tags":["xxl-job、分布式调度"]},{"title":"Flask","path":"/2025/02/21/Flask基础/","content":"简介‌Flask‌ 是一个基于 Python 的轻量级 ‌Web 开发框架‌，以简洁、灵活著称。它不强制依赖特定工具或库，开发者可自由组合技术栈，适合构建小型到中型的 Web 应用或 API 服务。 安装虚拟环境使用虚拟环境可以在开发和生产环境下管理项目依赖。 虚拟环境解决了什么问题？你的 Python 项目越多，就越有可能需要使用不同版本的 Python 包，甚至 Python 本身。某个项目使用的新版本的库可能会破坏其他项目的兼容性。 虚拟环境是 Python 库的独立集合，每一个项目对应一个虚拟环境。安装到某个项目的包不会影响其他项目或是操作系统层级的包。 创建虚拟环境 mkdir myprojectcd myprojectpython3 -m venv .venv 激活虚拟环境 $ . .venv/bin/activate# deactivate 退出 你的 shell 提示符现在会显示激活的虚拟环境名称。 .venvlim@lim-PC:~/work/sty_workspace/sty_flask$ 安装在激活的虚拟环境中，安装 Flask： .venv/bin/pip3 install Flask 安装完成后，可以通过以下命令验证 Flask 是否安装成功： .venv/bin/pip3 show Flask 输出结果： Name: FlaskVersion: 3.1.0Summary: A simple framework for building complex web applications.Home-page:Author:Author-email:License:Location: persistenthomelimworksty_workspacesty_flask.venvlibpython3.12site-packagesRequires: blinker, click, itsdangerous, Jinja2, WerkzeugRequired-by: 第一个应用 homelimworksty_workspacesty_flaskapp.py from flask import Flaskapp = Flask(__name__)@app.route(/)def hello_world(): return pHello, World!/p 执行命令运行 Flask 应用： .venv/bin/flask --app app run 你会看到 Flask 开发服务器启动，并显示类似于以下内容： * Serving Flask app app * Debug mode: offWARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Running on http://127.0.0.1:5000Press CTRL+C to quit 打开浏览器，访问 http://127.0.0.1:5000/，应该会看到 “Hello, World!” 的消息，表示 Flask 已成功安装并运行。 代码解析： from flask import Flask： 这行代码从 flask 模块中导入了 Flask 类。Flask 类是 Flask 框架的核心，用于创建 Flask 应用程序实例。 **app = Flask(__name__)**： 这行代码创建了一个 Flask 应用实例。__name__ 是一个特殊的 Python 变量，它在模块被直接运行时是 __main__，在被其他模块导入时是模块的名字。传递 __name__ 给 Flask 构造函数允许 Flask 应用找到和加载配置文件。 **@app.route(‘‘)**： 这是一个装饰器，用于告诉 Flask 哪个 URL 应该触发下面的函数。在这个例子中，它指定了根 URL（即网站的主页）。 **def hello_world():**： 这是定义了一个名为 hello_world 的函数，它将被调用当用户访问根 URL 时。 **return ‘Hello, World!’**： 这行代码是 hello_world 函数的返回值。当用户访问根 URL 时，这个字符串将被发送回用户的浏览器。 调试模式： .venv/bin/flask --app app run --debug * Serving Flask app app * Debug mode: onWARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Running on http://127.0.0.1:5000Press CTRL+C to quit * Restarting with stat * Debugger is active! * Debugger PIN: 547-932-025 该命令的作用不仅仅是启动服务器。通过启用调试模式，服务器将在代码更改时自动重新加载，并在请求期间发生错误时在浏览器中显示交互式调试器。 Flask 基本概念了解 Flask 的基本概念对于开发高效的 Web 应用非常重要。 以下是 Flask 的主要基本概念的详细解析： 路由：路由是 URL 到 Python 函数的映射。Flask 允许你定义路由，这样当特定的 URL 被访问时，就会调用相应的函数。 视图函数：视图函数是处理请求并返回响应的 Python 函数。它们通常接收请求对象作为参数，并返回响应对象。 请求对象：请求对象包含了客户端发送的请求信息，如请求方法、URL、请求头、表单数据等。 响应对象：响应对象包含了发送给客户端的响应信息，如状态码、响应头、响应体等。 模板：Flask 使用 Jinja2 模板引擎来渲染 HTML 模板。模板允许你将 Python 代码嵌入到 HTML 中，从而动态生成网页。 应用工厂：应用工厂是一个 Python 函数，它创建并返回一个 Flask 应用实例。这允许你配置和初始化你的应用，并且可以创建多个应用实例。 配置对象：Flask 应用有一个配置对象，你可以使用它来设置各种配置选项，如数据库连接字符串、调试模式等。 蓝图：蓝图是 Flask 中的一个组织代码的方式，它允许你将相关的视图函数、模板和静态文件组织在一起，并且可以在多个应用中重用。 静态文件：静态文件是不会被服务器端执行的文件，如 CSS、JavaScript 和图片文件。Flask 提供了一个简单的方法来服务这些文件。 扩展：Flask 有许多扩展，可以添加额外的功能，如数据库集成、表单验证、用户认证等。 会话：Flask 使用客户端会话来存储用户信息，这允许你在用户浏览你的应用时记住他们的状态。 错误处理：Flask 允许你定义错误处理函数，当特定的错误发生时，这些函数会被调用。 项目结构一个 Flask 应用可以简单到只有一个文件。 比如以下 hello.py 文件就是一个 Flask 应用： from flask import Flaskapp = Flask(__name__)@app.route(/)def hello(): return Hello, World! 然而，当项目变大时，把所有代码都放到一个文件里不太现实。 Flask 项目结构可以根据应用的规模和复杂性有所不同。 以下是几种常见的 Flask 项目结构，分别适用于简单应用和较复杂的应用。 简单项目结构：适用于小型应用，所有代码集中在一个文件中。 中型项目结构：将应用分为多个模块，便于管理和扩展。 复杂项目结构：支持更高的模块化，适用于大型应用，包含路由、模型、模板和静态文件目录。 简单项目结构对于一个简单的 Flask 应用，项目结构可以非常简洁： my_flask_app/│├── app.py└── requirements.txt **app.py**：主要的 Flask 应用文件，包含路由和视图函数的定义。 **requirements.txt**：列出项目的依赖库，用于记录 Flask 和其他包的版本信息。 my_flask_app 目录下的 app.py 文件代码： from flask import Flaskapp = Flask(__name__)@app.route(/)def home(): return Hello, World!if __name__ == __main__: app.run(debug=True) requirements.txt 示例： Flask==2.2.3 中型项目结构对于稍复杂的应用，通常会将项目分为多个模块和目录： my_flask_app/│├── app/│ ├── __init__.py│ ├── routes.py│ └── models.py│├── config.py├── requirements.txt└── run.py app/：包含 Flask 应用的主要代码。 **__init__.py**：初始化 Flask 应用和配置扩展。 **routes.py**：定义应用的路由和视图函数。 **models.py**：定义应用的数据模型。 **config.py**：配置文件，包含应用的配置信息。 **requirements.txt**：列出项目的依赖库。 **run.py**：用于启动 Flask 应用。 app/__init__.py 示例： from flask import Flaskdef create_app(): app = Flask(__name__) app.config.from_object(config.Config) from . import routes app.register_blueprint(routes.bp) return app approutes.py 示例： from flask import Blueprintbp = Blueprint(main, __name__)@bp.route(/)def home(): return Hello, World! run.py 示例： from app import create_appapp = create_app()if __name__ == __main__: app.run(debug=True) 复杂项目结构对于较大的应用，可能需要更复杂的项目结构，以支持更高的模块化和扩展性： my_flask_app/│├── app/│ ├── __init__.py│ ├── routes/│ │ ├── __init__.py│ │ ├── main.py│ │ └── auth.py│ ├── models/│ │ ├── __init__.py│ │ └── user.py│ ├── templates/│ │ ├── layout.html│ │ └── home.html│ └── static/│ ├── css/│ └── js/│├── config.py├── requirements.txt├── migrations/│ └── ...└── run.py app/routes/：将不同功能模块的路由分开管理。 **main.py**：主模块的路由。 **auth.py**：认证相关的路由。 app/models/：管理数据模型，通常与数据库操作相关。 **user.py**：用户模型。 **app/templates/**：存放 HTML 模板文件。 **app/static/**：存放静态文件，如 CSS 和 JavaScript。 **migrations/**：数据库迁移文件，通常与 SQLAlchemy 相关。 approutesmain.py 示例： from flask import Blueprint, render_templatebp = Blueprint(main, __name__)@bp.route(/)def home(): return render_template(home.html) appmodelsuser.py 示例： from app import dbclass User(db.Model): id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(150), unique=True, nullable=False) 路由Flask 路由是 Web 应用程序中将 URL 映射到 Python 函数的机制。 Flask 路由是 Flask 应用的核心部分，用于处理不同 URL 的请求，并将请求的处理委托给相应的视图函数。 以下是关于 Flask 路由的详细说明，包括路由的定义、参数、方法和规则等。 定义路由：使用 @app.route(/path) 装饰器定义 URL 和视图函数的映射。 路由参数：通过动态部分在 URL 中传递参数。 路由规则：使用类型转换器指定 URL 参数的类型。 请求方法：指定允许的 HTTP 请求方法。 路由函数返回：视图函数可以返回不同类型的响应。 静态文件和模板：管理静态文件和动态渲染 HTML 模板。 路由优先级：确保路由顺序正确，以避免意外的匹配结果。 定义路由基本路由定义： from flask import Flaskapp = Flask(__name__)@app.route(/)def home(): return Welcome to the Home Page! @app.route(/)：装饰器，用于定义路由。/ 表示根 URL。 def home()：视图函数，当访问根 URL 时，返回 Welcome to the Home Page!。 使用 flask.Flask.add_url_rule() 注册路由： app = Flask()app.add_url_rule(/ping, view_func=AppHandler.ping) rule ( str ) – URL 规则字符串。 endpoint （[str]) | None）– 与规则和视图函数关联的端点名称。在路由和构建 URL 时使用。默认为 view_func.__name__ view_func（ft.RouteCallable | None）– 与端点名称关联的视图函数。 provide_automatic_options( bool|None ) – 添加 OPTIONS 方法并自动响应 OPTIONS 请求。 options（t.Any） – 传递给 Rule 对象的额外选项。 路由参数路由可以包含动态部分，通过在路由中指定参数，可以将 URL 中的部分数据传递给视图函数。 @app.route(/greet/name)def greet(name): return fHello, name! 路由规则路由规则支持不同类型的参数和匹配规则。 类型规则： 字符串（默认）： 匹配任意字符串。 整数（int:name）： 匹配整数值。 浮点数（float:value）： 匹配浮点数值。 路径（path:name）： 匹配任意字符，包括斜杠 /。 @app.route(/user/int:user_id)def user_profile(user_id): return fUser ID: user_id@app.route(/files/path:filename)def serve_file(filename): return fServing file: filename @app.route(/user/int:user_id)：匹配整数类型的 user_id。 @app.route(/files/path:filename)：匹配包含斜杠的路径 filename。 如果直接使用 @app.route(/user/user_id) 接收入参，浏览器输入 http://127.0.0.1:5000/user/1。user_id 会被转成字符串。 请求方法Flask 路由支持不同的 HTTP 请求方法，如 GET、POST、PUT、DELETE 等。可以通过 methods 参数指定允许的请求方法。 @app.route(/submit, methods=[POST])def submit(): return Form submitted! 路由转换器Flask 提供了一些内置的转换器，可以对 URL 中的参数进行特定类型的转换。 常用转换器： int： 匹配整数。 float： 匹配浮点数。 path： 匹配任意路径，包括斜杠。 @app.route(/items/int:item_id/details)def item_details(item_id): return fItem details for item ID: item_id int:item_id：将 URL 中的 item_id 转换为整数。 路由函数返回视图函数可以返回多种类型的响应： 字符串：返回纯文本响应。 HTML：返回 HTML 页面。 JSON：返回 JSON 数据。 Response 对象：自定义响应。 from flask import jsonify, Response@app.route(/json)def json_response(): data = key: value return jsonify(data)@app.route(/custom)def custom_response(): response = Response(Custom response with headers, status=200) response.headers[X-Custom-Header] = Value return response 静态文件和模板静态文件（如 CSS、JavaScript、图片）可以通过 static 路由访问。模板文件则通过 templates 文件夹组织，用于渲染 HTML 页面。 静态 CSS 文件访问： link rel=stylesheet href= url_for(static, filename=style.css) 图片渲染： img src= url_for(static, filename=img/test.jpg) alt=示例图片 模板文件渲染： !DOCTYPE htmlhtmlhead titleHello/title/headbody h1Hello/h1 link rel=stylesheet href= url_for(static, filename=style.css) img src= url_for(static, filename=img/test.jpg) alt=示例图片/body/html from flask import render_template@app.route(/hello/name)def hello(name): return render_template(hello.html, name=name) 注意： 模板文件要放到 templates 文件夹中，文件夹名称必须为 templates 静态文件夹必须命名为 static 路由优先级Flask 按照定义的顺序匹配路由，第一个匹配成功的路由将被处理。确保更具体的路由放在更一般的路由之前。 @app.route(/user/int:user_id)def user_profile(user_id): return fUser ID: user_id@app.route(/user)def user_list(): return User List /user/123 将匹配到 /user/int:user_id，而 /user 将匹配到 user_list。 视图函数视图函数是 Flask 应用中的核心部分，它负责处理请求并生成响应。 视图函数与路由紧密结合，通过路由将 URL 映射到具体的视图函数。 以下是对 Flask 视图函数的详细说明，包括如何定义、使用请求数据、返回响应、以及如何处理错误等。 定义视图函数：视图函数是处理请求并返回响应的核心功能。 接收请求数据：使用 request 对象获取 URL 参数、表单数据、查询参数等。 返回响应：可以返回字符串、HTML、JSON 或自定义响应对象。 处理请求和响应：使用 request 对象和 make_response 来处理请求和生成自定义响应。 处理错误：视图函数内处理异常或使用 Flask 的错误处理机制。 视图函数的装饰器：使用 @app.before_request、@app.after_request 等装饰器处理请求前后逻辑。 视图函数返回的状态码：可以指定 HTTP 状态码来表示请求的处理结果。 定义视图函数视图函数是一个普通的 Python 函数，它接收请求并返回响应。视图函数通常与路由配合使用，通过装饰器将 URL 映射到视图函数。 from flask import Flaskapp = Flask(__name__)@app.route(/)def home(): return Hello, World! @app.route(/)：将根 URL / 映射到 home 视图函数。 def home()：视图函数，返回字符串 Hello, World! 作为响应。 接收请求数据视图函数可以接收不同类型的请求数据，包括 URL 参数、表单数据、查询参数等。 获取 URL 参数@app.route(/greet/name)def greet(name): return fHello, name! name 是一个 URL 参数，传递到视图函数 greet。 获取表单数据 sty_flasktemplatesindex.HTML !DOCTYPE htmlhtmlhead titleHello/title/headbody form action=/submit method=POST input type=text name=username placeholder=Name/input input type=submit value=Submit/input /form/body/html sty_flaskapp.py from flask import render_template, Flask, requestapp = Flask(__name__)@app.route(/)def index(): return render_template(index.html)@app.route(/submit, methods=[POST])def submit(): username = request.form.get(username, Guest) return fForm submitted by username request.form.get(‘username’)： 获取 POST 请求中表单数据的 username 字段。 获取查询参数!DOCTYPE htmlhtmlhead titleHello/title/headbody form action=/search method=GET input type=text name=query placeholder=Name/input input type=submit value=Query/input /form/body/html @app.route(/search)def search(): query = request.args.get(query) return fSearch results for: query request.args.get(‘query’)： 获取 GET 请求中的查询参数 query。 返回响应视图函数可以返回多种类型的响应，包括字符串、HTML、JSON、或自定义响应对象。 返回字符串： @app.route(/message)def message(): return This is a simple message. 返回 HTML 模板： from flask import render_template@app.route(/hello/name)def hello(name): return render_template(hello.html, name=name) render_template(hello.html, name=name)：渲染 HTML 模板 hello.HTML，并将 name 变量传递给模板。 返回 JSON 数据： from flask import jsonify@app.route(/api/data)def api_data(): data = key: value return jsonify(data) jsonify(data)：将 Python 字典转换为 JSON 响应。 返回自定义响应对象： from flask import Response@app.route(/custom)def custom_response(): response = Response(Custom response with headers, status=200) response.headers[X-Custom-Header] = Value return response Response(Custom response with headers, status=200)：创建自定义响应对象，并设置响应头。 处理请求和响应视图函数可以访问请求对象，并根据请求数据生成响应。可以使用 request 对象来获取请求的信息，使用 make_response 来创建自定义响应。 使用 request 对象： from flask import request@app.route(/info)def info(): user_agent = request.headers.get(User-Agent) return fYour user agent is user_agent 使用 make_response： from flask import make_response@app.route(/header)def custom_header(): response = make_response(Response with custom header) response.headers[X-Custom-Header] = Value return response make_response(Response with custom header)：创建响应对象并设置自定义头信息。 处理错误可以在视图函数中处理异常或错误，或者通过 Flask 提供的错误处理机制来处理应用中的错误。 在视图函数中处理错误： @app.route(/divide/int:x/int:y)def divide(x, y): try: result = x / y return fResult: result except ZeroDivisionError: return Error: Division by zero, 400 使用 try-except 语句处理除零错误，并返回自定义错误消息和状态码。 全局错误处理： @app.errorhandler(404)def not_found(error): return Page not found, 404 @app.errorhandler(404)：定义处理 404 错误的函数。 视图函数的装饰器除了 @app.route，Flask 还支持其他装饰器，用于实现更复杂的功能。 示例： **@app.before_request**：在每个请求处理之前运行的函数。 **@app.after_request**：在每个请求处理之后运行的函数。 **@app.teardown_request**：在请求结束后运行的函数，用于清理工作。 示例装饰器使用： @app.before_requestdef before_request(): print(Before request)@app.after_requestdef after_request(response): print(After request) return response@app.teardown_requestdef teardown_request(exception): print(Teardown request) 状态码视图函数不仅可以返回内容，还可以指定 HTTP 状态码。 @app.route(/status)def status(): return Everything is OK, 200 返回状态码 200 表示请求成功。 返回带有状态码的响应对象： from flask import Response@app.route(/error)def error(): return Response(An error occurred, status=500) 返回状态码 500 表示服务器内部错误。 表单处理在 Flask 中，表单处理是构建 Web 应用时一个常见的需求。 处理表单数据涉及到接收、验证和处理用户提交的表单。Flask 提供了基本的表单处理功能，但通常结合 Flask-WTF 扩展来简化表单操作和验证。 基本表单处理：使用 request.form 获取表单数据。 使用 Flask-WTF：结合 WTForms 进行表单处理和验证，简化表单操作。 表单验证：使用验证器确保表单数据的有效性。 文件上传：处理文件上传和保存文件。 CSRF 保护：确保表单免受跨站请求伪造攻击。 基本表单处理Flask 提供了直接处理表单数据的方式，使用 request 对象来获取提交的数据。 创建 HTML 表单 templatesform.HTML !DOCTYPE htmlhtmlhead titleForm Example/title/headbody form action=/submit method=post label for=nameName:/label input type=text id=name name=name br label for=emailEmail:/label input type=email id=email name=email br input type=submit value=Submit /form/body/html action=/submit：表单数据提交到 submit 路径。 method=post：使用 POST 方法提交数据。 处理表单数据 app.py from flask import Flask, render_template, requestapp = Flask(__name__)@app.route(/)def form(): return render_template(form.html)@app.route(/submit, methods=[POST])def submit(): name = request.form.get(name) email = request.form.get(email) return fName: name, Email: emailif __name__ == __main__: app.run(debug=True) request.form.get(name) 和 request.form.get(email)：获取提交的表单数据。 使用 Flask-WTF 扩展Flask-WTF 是一个封装了 WTForms 的扩展，提供了表单处理和验证的功能，使得表单处理更加简洁和强大。 安装 Flask-WTF pip install flask-wtf# wtforms3.0 后需要额外安装email-validator包pip install email-validator app.py from flask import Flask, render_template, redirect, url_forfrom flask_wtf import FlaskFormfrom wtforms import StringField, EmailField, SubmitFieldfrom wtforms.validators import DataRequired, Emailapp = Flask(__name__)app.secret_key = your_secret_key # Required for form protectionclass MyForm(FlaskForm): name = StringField(Name, validators=[DataRequired()]) email = EmailField(Email, validators=[DataRequired(), Email()]) submit = SubmitField(Submit)@app.route(/, methods=[GET, POST])def form(): form = MyForm() if form.validate_on_submit(): name = form.name.data email = form.email.data return fName: name, Email: email return render_template(form.html, form=form)if __name__ == __main__: app.run(debug=True) templatesform.HTML !DOCTYPE htmlhtmlhead titleForm Example/title/headbody form method=post form.hidden_tag() div form.name.label br form.name(size=32) /div div form.email.label br form.email(size=32) /div div form.submit() /div /form/body/html form.hidden_tag() ：生成隐藏字段，用于保护表单免受 CSRF 攻击。 form.name.label 和 form.name(size = 32) ：渲染表单字段及其标签。 表单验证Flask-WTF 和 WTForms 提供了丰富的表单验证功能。你可以使用内置的验证器或自定义验证器来确保表单数据的有效性。 from wtforms import Form, StringField, EmailField, SubmitFieldfrom wtforms.validators import DataRequired, Email, Lengthclass MyForm(FlaskForm): name = StringField(Name, validators=[ DataRequired(), Length(min=1, max=50) ]) email = EmailField(Email, validators=[ DataRequired(), Email() ]) submit = SubmitField(Submit) DataRequired()：确保字段不为空。 Length(min=1, max=50)：限制字符串的最小和最大长度。 Email()：验证字段是否为有效的电子邮件地址。 文件上传Flask 还支持处理文件上传。上传的文件可以通过 request.files 访问。 创建文件上传表单 emplatesupload.HTML !DOCTYPE htmlhtmlhead titleUpload File/title/headbody form action=/upload method=post enctype=multipart/form-data label for=fileFile:/label input type=file id=file name=file br input type=submit value=Upload /form/body/html enctype=multipart/form-data：指定表单数据的编码类型，支持文件上传。 处理文件上传 app.py from flask import Flask, request, redirect, url_forapp = Flask(__name__)app.secret_key = your_secret_key@app.route(/upload, methods=[POST])def upload(): file = request.files.get(file) if file: filename = file.filename file.save(fuploads/filename) return fFile uploaded successfully: filename return No file uploadedif __name__ == __main__: app.run(debug=True) request.files.get(file)：获取上传的文件对象。 file.save(fuploads/filename)：将文件保存到指定目录。 CSRF 保护Flask-WTF 自动为表单提供 CSRF 保护。你需要配置一个密钥来启用 CSRF 保护，并在模板中包含隐藏的 CSRF 令牌。 配置 CSRF 保护： app.secret_key = your_secret_key 在模板中添加 CSRF 令牌： form method=post form.hidden_tag() !-- Form fields here --/form 蓝图 (Blueprints)Flask 的蓝图（Blueprints）是一种组织代码的机制，允许你将 Flask 应用分解成多个模块。这样可以更好地组织应用逻辑，使得应用更具可维护性和可扩展性。 每个蓝图可以有自己的路由、视图函数、模板和静态文件，这样可以将相关的功能分组。 通过使用蓝图，你可以将 Flask 应用拆分成多个模块，每个模块处理相关的功能，使得代码更加清晰和易于管理。 创建蓝图：在独立的模块中定义蓝图，并指定路由和视图函数。 注册蓝图：在主应用中注册蓝图，并设置路由前缀。 使用蓝图中的模板和静态文件：将模板和静态文件放在蓝图的 templates 和 static 文件夹中。 使用请求钩子和错误处理：在蓝图中定义请求钩子和错误处理函数。 创建蓝图创建蓝图涉及到以下几个步骤： 定义蓝图： 在一个独立的模块（文件）中定义蓝图。 注册蓝图： 在主应用中注册蓝图，使其生效。 假设我们要创建一个博客应用，其中包含用户管理和博客功能，我们可以将这些功能分成两个蓝图：auth 和 blog。 项目结构： yourapp/│├── app.py├── auth/│ ├── __init__.py│ └── routes.py│└── blog/ ├── __init__.py └── routes.py 定义蓝图 authroutes.py from flask import Blueprint, render_template, request, redirect, url_forauth = Blueprint(auth, __name__)@auth.route(/login)def login(): return render_template(login.html)@auth.route(/logout)def logout(): return redirect(url_for(auth.login))@auth.route(/register)def register(): return render_template(register.html) Blueprint(‘auth’, name **)**：创建一个名为 auth 的蓝图。 蓝图中定义的路由函数可以用来处理请求。 blogroutes.py from flask import Blueprint, render_templateblog = Blueprint(blog, __name__)@blog.route(/)def index(): return render_template(index.html)@blog.route(/post/int:post_id)def post(post_id): return fPost ID: post_id Blueprint(‘blog’, name **)**：创建一个名为 blog 的蓝图。 注册蓝图 app.py from flask import Flaskapp = Flask(__name__)# 导入蓝图from auth.routes import authfrom blog.routes import blog# 注册蓝图app.register_blueprint(auth, url_prefix=/auth)app.register_blueprint(blog, url_prefix=/blog)if __name__ == __main__: app.run(debug=True) app.register_blueprint(auth, url_prefix=/auth)：注册 auth 蓝图，并将所有的路由前缀设置为 /auth。 app.register_blueprint(blog, url_prefix=/blog)：注册 blog 蓝图，并将所有的路由前缀设置为 /blog。 使用蓝图中的模板和静态文件蓝图中的模板和静态文件应放在蓝图的文件夹下的 templates 和 static 子文件夹中。 项目结构： yourapp/│├── app.py├── auth/│ ├── __init__.py│ ├── routes.py│ └── templates/│ ├── login.html│ └── register.html│└── blog/ ├── __init__.py ├── routes.py └── templates/ ├── index.html └── post.html 在蓝图中使用请求钩子蓝图支持请求钩子，例如 before_request 和 after_request，可以在蓝图中定义这些钩子来处理请求和响应。 authroutes.py @auth.before_app_requestdef before_request(): # 执行在每个请求之前的操作 pass@auth.after_app_requestdef after_request(response): # 执行在每个请求之后的操作 return response 在蓝图中定义错误处理蓝图也可以定义自己的错误处理函数。 blogroutes.py @blog.errorhandler(404)def page_not_found(error): return Page not found, 404 错误处理Flask 提供了灵活的错误处理机制，可以捕获并处理应用中的各种错误。 以下是详细的说明，涵盖了如何定义和处理错误，如何处理 HTTP 状态码以及如何处理自定义错误。 处理 HTTP 错误：使用 @app.errorhandler 装饰器定义针对特定 HTTP 状态码的错误处理函数。 蓝图中的错误处理：在蓝图中定义错误处理函数，允许模块化的错误处理。 自定义错误：定义自定义异常类，并在应用中捕获和处理这些异常。 全局错误处理：使用全局错误处理函数捕获所有未处理的异常。 使用 abort 函数：在视图函数中主动触发 HTTP 错误。 渲染自定义错误页面：为每个错误码创建自定义的 HTML 错误页面。 处理 HTTP 错误Flask 允许你定义针对特定 HTTP 状态码的错误处理函数。这些处理函数可以用于捕获并处理应用中的常见错误，如 404 页面未找到错误、500 服务器内部错误等。 app.py from flask import Flask, render_templateapp = Flask(__name__)@app.route(/)def index(): return Welcome to the homepage!@app.errorhandler(404)def page_not_found(error): return render_template(404.html), 404@app.errorhandler(500)def internal_server_error(error): return render_template(500.html), 500if __name__ == __main__: app.run(debug=True) **@app.errorhandler(404)**：捕获 404 错误，并返回自定义的 404 错误页面。 **@app.errorhandler(500)**：捕获 500 错误，并返回自定义的 500 错误页面。 使用蓝图中的错误处理蓝图（Blueprints）也可以定义自己的错误处理函数。这使得每个模块可以有自己的错误处理逻辑。 authroutes.py from flask import Blueprint, render_templateauth = Blueprint(auth, __name__)@auth.errorhandler(404)def auth_not_found(error): return render_template(auth_404.html), 404 app.py from flask import Flaskfrom auth.routes import authapp = Flask(__name__)app.register_blueprint(auth, url_prefix=/auth)if __name__ == __main__: app.run(debug=True) 处理自定义错误你可以定义自定义异常类，并在应用中捕获和处理这些异常。这允许你在应用中实现更复杂的错误处理逻辑。 自定义异常类： class CustomError(Exception): pass 抛出自定义异常： @app.route(/raise_custom_error)def raise_custom_error(): raise CustomError(This is a custom error.) 处理自定义异常： @app.errorhandler(CustomError)def handle_custom_error(error): return str(error), 400 全局错误处理如果你希望在整个应用中处理所有未处理的异常，可以使用全局错误处理函数。这些处理函数可以捕获所有未被显式捕获的错误。 app.py @app.errorhandler(Exception)def handle_exception(error): # 处理所有异常 return fAn error occurred: error, 500 使用 abort 函数Flask 提供了一个 abort 函数，用于在视图函数中主动触发 HTTP 错误。这可以用于在特定条件下返回错误响应。 from flask import abort@app.route(/abort_example)def abort_example(): abort(403) # 返回 403 Forbidden 错误 **abort(403)**：触发 403 错误，自动调用对应的错误处理函数。 渲染自定义错误页面可以为每个错误码创建自定义的 HTML 页面，使得错误页面与应用的整体设计一致。 项目结构示例： yourapp/│├── app.py├── templates/│ ├── 404.html│ ├── 500.html│ └── auth_404.html 自定义错误页面示例： templates404.HTML !doctype htmlhtml lang=enhead meta charset=utf-8 titlePage Not Found/title/headbody h1404 - Page Not Found/h1 pSorry, the page you are looking for does not exist./p/body/html Flask 中间件和扩展在 Flask 中，中间件和扩展是增强和扩展应用功能的两个关键机制。 通过中间件和扩展，你可以大大增强 Flask 应用的功能和灵活性，使得应用能够满足各种复杂的需求。 下面详细介绍这两者的概念和如何使用它们。 Flask 中间件： 使用请求钩子在请求处理的不同阶段插入代码。 创建自定义中间件类来处理请求和响应。 Flask 扩展： 使用现有的扩展（如 Flask-SQLAlchemy、Flask-WTF）来添加功能。 创建自定义扩展来满足特定需求。 中间件Flask 的中间件（middleware）是对请求和响应进行处理的钩子，通常用于在请求到达视图函数之前或在响应发送到客户端之前执行一些操作。中间件可以用于日志记录、请求修改、响应修改等。 请求钩子请求钩子允许你在处理请求的不同阶段插入代码，Flask 提供了几种钩子来处理请求生命周期的不同阶段： **before_request**：在每个请求处理之前执行。 **after_request**：在每个请求处理之后执行。 **teardown_request**：请求处理结束后，无论是否发生异常都会执行。 **before_first_request**：仅在应用第一次处理请求之前执行。 app.py from flask import Flask, requestapp = Flask(__name__)@app.before_requestdef before_request(): print(Before request)@app.after_requestdef after_request(response): print(After request) return response@app.teardown_requestdef teardown_request(exception): print(Teardown request)@app.route(/)def index(): return Hello, World!if __name__ == __main__: app.run(debug=True) @app.before_request：在每个请求处理之前打印 “Before request”。 @app.after_request：在每个请求处理之后打印 “After request”。 @app.teardown_request：在每个请求处理后（无论是否发生异常）打印 “Teardown request”。 自定义中间件Flask 还允许你创建自定义中间件类，这些中间件类可以在请求和响应处理的各个阶段进行操作。 middleware.py class CustomMiddleware: def __init__(self, app): self.app = app def __call__(self, environ, start_response): def custom_start_response(status, headers): headers.append((X-Custom-Header, Value)) return start_response(status, headers) return self.app(environ, custom_start_response) app.py from flask import Flaskfrom middleware import CustomMiddlewareapp = Flask(__name__)app.wsgi_app = CustomMiddleware(app.wsgi_app)@app.route(/)def index(): return Hello, World!if __name__ == __main__: app.run(debug=True) CustomMiddleware：自定义中间件类，添加一个自定义响应头。 扩展Flask 扩展是用于为 Flask 应用添加功能的插件。Flask 的扩展可以集成第三方库，提供例如数据库集成、表单处理、用户认证等功能。 常见的 Flask 扩展 Flask-SQLAlchemy：集成 SQLAlchemy ORM，使数据库操作更方便。 Flask-WTF：集成 WTForms 表单库，简化表单处理。 Flask-Login：提供用户会话管理和用户认证功能。 Flask-Migrate：用于数据库迁移的扩展，基于 Alembic。 Flask-Mail：用于发送电子邮件。 安装和使用 Flask 扩展以 Flask-SQLAlchemy 为例，安装： pip install flask-sqlalchemy 配置和使用，app.py 文件代码： from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyapp = Flask(__name__)app.config[SQLALCHEMY_DATABASE_URI] = sqlite:///example.dbdb = SQLAlchemy(app)class User(db.Model): id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(80), unique=True, nullable=False)@app.route(/)def index(): return Hello, World!if __name__ == __main__: app.run(debug=True) SQLAlchemy 扩展集成了 SQLAlchemy，使得你可以轻松地定义模型并与数据库交互。 创建自定义扩展如果现有的扩展不能满足你的需求，你可以创建自己的扩展。创建自定义扩展通常涉及到定义一个类，提供初始化配置和相关功能。 myextension.py class MyExtension: def __init__(self, app=None): if app is not None: self.init_app(app) def init_app(self, app): app.config.setdefault(MY_EXTENSION_CONFIG, default_value) app.after_request(self.after_request) def after_request(self, response): response.headers[X-My-Extension] = MyValue return response app.py from flask import Flaskfrom myextension import MyExtensionapp = Flask(__name__)my_ext = MyExtension(app)@app.route(/)def index(): return Hello, World!if __name__ == __main__: app.run(debug=True) MyExtension：自定义扩展，添加了一个自定义响应头。","tags":["python、flask"],"categories":["python"]},{"title":"circle-shop","path":"/2024/12/13/circle-shop/","content":"项目概述项目简介主界面主要功能项目特点需求分析功能需求用户注册用户登录验证码图形验证码短信验证码上传用户头像非功能需求用户角色系统架构设计技术选型本地存储与 OSS 维度 本地存储 OSS（对象存储服务） 成本 初期投资大，硬件购买和运维成本高。 按需付费，按存储量和流量计费，初期无大额投资。 可扩展性 扩展有限，增加存储空间和带宽需要硬件投入。 弹性扩展，按需扩展，无需手动干预。 可靠性 容错能力有限，需要自行处理冗余和备份。 高可用性，数据冗余自动处理，支持多数据中心。 安全性 需要自行管理访问控制、加密和备份等。 提供强大的加密、访问控制、身份验证和审计日志。 维护与运维 需要投入人力进行硬件和软件的维护、修复。 由云厂商负责硬件和软件的维护，自动修复故障。 数据访问 局域网访问较快，跨地域访问较慢。 全球分布，低延迟，适合跨地域、大规模访问。 灵活性 配置和扩展复杂，灵活性较低。 高灵活性，支持不同类型的数据存储和生命周期管理。 合规性 需要自行管理合规要求和审计。 云厂商提供合规支持，如 GDPR、ISO 等。 使用复杂度 配置和管理复杂，需要专业技术人员。 使用简单，通过 Web 控制台或 API 进行管理。 灾难恢复 需要自行设计备份和恢复方案。 自动化备份和恢复，支持异地灾难恢复。 总结： 本地存储 适合对数据控制、性能有高度要求的场景，但成本、运维、扩展等方面存在一定的挑战。 OSS 提供了更高的弹性、可扩展性和便捷性，适合存储量大、需要全球访问或云计算集成的应用，成本相对较低，运维压力小。 根据对比存储推荐使用阿里云 OSS。 系统架构图模块划分数据库设计ER 图表结构设计接口文档接口规范接口列表项目部署项目环境部署文档开发进度项目创建初始化 创建 Maven 聚合工程 circle-shoppom.xml ?xml version=1.0 encoding=UTF-8?project xmlns=http://maven.apache.org/POM/4.0.0 xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation=http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion4.0.0/modelVersion groupIdgithub.lianyutian.cshop/groupId artifactIdcircle-shop/artifactId version1.0-SNAPSHOT/version packagingpom/packaging modules modulecshop-common/module modulecshop-user/module /modules properties java.version17/java.version maven.compiler.source17/maven.compiler.source maven.compiler.target17/maven.compiler.target project.build.sourceEncodingUTF-8/project.build.sourceEncoding !-- 版本匹配说明 -- !-- https://sca.aliyun.com/docs/2023/overview/version-explain/?spm=5176.29160081.0.0.74805c72WoVfdt -- !-- 指定 SpringBoot 版本 -- spring.boot.version3.2.4/spring.boot.version !-- 指定 SpringCloud 版本 -- spring.cloud.version2023.0.1/spring.cloud.version !-- 指定 SpringCloudAlibaba 版本 -- alibaba.cloud.version2023.0.1.0/alibaba.cloud.version !-- 指定 lombok 版本 -- lombok.version1.18.26/lombok.version !-- 通用工具包版本 -- commons-lang3.version3.14.0/commons-lang3.version !-- gson 版本 -- gson.version2.10.1/gson.version /properties dependencyManagement dependencies dependency groupIdorg.springframework.boot/groupId artifactIdspring-boot-dependencies/artifactId version$spring.boot.version/version typepom/type scopeimport/scope /dependency dependency groupIdorg.springframework.cloud/groupId artifactIdspring-cloud-dependencies/artifactId version$spring.cloud.version/version typepom/type scopeimport/scope /dependency dependency groupIdcom.alibaba.cloud/groupId artifactIdspring-cloud-alibaba-dependencies/artifactId version$alibaba.cloud.version/version typepom/type scopeimport/scope /dependency dependency groupIdorg.projectlombok/groupId artifactIdlombok/artifactId version$lombok.version/version /dependency dependency groupIdorg.apache.commons/groupId artifactIdcommons-lang3/artifactId version$commons-lang3.version/version /dependency dependency groupIdcom.google.code.gson/groupId artifactIdgson/artifactId version$gson.version/version /dependency /dependencies /dependencyManagement !-- 加快代码库下载， 这里使用阿里云镜像仓库-- repositories repository idmaven-ali/id urlhttp://maven.aliyun.com/nexus/content/groups/public///url releases enabledtrue/enabled /releases snapshots enabledtrue/enabled updatePolicyalways/updatePolicy checksumPolicyfail/checksumPolicy /snapshots /repository /repositories pluginRepositories pluginRepository idpublic/id namealiyun nexus/name urlhttp://maven.aliyun.com/nexus/content/groups/public//url releases enabledtrue/enabled /releases snapshots enabledfalse/enabled /snapshots /pluginRepository /pluginRepositories !-- springboot 打包 docker 镜像使用 -- build plugins plugin groupIdorg.springframework.boot/groupId artifactIdspring-boot-maven-plugin/artifactId version$spring.boot.version/version configuration addResourcestrue/addResources /configuration /plugin /plugins /build/project 创建子模块通用工程 cshop-commoncshop-commonpom.xml ?xml version=1.0 encoding=UTF-8?project xmlns=http://maven.apache.org/POM/4.0.0 xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation=http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion4.0.0/modelVersion parent groupIdgithub.lianyutian.cshop/groupId artifactIdcircle-shop/artifactId version1.0-SNAPSHOT/version /parent groupIdgithub.lianyutian.cshop.common/groupId artifactIdcshop-common/artifactId properties maven.compiler.source17/maven.compiler.source maven.compiler.target17/maven.compiler.target project.build.sourceEncodingUTF-8/project.build.sourceEncoding /properties dependencies dependency groupIdorg.projectlombok/groupId artifactIdlombok/artifactId /dependency dependency groupIdorg.springframework.boot/groupId artifactIdspring-boot-starter-web/artifactId /dependency dependency groupIdorg.apache.commons/groupId artifactIdcommons-lang3/artifactId /dependency dependency groupIdcom.google.code.gson/groupId artifactIdgson/artifactId /dependency /dependencies/project 统一工具类业务状态码枚举 cshop-commonsrcmainJavagithublianyutiancshopcommonenumsBizCodeEnum.Java package github.lianyutian.cshop.common.enums;import lombok.Getter;/** * 统一业务枚举状态码 * * @author lianyutian * @since 2024-12-13 13:27:13 * @version 1.0 * p 整个状态码总共 7 位，前 3 位表示「业务微服务」状态码，后 4 位表示「服务内部接口」状态码，后续需要再进行拆分。 * 公共操作：110。 * 用户服务：210， */@Getterpublic enum BizCodeEnum /** 通用操作码 */ COMMON_OP_REPEAT(110001, 重复操作), COMMON_PARAM_ERROR(110002, 参数错误), COMMON_SERVER_ERROR(110003, 服务异常), COMMON_TOO_MANY_TRY(110004, 当前访问人数过多，请稍候再试...), /** 用户微服务验证码相关 2101 开头 */ USER_PHONE_ERROR(2101001, 手机号不合法), USER_CODE_FAST_LIMITED(2101002, 验证码已发送，请稍后再发), USER_CODE_PHONE_ERROR(2101003, 手机验证码错误), USER_CODE_CAPTCHA_ERROR(2101004, 图形验证码错误), USER_CODE_EMAIL_ERROR(2101005, 邮箱验证码错误), USER_CODE_SMS_ERROR(2101006, 短信验证码错误), USER_CODE_SMS_SEND_ERROR(2101006, 短信发送失败请稍后重试), USER_CODE_SMS_SEND_REPLICATE_ERROR(2101007, 短信验证码已发送请稍后重试), USER_CODE_SEND_ERROR(2101008, 验证码发送失败，请稍后重试), /** 用户微服务账号相关 2102 开头 */ USER_ACCOUNT_EXIST(2102001, 用户已存在), USER_ACCOUNT_UNREGISTER(2102002, 用户不存在), USER_ACCOUNT_PWD_ERROR(2102003, 用户账号或密码错误), USER_REFRESH_TOKEN_EMPTY(2102004, 请重新登录), USER_ACCOUNT_UNLOGIN(2102005, 用户账号未登录), USER_LOGIN_SUCCESS(0, 用户登录成功), USER_UPDATE_LOCK_FAIL(2102006, 修改用户信息获取锁失败), USER_INFO_SHOW_LOCK_FAIL(2102007, 读取用户信息获取锁失败), /** 用户微服务上传相关 2103 开头 */ USER_AVATAR_FILE_UPLOAD_ERROR(2103001, 用户头像上传失败), /** 用户微服务收货地址相关 2104 开头 */ USER_ADDRESS_NOT_EXITS(2104001, 收货地址不存在), USER_ADDRESS_ADD_FAIL(2104002, 新增收货地址失败), USER_ADDRESS_DEL_FAIL(2104003, 删除收货地址失败), /** 用户关注、取消 2105 开头 博主关注、取消 */ USER_FOLLOWER_NOT_SELF(2105001, 不能关注自己哦), USER_UN_FOLLOWER_NOT_SELF(2105002, 不能取关自己哦), USER_FOLLOWED(2105003, 已经关注过了哦), USER_UN_FOLLOWED(2105004, 已经取关过了哦), USER_ATTENTION_NOT_SELF(2105005, 博主不能关注自己哦), USER_UN_ATTENTION_NOT_SELF(2105006, 博主不能取关自己哦), USER_ATTENTED(2105007, 已经关注过了哦), USER_UN_ATTENTED(2105008, 已经取关过了哦), USER_FOLLOWER_SUCCESS(0, 关注成功), USER_UN_FOLLOWER_SUCCESS(0, 取关成功), USER_ATTENTION_SUCCESS(0, 关注成功), USER_UN_ATTENTION_SUCCESS(0, 取关成功), USER_FOLLOWER_INFO_LOCK_FAIL(2105009, 查询用户是否关注锁失败), /** 用户笔记相关 2106 开头 */ NOTE_NOT_EXITS(2106001, 笔记不存在), NOTE_ADD_FAIL(2104002, 新增笔记失败), NOTE_DEL_FAIL(2104003, 删除笔记失败), NOTE_UPDATE_FAIL(2102004, 笔记更新失败), NOTE_UPDATE_LOCK_FAIL(2104006, 修改笔记信息获取锁失败), NOTE_INFO_LOCK_FAIL(2102007, 读取笔记信息获取锁失败); /** 错误信息 */ private final String message; /** 状态码 */ private final int code; /** * 编码 * * @param code 状态码 * @param message 错误信息 */ BizCodeEnum(int code, String message) this.code = code; this.message = message; 统一接口响应 cshop-commonsrcmainJavagithublianyutiancshopcommonmodelApiResult.Java package github.lianyutian.cshop.common.model;import github.lianyutian.cshop.common.enums.BizCodeEnum;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;/** * 接口统一响应封装 * * @author lianyutian * @since 2024-12-13 13:40:47 * @version 1.0 */@Data@AllArgsConstructor@NoArgsConstructorpublic class ApiResultT /** 接口响应状态码 0 表示成功 其他表示失败 */ private Integer code; /** 数据 */ private T data; /** 描述 */ private String msg; /** * 成功响应 * * @return @see ApiResult */ public static T ApiResultT success() return new ApiResult(0, null, null); /** * 成功响应，传入数据 * * @param data 接口数据 * @return @see ApiResult */ public static T ApiResultT success(T data) return new ApiResult(0, data, null); /** * 失败响应 * * @param code 状态码 * @return @see ApiResult */ public static T ApiResultT error(Integer code, String msg) return new ApiResult(code, null, msg); /** * 自定义状态码和错误信息 * * @param code 状态码 * @param msg 错误信息 * @return @see ApiResult */ public static T ApiResultT buildResult(int code, String msg) return new ApiResult(code, null, msg); /** * 通过枚举返回 * * @param bizCodeEnum 业务枚举状态码 * @return @see ApiResult */ public static T ApiResultT result(BizCodeEnum bizCodeEnum) return ApiResult.buildResult(bizCodeEnum.getCode(), bizCodeEnum.getMessage()); 业务异常类 cshop-commonsrcmainJavagithublianyutiancshopcommonexceptionBizException.Java package github.lianyutian.cshop.common.exception;import github.lianyutian.cshop.common.enums.BizCodeEnum;import lombok.Data;import lombok.EqualsAndHashCode;/** * 业务异常 * * @author lianyutian * @since 2024-12-13 13:54:35 * @version 1.0 */@EqualsAndHashCode(callSuper = false)@Datapublic class BizException extends RuntimeException /** 默认错误码 */ private static final int DEFAULT_ERROR_CODE = -1; /** 异常 code 码 */ private int code; /** 异常消息 */ private String message; /** * 根据 code、message 返回异常信息 * * @param code 错误码 * @param message 异常消息 */ public BizException(int code, String message) super(message); this.code = code; this.message = message; /** 根据 BizCode 返回异常信息 */ public BizException(BizCodeEnum bizCodeEnum) super(bizCodeEnum.getMessage()); this.code = bizCodeEnum.getCode(); this.message = bizCodeEnum.getMessage(); /** * 根据 errMsg 返回异常信息 * * @param errorMsg 错误信息 */ public BizException(String errorMsg) super(errorMsg); this.code = DEFAULT_ERROR_CODE; this.message = errorMsg; 全局异常处理 cshop-commonsrcmainJavagithublianyutiancshopcommonexceptionGlobalExceptionHandler.Java package github.lianyutian.cshop.common.exception;import github.lianyutian.cshop.common.model.ApiResult;import lombok.extern.slf4j.Slf4j;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;/** * 全局异常处理 * * @author lianyutian * @since 2024-12-13 14:04:58 * @version 1.0 */@ControllerAdvice@Slf4jpublic class GlobalExceptionHandler @ExceptionHandler(value = Exception.class) @ResponseBody public ApiResultString handle(Exception e) // 判断是否是业务异常还是非业务异常 if (e instanceof BizException bizException) log.error([这里是业务异常信息]，具体内容如下: , e.getMessage(), e); return ApiResult.error(bizException.getCode(), bizException.getMessage()); else log.info([这里是系统异常信息，具体内容如下: ], e.getMessage(), e); return ApiResult.error(HttpStatus.INTERNAL_SERVER_ERROR.value(), 服务异常请稍后重试); 通用工具类JsonUtil cshop-commonsrcmainJavagithublianyutiancshopcommonutilsJsonUtil.Java package github.lianyutian.cshop.common.utils;import com.google.gson.Gson;import com.google.gson.JsonSyntaxException;import lombok.extern.slf4j.Slf4j;/** * Json 工具类 * * @author lianyutian * @since 2024-12-27 14:25:42 * @version 1.0 */@Slf4jpublic class JsonUtil private static final Gson GSON = new Gson(); /** * 将对象转换为 JSON 字符串 * * @param object 需要转换的对象 * @return JSON 字符串 * @throws IllegalArgumentException 如果输入对象为 null */ public static String toJson(Object object) if (object == null) throw new IllegalArgumentException(Input object cannot be null); return GSON.toJson(object); /** * 将 JSON 字符串转换为指定类型的对象 * * @param json JSON 字符串 * @param clazz 目标类型 * @param T 泛型类型 * @return 转换后的对象 * @throws IllegalArgumentException 如果输入 JSON 字符串为 null 或空 * @throws JsonSyntaxException 如果 JSON 字符串格式不正确 */ public static T T fromJson(String json, ClassT clazz) if (json == null || json.trim().isEmpty()) throw new IllegalArgumentException(Input JSON string cannot be null or empty); try return GSON.fromJson(json, clazz); catch (JsonSyntaxException e) log.error(Failed to parse JSON string: , json, e); throw e; CommonUtil cshop-commonsrcmainJavagithublianyutiancshopcommonutilsCommonUtil.Java package github.lianyutian.cshop.common.utils;import github.lianyutian.cshop.common.exception.BizException;import github.lianyutian.cshop.common.model.ApiResult;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.net.InetAddress;import java.net.UnknownHostException;import java.nio.charset.StandardCharsets;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.Random;import java.util.UUID;import lombok.extern.slf4j.Slf4j;/** * 通用工具类 * * @author lianyutian * @since 2024-12-17 14:57:04 * @version 1.0 */@Slf4jpublic class CommonUtil /** 加密串 */ private static final String SECRET_STRING = ./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz; /** * 获取客户端 ip * * @param request HTTP 请求对象，用于获取客户端 IP 地址 * @return 客户端的 IP 地址 * @throws RuntimeException 如果获取 IP 地址失败 */ public static String getRemoteIpAddr(HttpServletRequest request) String ipAddress; try // 尝试从请求头中获取客户端 IP 地址 ipAddress = request.getHeader(x-forwarded-for); if (ipAddress == null || ipAddress.isEmpty() || unknown.equalsIgnoreCase(ipAddress)) ipAddress = request.getHeader(Proxy-Client-IP); if (ipAddress == null || ipAddress.isEmpty() || unknown.equalsIgnoreCase(ipAddress)) ipAddress = request.getHeader(WL-Proxy-Client-IP); if (ipAddress == null || ipAddress.isEmpty() || unknown.equalsIgnoreCase(ipAddress)) // 如果请求头中没有 IP 地址信息，则直接获取远程地址 ipAddress = request.getRemoteAddr(); if (127.0.0.1.equals(ipAddress)) // 如果是本地地址，则尝试获取本地主机的 IP 地址 InetAddress inet = InetAddress.getLocalHost(); ipAddress = inet.getHostAddress(); // 处理通过多个代理的情况，提取出真实的客户端 IP 地址 if (ipAddress != null ipAddress.length() 15) if (ipAddress.indexOf(,) 0) ipAddress = ipAddress.substring(0, ipAddress.indexOf(,)); if (ipAddress == null || ipAddress.isEmpty()) throw new RuntimeException(Failed to get remote IP address); catch (UnknownHostException e) log.error(e.getMessage(), e); throw new RuntimeException(Failed to get local host IP address, e); catch (Exception e) log.error(e.getMessage(), e); throw new RuntimeException(Failed to get remote IP address, e); return ipAddress; /** * MD5 加密 * * @param data 需要加密的数据 * @return 加密后的数据 * @throws RuntimeException 如果加密失败 */ public static String MD5(String data) try // 创建 MD5 加密器实例 MessageDigest md = MessageDigest.getInstance(MD5); // 对数据进行加密处理 byte[] array = md.digest(data.getBytes(StandardCharsets.UTF_8)); StringBuilder sb = new StringBuilder(); for (byte item : array) // 将加密后的字节数组转换为十六进制字符串 sb.append(Integer.toHexString((item 0xFF) | 0x100), 1, 3); // 返回加密后的字符串 return sb.toString().toUpperCase(); catch (NoSuchAlgorithmException e) log.error(e.getMessage(), e); throw new RuntimeException(Failed to create MD5 digest, e); /** * 生成指定长度的数字验证码 * * @param length 验证码的长度 * @return 生成的数字验证码 */ public static String getRandomCode(int length) String numbers = 0123456789; StringBuilder sb = new StringBuilder(); for (int i = 0; i length; i++) int index = (int) (Math.random() * numbers.length()); sb.append(numbers.charAt(index)); return sb.toString(); /** * 获取当前时间戳 * * @return 当前时间戳 */ public static long getCurrentTimestamp() return System.currentTimeMillis(); /** * 生成 UUID * * @return 生成的 UUID 字符串 */ public static String generateUUID() return UUID.randomUUID().toString().replace(-, ); /** * 向客户端发送 HTTP 响应 此方法用于将给定的 ApiResult 对象序列化为 JSON 格式 * * p 并通过 HttpServletResponse 对象将其作为 HTTP 响应返回给客户端 它处理响应的序列化和发送过程，并记录相关日志 * * @param response 用于发送响应的 HttpServletResponse 对象 * @param result 要序列化并发送的 ApiResult 对象 */ public static void sendResponse(HttpServletResponse response, ApiResultVoid result) // 设置响应头 response.setContentType(application/json; charset=utf-8); String jsonResponse; try // 将 ApiResult 对象序列化为 JSON 字符串 jsonResponse = JsonUtil.toJson(result); catch (Exception e) // 记录序列化异常信息 log.warn(序列化响应数据异常：, e.getMessage(), e); // 如果序列化失败，抛出自定义异常 throw new BizException(序列化响应数据失败); try (PrintWriter writer = response.getWriter()) // 写出响应 writer.print(jsonResponse); // 刷新响应缓冲区，确保响应被发送 response.flushBuffer(); catch (IOException e) // 记录发送响应异常信息 log.warn(返回响应给前端异常：, e.getMessage(), e); // 如果发送响应失败，抛出自定义异常 throw new BizException(返回响应给前端失败); // 如果启用了信息级别日志记录，记录发送的响应数据 if (log.isInfoEnabled()) log.info(返回响应给前端数据：, jsonResponse); /** * 生成区间范围内的随机数 * * @param min min * @param max max * @return 随机数 */ public static int genRandomInt(int min, int max) return genRandomInt(max - min) + min; /** * 生成随机数 * * @param bound bound * @return 随机数 */ public static int genRandomInt(int bound) return new Random().nextInt(bound); CheckUtil cshop-commonsrcmainJavagithublianyutiancshopcommonutilsCheckUtil.Java package github.lianyutian.cshop.common.utils;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 校验工具类 * * @author lianyutian * @since 2024-12-19 13:38:22 * @version 1.0 */public class CheckUtil /** 手机号正则 */ private static final Pattern PHONE_PATTERN = Pattern.compile(^((13[0-9])|(15[^4,\\\\D])|(18[0,5-9]))\\\\d8$); /** * 检测是否是手机号 * * @param phone 手机号 * @return boolean */ public static boolean isPhone(String phone) if (null == phone || .equals(phone)) return false; Matcher m = PHONE_PATTERN.matcher(phone); return m.matches(); BeanUtil cshop-commonsrcmainJavagithublianyutiancshopcommonutilsBeanUtil.Java package github.lianyutian.cshop.common.utils;import java.lang.reflect.Constructor;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.BeanUtils;/** * Bean 拷贝工具类 * * @author lianyutian * @since 2025-01-03 15:09:31 * @version 1.0 */@Slf4jpublic class BeanUtil private static final ConstructorCache CONSTRUCTOR_CACHE = new ConstructorCache(); public static T T copy(Object source, ClassT targetClass) if (source == null) return null; T target; try ConstructorT constructor = CONSTRUCTOR_CACHE.getConstructor(targetClass); target = constructor.newInstance(); BeanUtils.copyProperties(source, target); catch (ReflectiveOperationException e) log.error( Failed to copy properties from to , source.getClass().getName(), targetClass.getName(), e); throw new BeanCopyException(Failed to copy properties, e); return target; public static T ListT copyList(List? sourceList, ClassT targetClass) if (sourceList == null || sourceList.isEmpty()) return null; ListT targetList = new ArrayList(sourceList.size()); for (Object source : sourceList) T target = copy(source, targetClass); if (target != null) targetList.add(target); return targetList; private static class ConstructorCache private final MapClass?, Constructor? cache = new ConcurrentHashMap(); @SuppressWarnings(unchecked) public T ConstructorT getConstructor(ClassT clazz) throws ReflectiveOperationException ConstructorT constructor = (ConstructorT) cache.get(clazz); if (constructor == null) synchronized (cache) constructor = (ConstructorT) cache.get(clazz); if (constructor == null) try constructor = clazz.getDeclaredConstructor(); constructor.setAccessible(true); cache.put(clazz, constructor); catch (NoSuchMethodException e) throw new ReflectiveOperationException(e); return constructor; public static class BeanCopyException extends RuntimeException public BeanCopyException(String message, Throwable cause) super(message, cause); Redis pom.xml !-- redisson 版本 --redisson.version3.41.0/redisson.version!-- https://mvnrepository.com/artifact/org.redisson/redisson --dependency groupIdorg.redisson/groupId artifactIdredisson/artifactId version$redisson.version/version/dependency cshop-commonpom.xml dependency groupIdorg.springframework.boot/groupId artifactIdspring-boot-starter-data-redis/artifactId/dependency!-- https://mvnrepository.com/artifact/org.redisson/redisson --dependency groupIdorg.redisson/groupId artifactIdredisson/artifactId/dependencydependencygroupIdorg.springframework.boot/groupIdartifactIdspring-boot-starter-data-redis/artifactId/dependency RedisConfig cshop-commonsrcmainJavagithublianyutiancshopcommonredisRedisConfig.Java package github.lianyutian.cshop.common.redis;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.redisson.Redisson;import org.redisson.api.RedissonClient;import org.redisson.client.codec.StringCodec;import org.redisson.config.Config;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;/** * redis 客户端配置 * * @author lianyutian * @since 2024-12-17 14:36:40 * @version 1.0 */@Configuration@ConditionalOnClass(RedisConnectionFactory.class)// 配置是否使用 redis (enable = true 时需要配置 redis，否则服务启动时会报错)@ConditionalOnProperty(prefix = spring.data.redis, name = enable, havingValue = true)public class RedisConfig @Value($spring.data.redis.host) private String redisHost; @Value($spring.data.redis.port) private String redisPort; @Value($spring.data.redis.password) private String redisPwd; @Value($spring.data.redis.timeout) private int redisTimeout; /** * 配置 RedisTemplate 用于操作 Redis 数据库 * * @param redisConnectionFactory Redis 连接工厂，用于创建 Redis 连接 * @return 配置好的 RedisTemplate 实例 */ @Bean public RedisTemplateObject, Object redisTemplate( RedisConnectionFactory redisConnectionFactory) // 实例化 RedisTemplate RedisTemplateObject, Object redisTemplate = new RedisTemplate(); // 设置连接 redisTemplate.setConnectionFactory(redisConnectionFactory); // 配置 Redis 序列化规则 // 使用 Jackson 作为 JSON 处理库。该序列化器可以用于将 Java 对象存储到 Redis 中时，自动转换为 JSON 字符串 ObjectMapper objectMapper = new ObjectMapper(); Jackson2JsonRedisSerializerObject jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(objectMapper, Object.class); // 设置 ObjectMapper 的可见性，以便它可以序列化和反序列化所有访问级别的属性 objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); // 设置 key-value 序列化规则 // 使用 StringRedisSerializer 序列化 key，以确保 key 是字符串形式存储 // 使用 Jackson2JsonRedisSerializer 序列化 value，将 Java 对象转换为 JSON 字符串存储 redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(jackson2JsonRedisSerializer); // 设置 hash-value 序列化规则 // 同样地，使用 StringRedisSerializer 序列化 hash 的 key，使用 Jackson2JsonRedisSerializer 序列化 hash 的 value redisTemplate.setHashKeySerializer(new StringRedisSerializer()); redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer); return redisTemplate; /** * 实例化 redissonClient * * @return RedissonClient */ @Bean public RedissonClient redissonClient() Config config = new Config(); config .useSingleServer() .setAddress(redis:// + redisHost + : + redisPort) .setPassword(redisPwd) // 设置连接池最小空闲大小 .setConnectionMinimumIdleSize(10) // 设置连接池大小 .setConnectionPoolSize(100) // 设置空闲链接超时时间 .setIdleConnectionTimeout(600000) .setSubscriptionConnectionMinimumIdleSize(10) .setSubscriptionConnectionPoolSize(100) // 设置超时时间 .setTimeout(redisTimeout); config.setCodec(new StringCodec()); // 设置线程数 config.setThreads(5); // 设置 netty 线程数 config.setNettyThreads(5); // 实例化 redisson 客户端 return Redisson.create(config); RedisCache cshop-commonsrcmainJavagithublianyutiancshopcommonredisRedisCache.Java package github.lianyutian.cshop.common.redis;import github.lianyutian.cshop.common.utils.CommonUtil;import github.lianyutian.cshop.common.utils.JsonUtil;import java.util.concurrent.TimeUnit;import lombok.extern.slf4j.Slf4j;import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.stereotype.Component;/** * Redis 缓存工具类 * * @author lianyutian * @since 2024-12-27 11:30:30 * @version 1.0 */@Component@ConditionalOnBean(RedisConfig.class)@Slf4jpublic class RedisCache private final RedisTemplateString, String redisTemplate; /** 缓存空数据 */ public static final String EMPTY_CACHE = ; /** 分布式锁加锁时间 200 毫秒 */ public static final long UPDATE_LOCK_TIMEOUT = 200; /** 一小时有效期 */ public static final Integer ONE_HOUR_SECONDS = 60 * 60; /** 两天有效期 */ public static final Integer TWO_DAYS_SECONDS = 2 * 24 * 60 * 60; /** 一天有效期 */ public static final Integer ONE_DAY_SECONDS = 24 * 60 * 60; public RedisCache(RedisTemplateString, String redisTemplate) this.redisTemplate = redisTemplate; /** * 生成缓存过期时间：2 天加上随机几小时，防止缓存雪崩，穿透数据库 * * @return 返回过期时间 */ public static Integer generateCacheExpire() return TWO_DAYS_SECONDS + CommonUtil.genRandomInt(0, 10) * 60 * 60; /** * 生成缓存穿透过期时间，单位 秒 * * @return 随机 30 - 100 秒 */ public static Integer generateCachePenetrationExpire() return CommonUtil.genRandomInt(30, 100); /** * 写入缓存 * * @param key key * @param value value * @param seconds 设置过期时间 */ public void set(String key, String value, int seconds) ValueOperationsString, String op = redisTemplate.opsForValue(); try if (seconds 0) // 设置缓存时间 op.set(key, value, seconds, TimeUnit.SECONDS); else if (seconds == 0) // 永不过期 op.set(key, value); else throw new IllegalArgumentException(Expiration time must be a non-negative integer); catch (Exception e) log.error(写入缓存失败, key: , value: [REDACTED], key, e); throw new RedisCacheException(写入缓存失败, e); /** * 写入缓存 value 为 Object 类型 * * @param key key * @param value value * @param seconds 过期时间 */ public void set(String key, Object value, int seconds) try // 先将 Object 转成 Json 字符串再进行存储 this.set(key, JsonUtil.toJson(value), seconds); catch (Exception e) log.error(写入缓存失败, key: , value: [REDACTED], key, e); throw new RedisCacheException(写入缓存失败, e); /** * 读取缓存 * * @param key key * @return 缓存数据 */ public String get(String key) try ValueOperationsString, String op = redisTemplate.opsForValue(); return op.get(key); catch (Exception e) log.error(读取缓存失败, key: , key, e); throw new RedisCacheException(读取缓存失败, e); /** * 删除缓存 * * @param key key * @return 删除成功返回 true，否则返回 false */ public boolean delete(String key) try return Boolean.TRUE.equals(redisTemplate.delete(key)); catch (Exception e) log.error(删除缓存失败, key: , key, e); throw new RedisCacheException(删除缓存失败, e); /** * 设置缓存过期时间 * * @param key key * @param seconds 过期时间 */ public void expire(String key, Integer seconds) if (key == null || key.isEmpty()) throw new IllegalArgumentException(Key cannot be null or empty); if (seconds == null || seconds 0) throw new IllegalArgumentException(Expiration time must be a non-negative integer); try redisTemplate.expire(key, seconds, TimeUnit.SECONDS); catch (Exception e) log.error(Failed to set expiration for key: , key, e); throw new RedisCacheException(Failed to set expiration for key: + key, e); /** * 获取缓存过期时间 * * @param key key * @param timeUnit 时间类型 * @return 过期时间 */ public Long getExpire(String key, TimeUnit timeUnit) if (key == null || key.isEmpty()) throw new IllegalArgumentException(Key cannot be null or empty); try return redisTemplate.getExpire(key, timeUnit); catch (Exception e) log.error(Failed to get expiration for key: , key, e); throw new RedisCacheException(Failed to get expiration for key: + key, e); /** * 获取整数值 * * @param key key * @return 缓存数据 */ public Long getLong(String key) if (key == null || key.isEmpty()) throw new IllegalArgumentException(Key cannot be null or empty); try ValueOperationsString, String op = redisTemplate.opsForValue(); String value = op.get(key); return value != null ? Long.parseLong(value) : null; catch (NumberFormatException e) log.error(Failed to parse integer value for key: , key, e); throw new RedisCacheException(Failed to parse integer value for key: + key, e); catch (Exception e) log.error(Failed to get integer value for key: , key, e); throw new RedisCacheException(Failed to get integer value for key: + key, e); /** * 增加缓存值 * * @param key key * @param delta 增加的值 */ public void increment(String key, int delta) try ValueOperationsString, String op = redisTemplate.opsForValue(); op.increment(key, delta); catch (Exception e) log.error(Failed to increment value for key: , key, e); throw new RedisCacheException(Failed to increment value for key: + key, e); class RedisCacheException extends RuntimeException public RedisCacheException(String message, Throwable cause) super(message, cause); RedisLock cshop-commonsrcmainJavagithublianyutiancshopcommonredisRedisLock.Java package github.lianyutian.cshop.common.redis;import java.util.concurrent.TimeUnit;import org.redisson.api.RLock;import org.redisson.api.RedissonClient;import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;import org.springframework.stereotype.Component;/** * Redis 分布式锁 * * @author lianyutian * @since 2024-12-27 11:30:30 * @version 1.0 */@Component@ConditionalOnBean(RedissonClient.class)public class RedisLock /** 分布式锁加锁时间 200 毫秒 */ public static final long UPDATE_LOCK_TIMEOUT = 200; private final RedissonClient redissonClient; public RedisLock(RedissonClient redissonClient) this.redissonClient = redissonClient; /** * redisson 互斥锁，等待 seconds 秒后自动失效 * * @param key key * @param seconds 秒 * @return 加锁结果 */ public boolean lock(String key, int seconds) // 先获取分布式锁 RLock rLock = redissonClient.getLock(key); // 如果已经加锁了返回 false if (rLock.isLocked()) return false; // 加锁，如果在指定时间内没释放锁，它会自动在底层把锁释放掉 rLock.lock(seconds, TimeUnit.SECONDS); // 加锁成功返回 true return true; /** * redisson 互斥锁，自动续期 * * @param key key * @return 加锁结果 */ public boolean lock(String key) // 先获取分布式锁 RLock rLock = redissonClient.getLock(key); // 如果已经加锁了返回 false if (rLock.isLocked()) return false; // 加锁 rLock.lock(); // 加锁成功返回 true return true; /** * 尝试加锁 * * @param key key * @param timeout 超时时间 * @return 加锁结果 */ public boolean tryLock(String key, long timeout) throws InterruptedException // 先获取分布式锁 RLock rLock = redissonClient.getLock(key); // 尝试加锁 return rLock.tryLock(timeout, TimeUnit.MILLISECONDS); /** * 手动释放锁 * * @param key key */ public void unlock(String key) // 先获取分布式锁 RLock rLock = redissonClient.getLock(key); // 如果已锁定，则释放锁 if (rLock.isLocked()) rLock.unlock(); 用户模块新建 cshop-userpom.xml ?xml version=1.0 encoding=UTF-8?project xmlns=http://maven.apache.org/POM/4.0.0 xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation=http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion4.0.0/modelVersion parent groupIdgithub.lianyutian.cshop/groupId artifactIdcircle-shop/artifactId version1.0-SNAPSHOT/version /parent groupIdgithub.lianyutian.cshop.user/groupId artifactIdcshop-user/artifactId properties maven.compiler.source17/maven.compiler.source maven.compiler.target17/maven.compiler.target project.build.sourceEncodingUTF-8/project.build.sourceEncoding /properties dependencies dependency groupIdgithub.lianyutian.cshop.common/groupId artifactIdcshop-common/artifactId version1.0-SNAPSHOT/version /dependency /dependencies/project cshop-usersrcmainJavagithublianyutiancshopuserUserApplication.Java package github.lianyutian.cshop.user;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;/** * 用户服务启动类 * * @author lianyutian * @since 2024-12-13 14:14:31 * @version 1.0 */@SpringBootApplication@ComponentScan(basePackages = github.lianyutian.cshop.user, github.lianyutian.cshop.common)public class UserApplication public static void main(String[] args) SpringApplication.run(UserApplication.class, args); cshop-usersrcmainresourcesapplication.yml # 服务端口server: port: 9001 spring: application: name: cshop-user # 设置日志级别：ERROR/WARN/INFO/DEBUG,默认是 INFO 以上才显示logging: level: root: INFO 测试 cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserController.Java package github.lianyutian.cshop.user.controller;import github.lianyutian.cshop.common.utils.ApiResult;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * UserController * * @author lianyutian * @since 2024-12-13 14:19:30 * @version 1.0 */@RestController@RequestMapping(/api/user/v1)public class UserController @PostMapping(test) public ApiResultString test() int i = 1 / 0; return ApiResult.success(hello circle-shop); 用户验证码图形验证码基础功能Kaptcha 是一个开源的 Java 图形验证码生成库，常用于在 Web 应用中生成验证码图片。 https://github.com/penggle/kaptcha pom.xml !-- 图形验证码 kaptcha 版本 --kaptcha.version2.3.2/kaptcha.version dependency\tgroupIdcom.github.penggle/groupId\tartifactIdkaptcha/artifactId\tversion$kaptcha.version/version/dependency cshop-userpom.xml dependency\tgroupIdcom.github.penggle/groupId\tartifactIdkaptcha/artifactId/dependency cshop-usersrcmainJavagithublianyutiancshopuserconfigKaptchaConfig.Java package github.lianyutian.cshop.user.config;import com.google.code.kaptcha.Constants;import com.google.code.kaptcha.impl.DefaultKaptcha;import com.google.code.kaptcha.util.Config;import java.util.Properties;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Kaptcha 配置类 * * @author lianyutian * @since 2024-12-17 11:15:02 * @version 1.0 */@Configurationpublic class KaptchaConfig @Bean @Qualifier(captchaProducer) public DefaultKaptcha producer() Properties properties = new Properties(); // 设置 Kaptcha 生成的图片宽度(像素) properties.setProperty(Constants.KAPTCHA_IMAGE_WIDTH, 200); // 设置 Kaptcha 生成的图片高度(像素) properties.setProperty(Constants.KAPTCHA_IMAGE_HEIGHT, 50); // 设置 Kaptcha 文本字体大小 properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_FONT_SIZE, 40); // 设置 Kaptcha 文本字体颜色 properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_FONT_COLOR, black); // 设置 Kaptcha 文本字符长度 properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_CHAR_LENGTH, 5); // 设置 Kaptcha 文本字符集为英文字母（大小写）和数字 properties.setProperty( Constants.KAPTCHA_TEXTPRODUCER_CHAR_STRING, abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890); // 设置 Kaptcha 文本字体 properties.setProperty(Constants.KAPTCHA_TEXTPRODUCER_FONT_NAMES, Arial); // NoNoise 类表示不添加任何噪声，即生成的验证码图片将不会有任何干扰线或点。 // 通过设置 Constants.KAPTCHA_NOISE_IMPL 属性，可以控制验证码图片的样式和复杂度 properties.setProperty(Constants.KAPTCHA_NOISE_IMPL, com.google.code.kaptcha.impl.NoNoise); Config config = new Config(properties); DefaultKaptcha defaultKaptcha = new DefaultKaptcha(); defaultKaptcha.setConfig(config); return defaultKaptcha; cshop-usersrcmainJavagithublianyutiancshopusercontrollerCaptchaController.Java package github.lianyutian.cshop.user.controller;import com.google.code.kaptcha.impl.DefaultKaptcha;import github.lianyutian.cshop.common.utils.CommonUtil;import jakarta.servlet.ServletOutputStream;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import lombok.AllArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.imageio.ImageIO;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.concurrent.TimeUnit;/** * 验证码前端控制器 * * @author lianyutian * @since 2024-12-17 11:17:12 * @version 1.0 */@RestController@RequestMapping(/api/captcha/v1)@AllArgsConstructor@Slf4jpublic class CaptchaController /** * 验证码生成器 */ private final DefaultKaptcha captchaProducer; /** * 获取图形验证码 * * @param response response */ @RequestMapping(getImgCaptcha) public void getImgCaptcha(HttpServletResponse response) // 1、先生成图形验证码文本 String captchaText = captchaProducer.createText(); log.info(验证码模块-获取图形验证码文本:, captchaText); // 2、根据验证码文本生成图形验证码图片 BufferedImage bufferedImage = captchaProducer.createImage(captchaText); try (ServletOutputStream outputStream = response.getOutputStream(); ) ImageIO.write(bufferedImage, jpg, outputStream); outputStream.flush(); catch (IOException e) log.error(验证码模块-获取图形验证码异常:, e.getMessage(), e); 接入 Redis在分布式系统中，有多个实例运行服务时，验证码的存储和验证涉及到跨实例的数据一致性问题。 通常，验证码是存储在用户会话（Session）中，而如果服务是分布式的，那么每个服务实例可能有自己的独立会话存储，将会导致验证失败。为了解决这个问题，我们接入 Redis 存储验证码。 在 common 模块中已经引入了 redis 所以 user 模块不用重复引入，直接配置 redis 就可以。 cshop-usersrcmainresourcesapplication.yml spring: # redis配置 data: redis: enable: true host: 116.198.217.158 port: 6379 password: MIIEowIBAAKCAQEAwG90ULRHmAXFXQzZSwleoYts2+bCzUvqhhqtGiv/F5kUsETY # 如果有密码 database: 0 # 默认数据库 timeout: 60000 # 读取 redis 超时时间 lettuce: pool: max-active: 100 # 最大连接数 max-idle: 100 # 最大空闲连接数 min-idle: 100 # 最小空闲连接数 max-wait: 60000 # 最大等待时间，单位是毫秒 cshop-usersrcmainJavagithublianyutiancshopuserconstantUserCacheKeyConstant.Java package github.lianyutian.cshop.user.constant;/** * 缓存常量 * * @author lianyutian * @since 2024-12-24 13:46:37 * @version 1.0 */public class UserCacheKeyConstant /** 图形验证码缓存 key 前缀 */ public static final String CAPTCHA_IMG_KEY_PREFIX = cshop-user:img-captcha:; /** 注册验证码缓存 key 前缀 */ public static final String CAPTCHA_REGISTER_KEY_PREFIX = cshop-user:register-captcha:; /** 用户信息更新锁前缀 */ public static final String USER_UPDATE_LOCK_KEY_PREFIX = cshop-user:update:lock:; /** 用户详细信息缓存前缀 */ public static final String USER_DETAIL_KEY_PREFIX = cshop-user:detail:; /** 用户展示信息缓存前缀 */ public static final String USER_SHOW_KEY_PREFIX = cshop-user:show:; cshop-usersrcmainJavagithublianyutiancshopusercontrollerCaptchaController.Java package github.lianyutian.cshop.user.controller;import com.google.code.kaptcha.impl.DefaultKaptcha;import github.lianyutian.cshop.common.enums.BizCodeEnum;import github.lianyutian.cshop.common.model.ApiResult;import github.lianyutian.cshop.common.redis.RedisCache;import github.lianyutian.cshop.common.utils.CheckUtil;import github.lianyutian.cshop.common.utils.CommonUtil;import github.lianyutian.cshop.user.constant.UserCacheKeyConstant;import github.lianyutian.cshop.user.service.captcha.CaptchaService;import jakarta.servlet.ServletOutputStream;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.awt.image.BufferedImage;import java.io.IOException;import javax.imageio.ImageIO;import lombok.AllArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;/** * CaptchaController * * @author lianyutian * @since 2024-12-17 11:17:12 * @version 1.0 */@RestController@RequestMapping(/api/captcha/v1)@AllArgsConstructor@Slf4jpublic class CaptchaController /** 图形验证码过期时间 */ private static final long CAPTCHA_EXPIRE_TIME = 60 * 1000 * 5; /** 验证码生成器 */ private final DefaultKaptcha captchaProducer; private final RedisCache redisCache; private final CaptchaService captchaService; /** * 获取图形验证码 * * @param request request * @param response response */ @PostMapping(getImgCaptcha) public void getImgCaptcha(HttpServletRequest request, HttpServletResponse response) // 1、先生成图形验证码文本 String captchaText = captchaProducer.createText(); log.info(验证码模块-获取图形验证码文本:, captchaText); // 2、存储到 redis 中，并设置过期时间 redisCache.set(getImgCaptchaKey(request), captchaText, CAPTCHA_EXPIRE_TIME); // 3、根据验证码文本生成图形验证码图片 BufferedImage bufferedImage = captchaProducer.createImage(captchaText); try (ServletOutputStream outputStream = response.getOutputStream(); ) ImageIO.write(bufferedImage, jpg, outputStream); outputStream.flush(); catch (IOException e) log.error(验证码模块-获取图形验证码异常:, e.getMessage(), e); private String getImgCaptchaKey(HttpServletRequest request) // 获取客户端用户的 IP 地址 String ip = CommonUtil.getRemoteIpAddr(request); // 获取请求头中的 User-Agent 属性值 String userAgent = request.getHeader(User-Agent); // 根据 ip + userAgent 生成对应的 key return UserCacheKeyConstant.CAPTCHA_IMG_KEY_PREFIX + CommonUtil.MD5(ip + userAgent); 短信发送阿里云短信https://www.alibabacloud.com/help/zh/sms/?spm a2c63.p38356.0.0.5d031637kOTDrA https://dysms.console.aliyun.com/quickstart 前置步骤 申请资质 资质是申请签名的实名化信息，可复用 前往查看 申请签名 签名是短信中能代表发送者属性的字段。 前往查看 申请模板 模板即具体发送的短信内容。 前往查看 安全设置https://dysms.console.aliyun.com/msgsetting/safe 创建 RAM 用户 创建用户 https://ram.console.aliyun.com/users/create 添加短信授权 API 详细 API 文档 https://api.aliyun.com/document/Dysmsapi/2017-05-25/SendSms 示例 https://api.aliyun.com/api-tools/sdk/Dysmsapi?version 2017-05-25language Java-async-teatab primer-doc 开发 pom.xml !-- 阿里云短信 sdk 版本 --alibabacloud.dysmsapi.version3.0.1/alibabacloud.dysmsapi.versiondependency groupIdcom.aliyun/groupId artifactIdalibabacloud-dysmsapi20170525/artifactId version$alibabacloud.dysmsapi.version/version/dependency cshop-userpom.xml dependency groupIdcom.aliyun/groupId artifactIdalibabacloud-dysmsapi20170525/artifactId/dependency cshop-usersrcmainJavagithublianyutiancshopuserservicesmsSmsCodeService.Java /** 短信服务接口 提供短信验证码发送功能 */package github.lianyutian.cshop.user.service.sms;/** * 短信服务接口 * * @author lianyutian * @since 2024-12-18 14:39:43 * @version 1.0 */public interface SmsCodeService /** * 发送短信验证码 * * @param phone 接收短信的手机号码 * @param templateId 短信模板 ID，用于指定短信的内容格式 * @param templateParam 短信模板参数，用于替换短信模板中的占位符 * @return 发送结果，通常为成功或失败的标识 */ boolean sendSmsCode(String phone, String templateId, String[] templateParam); cshop-usersrcmainJavagithublianyutiancshopuserservicesmsimplAliyunSmsCodeServiceImpl.Java package github.lianyutian.cshop.user.service.sms.impl;import com.aliyun.auth.credentials.Credential;import com.aliyun.auth.credentials.provider.StaticCredentialProvider;import com.aliyun.sdk.service.dysmsapi20170525.AsyncClient;import com.aliyun.sdk.service.dysmsapi20170525.models.SendSmsRequest;import com.aliyun.sdk.service.dysmsapi20170525.models.SendSmsResponse;import darabonba.core.client.ClientOverrideConfiguration;import github.lianyutian.cshop.common.utils.JsonUtil;import github.lianyutian.cshop.user.service.sms.SmsCodeService;import java.time.Duration;import java.util.Objects;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;/** * 阿里云短信服务实现类 * * @author lianyutian * @since 2024-12-19 08:42:48 * @version 1.0 */@Service@Slf4jpublic class AliyunSmsCodeServiceImpl implements SmsCodeService @Value($sms.aliyun.secretId) private String secretId; @Value($sms.aliyun.secretKey) private String secretKey; @Value($sms.aliyun.signName) private String signName; @Override public boolean sendSmsCode(String phone, String templateId, String[] templateParam) // 配置认证信息，包括访问密钥 ID、访问密钥密钥 StaticCredentialProvider provider = StaticCredentialProvider.create( Credential.builder().accessKeyId(secretId).accessKeySecret(secretKey).build()); try (AsyncClient client = AsyncClient.builder() // .httpClient(httpClient) // 使用配置的 HttpClient，否则使用默认的 HttpClient (Apache HttpClient) .credentialsProvider(provider) // .serviceConfiguration(Configuration.create()) // 服务级别配置 // 客户端级别配置重写，可以设置 Endpoint、HTTP 请求参数等 .overrideConfiguration( ClientOverrideConfiguration.create() // Endpoint 请参考 https://api.aliyun.com/product/Dysmsapi .setEndpointOverride(dysmsapi.aliyuncs.com) .setConnectTimeout(Duration.ofSeconds(30))) .build()) // 设置 API 请求参数 SendSmsRequest sendSmsRequest = SendSmsRequest.builder() .phoneNumbers(phone) .signName(signName) .templateCode(templateId) .templateParam(\\code\\:\\ + templateParam[0] + \\) // 请求级别配置重写，可以设置 HTTP 请求参数等 // .requestConfiguration(RequestConfiguration.create().setHttpHeaders(new // HttpHeaders())) .build(); // 异步获取 API 请求的返回值 CompletableFutureSendSmsResponse response = client.sendSms(sendSmsRequest); // 同步获取 API 请求的返回值 SendSmsResponse resp = response.get(); log.info(短信模块-短信发送结果：, JsonUtil.toJson(resp)); String code = resp.getBody().getCode(); if (Objects.equals(code, OK)) return true; catch (ExecutionException | InterruptedException e) log.error(e.getMessage(), e); return false; return false; cshop-usersrcmainJavagithublianyutiancshopuserservicesmsSmsSender.Java 因为短信服务提供商有多家，为方便可以自由选择提供商所以使用策略模式 package github.lianyutian.cshop.user.service.sms;import github.lianyutian.cshop.user.service.sms.impl.AliyunSmsCodeServiceImpl;import github.lianyutian.cshop.user.service.sms.impl.TencentcloudSmsCodeServiceImpl;import java.util.concurrent.atomic.AtomicInteger;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;/** * 短信发送管理 * * @author lianyutian * @since 2024-12-19 09:50:10 * @version 1.0 */@Service@Slf4jpublic class SmsSender /** 当前使用的短信服务 */ private SmsCodeService currentService; /** 当前短信模板 ID */ private String currentTemplateId; /** 失败计数 */ private final AtomicInteger failureCount = new AtomicInteger(0); /** 阿里云短信服务实现 */ private final AliyunSmsCodeServiceImpl aliyunSmsCodeService; /** 腾讯云短信服务实现 */ private final TencentcloudSmsCodeServiceImpl tencentcloudSmsCodeService; /** 最大失败次数 */ private final int maxFailures; private final String aliyunTemplateId; private final String tencentcloudTemplateId; /** 构造方法，默认使用阿里云短信服务 */ public SmsSender( @Value($sms.send.fail) int maxFailures, @Value($sms.send.templateId.aliyun) String aliyunTemplateId, @Value($sms.send.templateId.tencentcloud) String tencentcloudTemplateId, AliyunSmsCodeServiceImpl aliyunSmsCodeService, TencentcloudSmsCodeServiceImpl tencentcloudSmsCodeService) if (maxFailures = 0) throw new IllegalArgumentException(最大失败次数必须大于0); this.maxFailures = maxFailures; this.aliyunTemplateId = aliyunTemplateId; this.tencentcloudTemplateId = tencentcloudTemplateId; this.aliyunSmsCodeService = aliyunSmsCodeService; this.tencentcloudSmsCodeService = tencentcloudSmsCodeService; this.currentService = aliyunSmsCodeService; this.currentTemplateId = aliyunTemplateId; /** * 发送短信 * * @param phoneNumber 接收短信的电话号码 * @param templateParam 短信模板参数 * @return 短信发送结果，true 表示发送成功，false 表示发送失败 */ public boolean send(String phoneNumber, String[] templateParam) try boolean result = currentService.sendSmsCode(phoneNumber, currentTemplateId, templateParam); // 发送成功时，重置失败次数 failureCount.set(0); return result; catch (Exception e) log.error(短信模块-短信发送失败, , e.getMessage(), e); int currentFailureCount = failureCount.incrementAndGet(); if (currentFailureCount = maxFailures) // 切换到另一个厂商 switchVendor(currentFailureCount); return false; /** 切换短信服务供应商 */ private void switchVendor(int currentFailureCount) if (currentService instanceof AliyunSmsCodeServiceImpl) log.info(短信模块-切换到腾讯云, 当前失败次数: , currentFailureCount); currentService = tencentcloudSmsCodeService; currentTemplateId = tencentcloudTemplateId; else log.info(短信模块-切换到阿里云, 当前失败次数: , currentFailureCount); currentService = aliyunSmsCodeService; currentTemplateId = aliyunTemplateId; cshop-usersrcmainresourcesapplication.yml sms: aliyun: secretId: xxx secretKey: xxx signName: CircleShop商城 tencent: secretId: xxx secretKey: xxx signName: xxx send: fail: 10 templateId: aliyun: SMS_476800055 tencentcloud: xxx 腾讯云短信开通腾讯云短信（签名不通过暂缓）https://console.cloud.tencent.com/smsv2 https://blog.csdn.net/mjl1125/article/details/122047618 https://blog.csdn.net/huixi_aa/article/details/124687445 注册验证码 cshop-usersrcmainJavagithublianyutiancshopusercontrollerCaptchaController.Java private final CaptchaService captchaService;/** * 发送注册验证码 * * @param to 接收方 */@PostMapping(sendRegisterCode)public ApiResultVoid sendRegisterCode(@RequestParam(value = to) String to) if (!CheckUtil.isPhone(to)) return ApiResult.result(BizCodeEnum.USER_PHONE_ERROR); // 先从缓存中获取验证码 // key:cshop-user:register-captcha: 电话 // value: 电话_发送时间戳 String cacheKey = UserCacheKeyConstant.CAPTCHA_REGISTER_KEY_PREFIX + to; String registerCode = redisCache.get(cacheKey); // 如果不为空，则判断是否 60 秒内重复发送 if (StringUtils.isNotBlank(registerCode)) // 从缓存中取出验证码发送时间戳 long cacheCheckTtl = Long.parseLong(registerCode.split(_)[1]); // 当前时间 - 验证码发送时间戳，如果小于 60 秒，则不给重复发送 if (CommonUtil.getCurrentTimestamp() - cacheCheckTtl 1000 * 60) log.info( 验证码模块-请不要重复发送验证码，时间间隔：, (CommonUtil.getCurrentTimestamp() - cacheCheckTtl) / 1000); return ApiResult.result(BizCodeEnum.USER_CODE_FAST_LIMITED); // 发送注册验证码 boolean res = captchaService.sendCode(cacheKey, to); return res ? ApiResult.success() : ApiResult.result(BizCodeEnum.USER_CODE_SEND_ERROR); cshop-usersrcmainJavagithublianyutiancshopuserservicecaptchaCaptchaService.Java package github.lianyutian.cshop.user.service.captcha;/** * 验证码服务接口 * * @author lianyutian * @since 2024-12-17 17:17:03 * @version 1.0 */public interface CaptchaService /** * 发送验证码 * * @param cacheKey 缓存 key * @param to 接收者 * @return 发送结果 */ boolean sendCode(String cacheKey, String to); cshop-usersrcmainJavagithublianyutiancshopuserservicecaptchaimplCaptchaServiceImpl.Java package github.lianyutian.cshop.user.service.captcha.impl;import github.lianyutian.cshop.common.redis.RedisCache;import github.lianyutian.cshop.common.utils.CommonUtil;import github.lianyutian.cshop.user.service.captcha.CaptchaService;import github.lianyutian.cshop.user.service.sms.SmsSender;import java.util.concurrent.TimeUnit;import lombok.AllArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Service;/** * 验证码服务实现类 * * @author lianyutian * @since 2024-12-17 17:35:10 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class CaptchaServiceImpl implements CaptchaService /** 短信验证码过期时间 */ private static final long CAPTCHA_EXPIRE_TIME = 60 * 1000 * 5; private final RedisCache redisCache; private final SmsSender smsSender; @Override public boolean sendCode(String cacheKey, String to) // 获取随机验证码 String code = CommonUtil.getRandomCode(6); // 拼接验证码 格式：验证码_时间戳 String newCode = code + _ + CommonUtil.getCurrentTimestamp(); log.info(验证码模块-写入 Redis 验证码：, newCode); redisCache.set(cacheKey, newCode, CAPTCHA_EXPIRE_TIME, TimeUnit.MILLISECONDS); // 发送短信 boolean sendRes = smsSender.send(to, new String[] code); if (!sendRes) // 发送失败删除缓存 redisCache.delete(cacheKey); return sendRes; 用户头像上传https://www.alibabacloud.com/help/zh/oss/?spm a2c63.p38356.0.0.47cb60deEkjUPk https://www.alibabacloud.com/help/zh/oss/developer-reference/getting-started?spm a2c63.p38356.help-menu-31815.d_3_2_0_0.59105a1abcz5t5 pom.xml !-- 阿里云 OSS sdk 版本 --aliyun-sdk-oss.version3.18.1/aliyun-sdk-oss.version!-- https://mvnrepository.com/artifact/com.aliyun.oss/aliyun-sdk-oss --dependency groupIdcom.aliyun.oss/groupId artifactIdaliyun-sdk-oss/artifactId version$aliyun-sdk-oss.version/version/dependency cshop-usersrcmainresourcesapplication.yml oss: aliyun: secretId: xxx secretKey: xxx bucketName: xxx endPoint: oss-cn-shenzhen.aliyuncs.com cshop-usersrcmainJavagithublianyutiancshopuserserviceossOssService.Java package github.lianyutian.cshop.user.service.oss;import org.springframework.web.multipart.MultipartFile;/** * 对象存储服务 * * @author lianyutian * @since 2024-12-23 14:04:03 * @version 1.0 */public interface OssService /** * 上传用户头像 * * @param file 头像文件 * @return 头像地址 */ String uploadUserAvatar(MultipartFile file); cshop-usersrcmainJavagithublianyutiancshopuserserviceossimplOssServiceImpl.Java package github.lianyutian.cshop.user.service.oss.impl;import com.aliyun.oss.OSS;import com.aliyun.oss.OSSClientBuilder;import com.aliyun.oss.model.PutObjectResult;import github.lianyutian.cshop.common.utils.CommonUtil;import github.lianyutian.cshop.user.service.oss.OssService;import java.io.IOException;import java.io.InputStream;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.util.Objects;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;import org.springframework.web.multipart.MultipartFile;/** * 对象存储实现 * * @author lianyutian * @since 2024-12-23 14:06:09 * @version 1.0 */@Slf4j@Servicepublic class OssServiceImpl implements OssService @Value($oss.aliyun.secretId) private String secretId; @Value($oss.aliyun.secretKey) private String secretKey; @Value($oss.aliyun.bucketName) private String bucketName; @Value($oss.aliyun.endPoint) private String endPoint; @Override public String uploadUserAvatar(MultipartFile file) // 获取原始文件名 String originalFilename = Objects.requireNonNullElse(file.getOriginalFilename(), default_filename); // 获取日期格式，上传时作为目录名使用 LocalDateTime localDateTime = LocalDateTime.now(); DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(yyyy/MM/dd); // OSS 上传存储路径：user/2024/12/23/xxx.jpg String folder = dateTimeFormatter.format(localDateTime); // 获取扩展名 String extension = originalFilename.substring(originalFilename.lastIndexOf(.)); // 新文件名，通过 uuid 生成文件名， String fileName = user + / + folder + / + CommonUtil.generateUUID() + extension; OSS ossClient = new OSSClientBuilder().build(endPoint, secretId, secretKey); try (InputStream inputStream = file.getInputStream()) // 写入 OSS PutObjectResult putObjectResult = ossClient.putObject(bucketName, fileName, inputStream); // 返回图片路径 if (putObjectResult != null) return https:// + bucketName + . + endPoint + / + fileName; else log.error(用户微服务-上传模块-文件上传失败，putObjectResult 为空); return null; catch (IOException e) log.error(用户微服务-上传模块-文件上传失败：, e.getMessage(), e); return null; finally ossClient.shutdown(); cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserController.Java package github.lianyutian.cshop.user.controller;import github.lianyutian.cshop.common.enums.BizCodeEnum;import github.lianyutian.cshop.common.model.ApiResult;import github.lianyutian.cshop.user.model.param.UserEditParam;import github.lianyutian.cshop.user.model.param.UserLoginParam;import github.lianyutian.cshop.user.model.param.UserRegisterParam;import github.lianyutian.cshop.user.model.vo.UserDetailVO;import github.lianyutian.cshop.user.model.vo.UserShowVO;import github.lianyutian.cshop.user.service.UserService;import github.lianyutian.cshop.user.service.oss.OssService;import java.util.Map;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RequestPart;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;/** * UserController * * @author lianyutian * @since 2024-12-13 14:19:30 * @version 1.0 */@RestController@RequestMapping(/api/user/v1)@Slf4j@RequiredArgsConstructorpublic class UserController @Value($oss.aliyun.maxFileSize:1048576) // 新增文件大小限制配置 private long maxFileSize; @Value($oss.aliyun.allowedFileTypes:image/jpeg,image/png) // 新增允许的文件类型配置 private String[] allowedFileTypes; private final OssService ossService; private final UserService userService; /** * 上传用户头像 * * @param file 头像文件 * @return 上传结果 */ @PostMapping(uploadUserAvatar) public ApiResultString uploadUserAvatar(@RequestPart(file) MultipartFile file) // 验证文件是否为空 if (file == null || file.isEmpty()) log.warn(用户微服务-上传模块-文件为空); return ApiResult.result(BizCodeEnum.USER_AVATAR_FILE_UPLOAD_ERROR); // 验证文件大小 if (file.getSize() maxFileSize) log.warn(用户微服务-上传模块-文件超出最大限制: , file.getSize()); return ApiResult.result(BizCodeEnum.USER_AVATAR_FILE_UPLOAD_ERROR); // 验证文件类型 String contentType = file.getContentType(); if (!isFileTypeAllowed(contentType)) log.warn(用户微服务-上传模块-不允许的文件类型: , contentType); return ApiResult.result(BizCodeEnum.USER_AVATAR_FILE_UPLOAD_ERROR); String result = ossService.uploadUserAvatar(file); return result != null ? ApiResult.success(result) : ApiResult.result(BizCodeEnum.USER_AVATAR_FILE_UPLOAD_ERROR); 用户注册创建用户表 cshop-userdocSQLuser.SQL create table user( id bigint unsigned auto_increment primary key, name varchar(32) null comment 用户昵称, pwd varchar(64) null comment 用户密码, avatar varchar(524) null comment 用户头像, sex tinyint(1) default 1 null comment 0 女，1 男, phone varchar(11) default null comment 用户手机号, create_time datetime default CURRENT_TIMESTAMP null comment 创建时间, update_time datetime default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP comment 更新时间, constraint phone_idx unique (phone)) comment 用户表 row_format = DYNAMIC; 配置 pom.xml !-- mybatis-plus 版本 --mybatis-plus.version3.5.9/mybatis-plus.version!-- mysql 驱动 版本 --mysql-connector-java.version8.0.33/mysql-connector-java.versiondependency groupIdcom.baomidou/groupId artifactIdmybatis-plus-bom/artifactId version$mybatis-plus.version/version typepom/type scopeimport/scope/dependencydependency groupIdmysql/groupId artifactIdmysql-connector-java/artifactId version$mysql-connector-java.version/version/dependency cshop-userpom.xml dependency groupIdcom.baomidou/groupId artifactIdmybatis-plus-spring-boot3-starter/artifactId/dependencydependency groupIdmysql/groupId artifactIdmysql-connector-java/artifactId/dependency!-- 密码加密 --dependency groupIdorg.springframework.security/groupId artifactIdspring-security-crypto/artifactId/dependency cshop-usersrcmainresourcesapplication.yml spring: # mysql配置 datasource: username: root password: MIIEowIBAAKCAQEAwG90ULRHmAXFXQzZSwleoYts2+bCzUvqhhqtGiv/F5kUsETY url: jdbc:mysql://116.198.217.158:3306/cshop-user?useUnicode=truecharacterEncoding=utf-8useSSL=falseserverTimezone=Asia/Shanghai driver-class-name: com.mysql.cj.jdbc.Driver# 配置 mybatis plus 打印 sql 日志mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 注册功能开发BCryptPasswordEncoder cshop-usersrcmainJavagithublianyutiancshopuserconfigSecurityConfig.Java package github.lianyutian.cshop.user.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;/** * 密码加密 * * @author lianyutian * @since 2024-12-24 15:16:39 * @version 1.0 */@Configurationpublic class SecurityConfig @Bean public PasswordEncoder passwordEncoder() return new BCryptPasswordEncoder(); cshop-usersrcmainJavagithublianyutiancshopusermodelparamUserRegisterParam.Java package github.lianyutian.cshop.user.model.param;import lombok.Data;/** * 用户注册参数 * * @author lianyutian * @since 2024-12-24 13:30:19 * @version 1.0 */@Datapublic class UserRegisterParam /** 用户名 */ private String name; /** 密码 */ private String password; /** 用户头像 */ private String avatar; /** 性别 0 女，1 男 */ private String sex; /** 手机号 */ private String phone; /** 验证码 */ private String code; cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserController.Java /** * 用户注册 * * @param userRegisterVO 注册信息 * @return 注册结果 */@PostMapping(register)public ApiResultVoid register(@RequestBody UserRegisterParam userRegisterParam) return userService.register(userRegisterVO); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserService.Java package github.lianyutian.cshop.user.service;import github.lianyutian.cshop.common.model.ApiResult;import github.lianyutian.cshop.user.model.param.UserRegisterParam;/** * 用户服务接口 * * @author lianyutian * @since 2024-12-24 08:41:57 * @version 1.0 */public interface UserService /** * 用户注册 * * @param userRegisterParam 用户注册入参 * @return 注册结果 */ ApiResultVoid register(UserRegisterParam userRegisterParam); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserServiceImpl.Java package github.lianyutian.cshop.user.service.impl;import github.lianyutian.cshop.common.enums.BizCodeEnum;import github.lianyutian.cshop.common.exception.BizException;import github.lianyutian.cshop.common.model.ApiResult;import github.lianyutian.cshop.common.redis.RedisCache;import github.lianyutian.cshop.common.utils.BeanUtil;import github.lianyutian.cshop.user.mapper.UserMapper;import github.lianyutian.cshop.user.model.param.UserRegisterParam;import github.lianyutian.cshop.user.model.po.User;import github.lianyutian.cshop.user.service.UserService;import java.util.concurrent.TimeUnit;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.BeanUtils;import org.springframework.dao.DuplicateKeyException;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.springframework.util.CollectionUtils;/** * 用户服务实现类 * * @author lianyutian * @since 2024-12-24 08:44:49 * @version 1.0 */@Service@Slf4j@RequiredArgsConstructorpublic class UserServiceImpl implements UserService private final UserMapper userMapper; private final PasswordEncoder passwordEncoder; private final RedisCache redisCache; private final RedisLock redisLock; @Override @Transactional public ApiResultVoid register(UserRegisterParam userRegisterParam) // 1. 校验注册验证码是否正确 boolean checked = checkCode(userRegisterParam.getPhone(), userRegisterParam.getCode()); if (!checked) return ApiResult.result(BizCodeEnum.USER_CODE_PHONE_ERROR); // 1.2 通过手机号唯一索引实现唯一 User user = new User(); BeanUtils.copyProperties(userRegisterParam, user); // 密码加密 String secretPwd = passwordEncoder.encode(userRegisterParam.getPassword()); user.setPwd(secretPwd); try userMapper.insert(user); catch (DuplicateKeyException e) log.warn(用户微服务-注册模块-用户已存在 , userRegisterParam.getPhone()); return ApiResult.result(BizCodeEnum.USER_ACCOUNT_EXIST); return ApiResult.success(); private boolean checkCode(String phone, String code) // 先从缓存中获取验证码 key - cshop-user:register-captcha:电话 String cacheKey = UserCacheKeyConstant.CAPTCHA_REGISTER_KEY_PREFIX + phone; String codeVal = redisCache.get(cacheKey); if (StringUtils.isBlank(codeVal)) return false; String[] parts = codeVal.split(_); String registerCode = parts[0]; if (registerCode.equals(code)) // 删除验证码，确保验证码不可以重复使用 redisCache.delete(cacheKey); return true; return false; cshop-usersrcmainJavagithublianyutiancshopusermapperUserMapper.Java package github.lianyutian.cshop.user.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import github.lianyutian.cshop.user.model.po.User;import org.apache.ibatis.annotations.Mapper;/** * UserMapper * * @author lianyutian * @since 2024-12-24 14:19:30 * @version 1.0 */@Mapperpublic interface UserMapper extends BaseMapperUser 用户登录pom 配置 pom.xml !-- jwt 版本 --jwt.version0.12.6/jwt.version!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt --dependency groupIdio.jsonwebtoken/groupId artifactIdjjwt/artifactId version$jwt.version/version/dependency cshop-commonpom.xml dependency groupIdio.jsonwebtoken/groupId artifactIdjjwt/artifactId/dependency 功能开发 cshop-usersrcmainJavagithublianyutiancshopusermodelvoUserLoginParam.Java package github.lianyutian.cshop.user.model.param;import lombok.Data;/** * 用户登录参数 * * @author lianyutian * @since 2024-12-24 08:40:33 * @version 1.0 */@Datapublic class UserLoginParam /** 手机号 */ private String phone; /** 密码 */ private String password; cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserController.Java /** * 用户登录 * * @param userLoginParam 用户登录入参 * @return 登录结果 */@PostMapping(login)public ApiResultMapString, Object login(@RequestBody UserLoginParam userLoginParam) return userService.login(userLoginParam); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserService.Java /** * 用户登录 * * @param userLoginParam 用户登录入参 * @return 登录结果 */ApiResultMapString, Object login(UserLoginParam userLoginParam); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserServiceImpl.Java @Overridepublic ApiResultMapString, Object login(UserLoginParam userLoginParam) // 根据手机号查询是否存在 LambdaQueryWrapperUser queryWrapper = new LambdaQueryWrapper(); queryWrapper.eq(User::getPhone, userLoginParam.getPhone()); User user = userMapper.selectOne(queryWrapper); if (user == null) // 未注册 return ApiResult.result(BizCodeEnum.USER_ACCOUNT_PWD_ERROR); // 校验密码 if (passwordEncoder.matches(userLoginParam.getPassword(), user.getPwd())) // TODO 登录成功，生成 jwt return null; else return ApiResult.result(BizCodeEnum.USER_ACCOUNT_PWD_ERROR); 鉴权与刷新JWT JWT（JSON Web Token）鉴权与传统鉴权在技术实现、使用场景和性能等方面存在显著区别，以下是两者的主要对比： 1. 数据存储与状态管理 传统鉴权 使用 会话机制，服务器会在内存（或数据库）中维护用户状态。 通常通过 Session ID 标识用户，Session ID 存储在 Cookie 中，由客户端随每个请求发送给服务器。 需要在服务器端维护会话状态，因此会话管理的扩展性较差（如分布式部署时需要额外解决会话共享问题）。 JWT 鉴权 基于 无状态 的设计，服务器不需要保存任何会话信息。 用户的认证信息（如用户 ID、角色等）被编码为一个加密后的 Token，由客户端存储（如 Cookie 或 Local Storage）并在每次请求时发送给服务器。 适用于分布式系统，因为不需要依赖服务器的会话存储。 2. 安全性 传统鉴权 Session ID 本身通常没有用户信息，仅用来索引服务器存储的用户数据。 需要防范 会话劫持 和 跨站点伪造请求（CSRF）。 JWT 鉴权 Token 自包含用户数据，且通过签名（如 HMAC 或 RSA）防篡改。 如果密钥泄露，攻击者可能伪造 Token，因此密钥的安全性尤为重要。 需要额外注意 Token 的生命周期和刷新策略，避免被窃取后长期有效。 3. 扩展性和性能 传统鉴权 需要服务器处理和存储每个用户的会话状态，随着用户数量增加，扩展性有限。 每次用户请求都会涉及服务器端状态的读取操作，增加了服务器的负担。 JWT 鉴权 不需要在服务器端存储状态信息，所有信息都在 Token 中携带，服务器只需验证 Token。 减少了服务器负担，尤其适合高并发场景。 4. 生命周期和刷新机制 传统鉴权 Session 通常有明确的过期时间，可以通过服务器端直接失效（删除会话数据）。 提供较简单的会话管理和用户退出机制。 JWT 鉴权 JWT 一旦签发，在过期之前无法直接使其失效（除非引入额外的黑名单机制）。 通常使用 短期 Token + 刷新 Token 的组合，短期 Token 过期后用刷新 Token 获取新 Token。 5. 使用场景 传统鉴权 更适合需要频繁交互的小型或单体应用。 当安全性要求较高时，可以借助服务器管理会话来更灵活地控制用户权限。 JWT 鉴权 更适合微服务架构、移动应用、单页应用（SPA）等分布式场景。 跨域支持更友好，因为可以使用 HTTP 标头传递 Token。 总结 特性 传统鉴权 JWT 鉴权 状态管理 有状态，需要服务器存储 无状态，所有信息在 Token 中 扩展性 低，需处理会话共享 高，适合分布式系统 安全性 依赖服务器控制 密钥管理和 Token 安全性关键 生命周期 服务端可随时控制会话失效 生命周期控制复杂（需刷新机制） 适用场景 小型或单体应用 分布式系统、移动前后端分离应用 JWT（JSON Web Token）自动刷新机制主要用于提升用户体验和安全性。以下是具体原因： 提升用户体验： 减少登录频率：通过自动刷新机制，用户不需要频繁重新登录。当用户的访问令牌（Access Token）过期时，系统可以使用刷新令牌（Refresh Token）自动获取新的访问令牌，从而保持用户会话的连续性。 增强安全性： 短期有效的访问令牌：访问令牌通常设置较短的有效期（例如 15 分钟），这样即使访问令牌被泄露，攻击者也无法长时间使用它。 长期有效的刷新令牌：刷新令牌通常设置较长的有效期（例如 30 天），但只能用于获取新的访问令牌，不能直接访问受保护的资源。这样即使刷新令牌被泄露，攻击者也无法直接访问用户数据。 撤销机制：如果怀疑刷新令牌被泄露，可以立即撤销该令牌，从而防止进一步的未授权访问。 灵活性： 动态调整令牌有效期：可以根据业务需求动态调整访问令牌和刷新令牌的有效期，以平衡安全性和用户体验。 实现 JWT 自动刷新的步骤: 生成访问令牌和刷新令牌： 当用户登录成功时，生成一个短期有效的访问令牌和一个长期有效的刷新令牌。 将访问令牌返回给客户端，并将刷新令牌存储在安全的地方（如服务器端的数据库或缓存中）。 客户端存储令牌： 客户端通常将访问令牌存储在内存中（如浏览器的 localStorage 或 sessionStorage），并在每次请求时将其附加到请求头中。 刷新令牌通常存储在更安全的地方，如 HTTP-only Cookie，以防止 XSS 攻击。 访问令牌过期处理： 当访问令牌过期时，客户端会尝试使用刷新令牌获取新的访问令牌。 客户端发送一个请求到服务器，请求中包含刷新令牌。 服务器验证刷新令牌的有效性，如果有效，则生成一个新的访问令牌并返回给客户端。 刷新令牌的安全性： 刷新令牌应该存储在安全的地方，防止被窃取。 可以设置刷新令牌的过期时间，并在用户登出时立即撤销刷新令牌。 可以限制每个刷新令牌只能使用一次，使用后立即失效。 7.8.1 pom 配置 pom.xml !-- jwt 版本 --jwt.version0.12.6/jwt.version!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt --dependency groupIdio.jsonwebtoken/groupId artifactIdjjwt/artifactId version$jwt.version/version/dependency cshop-commonpom.xml dependency groupIdio.jsonwebtoken/groupId artifactIdjjwt/artifactId/dependency 7.8.2 功能开发7.8.2.1 jwt 生成 cshop-commonsrcmainJavagithublianyutiancshopcommonutilsJWTUtil.Java package github.lianyutian.cshop.common.utils;import github.lianyutian.cshop.common.model.LoginUserInfo;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jws;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.security.Keys;import java.util.Date;import java.util.HashMap;import java.util.Map;import lombok.extern.slf4j.Slf4j;/** * jwt 工具类 * * @author lianyutian * @since 2024-12-24 10:01:54 * @version 1.0 */@Slf4jpublic class JWTUtil /** AccessToken 过期时间，正常过期时间 7 天 */ private static final long EXPIRE = 1000L * 60 * 60 * 24 * 7; /** RefreshToken 过期时间，正常过期时间 30 天 */ public static final long REFRESH_EXPIRE = 1000L * 60 * 60 * 24 * 30; /** 加密的密钥，从环境变量或配置文件中读取 */ private static final String SECRET = MIIEowIBAAKCAQEAwG90ULRHmAXFXQzZSwleoYts2+bCzUvqhhqtGiv/F5kUsETY; /** token 前缀 */ private static final String TOKEN_PREFIX = circle-shop.; /** SUBJECT */ private static final String SUBJECT = circle-shop; public static final String KEY_PREFIX = circle-shop:refresh-token:; /** * 根据用户信息，生成 JWT 令牌 * * @return JWT 令牌 */ public static MapString, Object createJwt(LoginUserInfo loginUserInfo) if (loginUserInfo == null) throw new NullPointerException(登录对象为空); // 过期时间 Date expireTime = new Date(System.currentTimeMillis() + EXPIRE); // 生成 JWT TOKEN String token = Jwts.builder() .subject(SUBJECT) // payload .claim(id, loginUserInfo.getId()) .claim(name, loginUserInfo.getName()) .claim(avatar, loginUserInfo.getAvatar()) .issuedAt(new Date()) .expiration(expireTime) // 加密算法 .signWith(Keys.hmacShaKeyFor(SECRET.getBytes()), Jwts.SIG.HS256) .compact(); // 加前缀区分业务 token = TOKEN_PREFIX + token; MapString, Object result = new HashMap(); result.put(AccessToken, token); result.put(AccessTokenExpireTime, expireTime); result.put(RefreshToken, CommonUtil.generateUUID()); log.info(公共服务-生成 token，过期时间：, expireTime); return result; /** * 校验 token 是否正确 * * @param token token * @return Claims */ public static Claims parserToken(String token) if (token == null || !token.startsWith(TOKEN_PREFIX)) log.warn(公共服务-解析 token 失败：无效的 token 格式); return null; try // 去除前缀后解析 String cleanToken = token.replace(TOKEN_PREFIX, ); // jws 解析 JwsClaims claims = Jwts.parser() .verifyWith(Keys.hmacShaKeyFor(SECRET.getBytes())) .build() .parseSignedClaims(cleanToken); log.info(公共服务-解析 token 成功); return claims.getPayload(); catch (Exception e) log.error(公共服务-解析 token 失败：, e.getMessage(), e); return null; 7.8.2.2 登录成功生成 jwt cshop-usersrcmainJavagithublianyutiancshopuserserviceUserServiceImpl.Java @Overridepublic ApiResultMapString, Object login(UserLoginParam userLoginParam) // 根据手机号查询是否存在 LambdaQueryWrapperUser queryWrapper = new LambdaQueryWrapper(); queryWrapper.eq(User::getPhone, userLoginParam.getPhone()); User user = userMapper.selectOne(queryWrapper); if (user == null) // 未注册 return ApiResult.result(BizCodeEnum.USER_ACCOUNT_PWD_ERROR); // 校验密码 if (passwordEncoder.matches(userLoginParam.getPassword(), user.getPwd())) // 登录成功，生成 jwt MapString, Object jwt = createNewJwt(user); return ApiResult.success(jwt); else return ApiResult.result(BizCodeEnum.USER_ACCOUNT_PWD_ERROR); private MapString, Object createNewJwt(User user) // 登录成功，生成 Token LoginUserInfo loginUserInfo = BeanUtil.copy(user, LoginUserInfo.class); BeanUtils.copyProperties(user, loginUserInfo); // 生成 JWT Token，过期时间 MapString, Object jwt = JWTUtil.createJwt(loginUserInfo); // 4、设置 RefreshToken 到 Redis 中，过期时间为 30 天 String newRefreshToken = (String) jwt.get(RefreshToken); String key = JWTUtil.KEY_PREFIX + newRefreshToken; redisCache.set(key, 1, JWTUtil.REFRESH_EXPIRE, TimeUnit.MILLISECONDS); return jwt; 7.8.2.3 刷新 token cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserController.Java /** * 刷新 token * * @param refreshToken refreshToken * @param accessToken accessToken * @return 新的 token */@PostMapping(refreshToken)public ApiResultMapString, Object refreshToken( @RequestParam(value = refreshToken) String refreshToken, @RequestParam(value = accessToken) String accessToken) return userService.refreshToken(refreshToken, accessToken); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserService.Java /** * 刷新 token * * @param refreshToken 刷新 token * @param accessToken 访问 token */ApiResultMapString, Object refreshToken(String refreshToken, String accessToken); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserServiceImpl.Java @Overridepublic ApiResultMapString, Object refreshToken(String refreshToken, String accessToken) String refreshTokenVal = redisCache.get(JWTUtil.KEY_PREFIX + refreshToken); // refreshToken 过期 if (StringUtils.isBlank(refreshTokenVal)) return ApiResult.result(BizCodeEnum.USER_REFRESH_TOKEN_EMPTY); // 2、如果 refreshToken 存在，解密 accessToken Claims claims = JWTUtil.parserToken(accessToken); if (claims == null) // 无法解密提示未登录 return ApiResult.result(BizCodeEnum.USER_ACCOUNT_UNLOGIN); // 3、如果可以解密 accessToken， 则重新生成 accessToken 等信息返回 long userId = Long.parseLong(claims.get(id).toString()); LambdaQueryWrapperUser queryWrapper = new LambdaQueryWrapper(); queryWrapper.eq(User::getId, userId); User user = userMapper.selectOne(queryWrapper); if (user != null) MapString, Object jwt = createNewJwt(user); // 删除旧的 refreshToken redisCache.delete(JWTUtil.KEY_PREFIX + refreshToken); return ApiResult.success(jwt); else // 无法解密提示未登录 return ApiResult.result(BizCodeEnum.USER_ACCOUNT_UNLOGIN); 7.9 登录拦截在用户登录时可以获取到 token 信息，在访问一些接口时需要判断用户是否登录。此时可以在使用 Interceptor 拦截器拦截请求接口解析 token 判断用户是否登录。 cshop-commonsrcmainJavagithublianyutiancshopcommoninterceptorLoginInterceptor.Java package github.lianyutian.cshop.common.interceptor;import github.lianyutian.cshop.common.enums.BizCodeEnum;import github.lianyutian.cshop.common.model.ApiResult;import github.lianyutian.cshop.common.model.LoginUserInfo;import github.lianyutian.cshop.common.utils.CommonUtil;import github.lianyutian.cshop.common.utils.JWTUtil;import github.lianyutian.cshop.common.utils.JsonUtil;import io.jsonwebtoken.Claims;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.web.servlet.HandlerInterceptor;/** * 登录拦截 * * @author lianyutian * @since 2024-12-25 15:47:02 * @version 1.0 */@Slf4jpublic class LoginInterceptor implements HandlerInterceptor public static final ThreadLocalLoginUserInfo USER_THREAD_LOCAL = new ThreadLocal(); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception String token = request.getHeader(token); if (StringUtils.isBlank(token)) token = request.getParameter(token); Claims claims = JWTUtil.parserToken(token); if (claims == null) // 解密失败，登录过期，提示账号未登录 CommonUtil.sendResponse(response, ApiResult.result(BizCodeEnum.USER_ACCOUNT_UNLOGIN)); return false; long id = Long.parseLong(claims.get(id).toString()); String avatar = (String) claims.get(avatar); String name = (String) claims.get(name); LoginUserInfo loginUserInfo = LoginUserInfo.builder().id(id).avatar(avatar).name(name).build(); USER_THREAD_LOCAL.set(loginUserInfo); log.info(登录拦截器--用户信息：, JsonUtil.toJson(loginUserInfo)); return true; 配置拦截路径 cshop-commonsrcmainJavagithublianyutiancshopcommoninterceptorconfigInterceptorConfig.Java package github.lianyutian.cshop.common.interceptor.config;import github.lianyutian.cshop.common.interceptor.LoginInterceptor;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;/** * 登录拦截配置 * * @author lianyutian * @since 2024-12-25 16:17:31 * @version 1.0 */@Configuration@Slf4jpublic class InterceptorConfig implements WebMvcConfigurer public LoginInterceptor loginInterceptor() return new LoginInterceptor(); @Override public void addInterceptors(InterceptorRegistry registry) registry // 添加拦截器 .addInterceptor(loginInterceptor()) // 不需要拦截的路径 .excludePathPatterns( /api/user/*/getImgCaptcha, /api/user/*/sendRegisterCode, /api/user/*/register, /api/user/*/login, /api/user/*/uploadUserAvatar, /api/user/*/detailShow/*); 7.10 获取用户详细信息 cshop-usersrcmainJavagithublianyutiancshopusermodelvoUserDetailVO.Java package github.lianyutian.cshop.user.model.vo;import lombok.Data;/** * 用户信息 VO * * @author lianyutian * @since 2024-12-25 16:22:40 * @version 1.0 */@Datapublic class UserDetailVO private Long id; /** 用户名 */ private String name; /** 用户头像 */ private String avatar; /** 0 女，1 男 */ private Integer sex; /** 用户手机号 */ private String phone; cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserController.Java /** * 用户账号信息查询 * * @return 用户信息 */@GetMapping(detail)public ApiResultUserDetailVO detail() UserDetailVO userDetailVO = userService.getUserDetail(); return ApiResult.success(userDetailVO); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserService.Java /** * 获取用户详情 * * @return 用户详情 */UserDetailVO getUserDetail(); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserServiceImpl.Java @Overridepublic UserDetailVO getUserDetail() // 通过登录拦截器中 ThreadLocal 进行了用户信息传递 LoginUserInfo loginUserInfo = LoginInterceptor.USER_THREAD_LOCAL.get(); User user = userMapper.selectOne(new LambdaQueryWrapperUser().eq(User::getId, loginUserInfo.getId())); UserDetailVO userDetailVO = new UserDetailVO(); BeanUtils.copyProperties(user, userDetailVO); return userDetailVO; 无 token 访问用户信息 有效 token 访问用户信息 7.11 用户地址相关 cshop-userdocSQLuser.SQL create table user_address( id bigint unsigned auto_increment primary key, user_id bigint null comment 用户id, default_status tinyint(1) default 0 null comment 是否默认收货地址：0否 1是, receive_name varchar(64) null comment 收发货人姓名, phone varchar(64) null comment 收货人电话, province varchar(64) null comment 省/直辖市, city varchar(64) null comment 市, region varchar(64) null comment 区, detail_address varchar(200) null comment 详细地址, create_time datetime default CURRENT_TIMESTAMP null comment 创建时间, update_time datetime default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP comment 更新时间) comment 用户收货地址表 row_format = DYNAMIC;create index uid on user_address (user_id); 7.11.1 新增用户地址 cshop-usersrcmainJavagithublianyutiancshopusermodelparamAddressAddParam.Java package github.lianyutian.cshop.user.model.param;import lombok.Data;/** * 添加用户收货地址 VO * * @author lianyutian * @since 2024-12-26 10:18:32 * @version 1.0 */@Datapublic class AddressAddParam /** 是否默认收货地址：0 否 1 是 */ private Integer defaultStatus; /** 收发货人姓名 */ private String receiveName; /** 收货人电话 */ private String phone; /** 省/直辖市 */ private String province; /** 市 */ private String city; /** 区 */ private String region; /** 详细地址 */ private String detailAddress; cshop-usersrcmainJavagithublianyutiancshopuserenumsAddressStatusEnum.Java package github.lianyutian.cshop.user.enums;import lombok.Getter;/** * 收货地址状态枚举 * * @author lianyutian * @since 2024-12-26 17:34:38 * @version 1.0 */@Getterpublic enum AddressStatusEnum DEFAULT_STATUS(0, 默认地址), NOT_DEFAULT_STATUS(1, 非默认地址); private final Integer code; private final String message; AddressStatusEnum(Integer code, String message) this.code = code; this.message = message; cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserAddressController.Java package github.lianyutian.cshop.user.controller;/** * UserAddressController * * @author lianyutian * @since 2024-12-26 09:42:18 * @version 1.0 */@AllArgsConstructor@RestController@RequestMapping(/api/address/v1)public class UserAddressController private final UserAddressService userAddressService; /** * 新增收货地址 * * @param addressAddParam 收货地址 * @return 新增结果 */ @PostMapping(add) public ApiResultVoid add(@RequestBody AddressAddParam addressAddParam) userAddressService.addUserAddress(addressAddParam); return ApiResult.success(); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserAddressService.Java package github.lianyutian.cshop.user.service;/** * 用户地址服务接口 * * @author lianyutian * @since 2024-12-26 09:54:49 * @version 1.0 */public interface UserAddressService /** * 新增用户地址 * * @param addressAddParam 新增用户地址参数 */ void addUserAddress(AddressAddParam addressAddParam); cshop-usersrcmainJavagithublianyutiancshopuserserviceimplUserAddressServiceImpl.Java package github.lianyutian.cshop.user.service.impl;/** * 用户地址服务接口实现类 * * @author lianyutian * @since 2024-12-26 09:55:13 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class UserAddressServiceImpl implements UserAddressService private final UserAddressMapper userAddressMapper; @Override @Transactional(rollbackFor = Exception.class) public void addUserAddress(AddressAddParam addressAddParam) LoginUserInfo loginUserInfo = getLoginUserInfo(); UserAddress userAddress = BeanUtil.copy(addressAddParam, UserAddress.class); userAddress.setUserId(loginUserInfo.getId()); setDefaultStatusIfRequired(userAddress); int affectedRows = userAddressMapper.insert(userAddress); log.info( 用户收货地址模块-新增收货地址：affectedRows=，data=, affectedRows, formatUserAddressForLog(userAddress)); private LoginUserInfo getLoginUserInfo() LoginUserInfo loginUserInfo = LoginInterceptor.USER_THREAD_LOCAL.get(); if (loginUserInfo == null) throw new IllegalStateException(LoginUserInfo not found in ThreadLocal); return loginUserInfo; private void setDefaultStatusIfRequired(UserAddress userAddress) if (Objects.equals( userAddress.getDefaultStatus(), AddressStatusEnum.DEFAULT_STATUS.getCode())) // 设置默认的为非默认状态 userAddressMapper.update( null, new LambdaUpdateWrapperUserAddress() .set(UserAddress::getDefaultStatus, AddressStatusEnum.NOT_DEFAULT_STATUS.getCode()) .eq(UserAddress::getUserId, userAddress.getUserId()) .eq(UserAddress::getDefaultStatus, AddressStatusEnum.DEFAULT_STATUS.getCode())); private String formatUserAddressForLog(UserAddress userAddress) // 只打印必要的字段，避免泄露敏感信息 return id= + userAddress.getId() + , userId= + userAddress.getUserId() + , defaultStatus= + userAddress.getDefaultStatus(); cshop-usersrcmainJavagithublianyutiancshopusermapperUserAddressMapper.Java package github.lianyutian.cshop.user.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import github.lianyutian.cshop.user.model.po.UserAddress;import org.apache.ibatis.annotations.Mapper;/** * UserAddressMapper * * @author lianyutian * @since 2024-12-26 14:19:30 * @version 1.0 */@Mapperpublic interface UserAddressMapper extends BaseMapperUserAddress cshop-usersrcmainresourcesmapperUserAddressMapper.xml ?xml version=1.0 encoding=UTF-8?!DOCTYPE mapper PUBLIC -//mybatis.org//DTD Mapper 3.0//EN http://mybatis.org/dtd/mybatis-3-mapper.dtdmapper namespace=github.lianyutian.cshop.user.mapper.UserAddressMapper resultMap id=BaseResultMap type=github.lianyutian.cshop.user.model.po.UserAddress id property=id column=id jdbcType=BIGINT/ result property=userId column=user_id jdbcType=BIGINT/ result property=defaultStatus column=default_status jdbcType=TINYINT/ result property=receiveName column=receive_name jdbcType=VARCHAR/ result property=phone column=phone jdbcType=VARCHAR/ result property=province column=province jdbcType=VARCHAR/ result property=city column=city jdbcType=VARCHAR/ result property=region column=region jdbcType=VARCHAR/ result property=detailAddress column=detail_address jdbcType=VARCHAR/ result property=createTime column=create_time jdbcType=TIMESTAMP/ result property=updateTime column=update_time jdbcType=TIMESTAMP/ /resultMap sql id=Base_Column_List id,user_id,default_status, receive_name,phone,province, city,region,detail_address, create_time,update_time /sql/mapper 7.11.2 根据 id 查询收货地址详情 cshop-usersrcmainJavagithublianyutiancshopusermodelvoUserAddressVO.Java package github.lianyutian.cshop.user.model.vo;import lombok.Data;/** * 用户地址 VO 界面展示 * * @author lianyutian * @since 2024-12-26 09:59:44 * @version 1.0 */@Datapublic class UserAddressVO private Long id; /** 用户 id */ private Long userId; /** 是否默认收货地址：0 否 1 是 */ private Integer defaultStatus; /** 收发货人姓名 */ private String receiveName; /** 收货人电话 */ private String phone; /** 省/直辖市 */ private String province; /** 市 */ private String city; /** 区 */ private String region; /** 详细地址 */ private String detailAddress; cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserAddressController.Java /** * 根据 id 查询收货地址详情 * * @param addressId 收货地址 id * @return 收获地址详情 */@GetMapping(detail/addressId)public ApiResultUserAddressVO detail(@PathVariable(addressId) Long addressId) UserAddressVO userAddressVo = userAddressService.getUserAddressDetail(addressId); return userAddressVo == null ? ApiResult.result(BizCodeEnum.USER_ADDRESS_NOT_EXITS) : ApiResult.success(userAddressVo); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserAddressService.Java /** * 根据用户地址 id 获取用户地址详情 * * @param addressId 地址 ID * @return 用户地址详情 */UserAddressVO getUserAddressDetail(Long addressId); cshop-usersrcmainJavagithublianyutiancshopuserserviceimplUserAddressServiceImpl.Java @Overridepublic UserAddressVO getUserAddressDetail(Long addressId) if (addressId == null || addressId = 0) throw new IllegalArgumentException(Invalid addressId); UserAddress userAddress = userAddressMapper.selectById(addressId); if (userAddress == null) return null; return BeanUtil.copy(userAddress, UserAddressVO.class); 7.11.3 获取用户地址列表 cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserAddressController.Java /** * 获取用户地址列表 * * @return 用户地址列表 */@GetMapping(list)public ApiResultListUserAddressVO list() ListUserAddressVO allUserAddressList = userAddressService.getAllUserAddressList(); return ApiResult.success(allUserAddressList); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserAddressService.Java /** * 获取用户地址列表 * * @return 用户地址列表 */ListUserAddressVO getAllUserAddressList(); cshop-usersrcmainJavagithublianyutiancshopuserserviceimplUserAddressServiceImpl.Java @Overridepublic ListUserAddressVO getAllUserAddressList() LoginUserInfo loginUserInfo = getLoginUserInfo(); ListUserAddress userAddressList = userAddressMapper.selectList( new LambdaQueryWrapperUserAddress() .eq(UserAddress::getUserId, loginUserInfo.getId())); return userAddressList.stream().map(this::convertToUserAddressVO).collect(Collectors.toList());private UserAddressVO convertToUserAddressVO(UserAddress userAddress) return BeanUtil.copy(userAddress, UserAddressVO.class); 7.11.4 修改指定收货地址 cshop-usersrcmainJavagithublianyutiancshopusermodelparamAddressEditParam.Java package github.lianyutian.cshop.user.model.param;import lombok.Data;/** * 修改指定收货地址入参 * * @author lianyutian * @since 2024-12-26 11:02:20 * @version 1.0 */@Datapublic class AddressEditParam /** 地址 id */ private Long id; /** 是否默认收货地址：0 否 1 是 */ private Integer defaultStatus; /** 收发货人姓名 */ private String receiveName; /** 收货人电话 */ private String phone; /** 省/直辖市 */ private String province; /** 市 */ private String city; /** 区 */ private String region; /** 详细地址 */ private String detailAddress; cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserAddressController.Java /** * 修改指定收货地址 * * @param addressEditParam 收货地址 * @return 修改结果 */@PostMapping(edit)public ApiResultVoid edit(@RequestBody AddressEditParam addressEditParam) boolean updated = userAddressService.updateUserAddress(addressEditParam); return updated ? ApiResult.success() : ApiResult.result(BizCodeEnum.USER_ADDRESS_NOT_EXITS); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserAddressService.Java /** * 修改用户地址 * * @param addressEditParam 修改用户地址参数 */boolean updateUserAddress(AddressEditParam addressEditParam); cshop-usersrcmainJavagithublianyutiancshopuserserviceimplUserAddressServiceImpl.Java @Override@Transactional(rollbackFor = Exception.class)public boolean updateUserAddress(AddressEditParam addressEditParam) UserAddress oldUserAddress = userAddressMapper.selectById(addressEditParam.getId()); if (oldUserAddress == null) return false; LoginUserInfo loginUserInfo = getLoginUserInfo(); UserAddress userAddress = BeanUtil.copy(addressEditParam, UserAddress.class); userAddress.setUserId(loginUserInfo.getId()); setDefaultStatusIfRequired(userAddress); int affectedRows = userAddressMapper.update( userAddress, new LambdaUpdateWrapperUserAddress() .eq(UserAddress::getId, addressEditParam.getId())); if (affectedRows == 0) log.warn(用户收货地址模块-更新收货地址失败：id=, addressEditParam.getId()); return false; log.info( 用户收货地址模块-更新收货地址：affectedRows=，data=, affectedRows, formatUserAddressForLog(userAddress)); return true; 7.11.5 删除用户地址 cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserAddressController.Java /** * 删除指定收货地址 * * @param addressId 收货地址 id * @return 删除结果 */@GetMapping(delete/addressId)public ApiResultVoid delete(@PathVariable(addressId) Long addressId) return userAddressService.deleteUserAddress(addressId) == 1 ? ApiResult.success() : ApiResult.result(BizCodeEnum.USER_ADDRESS_NOT_EXITS); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserAddressService.Java /** * 删除用户地址 * * @param addressId 地址 ID * @return 删除结果 */int deleteUserAddress(Long addressId); cshop-usersrcmainJavagithublianyutiancshopuserserviceimplUserAddressServiceImpl.Java @Override@Transactional(rollbackFor = Exception.class)public int deleteUserAddress(Long addressId) return userAddressMapper.deleteById(addressId); 7.12 用户详情引入 Redis用户点击自身详情时会显示 用户名、头像、性别、手机号 等信息，这些信息很少变动，可以考虑写入缓存中。 cshop-usersrcmainJavagithublianyutiancshopuserconstantUserCacheKeyConstant.Java package github.lianyutian.cshop.user.constant;/** * 缓存常量 * * @author lianyutian * @since 2024-12-24 13:46:37 * @version 1.0 */public class UserCacheKeyConstant /** 图形验证码缓存 key 前缀 */ public static final String CAPTCHA_IMG_KEY_PREFIX = cshop-user:img-captcha:; /** 注册验证码缓存 key 前缀 */ public static final String CAPTCHA_REGISTER_KEY_PREFIX = cshop-user:register-captcha:; /** 用户信息更新锁前缀 */ public static final String USER_UPDATE_LOCK_KEY_PREFIX = cshop-user:update:lock:; /** 用户信息缓存前缀 */ public static final String USER_DETAIL_KEY_PREFIX = cshop-user:detail:; /** 用户展示信息缓存前缀 */ public static final String USER_SHOW_KEY_PREFIX = cshop-user:show:; cshop-usersrcmainJavagithublianyutiancshopuserserviceimplUserServiceImpl.Java private final RedisCache redisCache;@Overridepublic UserDetailVO getUserDetail() // 通过登录拦截器中 ThreadLocal 进行了用户信息传递 LoginUserInfo loginUserInfo = LoginInterceptor.USER_THREAD_LOCAL.get(); UserDetailVO userDetailVO = getUserDetailFromCache(loginUserInfo.getId()); if (userDetailVO != null) return userDetailVO; // 不存在才去查库 User user = userMapper.selectOne(new LambdaQueryWrapperUser().eq(User::getId, loginUserInfo.getId())); userDetailVO = BeanUtil.copy(user, UserDetailVO.class); redisCache.set( UserCacheKeyConstant.USER_DETAIL_KEY_PREFIX + loginUserInfo.getId(), userDetailVO, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); log.info(用户模块-缓存用户信息：, JsonUtil.toJson(user)); return userDetailVO;private UserDetailVO getUserDetailFromCache(long userId) String key = UserCacheKeyConstant.USER_DETAIL_KEY_PREFIX + userId; String userDetail = redisCache.get(key); log.info(用户模块-从缓存中获取用户信息：, userDetail); if (StringUtils.isNotBlank(userDetail)) // 缓存延期 redisCache.expire(key, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); return JsonUtil.fromJson(userDetail, UserDetailVO.class); return null; 7.13 用户信息展示 点击进入用户主页可以显示用户 用户名、id、性别 等主要信息 7.13.1 V1 版本 cshop-usersrcmainJavagithublianyutiancshopusermodelvoUserShowVO.Java package github.lianyutian.cshop.user.model.vo;import lombok.Data;/** * 用户展示信息 VO 展示给他人看的信息 * * @author lianyutian * @since 2024-12-27 17:11:22 * @version 1.0 */@Datapublic class UserShowVO /** 用户 id */ private Long id; /** 用户名 */ private String name; /** 用户头像 */ private String avatar; cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserController.Java /** * 获取用户展示信息 * * @param userId 用户 ID * @return 用户展示信息 */@GetMapping(detail/show/userId)public ApiResultUserShowVO getUserShow(@PathVariable(userId) Long userId) UserShowVO userShowVO = userService.getUserShow(userId); return ApiResult.success(userShowVO); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserService.Java /** * 获取用户展示详情 * * @param userId 用户 id * @return 用户展示详情 */UserShowDetailVO getUserShow(Long userId); cshop-usersrcmainJavagithublianyutiancshopuserserviceimplUserServiceImpl.Java public UserShowVO getUserShow_V1(Long userId) User user = userMapper.selectOne(new LambdaQueryWrapperUser().eq(User::getId, userId)); UserShowVO userShowVO = new UserShowVO(); return BeanUtil.copy(user, userShowVO); 优点 查询用户信息都直接查数据库，没有数据一致性问题 缺点 所有请求都查库，性能不高 如果并发量大可能直接打崩数据库 7.12.2 V2 版本因为用户信息展示是个读多写少的场景，用户信息自身很少变更但是用户展示信息会有较多的查询展示。非常适合缓存，所以这里引入 Redis 缓存用户的展示信息。 cshop-usersrcmainJavagithublianyutiancshopuserserviceimplUserServiceImpl.Java public UserShowVO getUserShow_V2(Long userId) UserShowVO userShowVO = getUserShowFromCache(userId); if (userShowVO != null) UserShowVO userShowVO = new UserShowVO(); return BeanUtil.copy(userShowVO, UserShowVO.class); User user = userMapper.selectOne(new LambdaQueryWrapperUser().eq(User::getId, userId)); UserShowVO userShowVO = new UserShowVO(); return BeanUtil.copy(userShowVO, UserShowVO.class);private UserShowVO getUserShowFromCache(long userId) String key = UserCacheKeyConstant.USER_SHOW_KEY_PREFIX + userId; String userShow = redisCache.get(key); log.info(用户模块-从缓存中获取用户展示信息：, userShow); if (StringUtils.isNotBlank(userShow)) // 缓存延期 redisCache.expire(key, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); return JsonUtil.fromJson(userShow, UserShowVO.class); return null; 优点 缓存存在时所有查询走缓存，性能高 缺点 缓存不存在时，如果有超高并发进入还是会直接打进数据库 当查询不存在的 userId 时会直接穿透缓存打到数据库，同时高并发查询不存在的 userId 也可能打崩数据库 7.12.3 V3 版本public UserShowVO getUserShow_V3(Long userId) UserShowVO userShowVO = getUserShowFromCache(userId); if (userShowVO != null) return BeanUtil.copy(userShowVO, UserShowVO.class); boolean tryLocked = false; try // 解决高并发查库的问题 tryLocked = redisLock.tryLock(cshop-user:user-show:lock: + userId, 200); if (!tryLocked) return null; User user = userMapper.selectOne(new LambdaQueryWrapperUser().eq(User::getId, userId)); if (user == null) // 解决缓存穿透问题 redisCache.set( UserCacheKeyConstant.USER_SHOW_KEY_PREFIX + userId, , RedisCache.generateCachePenetrationExpire(), TimeUnit.MILLISECONDS); return null; return BeanUtil.copy(user, UserShowVO.class); catch (InterruptedException e) log.info(【getUserShow】获取锁失败, userId , userId); return null; finally if (tryLocked) redisLock.unlock(cshop-user:info:lock: + userId); 优点 解决高并发下查数据库问题 解决高并发下查不存在 userId 问题 缺点 用户同时更新信息时存在缓存和数据库不一致问题 7.12.4 V4 版本** * 用户展示信息 * * p1.假如 用户Z 发布了一篇内容突然爆火，同一时刻有上万用户来查看 用户Z 的个人信息，此时就会存在同一时刻会有超大并发流量进入该接口 * * p2.如果有恶意用户大批量使用不存在的 用户id 来查询，就会造成缓存穿透，大量请求击穿的 DB 层。 * * p3.如果 用户Z 在这个时刻修改了自己的信息，怎么保证其他用户查询到的是最新的信息，怎么保证缓存和数据库的数据一致性 * * p场景：例如 线程A 来查询 用户Z 的信息，同时 线程B 修改 用户Z 信息且此时缓存中 用户Z 信息刚好过期。 * * p那么此时 线程A 会去查数据库，这个时候 线程B 还没将 用户Z 修改后的信息保存到数据库中。 * * p所以 线程A 拿到的是旧的数据，再假设此时 线程A 没抢到 CPU 资源阻塞住了。 * * p这个时候 线程B 已经修改完自身信息并保存入数据库，同时会将新数据刷新到缓存中。 * * p再执行完成这一步后，线程A 才继续执行，此时 线程A 拿到的还是旧的数据，也会去刷新缓存。 * * p那么此时缓存中的数据是 线程A 在 线程B 更新前的旧数据，数据库中是 线程B 更新的新数据。 * * p解决方案：更新用户接口也加 同 一把分布式锁，保证读写串行。用户更新自身信息是占比很少的写操作，这里考虑的是极端场景 * * @param userId 用户id * @return 用户展示信息 */@Overridepublic UserShowVO getUserShow(Long userId) UserShowVO userShowVO = getUserShowFromCache(userId); if (userShowVO != null) return userShowVO; // 2、缓存为空再从数据库中获取 return getUserShowFromDB(userId);private UserDetailVO getUserDetailFromCache(long userId) String key = UserCacheKeyConstant.USER_DETAIL_KEY_PREFIX + userId; String userDetail = redisCache.get(key); log.info(用户模块-从缓存中获取用户信息：, userDetail); if (StringUtils.isNotBlank(userDetail)) // 缓存延期 redisCache.expire(key, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); return JsonUtil.fromJson(userDetail, UserDetailVO.class); return null;private UserShowVO getUserShowFromCache(long userId) String key = UserCacheKeyConstant.USER_SHOW_KEY_PREFIX + userId; String userShow = redisCache.get(key); log.info(用户模块-从缓存中获取用户展示信息：, userShow); if (StringUtils.isNotBlank(userShow)) // 缓存延期 redisCache.expire(key, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); return JsonUtil.fromJson(userShow, UserShowVO.class); return null;private UserShowVO getUserShowFromDB(Long userId) String userUpdateLockKey = UserCacheKeyConstant.USER_UPDATE_LOCK_KEY_PREFIX + userId; // 设置分布式锁 boolean tryLocked = false; try // TODO 解释 tryLocked = redisLock.tryLock(userUpdateLockKey, RedisCache.UPDATE_LOCK_TIMEOUT); if (!tryLocked) // 加锁超时 /* 尝试加锁时间有 RedisCache.UPDATE_LOCK_TIMEOUT 有可能其他线程已经获取数据并写入缓存了所以这里再尝试去读下缓存 */ UserShowVO userShowFromCache = getUserShowFromCache(userId); if (userShowFromCache != null) return userShowFromCache; log.warn(【getUserShowFromDB】用户缓存为空，查询用户信息获取锁失败 , userId); return null; User user = userMapper.selectById(userId); if (user == null) // 如果为空先在缓存中设置一个空值，防止缓存穿透（解决 2） redisCache.set( UserCacheKeyConstant.USER_SHOW_KEY_PREFIX + userId, RedisCache.EMPTY_CACHE, RedisCache.generateCachePenetrationExpire(), TimeUnit.MILLISECONDS); return null; UserShowVO userShowVO = BeanUtil.copy(user, UserShowVO.class); log.info(【getUserShowFromDB】用户缓存为空，从数据库获取用户信息 , JsonUtil.toJson(userShowVO)); redisCache.set( UserCacheKeyConstant.USER_SHOW_KEY_PREFIX + userId, userShowVO, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); return userShowVO; catch (InterruptedException e) // 加锁失败 // 这里再去尝试获取下缓存-双重检查 UserShowVO userShowFromCache = getUserShowFromCache(userId); if (userShowFromCache != null) return userShowFromCache; log.error(【getUserShowFromDB】尝试加锁异常，异常信息：, e.getMessage(), e); throw new BizException(BizCodeEnum.USER_INFO_SHOW_LOCK_FAIL); finally if (tryLocked) redisLock.unlock(userUpdateLockKey); 7.13 用户信息更新 cshop-usersrcmainJavagithublianyutiancshopusermodelparamUserEditParam.Java package github.lianyutian.cshop.user.model.param;import lombok.Data;/** * 用户信息修改入参 * * @author lianyutian * @since 2024-12-27 13:23:04 * @version 1.0 */@Datapublic class UserEditParam /** 用户 id */ private Long id; /** 手机号 */ private String phone; /** 用户名 */ private String name; /** 头像 */ private String avatar; /** 性别 */ private int sex; cshop-usersrcmainJavagithublianyutiancshopusercontrollerUserController.Java /** * 用户信息修改 * * @param userEditParam 用户信息 * @return 修改结果 */@PostMapping(edit)public ApiResultVoid edit(@RequestBody UserEditParam userEditParam) userService.updateUser(userEditParam); return ApiResult.success(); cshop-usersrcmainJavagithublianyutiancshopuserserviceUserService.Java /** * 更新用户信息 * * @param userEditParam 用户编辑参数 */void updateUserInfo(UserEditParam userEditParam); cshop-usersrcmainJavagithublianyutiancshopuserserviceimplUserServiceImpl.Java @Override@Transactional(rollbackFor = Exception.class)public void updateUser(UserEditParam userEditParam) LoginUserInfo loginUserInfo = LoginInterceptor.USER_THREAD_LOCAL.get(); userEditParam.setId(loginUserInfo.getId()); boolean locked = false; try // 这里加分布式锁是为了保证高并发下有其他用户查询该用户信息时保证数据库和缓存的一致性 locked = redisLock.lock(UserCacheKeyConstant.USER_UPDATE_LOCK_KEY_PREFIX + loginUserInfo.getId()); if (!locked) log.error(用户模块-修改用户信息：用户 获取锁失败, loginUserInfo.getId()); throw new BizException(BizCodeEnum.USER_DETAIL_UPDATE_FAIL); // 先删掉缓存，防止出现数据库更新成功但是更新缓存失败，获取用户信息时一直都是缓存的数据 redisCache.delete(UserCacheKeyConstant.USER_SHOW_KEY_PREFIX + loginUserInfo.getId()); redisCache.delete(UserCacheKeyConstant.USER_DETAIL_KEY_PREFIX + loginUserInfo.getId()); User user = BeanUtil.copy(userEditParam, User.class); int rows = userMapper.update( user, new LambdaUpdateWrapperUser().eq(User::getId, loginUserInfo.getId())); log.info(用户模块-修改用户信息：rows=，data=, rows, userEditParam); User newUser = userMapper.selectOne( new LambdaQueryWrapperUser().eq(User::getId, loginUserInfo.getId())); UserShowVO userShowVO = BeanUtil.copy(newUser, UserShowVO.class); // 这里存在数据库更新后，缓存更新失败的场景（这里不去强制保证数据库更新完成后一定更新成功缓存） redisCache.set( UserCacheKeyConstant.USER_SHOW_KEY_PREFIX + loginUserInfo.getId(), userShowVO, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); UserDetailVO userDetailVO = BeanUtil.copy(newUser, UserDetailVO.class); redisCache.set( UserCacheKeyConstant.USER_DETAIL_KEY_PREFIX + loginUserInfo.getId(), userDetailVO, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); finally if (locked) redisLock.unlock(UserCacheKeyConstant.USER_UPDATE_LOCK_KEY_PREFIX + loginUserInfo.getId()); 7.14 笔记服务https://nginx.org/en/download.html 7.14.1 新建笔记服务 cshop-commonpom.xml !-- mybatis-plus 分页插件 --dependency groupIdcom.baomidou/groupId artifactIdmybatis-plus-jsqlparser/artifactId/dependency cshop-notepom.xml ?xml version=1.0 encoding=UTF-8?project xmlns=http://maven.apache.org/POM/4.0.0 xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation=http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion4.0.0/modelVersion parent groupIdgithub.lianyutian.cshop/groupId artifactIdcircle-shop/artifactId version1.0-SNAPSHOT/version /parent groupIdgithub.lianyutian.cshop.note/groupId artifactIdcshop-note/artifactId description笔记服务/description properties maven.compiler.source17/maven.compiler.source maven.compiler.target17/maven.compiler.target project.build.sourceEncodingUTF-8/project.build.sourceEncoding /properties dependencies dependency groupIdgithub.lianyutian.cshop.common/groupId artifactIdcshop-common/artifactId version1.0-SNAPSHOT/version /dependency dependency groupIdorg.springframework.boot/groupId artifactIdspring-boot-starter-web/artifactId /dependency dependency groupIdmysql/groupId artifactIdmysql-connector-java/artifactId /dependency dependency groupIdcom.baomidou/groupId artifactIdmybatis-plus-spring-boot3-starter/artifactId /dependency dependency groupIdorg.apache.rocketmq/groupId artifactIdrocketmq-client/artifactId /dependency /dependencies/project cshop-notesrcmainresourcesapplication.yml # 服务端口server: port: 9003spring: application: name: cshop-note # mysql配置 datasource: username: root password: MIIEowIBAAKCAQEAwG90ULRHmAXFXQzZSwleoYts2+bCzUvqhhqtGiv/F5kUsETY url: jdbc:mysql://116.198.217.158:3306/cshop-user?useUnicode=truecharacterEncoding=utf-8useSSL=falseserverTimezone=Asia/Shanghai driver-class-name: com.mysql.cj.jdbc.Driver # redis配置 data: redis: host: 116.198.217.158 port: 6379 password: MIIEowIBAAKCAQEAwG90ULRHmAXFXQzZSwleoYts2+bCzUvqhhqtGiv/F5kUsETY # 如果有密码 database: 0 # 默认数据库 timeout: 60000 # 读取 redis 超时时间 lettuce: pool: max-active: 100 # 最大连接数 max-idle: 100 # 最大空闲连接数 min-idle: 100 # 最小空闲连接数 max-wait: 60000 # 最大等待时间，单位是毫秒# 设置日志级别：ERROR/WARN/INFO/DEBUG,默认是 INFO 以上才显示logging: level: root: INFO# 配置 mybatis plus 打印 sql 日志mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl# rocketmq配置rocketmq: accessKey: mqadmin secretKey: MIIEowIBAAKCAQEAwG90ULRHmAXFXQzZSwleoYts2+bCzUvqhhqtGiv/F5kUsETY nameServer: 116.198.217.158:9876 cshop-notesrcmainJavagithublianyutiancshopnoteNoteApplication.Java package github.lianyutian.cshop.note;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;/** * 笔记服务启动类 * * @author lianyutian * @since 2025-01-02 14:55:33 * @version 1.0 */@SpringBootApplication@ComponentScan(basePackages = github.lianyutian.cshop.note, github.lianyutian.cshop.common)public class NoteApplication public static void main(String[] args) SpringApplication.run(NoteApplication.class, args); 7.14.2 新增笔记 cshop-notesrcmainJavagithublianyutiancshopnotemodelparamNoteAddParam.Java package github.lianyutian.cshop.note.model.param;import com.fasterxml.jackson.annotation.JsonFormat;import java.util.Date;import lombok.Data;/** * 添加笔记入参 * * @author lianyutian * @since 2025-01-02 17:16:18 * @version 1.0 */@Datapublic class NoteAddParam /** 笔记图片链接 */ private String imgUrls; /** 笔记标题 */ private String title; /** 正文内容 */ private String content; /** 笔记视频链接 */ private String videoUrl; /** 自主声明 */ private String declaration; /** 1 公开可见，2 仅自己可见，3 仅互关好友可见，4 部分人可见 5 部分人不可见 */ private Integer visibleRange; /** 发布时间 */ @JsonFormat(pattern = yyyy-MM-dd HH:mm:ss, timezone = GMT+8) private Date publishTime; cshop-notesrcmainJavagithublianyutiancshopnotecontrollerNoteController.Java package github.lianyutian.cshop.note.controller;import github.lianyutian.cshop.common.enums.BizCodeEnum;import github.lianyutian.cshop.common.model.ApiResult;import github.lianyutian.cshop.note.model.param.NoteAddParam;import github.lianyutian.cshop.note.model.param.NoteEditParam;import github.lianyutian.cshop.note.model.vo.NoteDetailVO;import github.lianyutian.cshop.note.service.NoteService;import lombok.AllArgsConstructor;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * NoteController * * @author lianyutian * @since 2025-01-02 17:14:17 * @version 1.0 */@RestController@RequestMapping(/api/note/v1)@AllArgsConstructorpublic class NoteController private final NoteService noteService; /** * 添加笔记 * * @param noteAddParam 笔记入参 * @return 添加结果 */ @PostMapping(add) public ApiResultVoid addNote(@RequestBody NoteAddParam noteAddParam) int added = noteService.addNote(noteAddParam); return added 0 ? ApiResult.success() : ApiResult.result(BizCodeEnum.NOTE_ADD_FAIL); cshop-notesrcmainJavagithublianyutiancshopnoteserviceNoteService.Java package github.lianyutian.cshop.note.service;import github.lianyutian.cshop.note.model.param.NoteAddParam;import github.lianyutian.cshop.note.model.param.NoteEditParam;import github.lianyutian.cshop.note.model.vo.NoteDetailVO;/** * 笔记服务 * * @author lianyutian * @since 2025-01-03 10:53:40 * @version 1.0 */public interface NoteService /** * 添加笔记 * * @param noteAddParam 笔记入参 */ int addNote(NoteAddParam noteAddParam); cshop-notesrcmainJavagithublianyutiancshopnoteserviceimplNoteServiceImpl.Java package github.lianyutian.cshop.note.service.impl;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;import github.lianyutian.cshop.common.enums.BizCodeEnum;import github.lianyutian.cshop.common.exception.BizException;import github.lianyutian.cshop.common.interceptor.LoginInterceptor;import github.lianyutian.cshop.common.model.LoginUserInfo;import github.lianyutian.cshop.common.redis.RedisCache;import github.lianyutian.cshop.common.redis.RedisLock;import github.lianyutian.cshop.common.utils.BeanUtil;import github.lianyutian.cshop.common.utils.JsonUtil;import github.lianyutian.cshop.note.constant.NoteCacheKeyConstant;import github.lianyutian.cshop.note.constant.NoteRocketMQConstant;import github.lianyutian.cshop.note.enums.NoteMessageType;import github.lianyutian.cshop.note.enums.NoteStatusEnum;import github.lianyutian.cshop.note.mapper.NoteMapper;import github.lianyutian.cshop.note.model.param.NoteAddParam;import github.lianyutian.cshop.note.model.param.NoteEditParam;import github.lianyutian.cshop.note.model.po.Note;import github.lianyutian.cshop.note.model.vo.NoteDetailVO;import github.lianyutian.cshop.note.model.vo.NoteShowVO;import github.lianyutian.cshop.note.mq.message.NoteAddMessage;import github.lianyutian.cshop.note.mq.message.NoteUpdateMessage;import github.lianyutian.cshop.note.mq.producer.NoteTransactionProducer;import github.lianyutian.cshop.note.service.NoteService;import java.util.Date;import java.util.concurrent.TimeUnit;import lombok.AllArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;/** * 笔记服务实现类 * * @author lianyutian * @since 2025-01-03 10:54:31 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class NoteServiceImpl implements NoteService private final NoteMapper noteMapper; @Override @Transactional(rollbackFor = Exception.class) public int addNote(NoteAddParam noteAddParam) LoginUserInfo loginUserInfo = LoginInterceptor.USER_THREAD_LOCAL.get(); Note note = BeanUtil.copy(noteAddParam, Note.class); note.setUserId(loginUserInfo.getId()); note.setStatus(NoteStatusEnum.AUDITING); note.setPublishTime(new Date()); int row; try row = noteMapper.insert(note); catch (Exception e) log.error(db addNote error , e.getMessage(), e); throw new BizException(BizCodeEnum.NOTE_ADD_FAIL); log.info(笔记服务-新增笔记：rows=，data=, row, JsonUtil.toJson(noteAddParam)); return row; 7.14.3 修改笔记 cshop-notesrcmainJavagithublianyutiancshopnotemodelparamNoteEditParam.Java package github.lianyutian.cshop.note.model.param;import com.fasterxml.jackson.annotation.JsonFormat;import java.util.Date;import lombok.Data;/** * 笔记修改入参 * * @author lianyutian * @since 2025-01-03 11:07:53 * @version 1.0 */@Datapublic class NoteEditParam /** 笔记 id */ private Long id; /** 笔记图片链接 */ private String imgUrls; /** 笔记标题 */ private String title; /** 正文内容 */ private String content; /** 笔记视频链接 */ private String videoUrl; /** 自主声明 */ private String declaration; /** 1 公开可见，2 仅自己可见，3 仅互关好友可见，4 部分人可见 5 部分人不可见 */ private Integer visibleRange; /** 发布时间 */ @JsonFormat(pattern = yyyy-MM-dd HH:mm:ss, timezone = GMT+8) private Date publishTime; package github.lianyutian.cshop.note.controller;/** * NoteController * * @author lianyutian * @since 2025-01-02 17:14:17 * @version 1.0 */@RestController@RequestMapping(/api/note/v1)@AllArgsConstructorpublic class NoteController private final NoteService noteService; /** * 更新我的笔记 * * @param noteAddParam 更新笔记入参 * @return 更新结果 */ @PostMapping(edit) public ApiResultVoid updateNote(@RequestBody NoteEditParam noteAddParam) int updated = noteService.updateNote(noteAddParam); return updated 0 ? ApiResult.success() : ApiResult.result(BizCodeEnum.NOTE_UPDATE_FAIL); package github.lianyutian.cshop.note.service;/** * 笔记服务 * * @author lianyutian * @since 2025-01-03 10:53:40 * @version 1.0 */public interface NoteService /** * 更新笔记 * * @param noteAddParam 笔记更新入参 */ int updateNote(NoteEditParam noteAddParam); package github.lianyutian.cshop.note.service.impl;/** * 笔记服务实现类 * * @author lianyutian * @since 2025-01-03 10:54:31 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class NoteServiceImpl implements NoteService private final NoteMapper noteMapper; @Override @Transactional(rollbackFor = Exception.class) public int updateNote(NoteEditParam noteEditParam) // 1.查询笔记是否存在 LoginUserInfo loginUserInfo = LoginInterceptor.USER_THREAD_LOCAL.get(); Note updateNote = BeanUtil.copy(noteEditParam, Note.class); int row = 0; try row = noteMapper.update( updateNote, new LambdaUpdateWrapperNote() .eq(Note::getId, noteEditParam.getId()) .eq(Note::getUserId, loginUserInfo.getId())); log.info(笔记服务-更新笔记：row=, data=, row, JsonUtil.toJson(noteEditParam)); return row; catch (Exception e) log.error(updateNote error , e.getMessage(), e); throw new BizException(BizCodeEnum.NOTE_UPDATE_FAIL); 7.14.4 删除笔记package github.lianyutian.cshop.note.controller;/** * NoteController * * @author lianyutian * @since 2025-01-02 17:14:17 * @version 1.0 */@RestController@RequestMapping(/api/note/v1)@AllArgsConstructorpublic class NoteController private final NoteService noteService; /** * 删除我的笔记 * * @param noteId noteId * @return 删除结果 */ @GetMapping(delete/noteId) public ApiResultVoid delete(@PathVariable(noteId) long noteId) int deleted = noteService.deleteNote(noteId); return deleted 0 ? ApiResult.success() : ApiResult.result(BizCodeEnum.NOTE_DEL_FAIL); package github.lianyutian.cshop.note.service;/** * 笔记服务 * * @author lianyutian * @since 2025-01-03 10:53:40 * @version 1.0 */public interface NoteService /** * 删除笔记 * * @param id 笔记 id */ int deleteNote(long id); package github.lianyutian.cshop.note.service.impl;/** * 笔记服务实现类 * * @author lianyutian * @since 2025-01-03 10:54:31 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class NoteServiceImpl implements NoteService private final NoteMapper noteMapper; @Override @Transactional(rollbackFor = Exception.class) public int deleteNote(long id) return noteMapper.deleteById(id); 7.14.5 获取我的笔记详情 cshop-notesrcmainJavagithublianyutiancshopnotemodelvoNoteDetailVO.Java package github.lianyutian.cshop.note.model.vo;import java.util.Date;import lombok.Data;/** * 笔记 VO * * @author lianyutian * @since 2025-01-03 11:06:30 * @version 1.0 */@Datapublic class NoteDetailVO /** 笔记 id */ private long id; /** 笔记图片链接 */ private String imgUrls; /** 笔记标题 */ private String title; /** 正文内容 */ private String content; /** 笔记视频链接 */ private String videoUrl; /** 自主声明 */ private String declaration; /** 1 公开可见，2 仅自己可见，3 仅互关好友可见，4 部分人可见 5 部分人不可见 */ private Integer visibleRange; /** 发布时间 */ private Date publishTime; package github.lianyutian.cshop.note.controller;import github.lianyutian.cshop.common.enums.BizCodeEnum;import github.lianyutian.cshop.common.model.ApiResult;import github.lianyutian.cshop.note.model.param.NoteAddParam;import github.lianyutian.cshop.note.model.param.NoteEditParam;import github.lianyutian.cshop.note.model.vo.NoteDetailVO;import github.lianyutian.cshop.note.service.NoteService;import lombok.AllArgsConstructor;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * NoteController * * @author lianyutian * @since 2025-01-02 17:14:17 * @version 1.0 */@RestController@RequestMapping(/api/note/v1)@AllArgsConstructorpublic class NoteController private final NoteService noteService; /** * 获取我的笔记详情 * * @param noteId noteId * @return 笔记详情信息 */ @GetMapping(/detail/noteId) public ApiResultNoteDetailVO detail(@PathVariable(noteId) Long noteId) return ApiResult.success(noteService.getNoteDetail(noteId)); package github.lianyutian.cshop.note.service;/** * 笔记服务 * * @author lianyutian * @since 2025-01-03 10:53:40 * @version 1.0 */public interface NoteService /** * 获取笔记详情 * * @param noteId 笔记 id */ NoteDetailVO getNoteDetail(Long noteId); package github.lianyutian.cshop.note.service.impl;/** * 笔记服务实现类 * * @author lianyutian * @since 2025-01-03 10:54:31 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class NoteServiceImpl implements NoteService private final NoteMapper noteMapper; @Override public NoteDetailVO getNoteDetail(Long noteId) LoginUserInfo loginUserInfo = LoginInterceptor.USER_THREAD_LOCAL.get(); Note note = noteMapper.selectOne( new LambdaQueryWrapperNote() .eq(Note::getId, noteId) .eq(Note::getUserId, loginUserInfo.getId())); if (note == null) return null; return BeanUtil.copy(note, NoteDetailVO.class); 7.14.6 查看他人笔记详情 cshop-notesrcmainJavagithublianyutiancshopnotemodelvoNoteShowVO.Java package github.lianyutian.cshop.note.model.vo;import java.util.Date;import lombok.Data;/** * 笔记展示 VO * * @author lianyutian * @since 2025-01-03 11:06:30 * @version 1.0 */@Datapublic class NoteShowVO /** 笔记 id */ private long id; /** 笔记图片链接 */ private String imgUrls; /** 笔记标题 */ private String title; /** 正文内容 */ private String content; /** 笔记视频链接 */ private String videoUrl; /** 自主声明 */ private String declaration; /** 发布时间 */ private Date publishTime; cshop-notesrcmainJavagithublianyutiancshopnotecontrollerNoteShowController.Java package github.lianyutian.cshop.note.controller;/** * 用户笔记展示 * * @author lianyutian * @since 2025-01-09 10:12:54 * @version 1.0 */@RestController@RequestMapping(/api/note/v1)@AllArgsConstructorpublic class NoteShowController private final NoteShowService noteShowService; /** * 获取笔记详情 * * @param noteId 笔记 ID * @return 笔记详情 */ @PostMapping(detail/show) public ApiResultNoteShowVO getNoteShow(@RequestBody Long noteId) if (noteId == null) return ApiResult.result(BizCodeEnum.COMMON_PARAM_ERROR); NoteShowVO noteShowVO = noteShowService.getNoteShow(noteId); return noteShowVO == null ? ApiResult.result(BizCodeEnum.NOTE_NOT_EXITS) : ApiResult.success(noteShowVO); cshop-notesrcmainJavagithublianyutiancshopnoteserviceNoteShowService.Java package github.lianyutian.cshop.note.service;/** * 用户笔记展示 * * @author lianyutian * @since 2025-01-09 10:15:18 * @version 1.0 */public interface NoteShowService /** * 获取笔记展示详情 * * @param noteId 笔记 ID * @return 笔记详情 */ NoteShowVO getNoteShow(Long noteId); cshop-notesrcmainJavagithublianyutiancshopnoteserviceimplNoteShowServiceImpl.Java package github.lianyutian.cshop.note.service.impl;/** * 用户笔记展示实现 * * @author lianyutian * @since 2025-01-09 10:18:39 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class NoteShowServiceImpl implements NoteShowService private final NoteMapper noteMapper; @Override public NoteShowVO getNoteShow(Long noteId) Note note = noteMapper.selectOne( new LambdaQueryWrapperNote() .eq(Note::getId, noteId) .eq(Note::getStatus, NoteStatusEnum.PUBLISHED.getCode())); if (note == null) log.info(【getNoteShow】笔记不存在 , noteId); return null; return BeanUtil.copy(note, NoteShowVO.class); 7.14.7 查看笔记分页列表 cshop-notesrcmainJavagithublianyutiancshopnoteconfigMybatisPlusConfig.Java package github.lianyutian.cshop.note.config;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * MybatisPlus 插件配置 * * @author lianyutian * @since 2025-01-03 13:46:12 * @version 1.0 */@Configurationpublic class MybatisPlusConfig /** 添加分页插件 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; cshop-commonsrcmainJavagithublianyutiancshopcommonmodelvoPageVO.Java package github.lianyutian.cshop.common.model.vo;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import com.fasterxml.jackson.annotation.JsonIgnore;import java.util.Collections;import java.util.List;import java.util.Objects;import lombok.AllArgsConstructor;import lombok.Data;/** * 分页返回结果 * * @author lianyutian * @since 2025-01-03 14:19:25 * @version 1.0 */@Data@AllArgsConstructorpublic class PageVOT /** 总条数 */ protected Long total; /** 总页码数 */ protected Long pages; /** 当前页数据 */ protected ListT list; public static T PageVOT empty(Page? page) return new PageVO( Objects.requireNonNull(page, Page cannot be null).getTotal(), page.getPages(), Collections.emptyList()); public static T PageVOT of(Page? page, ListT list) if (page == null) throw new IllegalArgumentException(Page cannot be null); if (list == null) throw new IllegalArgumentException(List cannot be null); return new PageVO(page.getTotal(), page.getPages(), Collections.unmodifiableList(list)); @JsonIgnore public boolean isEmpty() return list.isEmpty(); cshop-commonsrcmainJavagithublianyutiancshopcommonmodelparamPageParam.Java package github.lianyutian.cshop.common.model.param;import com.baomidou.mybatisplus.core.metadata.OrderItem;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import jakarta.validation.constraints.Min;import lombok.Data;import org.apache.commons.lang3.StringUtils;/** * 分页查询入参 * * @author lianyutian * @since 2025-01-03 14:53:29 * @version 1.0 */@Datapublic class PageParam public static final Integer DEFAULT_PAGE_SIZE = 20; public static final Integer DEFAULT_PAGE_NUM = 1; /** 页码 */ @Min(value = 1, message = 页码不能小于1) private final Integer pageNo = DEFAULT_PAGE_NUM; /** 每页大小 */ @Min(value = 1, message = 每页查询数量不能小于1) private final Integer pageSize = DEFAULT_PAGE_SIZE; /** 是否升序 */ private Boolean isAsc = true; /** 排序字段 */ private String sortBy; public int from() return (pageNo - 1) * pageSize; public T PageT toMpPage(OrderItem... orderItems) PageT page = new Page(pageNo, pageSize); // 是否手动指定排序方式 if (orderItems != null orderItems.length 0) for (OrderItem orderItem : orderItems) page.addOrder(orderItem); return page; // 前端是否有排序字段 if (StringUtils.isNotEmpty(sortBy)) OrderItem orderItem = new OrderItem(); orderItem.setAsc(isAsc); orderItem.setColumn(sortBy); page.addOrder(orderItem); return page; public T PageT toMpPage(String defaultSortBy, boolean isAsc) if (StringUtils.isBlank(sortBy)) sortBy = defaultSortBy; this.isAsc = isAsc; PageT page = new Page(pageNo, pageSize); OrderItem orderItem = new OrderItem(); orderItem.setAsc(this.isAsc); orderItem.setColumn(sortBy); page.addOrder(orderItem); return page; public T PageT toMpPageDefaultSortByCreateTimeDesc() return toMpPage(create_time, false); cshop-notesrcmainJavagithublianyutiancshopnotemodelparamNotePageParam.Java package github.lianyutian.cshop.note.model.param;import github.lianyutian.cshop.common.model.param.PageParam;import lombok.Data;import lombok.EqualsAndHashCode;/** * 分页查询笔记入参 * * @author lianyutian * @since 2025-01-03 13:51:14 * @version 1.0 */@EqualsAndHashCode(callSuper = true)@Datapublic class NotePageParam extends PageParam /** 博主 ID */ private Long userId; package github.lianyutian.cshop.note.controller;/** * 用户笔记展示 * * @author lianyutian * @since 2025-01-09 10:12:54 * @version 1.0 */@RestController@RequestMapping(/api/note/v1)@AllArgsConstructorpublic class NoteShowController private final NoteShowService noteShowService; /** * 分页查询用户笔记列表 * * @param notePageParam 笔记列表入参 * @return 我的笔记列表 */ @PostMapping(list/show) public ApiResultPageVONoteShowVO getNoteShowList(@RequestBody NotePageParam notePageParam) return ApiResult.success(noteShowService.getNoteShowList(notePageParam)); package github.lianyutian.cshop.note.service;/** * 用户笔记展示 * * @author lianyutian * @since 2025-01-09 10:15:18 * @version 1.0 */public interface NoteShowService /** * 获取笔记展示列表 * * @param notePageParam 查询入参 * @return 笔记列表 */ PageVONoteShowVO getNoteShowList(NotePageParam notePageParam); package github.lianyutian.cshop.note.service.impl;/** * 用户笔记展示实现 * * @author lianyutian * @since 2025-01-09 10:18:39 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class NoteShowServiceImpl implements NoteShowService private final NoteMapper noteMapper; @Override public PageVONoteShowVO getNoteShowList(NotePageParam notePageParam) Long userId = notePageParam.getUserId(); // 查询数据库 LambdaQueryWrapperNote lambdaQueryWrapper = new LambdaQueryWrapper(); lambdaQueryWrapper .eq(Note::getUserId, userId) .eq(Note::getStatus, NoteStatusEnum.PUBLISHED) .orderByAsc(Note::getCreateTime); PageNote notePage = noteMapper.selectPage( notePageParam.toMpPageDefaultSortByCreateTimeDesc(), lambdaQueryWrapper); ListNoteShowVO noteShowList = BeanUtil.copyList(notePage.getRecords(), NoteShowVO.class); if (CollectionUtils.isEmpty(noteShowList)) return PageVO.empty(notePage); log.info(从数据库获取笔记信息 , JsonUtil.toJson(noteShowList)); return PageVO.of(notePage, noteShowList); 7.14.8 引入缓存7.14.8.1 获取我的笔记详情 获取我的笔记详情是一个读多写少的场景，笔记的更新频率是很少的。一般都是读操作，且获取自己笔记详情是没有并发场景只存在自己调该接口不需要锁。 cshop-notesrcmainJavagithublianyutiancshopnoteconstantNoteCacheKeyConstant.Java package github.lianyutian.cshop.note.constant;/** * 笔记缓存常量 * * @author lianyutian * @since 2025-01-08 14:06:12 * @version 1.0 */public class NoteCacheKeyConstant /** 笔记信息更新锁前缀 */ public static final String NOTE_UPDATE_LOCK_KEY_PREFIX = cshop-note:update:lock:; /** 笔记展示信息缓存前缀 */ public static final String NOTE_SHOW_KEY_PREFIX = cshop-note:show:; /** 笔记信息缓存前缀 */ public static final String NOTE_DETAIL_KEY_PREFIX = cshop-note:detail:; /** 笔记信息分页缓存前缀 */ public static final String NOTE_SHOW_PAGE_KEY_PREFIX = cshop-note:show-page:; /** 用户笔记信息总数缓存前缀 */ public static final String NOTE_TOTAL_KEY_PREFIX = cshop-note:total:; package github.lianyutian.cshop.note.service.impl;/** * 笔记服务实现类 * * @author lianyutian * @since 2025-01-03 10:54:31 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class NoteServiceImpl implements NoteService private final NoteMapper noteMapper; private final RedisCache redisCache; @Override public NoteDetailVO getNoteDetail(Long noteId) LoginUserInfo loginUserInfo = LoginInterceptor.USER_THREAD_LOCAL.get(); String noteDetailKey = NoteCacheKeyConstant.NOTE_DETAIL_KEY_PREFIX + noteId; NoteDetailVO noteDetailFromCache = getNoteDetailFromCache(noteDetailKey); if (noteDetailFromCache != null) return noteDetailFromCache; Note note = noteMapper.selectOne( new LambdaQueryWrapperNote() .eq(Note::getId, noteId) .eq(Note::getUserId, loginUserInfo.getId())); if (note == null) return null; return BeanUtil.copy(note, NoteDetailVO.class); private NoteDetailVO getNoteDetailFromCache(String noteDetailKey) String noteDetailFromCache = redisCache.get(noteDetailKey); if (StringUtils.isNotBlank(noteDetailFromCache)) Long expire = redisCache.getExpire(noteDetailKey, TimeUnit.SECONDS); // 如果过期时间已经在 1 小时内了就自动延期 if (expire RedisCache.ONE_HOUR_SECONDS) // 缓存精准自动延期 2 天 + 随机几个小时 redisCache.expire(noteDetailKey, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); return JsonUtil.fromJson(noteDetailFromCache, NoteDetailVO.class); return null; 7.14.8.2 查看他人笔记详情 查看他人笔记详情就需要考虑并发问题了。 场景 1：A 用户的某篇笔记爆火，此时就可能会存在成千或上万用户同时来查看这一篇笔记，所以需要使用缓存来抗住这些并发请求。 场景 2：在场景 1 的基础上，A 用户发现笔记有描述错误去更新了笔记。这个时候需要考虑笔记缓存和数据库中数据一致性问题。例如 B 用户线程请求笔记详情时，缓存刚好过期。这个时候去查询数据库获取到了笔记数据，接下来要更新缓存但是此时线程时间片用完被暂停。这时用户 A 线程去修改笔记，并更新数据库同时更新缓存。在用户 A 线程更新完缓存后，用户 B 线程才继续执行再去更新缓存，这个时候缓存中就是旧数据，数据库中是新数据。 package github.lianyutian.cshop.note.service.impl;/** * 用户笔记展示实现 * * @author lianyutian * @since 2025-01-09 10:18:39 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class NoteShowServiceImpl implements NoteShowService private final RedisCache redisCache; private final RedisLock redisLock; private final NoteMapper noteMapper; @Override public NoteShowVO getNoteShow(Long noteId) String noteShowKey = NoteCacheKeyConstant.NOTE_SHOW_KEY_PREFIX + noteId; NoteShowVO noteDetailFromCache = getNoteShowFromCache(noteShowKey); if (noteDetailFromCache != null) return noteDetailFromCache; return getNoteShowFromDB(noteShowKey, noteId); private NoteShowVO getNoteShowFromCache(String noteShowKey) String noteDetailFromCache = redisCache.get(noteShowKey); if (StringUtils.isNotBlank(noteDetailFromCache)) Long expire = redisCache.getExpire(noteShowKey, TimeUnit.SECONDS); // 如果过期时间已经在 1 小时内了就自动延期 if (expire RedisCache.ONE_HOUR_SECONDS) // 缓存精准自动延期 2 天 + 随机几个小时 redisCache.expire(noteShowKey, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); return JsonUtil.fromJson(noteDetailFromCache, NoteShowVO.class); return null; private NoteShowVO getNoteShowFromDB(String noteDetailKey, Long noteId) /* 1.设置分布式锁防止超高并发请求打到数据库 2.保证笔记数据更新时缓存和数据库的数据一致性 */ String noteUpdateLockKey = NoteCacheKeyConstant.NOTE_UPDATE_LOCK_KEY_PREFIX + noteId; boolean locked = false; try locked = redisLock.tryLock(noteUpdateLockKey, RedisLock.UPDATE_LOCK_TIMEOUT); if (!locked) // 加锁超时时间有 200ms, 所以再次尝试获取缓存 NoteShowVO noteDetailFromCache = getNoteShowFromCache(noteDetailKey); if (noteDetailFromCache != null) return noteDetailFromCache; log.warn(【getNoteShowDetail】笔记缓存为空，查询笔记信息获取锁失败 , noteId); throw new BizException(BizCodeEnum.NOTE_INFO_LOCK_FAIL); // 获取锁成功，查询数据库 Note note = noteMapper.selectOne( new LambdaQueryWrapperNote() .eq(Note::getId, noteId) .eq(Note::getStatus, NoteStatusEnum.PUBLISHED.getCode())); if (note == null) log.warn(【getNoteShowDetail】笔记不存在 , noteId); // 防止同时间大量无效 noteId 穿透缓存打到数据库造成缓存穿透 redisCache.set( noteDetailKey, RedisCache.EMPTY_CACHE, RedisCache.generateCachePenetrationExpire(), TimeUnit.MILLISECONDS); return null; return BeanUtil.copy(note, NoteShowVO.class); catch (InterruptedException e) NoteShowVO noteDetailFromCache = getNoteShowFromCache(noteDetailKey); if (noteDetailFromCache != null) return noteDetailFromCache; log.error(【getNoteShow】尝试加锁异常，异常信息：, e.getMessage(), e); throw new BizException(BizCodeEnum.NOTE_INFO_LOCK_FAIL); finally if (locked) redisLock.unlock(noteUpdateLockKey); 7.14.8.3 查看笔记分页列表package github.lianyutian.cshop.note.service.impl;/** * 用户笔记展示实现 * * @author lianyutian * @since 2025-01-09 10:18:39 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class NoteShowServiceImpl implements NoteShowService private final RedisCache redisCache; private final RedisLock redisLock; private final NoteMapper noteMapper; @Override public PageVONoteShowVO getNoteShowList(NotePageParam notePageParam) // 从缓存查询分页数据 ListNoteShowVO noteListFromCache = getNoteShowListFromCache( NoteCacheKeyConstant.NOTE_SHOW_PAGE_KEY_PREFIX + notePageParam.getUserId() + : + notePageParam.getPageNo()); if (!CollectionUtils.isEmpty(noteListFromCache)) return getNotePage(notePageParam, noteListFromCache); ListNoteShowVO noteListFromDB = getNoteShowListFromDB(notePageParam); if (!CollectionUtils.isEmpty(noteListFromDB)) return getNotePage(notePageParam, noteListFromDB); return null; /** * 获取缓存的分页笔记信息 * * @param notePageInfoKey 分页缓存 key * @return 分页笔记信息 */ @SuppressWarnings(unchecked) private ListNoteShowVO getNoteShowListFromCache(String notePageInfoKey) String cachePageInfo = redisCache.get(notePageInfoKey); if (StringUtils.isNotBlank(cachePageInfo)) Long expire = redisCache.getExpire(notePageInfoKey, TimeUnit.SECONDS); // 如果过期时间已经在 1 小时内了就自动延期 if (expire RedisCache.ONE_HOUR_SECONDS) // 缓存精准自动延期 2 天 + 随机几个小时 redisCache.expire(notePageInfoKey, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); return JsonUtil.fromJson(cachePageInfo, List.class); return null; private ListNoteShowVO getNoteShowListFromDB(NotePageParam notePageParam) Long userId = notePageParam.getUserId(); // 分布式锁 key String noteUpdateLockKey = NoteCacheKeyConstant.NOTE_UPDATE_LOCK_KEY_PREFIX + userId; boolean tryLocked = false; // 笔记分页缓存 key String notePageKey = NoteCacheKeyConstant.NOTE_SHOW_PAGE_KEY_PREFIX + userId + : + notePageParam.getPageNo(); try tryLocked = redisLock.tryLock(noteUpdateLockKey, RedisCache.UPDATE_LOCK_TIMEOUT); if (!tryLocked) /* 尝试加锁时间有 RedisCache.UPDATE_LOCK_TIMEOUT 有可能其他线程已经获取数据并写入缓存了所以这里再尝试去读下缓存 */ ListNoteShowVO noteListFromCache = getNoteShowListFromCache(notePageKey); if (!CollectionUtils.isEmpty(noteListFromCache)) return noteListFromCache; log.info(【getNoteListFromDB】笔记缓存为空，查询笔记信息获取锁失败 , userId); return null; // 查询数据库 LambdaQueryWrapperNote lambdaQueryWrapper = new LambdaQueryWrapper(); lambdaQueryWrapper .eq(Note::getUserId, userId) .eq(Note::getStatus, NoteStatusEnum.PUBLISHED) .orderByAsc(Note::getCreateTime); PageNote notePage = noteMapper.selectPage( notePageParam.toMpPageDefaultSortByCreateTimeDesc(), lambdaQueryWrapper); ListNoteShowVO noteShowList = BeanUtil.copyList(notePage.getRecords(), NoteShowVO.class); if (CollectionUtils.isEmpty(noteShowList)) // 防止缓存穿透 redisCache.set( notePageKey, RedisCache.EMPTY_CACHE, RedisCache.generateCachePenetrationExpire(), TimeUnit.MILLISECONDS); return null; redisCache.set( notePageKey, noteShowList, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); log.info(【getNoteListFromDB】笔记缓存为空，从数据库获取笔记信息 , JsonUtil.toJson(noteShowList)); return noteShowList; catch (InterruptedException e) // 加锁失败 // 这里再去尝试获取下缓存-双重检查 ListNoteShowVO noteListFromCache = getNoteShowListFromCache(notePageKey); if (!CollectionUtils.isEmpty(noteListFromCache)) return noteListFromCache; log.error(【getNoteListFromDB】尝试加锁异常，异常信息：, e.getMessage(), e); throw new BizException(BizCodeEnum.NOTE_INFO_LOCK_FAIL); finally if (tryLocked) redisLock.unlock(noteUpdateLockKey); private PageVONoteShowVO getNotePage(NotePageParam notePageParam, ListNoteShowVO noteList) // 计算我的笔记列表总数 String userNoteTotalKey = NoteCacheKeyConstant.NOTE_TOTAL_KEY_PREFIX + notePageParam.getUserId(); // 笔记总条数 Long total = redisCache.getLong(userNoteTotalKey); // 计算总页数 double totalPages = Math.ceil((double) total / notePageParam.getPageSize()); return new PageVO(total, (long) totalPages, Collections.unmodifiableList(noteList)); 7.14.9 重建分页缓存 用户查询笔记分页时，会从数据库根据分页数查询分页记录并把结果写入到缓存。如果用户添加更新了一篇新笔记，那么整个分页缓存记录都需要重新构建。重建缓存是个耗时的过程，所以引入 RocketMq 做一个异步更新操作。添加更新一篇笔记后会发送 MQ 消息，消费端监听消息，重建缓存。 pom.xml !-- rocketmq 版本 --rocketmq-starter.version2.2.1/rocketmq-starter.versiondependency groupIdorg.apache.rocketmq/groupId artifactIdrocketmq-spring-boot-starter/artifactId version$rocketmq-starter.version/version/dependency cshop-commonpom.xml dependency groupIdorg.apache.rocketmq/groupId artifactIdrocketmq-spring-boot-starter/artifactId/dependency cshop-notepom.xml dependency groupIdorg.apache.rocketmq/groupId artifactIdrocketmq-client/artifactId/dependency cshop-commonsrcmainJavagithublianyutiancshopcommonmqRocketMQConfig.Java package github.lianyutian.cshop.common.mq;import lombok.Data;import org.apache.rocketmq.acl.common.AclClientRPCHook;import org.apache.rocketmq.acl.common.SessionCredentials;import org.apache.rocketmq.remoting.RPCHook;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * rocketmq 配置类 * * @author lianyutian * @since 2025-01-15 10:26:51 * @version 1.0 */@Data@Configuration@ConditionalOnProperty(prefix = rocketmq, value = nameServer)public class RocketMQConfig @Value($rocketmq.nameServer) private String nameServer; @Value($rocketmq.accessKey) private String accessKey; @Value($rocketmq.secretKey) private String secretKey; /** * 鉴权 hook * * @return RPCHook */ @Bean public RPCHook rpcHook() return new AclClientRPCHook(new SessionCredentials(accessKey, secretKey)); cshop-notesrcmainresourcesapplication.yml # rocketmq配置rocketmq: accessKey: mqadmin secretKey: MIIEowIBAAKCAQEAwG90ULRHmAXFXQzZSwleoYts2+bCzUvqhhqtGiv/F5kUsETY nameServer: 116.198.217.158:9876 cshop-notesrcmainJavagithublianyutiancshopnoteconstantNoteRocketMQConstant.Java package github.lianyutian.cshop.note.constant;/** * MQ 常量类 * * @author lianyutian * @since 2025-01-14 14:53:14 * @version 1.0 */public class NoteRocketMQConstant public static final String NOTE_UPDATE_PRODUCER_GROUP = note-update-producer-group; public static final String NOTE_UPDATE_TOPIC = note-update-topic; cshop-notesrcmainJavagithublianyutiancshopnoteenumsNoteMessageType.Java package github.lianyutian.cshop.note.enums;import lombok.Getter;/** * 笔记 MQ 消息类型枚举 * * @author lianyutian * @since 2025-01-15 14:26:26 * @version 1.0 */@Getterpublic enum NoteMessageType /** 笔记新增消息 */ ADD_NOTE(ADD, 新增笔记消息), /** 笔记更新消息 */ UPDATE_NOTE(UPDATE, 更新笔记消息); private final String type; private final String message; NoteMessageType(String type, String message) this.type = type; this.message = message; cshop-notesrcmainJavagithublianyutiancshopnotemqmessageNoteUpdateMessage.Java package github.lianyutian.cshop.note.mq.message;import java.io.Serializable;import lombok.Builder;import lombok.Getter;import lombok.Setter;/** * 笔记更新消息 * * @author lianyutian * @since 2025-01-14 16:16:40 * @version 1.0 */@Getter@Setter@Builderpublic class NoteUpdateMessage implements Serializable /** 笔记 ID */ private Long noteId; /** 博主 ID */ private Long userId; cshop-notesrcmainJavagithublianyutiancshopnotemqproducerNoteTransactionProducer.Java package github.lianyutian.cshop.note.mq.producer;/** * 笔记事务消息生产者 * * @author lianyutian * @since 2025-01-14 14:52:03 * @version 1.0 */@Getter@Component@Slf4jpublic class NoteTransactionProducer private final TransactionMQProducer producer; @Autowired public NoteTransactionProducer( RocketMQConfig rocketMQConfig, RPCHook rpcHook, NoteAddListener noteAddListener) // 初始化事务生产者客户端，设置对应的生产者组 producer = new TransactionMQProducer(NoteRocketMQConstant.NOTE_UPDATE_PRODUCER_GROUP, rpcHook); // 设置 nameserver producer.setNamesrvAddr(rocketMQConfig.getNameServer()); producer.setTransactionListener(noteAddListener); // 启动生产者服务 start(); /** 启动 rocketmq 生产者服务 该对象在使用之前必须要调用一次，只能初始化一次 */ public void start() try this.producer.start(); catch (MQClientException e) log.error(rocketmq producer start error, e); /** 关闭 rocketmq 生产者 */ public void shutdown() this.producer.shutdown(); /** * 发送事务消息 * * @param topic topic * @param tag tag * @param message 消息 * @param arg 额外参数 * @param type 消息类型 */ public void sendTransactionMessage( String topic, String tag, String message, Object arg, NoteMessageType type) Message msg = new Message(topic, tag, message.getBytes(StandardCharsets.UTF_8)); try SendResult send = producer.sendMessageInTransaction(msg, arg); if (SendStatus.SEND_OK == send.getSendStatus()) log.info(发送 MQ 消息成功, type:, message:, arg:, type.getMessage(), message, arg); else throw new BizException(send.getSendStatus().toString()); catch (Exception e) log.error(发送 MQ 消息失败：, e); throw new BizException(发送 MQ 消息失败); /** * 同步发送单条消息 * * @param topic 主题 * @param tag tag * @param message 消息 * @param type 类型 */ public void sendMessage(String topic, String tag, String message, NoteMessageType type) sendDelayMessage(topic, tag, message, DelayLevel.LEVEL_0, type); /** * 发送单条延迟消息 * * @param topic topic * @param tag tag * @param message 消息 * @param delayTimeLevel 延迟等级 * @param type 类型 */ public void sendDelayMessage( String topic, String tag, String message, DelayLevel delayTimeLevel, NoteMessageType type) Message msg = new Message(topic, tag, message.getBytes(StandardCharsets.UTF_8)); try if (delayTimeLevel.getValue() 0) msg.setDelayTimeLevel(delayTimeLevel.getValue()); SendResult send = producer.send(msg); if (SendStatus.SEND_OK == send.getSendStatus()) log.info(发送 MQ 消息成功, type:, message:, type.getMessage(), message); else throw new BizException(send.getSendStatus().toString()); catch (Exception e) log.error(发送 MQ 消息失败：, e); throw new BizException(发送 MQ 消息失败); /** * 批量发送延迟消息 * * @param topic topic * @param tag tag * @param messages 多个消息 * @param delayTimeLevel 延迟等级 * @param type 类型 */ public void sendDelayMessages( String topic, String tag, ListString messages, DelayLevel delayTimeLevel, NoteMessageType type) ListMessage list = new ArrayList(); for (String message : messages) Message msg = new Message(topic, tag, message.getBytes(StandardCharsets.UTF_8)); if (delayTimeLevel.getValue() 0) msg.setDelayTimeLevel(delayTimeLevel.getValue()); list.add(msg); try SendResult send = producer.send(list); if (SendStatus.SEND_OK == send.getSendStatus()) log.info(发送 MQ 消息成功, type:, type.getMessage()); else throw new BizException(send.getSendStatus().toString()); catch (Exception e) log.error(发送 MQ 消息失败：, e); throw new BizException(发送 MQ 消息失败); cshop-notesrcmainJavagithublianyutiancshopnotemqproducerlistenerNoteAddListener.Java package github.lianyutian.cshop.note.mq.producer.listener;/** * 笔记添加消息监听 * * @author lianyutian * @since 2025-01-16 10:59:25 * @version 1.0 */@Slf4j@Component@AllArgsConstructorpublic class NoteAddListener implements TransactionListener private final NoteMapper noteMapper; @Override public LocalTransactionState executeLocalTransaction(Message msg, Object arg) return LocalTransactionState.UNKNOW; @Override public LocalTransactionState checkLocalTransaction(MessageExt msg) return checkNoteAddStatus(msg); private LocalTransactionState checkNoteAddStatus(Message msg) try String messageBody = new String(msg.getBody(), StandardCharsets.UTF_8); NoteUpdateMessage noteAddMessage = JsonUtil.fromJson(messageBody, NoteUpdateMessage.class); if (noteAddMessage == null) log.error(Failed to parse NoteAddMessage from message body: , messageBody); return LocalTransactionState.ROLLBACK_MESSAGE; Long noteId = noteAddMessage.getNoteId(); if (noteId == null) log.error(NoteId is null in NoteAddMessage: , noteAddMessage); return LocalTransactionState.ROLLBACK_MESSAGE; Note note = noteMapper.selectById(noteId); if (note != null) log.info(Note with id found, committing message, noteId); return LocalTransactionState.COMMIT_MESSAGE; else log.warn(Note with id not found, returning unknown state, noteId); return LocalTransactionState.UNKNOW; catch (Exception e) log.error(Error processing message: , e.getMessage(), e); return LocalTransactionState.ROLLBACK_MESSAGE; cshop-notesrcmainJavagithublianyutiancshopnotemqconsumerNoteUpdateConsumerConfig.Java package github.lianyutian.cshop.note.mq.consumer;/** * 默认消费者 * * @author lianyutian * @since 2025-01-15 10:32:28 * @version 1.0 */@Componentpublic class NoteUpdateConsumerConfig @Bean public DefaultMQPushConsumer noteUpdateConsumer( RocketMQConfig rocketMQConfig, NoteUpdateListener noteUpdateListener, NoteAddListener noteAddListener, RPCHook rpcHook) throws MQClientException DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(null, NoteRocketMQConstant.NOTE_UPDATE_PRODUCER_GROUP, rpcHook); consumer.setNamesrvAddr(rocketMQConfig.getNameServer()); consumer.subscribe(NoteRocketMQConstant.NOTE_UPDATE_TOPIC, *); consumer.registerMessageListener(noteUpdateListener); consumer.start(); return consumer; cshop-notesrcmainJavagithublianyutiancshopnotemqconsumerlistenerNoteUpdateListener.Java package github.lianyutian.cshop.note.mq.consumer.listener;/** * 笔记更新消息监听器 * * @author lianyutian * @since 2025-01-15 10:34:58 * @version 1.0 */@Slf4j@Component@AllArgsConstructorpublic class NoteUpdateListener implements MessageListenerConcurrently /** 每页 20 条 */ private static final int PAGE_SIZE = 2; private final RedisCache redisCache; private final RedisLock redisLock; private final NoteMapper noteMapper; @Override public ConsumeConcurrentlyStatus consumeMessage( ListMessageExt noteMessageList, ConsumeConcurrentlyContext context) try for (MessageExt noteMessage : noteMessageList) String msg = new String(noteMessage.getBody()); Long userId; NoteUpdateMessage noteUpdateMessage = JsonUtil.fromJson(msg, NoteUpdateMessage.class); userId = noteUpdateMessage.getUserId(); log.info(笔记 MQ 异步更新-执行博主笔记分页缓存数据异步更新，消息内容：, JsonUtil.toJson(noteUpdateMessage)); // 这里增加分布式锁，同一个用户同时间只能操作一次，避免重复请求 String noteUpdateLockKey = NoteCacheKeyConstant.NOTE_UPDATE_LOCK_KEY_PREFIX + userId; boolean locked = false; try // 这里通过阻塞的方式进行加锁，跟新增/更新笔记操作互斥，并发操作时进行阻塞 locked = redisLock.blockedLock(noteUpdateLockKey); updateCache(userId); finally if (locked) redisLock.unlock(noteUpdateLockKey); catch (Exception e) // 本次消费失败，下次重新消费 log.error(笔记 MQ 异步更新 consume error, 更新博主笔记缓存数据消费失败, e); return ConsumeConcurrentlyStatus.RECONSUME_LATER; log.info(笔记 MQ 异步更新-博主笔记缓存数据消费成功, result: , ConsumeConcurrentlyStatus.CONSUME_SUCCESS); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; private void updateCache(Long userId) // 此时我们需要对博主的笔记列表进行分页缓存重新构建 // 新增需要构建所有笔记分页缓存 // 1、计算我的笔记列表总数 String userNoteTotalKey = NoteCacheKeyConstant.NOTE_TOTAL_KEY_PREFIX + userId; Long size = redisCache.getLong(userNoteTotalKey); log.info(笔记 MQ 异步更新-key:, value:, userNoteTotalKey, size); // 计算总分页数 int pageTotal = (int) Math.ceil((double) size / PAGE_SIZE) + 1; for (int pageNum = 1; pageNum = pageTotal; pageNum++) buildPageCache(userId, pageNum); private void buildPageCache(Long userId, int pageNum) // 笔记分页缓存 key String notePageKey = NoteCacheKeyConstant.NOTE_SHOW_PAGE_KEY_PREFIX + userId + : + pageNum; // 先从缓存中获取一下 String notePageCache = redisCache.get(notePageKey); // 如果分页缓存为空，跳过 if (StringUtils.isBlank(notePageCache)) return; // 只有缓存中存在这一页的数据才会去数据库读取最新的笔记信息去更新 // 查询我的未删除笔记列表 LambdaQueryWrapperNote lambdaQueryWrapper = new LambdaQueryWrapper(); lambdaQueryWrapper .eq(Note::getUserId, userId) .eq(Note::getStatus, NoteStatusEnum.PUBLISHED) .orderByDesc(Note::getUpdateTime); PageNote notePageParam = new Page(pageNum, PAGE_SIZE); PageNote notePage = noteMapper.selectPage(notePageParam, lambdaQueryWrapper); ListNote noteList = notePage.getRecords(); log.info( 笔记 MQ 异步更新-从数据库获取我的笔记列表，pageNum:, total:, size：, userId: , notePage.getPages(), notePage.getTotal(), notePage.getSize(), userId); ListNoteShowVO noteShowVOList = BeanUtil.copyList(noteList, NoteShowVO.class); // 写入分页缓存数据 redisCache.set( notePageKey, noteShowVOList, RedisCache.generateCacheExpire(), TimeUnit.MILLISECONDS); package github.lianyutian.cshop.note.service.impl;/** * 笔记服务实现类 * * @author lianyutian * @since 2025-01-03 10:54:31 * @version 1.0 */@Service@Slf4j@AllArgsConstructorpublic class NoteServiceImpl implements NoteService private final NoteMapper noteMapper; private final RedisLock redisLock; private final RedisCache redisCache; private final NoteTransactionProducer noteTransactionProducer; @Override @Transactional(rollbackFor = Exception.class) public int addNote(NoteAddParam noteAddParam) LoginUserInfo loginUserInfo = LoginInterceptor.USER_THREAD_LOCAL.get(); Note note = BeanUtil.copy(noteAddParam, Note.class); note.setUserId(loginUserInfo.getId()); // note.setStatus(NoteStatusEnum.AUDITING); note.setStatus(NoteStatusEnum.PUBLISHED); note.setPublishTime(new Date()); int row; try row = noteMapper.insert(note); if (row 0) try redisCache.increment( NoteCacheKeyConstant.NOTE_TOTAL_KEY_PREFIX + loginUserInfo.getId(), 1); // 不能因为消息发送失败导致笔记新增失败 // TODO 需要定时任务扫描新增笔记来兜底分页刷新 publishNoteAddedEvent(note.getId(), loginUserInfo.getId()); catch (Exception e) log.error(redis or mq error , e.getMessage(), e); catch (Exception e) log.error(db addNote error , e.getMessage(), e); throw new BizException(BizCodeEnum.NOTE_ADD_FAIL); log.info(笔记服务-新增笔记：rows=，data=, row, JsonUtil.toJson(noteAddParam)); return row; @Override @Transactional(rollbackFor = Exception.class) public int updateNote(NoteEditParam noteEditParam) // 1.查询笔记是否存在 LoginUserInfo loginUserInfo = LoginInterceptor.USER_THREAD_LOCAL.get(); // 这里增加分布式锁是为了保证 Redis 中缓存的笔记数据和 DB 中的笔记数据一致 /* 存在这种场景：假设当前缓存为空，用户 A 更新自己的笔记，同时用户 B 查询用户 A 的笔记。如果这时用户 A 还未更新数据库，用户 B 已经从数据库查询到了数据 同时用户 B 所在线程 CPU 执行时间消耗完被挂起。此时用户 A 再更新数据库成功并将新数据写入缓存。用户 B 线程才继续执行，此时用户 B 查询到的数据是旧的。 又去写入了缓存那么此时的缓存数据就是旧的。 */ String noteUpdateLockKey = NoteCacheKeyConstant.NOTE_UPDATE_LOCK_KEY_PREFIX + noteEditParam.getId(); boolean locked = false; try locked = redisLock.lock(noteUpdateLockKey); if (!locked) log.info(笔记模块-用户修改笔记信息：用户 获取锁失败, 笔记 , loginUserInfo.getId(), noteEditParam.getId()); throw new BizException(BizCodeEnum.NOTE_UPDATE_LOCK_FAIL); Note updateNote = BeanUtil.copy(noteEditParam, Note.class); int row = noteMapper.update( updateNote, new LambdaUpdateWrapperNote() .eq(Note::getId, noteEditParam.getId()) .eq(Note::getUserId, loginUserInfo.getId())); if (row 0) updateNoteCache(noteEditParam.getId()); publishNoteUpdatedEvent(noteEditParam.getId(), loginUserInfo.getId()); log.info(笔记服务-更新笔记：row=, data=, row, JsonUtil.toJson(noteEditParam)); return row; catch (Exception e) log.error(updateNote error , e.getMessage(), e); // 删掉缓存 redisCache.delete(NoteCacheKeyConstant.NOTE_SHOW_KEY_PREFIX + noteEditParam.getId()); redisCache.delete(NoteCacheKeyConstant.NOTE_DETAIL_KEY_PREFIX + noteEditParam.getId()); throw new BizException(BizCodeEnum.NOTE_UPDATE_FAIL); finally if (locked) redisLock.unlock(noteUpdateLockKey); private void publishNoteAddedEvent(Long noteId, Long userId) noteTransactionProducer.sendTransactionMessage( NoteRocketMQConstant.NOTE_UPDATE_TOPIC, NoteMessageType.ADD_NOTE.getType(), JsonUtil.toJson(NoteUpdateMessage.builder().noteId(noteId).userId(userId).build()), null, NoteMessageType.ADD_NOTE); private void publishNoteUpdatedEvent(Long noteId, Long userId) noteTransactionProducer.sendMessage( NoteRocketMQConstant.NOTE_UPDATE_TOPIC, NoteMessageType.UPDATE_NOTE.getType(), JsonUtil.toJson(NoteUpdateMessage.builder().noteId(noteId).userId(userId).build()), NoteMessageType.UPDATE_NOTE); 社交服务优惠券服务后台界面项目创建yarn create vueyarn create v1.22.22[1/4] Resolving packages...[2/4] Fetching packages...[3/4] Linking dependencies...[4/4] Building fresh packages...success Installed create-vue@3.15.1 with binaries: - create-vue[##] 2/2┌ Vue.js - The Progressive JavaScript Framework│◇ 请输入项目名称：│ cshop-admin-front│◇ 请选择要包含的功能： (↑/↓ 切换，空格选择，a 全选，回车确认)│ TypeScript, Router（单页面应用开发）, Pinia（状态管理）, Vitest（单元测试）, ESLint（错误预防）, Prettier（代码格式化）│◇ 是否引入 Oxlint 以加快检测？（试验阶段）│ No正在初始化项目 D:\\work\\workspace\\circle-shop\\cshop-admin-front...│└ 项目初始化完成，可执行以下命令： cd cshop-admin-front yarn yarn format yarn dev| 可选：使用以下命令在项目目录中初始化 Git： git init git add -A git commit -m initial commitDone in 29.18s. 测试计划测试范围测试用例性能测试运维计划日志管理异常处理备份策略附录术语表参考文献常见问题","tags":["Java、商城、分布式"]},{"title":"cloud-mall-vue","path":"/2024/11/26/cloud-mall-vue/","content":"1. 初始化项目1.1 构建项目npm init vue@latest jsconfig.json配置别名路径 配置别名路径可以在写代码时联想提示路径 compilerOptions: baseUrl: ./, paths: @/*: [src/*] , exclude: [node_modules, dist] 引入element-plus和自动引入插件 npm install element-plus --savenpm install -D unplugin-vue-components unplugin-auto-import vite.config.js // vite.config.tsimport defineConfig from viteimport AutoImport from unplugin-auto-import/viteimport Components from unplugin-vue-components/viteimport ElementPlusResolver from unplugin-vue-components/resolversexport default defineConfig( // ... plugins: [ // ... AutoImport( resolvers: [ElementPlusResolver()], ), Components( resolvers: [ElementPlusResolver()], ), ],) 安装sass依赖 基于vite的项目默认不支持css预处理器，需要开发者单独安装 # 安装为开发依赖npm i sass -D 引入common.scss src\\styles\\common.scss // 重置样式* box-sizing: border-box;html height: 100%; font-size: 14px;body height: 100%; color: #333; min-width: 1240px; font: 1em/1.4 Microsoft Yahei, PingFang SC, Avenir, Segoe UI, Hiragino Sans GB, STHeiti, Microsoft Sans Serif, WenQuanYi Micro Hei, sans-serif;body,ul,h1,h3,h4,p,dl,dd padding: 0; margin: 0;a text-decoration: none; color: #333; outline: none;i font-style: normal;input[type=text],input[type=search],input[type=password],input[type=checkbox] padding: 0; outline: none; border: none; -webkit-appearance: none; ::placeholder color: #ccc; img max-width: 100%; max-height: 100%; vertical-align: middle; background: #ebebeb url(@/assets/images/200.png) no-repeat center / contain;ul list-style: none;#app background: #f5f5f5; user-select: none;.container width: 1240px; margin: 0 auto; position: relative;.ellipsis white-space: nowrap; text-overflow: ellipsis; overflow: hidden;.ellipsis-2 word-break: break-all; text-overflow: ellipsis; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden;.fl float: left;.fr float: right;.clearfix:after content: .; display: block; visibility: hidden; height: 0; line-height: 0; clear: both;// reset element.el-breadcrumb__inner.is-link font-weight: 400 !important; src\\main.js import createApp from vueimport createPinia from piniaimport App from ./App.vueimport router from ./router// 引入初始化样式文件import @/styles/common.scss... 定义颜色变量 src\\styles\\var.scss $mallColor: #27ba9b;$helpColor: #e26237;$sucColor: #1dc779;$warnColor: #ffb302;$priceColor: #cf4444; vite.config.js ...// https://vite.dev/config/export default defineConfig( ... resolve: alias: @: fileURLToPath(new URL(./src, import.meta.url)) , , css: preprocessorOptions: scss: // 自动导入定制化样式文件进行样式覆盖 // 用于在每个 SCSS 文件编译之前，自动添加一段代码。 // 表示导入 @/styles/var.scss 文件，并将其中的内容作为全局样式使用。 // 运行项目，所有的 SCSS 文件会自动加载 @/styles/var.scss 中的内容。 // ar.scss 中定义的变量、函数、混合等可以直接使用。 additionalData: ` @use @/styles/var.scss as *; `, ) 引入ali字体 字体图标采用的是阿里的字体图标库，在 index.html文件中引入 !DOCTYPE htmlhtml lang= head meta charset=UTF-8 link rel=icon href=/favicon.ico link rel=stylesheet href=//at.alicdn.com/t/font_2143783_iq6z4ey5vu.css meta name=viewport content=width=device-width, initial-scale=1.0 title云商城/title /head body div id=app/div script type=module src=/src/main.js/script /body/html 1.2 自动格式化配置1.2.1 安装 Prettier确保 Prettier 安装在项目中： npm install --save-dev prettier 创建 Prettier 配置文件，在项目根目录创建 .prettierrc 文件，添加以下内容： semi: false, singleQuote: true, tabWidth: 2, trailingComma: es5, arrowParens: always 也可以创建 .prettierignore 文件，指定忽略的文件或目录： node_modulesdist 1.2.2 安装 ESLint 和插件如果未在初始化时选择 ESLint，可以手动安装： npm install --save-dev eslint eslint-plugin-vue 如果需要 Prettier 和 ESLint 集成： npm install --save-dev eslint-config-prettier eslint-plugin-prettier 配置 ESLint 创建或修改 eslint.config.js 文件，确保包含以下内容： import js from @eslint/jsimport pluginVue from eslint-plugin-vueexport default [ js.configs.recommended, ...pluginVue.configs[flat/essential], name: app/files-to-lint, files: [**/*.js,mjs,jsx,vue], rules: // 自定义规则：关闭多单词组件名称校验 vue/multi-word-component-names: off, , , name: app/files-to-ignore, ignores: [**/dist/**, **/dist-ssr/**, **/coverage/**], ,] 1.2.3 配置 VSCode 格式化在 VSCode 中安装以下扩展： ESLint Prettier - Code Formatter 在项目根目录创建或修改 .vscode/settings.json： explorer.fileNesting.enabled: true, explorer.fileNesting.patterns: tsconfig.json: tsconfig.*.json, env.d.ts, vite.config.*: jsconfig*, vitest.config.*, cypress.config.*, playwright.config.*, package.json: package-lock.json, pnpm*, .yarnrc*, yarn*, .eslint*, eslint*, .prettier*, prettier*, .editorconfig , editor.codeActionsOnSave: source.fixAll: explicit , editor.formatOnSave: true, editor.defaultFormatter: esbenp.prettier-vscode, files.autoSave: onFocusChange, [vue]: editor.defaultFormatter: esbenp.prettier-vscode , prettier.tabWidth: 2 1.3 安装axiosnpm i axios 官方文档地址：https://axios-http.com/zh/docs/intro基础配置通常包括： 实例化 - baseURL + timeout 拦截器 - 携带token 401拦截等 src\\utils\\http.js import axios from axios// 创建axios实例const http = axios.create( baseURL: http://www.cloudmall.com, timeout: 5000)// axios请求拦截器http.interceptors.request.use(config = return config, e = Promise.reject(e))// axios响应式拦截器http.interceptors.response.use(res = res.data, e = return Promise.reject(e))export default http 1.4 构建初步路由 src\\router\\index.js // createRouter：创建router实例对象// createWebHistory：创建history模式的路由import createRouter, createWebHistory from vue-routerimport Layout from @/views/Layout/index.vueconst router = createRouter( history: createWebHistory(import.meta.env.BASE_URL), // path和component对应关系的位置 routes: [ path: /, component: Layout ])export default router src\\App.vue script setup/scripttemplate !-- 配置导航，配置路由出口(路径匹配的组件显示的位置) -- RouterView/RouterView/templatestyle scoped/style 2. Layout页 src\\views\\Layout\\components\\LayoutNav.vue script setup/scripttemplate nav class=app-topnav div class=container ul template v-if=true lia href=javascript:;i class=iconfont icon-user/i周杰伦/a/li li el-popconfirm title=确认退出吗? confirm-button-text=确认 cancel-button-text=取消 template #reference a href=javascript:;退出登录/a /template /el-popconfirm /li lia href=javascript:;我的订单/a/li lia href=javascript:;会员中心/a/li /template template v-else lia href=javascript:;请先登录/a/li lia href=javascript:;帮助中心/a/li lia href=javascript:;关于我们/a/li /template /ul /div /nav/templatestyle scoped lang=scss.app-topnav background: #333; ul display: flex; height: 53px; justify-content: flex-end; align-items: center; li a padding: 0 15px; color: #cdcdcd; line-height: 1; display: inline-block; i font-size: 14px; margin-right: 2px; :hover color: $mallColor; ~li a border-left: 2px solid #666; /style src\\views\\Layout\\components\\LayoutHeader.vue script setup/scripttemplate header class=app-header div class=container h1 class=logo RouterLink to=/小兔鲜/RouterLink /h1 ul class=app-header-nav li class=home RouterLink to=/首页/RouterLink /li li RouterLink to=/居家/RouterLink /li li RouterLink to=/美食/RouterLink /li li RouterLink to=/服饰/RouterLink /li /ul div class=search i class=iconfont icon-search/i input type=text placeholder=搜一搜 /div !-- 头部购物车 -- /div /header/templatestyle scoped lang=scss.app-header background: #fff; .container display: flex; align-items: center; .logo width: 200px; a display: block; height: 132px; width: 100%; text-indent: -9999px; background: url(@/assets/images/logo.png) no-repeat center 18px / contain; .app-header-nav width: 820px; display: flex; padding-left: 40px; position: relative; z-index: 998; li margin-right: 40px; width: 38px; text-align: center; a font-size: 16px; line-height: 32px; height: 32px; display: inline-block; :hover color: $mallColor; border-bottom: 1px solid $mallColor; .active color: $mallColor; border-bottom: 1px solid $mallColor; .search width: 170px; height: 32px; position: relative; border-bottom: 1px solid #e7e7e7; line-height: 32px; .icon-search font-size: 18px; margin-left: 5px; input width: 140px; padding-left: 5px; color: #666; .cart width: 50px; .curr height: 32px; line-height: 32px; text-align: center; position: relative; display: block; .icon-cart font-size: 22px; em font-style: normal; position: absolute; right: 0; top: 0; padding: 1px 6px; line-height: 1; background: $helpColor; color: #fff; font-size: 12px; border-radius: 10px; font-family: Arial; /style src\\views\\Layout\\components\\LayoutFooter.vue template footer class=app_footer !-- 联系我们 -- div class=contact div class=container dl dt客户服务/dt ddi class=iconfont icon-kefu/i 在线客服/dd ddi class=iconfont icon-question/i 问题反馈/dd /dl dl dt关注我们/dt ddi class=iconfont icon-weixin/i 公众号/dd ddi class=iconfont icon-weibo/i 微博/dd /dl dl dt下载APP/dt dd class=qrcodeimg src=@/assets/images/qrcode.jpg //dd dd class=download span扫描二维码/span span立马下载APP/span a href=javascript:;下载页面/a /dd /dl dl dt服务热线/dt dd class=hotline400-0000-000 small周一至周日 8:00-18:00/small/dd /dl /div /div !-- 其它 -- div class=extra div class=container div class=slogan a href=javascript:; i class=iconfont icon-footer01/i span价格亲民/span /a a href=javascript:; i class=iconfont icon-footer02/i span物流快捷/span /a a href=javascript:; i class=iconfont icon-footer03/i span品质新鲜/span /a /div !-- 版权信息 -- div class=copyright p a href=javascript:;关于我们/a a href=javascript:;帮助中心/a a href=javascript:;售后服务/a a href=javascript:;配送与验收/a a href=javascript:;商务合作/a a href=javascript:;搜索推荐/a a href=javascript:;友情链接/a /p pCopyRight © 小兔鲜儿/p /div /div /div /footer /template style scoped lang=scss .app_footer overflow: hidden; background-color: #f5f5f5; padding-top: 20px; .contact background: #fff; .container padding: 60px 0 40px 25px; display: flex; dl height: 190px; text-align: center; padding: 0 72px; border-right: 1px solid #f2f2f2; color: #999; :first-child padding-left: 0; :last-child border-right: none; padding-right: 0; dt line-height: 1; font-size: 18px; dd margin: 36px 12px 0 0; float: left; width: 92px; height: 92px; padding-top: 10px; border: 1px solid #ededed; .iconfont font-size: 36px; display: block; color: #666; :hover .iconfont color: $mallColor; :last-child margin-right: 0; .qrcode width: 92px; height: 92px; padding: 7px; border: 1px solid #ededed; .download padding-top: 5px; font-size: 14px; width: auto; height: auto; border: none; span display: block; a display: block; line-height: 1; padding: 10px 25px; margin-top: 5px; color: #fff; border-radius: 2px; background-color: $mallColor; .hotline padding-top: 20px; font-size: 22px; color: #666; width: auto; height: auto; border: none; small display: block; font-size: 15px; color: #999; .extra background-color: #333; .slogan height: 178px; line-height: 58px; padding: 60px 100px; border-bottom: 1px solid #434343; display: flex; justify-content: space-between; a height: 58px; line-height: 58px; color: #fff; font-size: 28px; i font-size: 50px; vertical-align: middle; margin-right: 10px; font-weight: 100; span vertical-align: middle; text-shadow: 0 0 1px #333; .copyright height: 170px; padding-top: 40px; text-align: center; color: #999; font-size: 15px; p line-height: 1; margin-bottom: 20px; a color: #999; line-height: 1; padding: 0 10px; border-right: 1px solid #999; :last-child border-right: none; /style src\\views\\Layout\\index.vue script setupimport LayoutNav from ./components/LayoutNav.vueimport LayoutHeader from ./components/LayoutHeader.vueimport LayoutFooter from ./components/LayoutFooter.vue/scripttemplate LayoutNav / LayoutHeader / !-- 二级路由 -- RouterView / LayoutFooter //template 完成后目标如图： 3. 一级导航 3.1 动态数据渲染获取分类API src\\apis\\layout.js // 获取一级分类export function getCategoryAPI () return http( url: /home/category/head ) 渲染数据 src\\views\\Layout\\components\\LayoutHeader.vue script setupimport ref, onMounted from vueimport getCategoryAPI from @/apis/layoutconst categoryList = ref([])const getCategory = async () = const res = await getCategoryAPI() categoryList.value = res.resultonMounted(()=getCategory())/scripttemplate header class=app-header div class=container h1 class=logo RouterLink to=/小兔鲜/RouterLink /h1 !-- 渲染一级分类数据 -- ul class=app-header-nav li class=home v-for=item in categoryList :key=item.id RouterLink to=/item.name/RouterLink /li /ul div class=search i class=iconfont icon-search/i input type=text placeholder=搜一搜 /div !-- 头部购物车 -- /div /header/template 3.2 吸顶导航交互实现3.2.1 基础代码 src\\views\\Layout\\components\\LayoutFixed.vue script setupimport ref, onMounted from vueimport getCategoryAPI from @/apis/layoutconst categoryList = ref([])const getCategory = async () = const res = await getCategoryAPI() categoryList.value = res.resultonMounted(()=getCategory())/scripttemplate div class=app-header-sticky div class=container RouterLink class=logo to=/ / !-- 导航区域 -- ul class=app-header-nav li class=home v-for=item in categoryList :key=item.id RouterLink to=/item.name/RouterLink /li /ul div class=right RouterLink to=/品牌/RouterLink RouterLink to=/专题/RouterLink /div /div /div/templatestyle scoped lang=scss.app-header-sticky width: 100%; height: 80px; position: fixed; left: 0; top: 0; z-index: 999; background-color: #fff; border-bottom: 1px solid #e4e4e4; // 此处为关键样式!!! // 状态一：往上平移自身高度 + 完全透明 transform: translateY(-100%); opacity: 0; // 状态二：移除平移 + 完全不透明 .show transition: all 0.3s linear; transform: none; opacity: 1; .container display: flex; align-items: center; .logo width: 200px; height: 80px; background: url(@/assets/images/logo.png) no-repeat right 2px; background-size: 160px auto; .right width: 220px; display: flex; text-align: center; padding-left: 40px; border-left: 2px solid $mallColor; a width: 38px; margin-right: 40px; font-size: 16px; line-height: 1; :hover color: $mallColor; .app-header-nav width: 820px; display: flex; padding-left: 40px; position: relative; z-index: 998; li margin-right: 40px; width: 38px; text-align: center; a font-size: 16px; line-height: 32px; height: 32px; display: inline-block; :hover color: $mallColor; border-bottom: 1px solid $mallColor; .active color: $mallColor; border-bottom: 1px solid $mallColor; /style 3.2.2 实现吸顶交互 核心逻辑：根据滚动距离判断当前show类名是否显示，大于78显示，小于78，不显示 // https://vueuse.org/guide/npm i @vueuse/core script setup// vueUseimport useScroll from @vueuse/coreimport ref, onMounted from vueimport getCategoryAPI from @/apis/layout// useScroll// https://vueuse.org/core/useScroll/#usescroll// 获取窗口 y 轴移动距离const y = useScroll(window)const categoryList = ref([])const getCategory = async () = const res = await getCategoryAPI() categoryList.value = res.resultonMounted(()=getCategory())/scripttemplate div class=app-header-sticky :class= show: y 78 !-- 移动距离大于 78 时显示吸顶导航 -- div class=container RouterLink class=logo to=/ / !-- 导航区域 -- ul class=app-header-nav li class=home v-for=item in categoryList :key=item.id RouterLink to=/item.name/RouterLink /li /ul div class=right RouterLink to=/品牌/RouterLink RouterLink to=/专题/RouterLink /div /div /div/template... 3.3 优化重复请求 在加载首页时 LayoutHeader.vue 和 LayoutFixed.vue 都发送了获取分类数据请求。然而分类数据是固定的不需要分开发送两次请求，可以使用 pinia 存储分类数据，优化重复请求。 3.3.1 定义分类 sotre src\\stores\\categoryStore.js // 引入defineStore用于创建storeimport defineStore from piniaimport ref from vueimport getCategoryAPI from @/apis/layout// 定义并暴露一个storeexport const useCategoryStore = defineStore(category,() = // 导航列表的数据管理 // state 导航列表数据 const categoryList = ref([]) // action 获取导航数据的方法 const getCategory = async () = const res = await getCategoryAPI() categoryList.value = res.result return categoryList, getCategory ) 3.3.2 加载分类数据 src\\views\\Layout\\index.vue script setup...import useCategoryStore from @/stores/categoryStoreimport onMounted from vue// 触发获取导航分类数据 actionconst categoryStore = useCategoryStore()onMounted(() = categoryStore.getCategory())/scripttemplate .../template 3.3.3 从pinia中获取数据渲染 src\\views\\Layout\\components\\LayoutFixed.vue script setup// vueUseimport useScroll from @vueuse/coreimport useCategoryStore from @/stores/categoryStore;// vueuseconst y = useScroll(window)const categoryStore = useCategoryStore()/scripttemplate div class=app-header-sticky :class= show: y 78 !-- 移动距离大于 78 时显示吸顶导航 -- div class=container RouterLink class=logo to=/ / !-- 导航区域 -- ul class=app-header-nav li class=home v-for=item in categoryStore.categoryList :key=item.id !-- 从 pinia 中获取数据渲染 -- RouterLink to=/item.name/RouterLink /li /ul div class=right RouterLink to=/品牌/RouterLink RouterLink to=/专题/RouterLink /div /div /div/template src\\views\\Layout\\components\\LayoutHeader.vue script setupimport useCategoryStore from @/stores/categoryStore;const categoryStore = useCategoryStore()/scripttemplate header class=app-header div class=container h1 class=logo RouterLink to=/小兔鲜/RouterLink /h1 ul class=app-header-nav !-- 渲染一级分类数据 -- !-- 从 pinia 中获取数据渲染 -- li class=home v-for=item in categoryStore.categoryList :key=item.id RouterLink to=/item.name/RouterLink /li /ul div class=search i class=iconfont icon-search/i input type=text placeholder=搜一搜 /div !-- 头部购物车 -- /div /header/template 3.3.4 优化结果 4. HOME页4.1 整体结构创建 1- 按照结构新增五个组件，准备最简单的模版，分别在Home模块的入口组件中引入 src\\views\\Home\\components\\HomeCategory.vue HomeCategory HomeBanner HomeNew HomeHot HomeProduct script setup/scripttemplate div HomeCategory /div/template 2- Home模块入口组件中引入并渲染 script setupimport HomeCategory from ./components/HomeCategory.vueimport HomeBanner from ./components/HomeBanner.vueimport HomeNew from ./components/HomeNew.vueimport HomeHot from ./components/HomeHot.vueimport homeProduct from ./components/HomeProduct.vue/scripttemplate div class=container HomeCategory / HomeBanner / /div HomeNew / HomeHot / homeProduct //template 4.2 分类4.2.1 静态代码 src\\views\\Home\\components\\HomeCategory.vue script setup/scripttemplate div class=home-category ul class=menu li v-for=item in 9 :key=item RouterLink to=/居家/RouterLink RouterLink v-for=i in 2 :key=i to=/南北干货/RouterLink !-- 弹层layer位置 -- div class=layer h4分类推荐 small根据您的购买或浏览记录推荐/small/h4 ul li v-for=i in 5 :key=i RouterLink to=/ img alt= / div class=info p class=name ellipsis-2 男士外套 /p p class=desc ellipsis男士外套，冬季必选/p p class=pricei¥/i200.00/p /div /RouterLink /li /ul /div /li /ul /div/templatestyle scoped lang=scss.home-category width: 250px; height: 500px; background: rgba(0, 0, 0, 0.8); position: relative; z-index: 99; .menu li padding-left: 40px; height: 55px; line-height: 55px; :hover background: $xtxColor; a margin-right: 4px; color: #fff; :first-child font-size: 16px; .layer width: 990px; height: 500px; background: rgba(255, 255, 255, 0.8); position: absolute; left: 250px; top: 0; display: none; padding: 0 15px; h4 font-size: 20px; font-weight: normal; line-height: 80px; small font-size: 16px; color: #666; ul display: flex; flex-wrap: wrap; li width: 310px; height: 120px; margin-right: 15px; margin-bottom: 15px; border: 1px solid #eee; border-radius: 4px; background: #fff; :nth-child(3n) margin-right: 0; a display: flex; width: 100%; height: 100%; align-items: center; padding: 10px; :hover background: #e3f9f4; img width: 95px; height: 95px; .info padding-left: 10px; line-height: 24px; overflow: hidden; .name font-size: 16px; color: #666; .desc color: #999; .price font-size: 22px; color: $priceColor; i font-size: 16px; // 关键样式 hover状态下的layer盒子变成block :hover .layer display: block; /style 4.2.2 动态渲染 src\\views\\Home\\components\\HomeCategory.vue script setupimport useCategoryStore from @/stores/categoryStoreconst categoryStore = useCategoryStore()/scripttemplate div class=home-category ul class=menu li v-for=item in categoryStore.categoryList :key=item.id RouterLink to=/ item.name /RouterLink RouterLink v-for=i in item.children.slice(0, 2) :key=i to=/ i.name /RouterLink !-- 弹层layer位置 -- div class=layer h4分类推荐 small根据您的购买或浏览记录推荐/small/h4 ul li v-for=i in item.goods :key=i.id RouterLink to=/ img alt= / div class=info p class=name ellipsis-2 i.name /p p class=desc ellipsis i.desc /p p class=pricei¥/i i.price /p /div /RouterLink /li /ul /div /li /ul /div/template 4.3 Banner图4.3.1 静态代码 src\\views\\Home\\components\\HomeBanner.vue script setup/scripttemplate div class=home-banner el-carousel height=500px el-carousel-item v-for=item in 4 :key=item img src=http://yjy-xiaotuxian-dev.oss-cn-beijing.aliyuncs.com/picture/2021-04-15/6d202d8e-bb47-4f92-9523-f32ab65754f4.jpg alt= /el-carousel-item /el-carousel /div/templatestyle scoped lang=scss.home-banner width: 1240px; height: 500px; position: absolute; left: 0; top: 0; z-index: 98; img width: 100%; height: 500px; /style 4.3.2 API src\\apis\\home.js import http from @/utils/http// 获取 banner 图export function getBannerAPI() return http.request( url: home/banner, ) 4.3.3 渲染数据script setupimport onMounted, ref from vueimport getBannerAPI from @/apis/homeconst bannerList = ref([])const getBanner = async () = const res = await getBannerAPI() bannerList.value = res.resultonMounted(() = getBanner())/scripttemplate div class=home-banner el-carousel height=500px autoplay el-carousel-item v-for=item in bannerList :key=item.id img :src=item.imgUrl alt= / /el-carousel-item /el-carousel /div/template 4.4 封装面板组件 新鲜好物和人气推荐模块，在结构上非常相似，只是内容不同，通过组件封装可以实现复用结构的效果。 核心思路：把可复用的结构只写一次，把可能发生变化的部分抽象成组件参数（props 插槽） 4.4.1 完整代码 src\\views\\Home\\components\\HomePanel.vue script setupdefineProps( titile: type: String, default: , subTitle: type: String, default: ,)/scripttemplate div class=home-panel div class=container div class=head !-- 主标题和副标题 -- h3 titile small subTitle /small /h3 /div !-- 主体内容区域(具名插槽) -- slot name=main/slot /div /div/templatestyle scoped lang=scss.home-panel background-color: #fff; .head padding: 40px 0; display: flex; align-items: flex-end; h3 flex: 1; font-size: 32px; font-weight: normal; margin-left: 6px; height: 35px; line-height: 35px; small font-size: 16px; color: #999; margin-left: 20px; /style 4.5 新鲜好物4.5.1 静态代码 src\\views\\Home\\components\\HomeNew.vue script setupimport HomePanel from ./HomePanel.vue/scripttemplate HomePanel titile=新鲜好物 sub-title=新鲜出炉 品质靠谱 template #main ul class=goods-list li v-for= :key=item.id RouterLink to=/ img :src=item.picture alt= / p class=name item.name /p p class=priceyen; item.price /p /RouterLink /li /ul /template /HomePanel/templatestyle scoped lang=scss.goods-list display: flex; justify-content: space-between; height: 406px; li width: 306px; height: 406px; background: #f0f9f4; transition: all 0.5s; :hover transform: translate3d(0, -3px, 0); box-shadow: 0 3px 8px rgb(0 0 0 / 20%); img width: 306px; height: 306px; p font-size: 22px; padding-top: 12px; text-align: center; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; .price color: $priceColor; /style 4.5.2 API src\\apis\\home.js // 获取新鲜好物export const getNewAPI = () = return http( url: /home/new, ) 4.5.3 动态渲染 src\\views\\Home\\components\\HomeNew.vue script setupimport ref from vueimport HomePanel from ./HomePanel.vueimport getNewAPI from @/apis/homeconst newList = ref([])const getNewList = async () = const res = await getNewAPI() newList.value = res.resultgetNewList()/scripttemplate HomePanel titile=新鲜好物 sub-title=新鲜出炉 品质靠谱 template #main ul class=goods-list li v-for=item in newList :key=item.id RouterLink to=/ img :src=item.picture alt= / p class=name item.name /p p class=priceyen; item.price /p /RouterLink /li /ul /template /HomePanel/template 4.6 人气推荐4.6.1 静态代码 src\\views\\Home\\components\\HomeHot.vue script setupimport HomePanel from ./HomePanel.vue/scripttemplate HomePanel titile=人气推荐 sub-title=人气爆款 不容错过 template #main ul class=goods-list li v-for=item in hotList :key=item.id RouterLink to=/ img :src=item.picture alt= / p class=name item.name /p p class=desc item.alt /p /RouterLink /li /ul /template /HomePanel/templatestyle scoped lang=scss.goods-list display: flex; justify-content: space-between; height: 406px; li width: 306px; height: 406px; background: #f0f9f4; transition: all 0.5s; :hover transform: translate3d(0, -3px, 0); box-shadow: 0 3px 8px rgb(0 0 0 / 20%); img width: 306px; height: 306px; p font-size: 22px; padding-top: 12px; text-align: center; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; .price color: $priceColor; /style 4.6.2 API src\\apis\\home.js // 获取人气推荐export const getHotAPI = () = return http(home/hot) 4.6.3 动态渲染script setupimport ref from vueimport HomePanel from ./HomePanel.vueimport getHotAPI from @/apis/homeconst hotList = ref([])const getHotList = async () = const res = await getHotAPI() hotList.value = res.resultgetHotList()/scripttemplate HomePanel titile=人气推荐 sub-title=人气爆款 不容错过 template #main ul class=goods-list li v-for=item in hotList :key=item.id RouterLink to=/ img :src=item.picture alt= / p class=name item.name /p p class=desc item.alt /p /RouterLink /li /ul /template /HomePanel/template 4.7 图片加载问题 场景：电商网站的首页通常会很长，用户不一定能访问到页面靠下面的图片，这类图片通过懒加载优化手段可以做到 4.7.1 自定义指令https://cn.vuejs.org/guide/reusability/custom-directives.html#usage-on-components https://vueuse.org/core/useIntersectionObserver/ 核心原理：图片进入视口才发送资源请求 src\\main.js import App from ./App.vueimport useIntersectionObserver from @vueuse/coreconst app = createApp(App)app.directive(img-lazy, mounted(el, binding) // el:指令绑定的元素 img // binding: binding.value 等于指令后面绑定的表达式 图片url // useIntersectionObserver 视图窗口插件，当进入视口时 isIntersecting = true const stop = useIntersectionObserver(el, ([ isIntersecting ]) = if (isIntersecting) el.src = binding.value // 在监听的图片第一次完成加载之后就停止监听 stop() ) ,) 修改为自定义指令 src\\views\\Home\\components\\HomeNew.vue template HomePanel titile=新鲜好物 sub-title=新鲜出炉 品质靠谱 template #main ul class=goods-list li v-for=item in newList :key=item.id RouterLink to=/ !-- 使用自定义指令 -- img v-img-lazy=item.picture alt= / p class=name item.name /p p class=priceyen; item.price /p /RouterLink /li /ul /template /HomePanel/template src\\views\\Home\\components\\HomeHot.vue template HomePanel titile=人气推荐 sub-title=人气爆款 不容错过 template #main ul class=goods-list li v-for=item in hotList :key=item.id RouterLink to=/ !-- 使用自定义指令 -- img v-img-lazy=item.picture alt= / p class=name item.name /p p class=desc item.alt /p /RouterLink /li /ul /template /HomePanel/template 4.7.2 优化指令懒加载指令的逻辑直接写到入口文件中，不合理。入口文件通常只做一些初始化的事情，不应该包含太多的逻辑代码，可以通过插件的方法把懒加载指令封装为插件，main.js 入口文件只需要负责注册插件即可。 https://cn.vuejs.org/guide/reusability/plugins.html src\\directives\\index.js import useIntersectionObserver from @vueuse/coreexport const imgLazyPlugin = install: (app) = app.directive(img-lazy, mounted(el, binding) // el:指令绑定的元素 img // binding: binding.value 等于指令后面绑定的表达式 图片url const stop = useIntersectionObserver(el, ([ isIntersecting ]) = if (isIntersecting) el.src = binding.value // 在监听的图片第一次完成加载之后就停止监听 stop() ) , ) , src\\main.js import App from ./App.vueimport imgLazyPlugin from @/directivesconst app = createApp(App)app.use(imgLazyPlugin) 4.8 Product产品列表4.8.1 静态代码 src\\views\\Home\\components\\HomeProduct.vue script setupimport HomePanel from ./HomePanel.vue/scripttemplate div class=home-product HomePanel :title=cate.name v-for=cate in goodsList :key=cate.id template #main div class=box RouterLink class=cover to=/ img v-img-lazy=cate.picture / strong class=label span cate.name 馆/span span cate.saleInfo /span /strong /RouterLink ul class=goods-list li v-for=goods in cate.goods :key=goods.id RouterLink to=/ class=goods-item img v-img-lazy=good.picture alt= / p class=name ellipsis good.name /p p class=desc ellipsis good.desc /p p class=priceyen; good.price /p /RouterLink /li /ul /div /template /HomePanel /div/templatestyle scoped lang=scss.home-product background: #fff; margin-top: 20px; .sub margin-bottom: 2px; a padding: 2px 12px; font-size: 16px; border-radius: 4px; :hover background: $mallColor; color: #fff; :last-child margin-right: 80px; .box display: flex; .cover width: 240px; height: 610px; margin-right: 10px; position: relative; img width: 100%; height: 100%; .label width: 188px; height: 66px; display: flex; font-size: 18px; color: #fff; line-height: 66px; font-weight: normal; position: absolute; left: 0; top: 50%; transform: translate3d(0, -50%, 0); span text-align: center; :first-child width: 76px; background: rgba(0, 0, 0, 0.9); :last-child flex: 1; background: rgba(0, 0, 0, 0.7); .goods-list width: 990px; display: flex; flex-wrap: wrap; li width: 240px; height: 300px; margin-right: 10px; margin-bottom: 10px; :nth-last-child(-n + 4) margin-bottom: 0; :nth-child(4n) margin-right: 0; .goods-item display: block; width: 220px; padding: 20px 30px; text-align: center; transition: all 0.5s; :hover transform: translate3d(0, -3px, 0); box-shadow: 0 3px 8px rgb(0 0 0 / 20%); img width: 160px; height: 160px; p padding-top: 10px; .name font-size: 16px; .desc color: #999; height: 29px; .price color: $priceColor; font-size: 20px; /style 4.8.2 API src\\apis\\home.js // 获取产品列表export const getGoodsAPI = () = return http(/home/goods) 4.8.3 动态渲染 src\\views\\Home\\components\\HomeProduct.vue script setupimport HomePanel from ./HomePanel.vueimport GoodItem from ./GoodItem.vueimport getGoodsAPI from @/apis/homeimport onMounted, ref from vueconst goodsList = ref([])const getGoodsList = async () = const res = await getGoodsAPI() goodsList.value = res.resultonMounted(() = getGoodsList())/scripttemplate div class=home-product HomePanel :title=cate.name v-for=cate in goodsList :key=cate.id template #main div class=box RouterLink class=cover to=/ img v-img-lazy=cate.picture / strong class=label span cate.name 馆/span span cate.saleInfo /span /strong /RouterLink ul class=goods-list li v-for=goods in cate.goods :key=goods.id RouterLink to=/ class=goods-item img v-img-lazy=good.picture alt= / p class=name ellipsis good.name /p p class=desc ellipsis good.desc /p p class=priceyen; good.price /p /RouterLink /li /ul /div /template /HomePanel /div/template 4.8.4 GoodItem封装 在项目的很多个业务模块中都需要用到同样的商品展示模块，没必要重复定义，封装起来，方便复用。 src\\views\\Home\\components\\GoodItem.vue script setupdefineProps( goods: type: Object, default: () = , ,)/scripttemplate RouterLink to=/ class=goods-item img v-img-lazy=goods.picture alt= / p class=name ellipsis goods.name /p p class=desc ellipsis goods.desc /p p class=priceyen; goods.price /p /RouterLink/templatestyle scoped lang=scss.goods-item display: block; width: 220px; padding: 20px 30px; text-align: center; transition: all 0.5s; :hover transform: translate3d(0, -3px, 0); box-shadow: 0 3px 8px rgb(0 0 0 / 20%); img width: 160px; height: 160px; p padding-top: 10px; .name font-size: 16px; .desc color: #999; height: 29px; .price color: $priceColor; font-size: 20px; /style 使用 src\\views\\Home\\components\\HomeProduct.vue script setup.../scripttemplate div class=home-product HomePanel :title=cate.name v-for=cate in goodsList :key=cate.id template #main div class=box RouterLink class=cover to=/ img v-img-lazy=cate.picture / strong class=label span cate.name 馆/span span cate.saleInfo /span /strong /RouterLink ul class=goods-list li v-for=goods in cate.goods :key=goods.id !-- 使用 GoodItem 组件 -- GoodItem :goods=goods / /li /ul /div /template /HomePanel /div/template 5. 一级分类5.1 分类页 5.1.1 静态代码 src\\views\\Category\\index.vue script setup/scripttemplate div class=top-category 分类 /div/templatestyle scoped lang=scss.top-category h3 font-size: 28px; color: #666; font-weight: normal; text-align: center; line-height: 100px; .sub-list margin-top: 20px; background-color: #fff; ul display: flex; padding: 0 32px; flex-wrap: wrap; li width: 168px; height: 160px; a text-align: center; display: block; font-size: 16px; img width: 100px; height: 100px; p line-height: 40px; :hover color: $mallColor; .ref-goods background-color: #fff; margin-top: 20px; position: relative; .head .xtx-more position: absolute; top: 20px; right: 20px; .tag text-align: center; color: #999; font-size: 20px; position: relative; top: -20px; .body display: flex; justify-content: space-around; padding: 0 40px 30px; .bread-container padding: 25px 0; /style 5.1.2 配置路由 src\\router\\index.js import Category from @/views/Category/index.vueconst router = createRouter( history: createWebHistory(import.meta.env.BASE_URL), // path和component对应关系的位置 routes: [ path: /, component: Layout, children: [ path: , component: Home, , // 配置分类路由，使用动态路由传递分类id path: /category/:id, name: category, component: Category, , ], , path: /login, component: Login, , ],)export default router 5.1.3 配置路由跳转 src\\views\\Layout\\components\\LayoutHeader.vue script setupimport useCategoryStore from @/stores/categoryStoreconst categoryStore = useCategoryStore()/scripttemplate header class=app-header div class=container h1 class=logo RouterLink to=/小兔鲜/RouterLink /h1 ul class=app-header-nav !-- 渲染一级分类数据 -- li class=home v-for=item in categoryStore.categoryList :key=item.id !-- 配置分类路由跳转 -- RouterLink active-class=active :to=`/category/$item.id` item.name /RouterLink /li /ul ... /div /header/template 5.2 面包屑导航5.2.1 静态代码 src\\views\\Category\\index.vue script setup/scripttemplate div class=top-category div class=container m-top-20 !-- 面包屑 -- div class=bread-container el-breadcrumb separator= el-breadcrumb-item :to= path: / 首页/el-breadcrumb-item el-breadcrumb-item topCategory.name /el-breadcrumb-item /el-breadcrumb /div /div /div/template 5.2.2 API src\\apis\\category.js import http from @/utils/http/** * @description: 获取分类数据 * @param * id 分类id * @return * */export const getTopCategoryAPI = (id) = return http( url: /category, params: id, , ) 5.2.3 动态渲染 src\\views\\Category\\index.vue script setupimport ref from vueimport getTopCategoryAPI from @/apis/categoryimport useRoute from vue-routerconst topCategory = ref()const getTopCategory = async (id) = const res = await getTopCategoryAPI(id) topCategory.value = res.resultconst route = useRoute()getTopCategory(route.params.id)/scripttemplate div class=top-category div class=container m-top-20 !-- 面包屑 -- div class=bread-container el-breadcrumb separator= el-breadcrumb-item :to= path: / 首页/el-breadcrumb-item el-breadcrumb-item topCategory.name /el-breadcrumb-item /el-breadcrumb /div /div /div/template 5.2.4 组件复用问题 问题：一级分类的切换正好满足上面的条件，组件实例复用，导致分类数据无法更新 解决问题的思路： 1.让组件实例不复用，强制销毁重建 以当前路由完整路径为key的值，给router-view组件绑定 key src\\views\\Layout\\index.vue script setup/scripttemplate LayoutNav / LayoutHeader / LayoutFixed / !-- 二级路由 -- !-- 绑定 key -- RouterView :key=$route.fullPath / LayoutFooter //template 2.监听路由变化，变化之后执行数据更新操作 beforeRouteUpdate钩子函数可以在每次路由更新之前执行，在回调中执行需要数据更新的业务逻辑即可 import onBeforeRouteUpdate from vue-router// 目标:路由参数变化的时候 可以把分类数据接口重新发送onBeforeRouteUpdate((to) = // 存在问题：使用最新的路由参数请求最新的分类数据 getTopCategory(to.params.id)) 5.3 分类 Banner5.3.1 API src\\apis\\category.js // 获取 banner 图export function getBannerAPI(params = ) // 默认为1 商品为2 const distributionSite = 1 = params return http( url: /home/banner, params: distributionSite, , ) 5.3.2 动态渲染 src\\views\\Category\\index.vue script setupimport ref, onMounted from vueimport getBannerAPI from @/apis/category// 获取bannerconst bannerList = ref([])const getBanner = async () = const res = await getBannerAPI( distributionSite: 2 ) bannerList.value = res.resultonMounted(() = getBanner())/scripttemplate div class=top-category div class=container m-top-20 !-- 面包屑 -- ... !-- 轮播图 -- div class=home-banner el-carousel height=500px autoplay el-carousel-item v-for=item in bannerList :key=item.id img :src=item.imgUrl alt= / /el-carousel-item /el-carousel /div /div/templatestyle scoped lang=scss.top-category ... .home-banner width: 1240px; height: 500px; margin: 0 auto; img width: 100%; height: 500px; /style 5.4 商品分类列表5.4.1 API src\\apis\\category.js export const getTopCategoryAPI = (id) = return http( url: /category, params: id, , ) 5.4.2 动态渲染获取面包屑数据时已经获取了商品列表数据，可以直接渲染 template div class=top-category div class=container m-top-20 !-- 面包屑 -- ... !-- 轮播图 -- ... !-- 分类商品列表 -- div class=sub-list h3全部分类/h3 ul li v-for=i in topCategory.children :key=i.id RouterLink to=/ img :src=i.picture / p i.name /p /RouterLink /li /ul /div div class=ref-goods v-for=item in topCategory.children :key=item.id div class=head h3- item.name -/h3 /div div class=body GoodItem v-for=good in item.goods :goods=good :key=good.id / /div /div /div /div/template 5.4.3 拆分业务逻辑基于逻辑函数拆分业务是指把同一个组件中独立的业务代码通过函数做封装处理，提升代码的可维护性。 实现步骤： 按照业务声明以 use 打头的逻辑函数 把独立的业务逻辑封装到各个函数内部 函数内部把组件中需要用到的数据或者方法return出去 在组件中调用函数把数据或者方法组合回来使用 src\\views\\Category\\composables\\useBanner.js import ref, onMounted from vueimport getBannerAPI from @/apis/category// 获取bannerexport function useBanner() const bannerList = ref([]) const getBanner = async () = const res = await getBannerAPI( distributionSite: 2, ) bannerList.value = res.result onMounted(() = getBanner()) return bannerList, src\\views\\Category\\composables\\useCategory.js import onMounted, ref from vueimport getTopCategoryAPI from @/apis/categoryimport onBeforeRouteUpdate from vue-routerimport useRoute from vue-routerexport function useCategory() // 获取面包屑分类数据 const topCategory = ref() const route = useRoute() const getTopCategory = async (id = route.params.id) = const res = await getTopCategoryAPI(id) topCategory.value = res.result onMounted(() = getTopCategory()) // 目标:路由参数变化的时候 可以把分类数据接口重新发送 onBeforeRouteUpdate((to) = getTopCategory(to.params.id) ) return topCategory, src\\views\\Category\\index.vue script setupimport GoodItem from ../Home/components/GoodItem.vueimport useBanner from ./composables/useBannerimport useCategory from ./composables/useCategoryconst bannerList = useBanner()const topCategory = useCategory()/script 6. 二级分类6.1 静态模板 src\\views\\SubCategory\\index.vue script setup/scripttemplate div class=container !-- 面包屑 -- div class=bread-container el-breadcrumb separator= el-breadcrumb-item :to= path: / 首页/el-breadcrumb-item el-breadcrumb-item :to= path: / 居家 /el-breadcrumb-item el-breadcrumb-item居家生活用品/el-breadcrumb-item /el-breadcrumb /div div class=sub-container el-tabs el-tab-pane label=最新商品 name=publishTime/el-tab-pane el-tab-pane label=最高人气 name=orderNum/el-tab-pane el-tab-pane label=评论最多 name=evaluateNum/el-tab-pane /el-tabs div class=body !-- 商品列表-- /div /div /div/templatestyle lang=scss scoped.bread-container padding: 25px 0; color: #666;.sub-container padding: 20px 10px; background-color: #fff; .body display: flex; flex-wrap: wrap; padding: 0 10px; .goods-item display: block; width: 220px; margin-right: 20px; padding: 20px 30px; text-align: center; img width: 160px; height: 160px; p padding-top: 10px; .name font-size: 16px; .desc color: #999; height: 29px; .price color: $priceColor; font-size: 20px; .pagination-container margin-top: 20px; display: flex; justify-content: center; /style 6.2 路由配置 src\\router\\index.js // createRouter：创建router实例对象// createWebHistory：创建history模式的路由import createRouter, createWebHistory from vue-router...import SubCategory from @/views/SubCategory/index.vueconst router = createRouter( history: createWebHistory(import.meta.env.BASE_URL), // path和component对应关系的位置 routes: [ path: /, component: Layout, children: [ ... path: category/sub/:id, name: subCategory, component: SubCategory, , ], , ... ],)export default router 路由跳转 src\\views\\Category\\index.vue script setup.../scripttemplate div class=top-category div class=container m-top-20 !-- 面包屑 -- ... !-- 轮播图 -- ... !-- 分类商品列表 -- div class=sub-list h3全部分类/h3 ul li v-for=i in topCategory.children :key=i.id RouterLink :to=`/category/sub/$i.id` img :src=i.picture / p i.name /p /RouterLink /li /ul /div ... /div/template 6.3 面包屑导航6.3.1 API src\\apis\\category.js /** * @description: 获取二级分类列表数据 * @param * id 分类id * @return * */export const getCategoryFilterAPI = (id) = return http( url: /category/sub/filter, params: id, , ) 6.3.2 动态渲染 src\\views\\SubCategory\\index.vue script setupimport onMounted, ref from vueimport getCategoryFilterAPI from @/apis/categoryimport useRoute from vue-routerconst route = useRoute()// 面包屑数据const categoryFilter = ref()const getCategoryFilter = async (id = route.params.id) = const res = await getCategoryFilterAPI(id) categoryFilter.value = res.resultonMounted(() = getCategoryFilter())/scripttemplate div class=container !-- 面包屑 -- div class=bread-container el-breadcrumb separator= el-breadcrumb-item router-link to=/首页/router-link /el-breadcrumb-item el-breadcrumb-item RouterLink :to=`/category/$categoryFilter.parentId` categoryFilter.parentName /RouterLink/el-breadcrumb-item el-breadcrumb-item categoryFilter.name /el-breadcrumb-item /el-breadcrumb /div /div/template 6.4 二级分类筛选6.4.1 API src\\apis\\category.js /** * @description: 获取导航数据 * @data categoryId: 1005000 , page: 1, pageSize: 20, sortField: publishTime | orderNum | evaluateNum * @return * */export const getSubCategoryAPI = (data) = return http( url: /category/goods/temporary, method: POST, data, ) 6.4.2 动态渲染 src\\views\\SubCategory\\index.vue script setupimport onMounted, ref from vueimport getSubCategoryAPI from @/apis/category // 二级分类列表数据const goodList = ref([])const activeName = ref(publishTime)const req = ref( categoryId: route.params.id, page: 1, pageSize: 20, sortField: publishTime,)const getSubCategory = async () = const res = await getSubCategoryAPI(req.value) goodList.value = res.result.itemsonMounted(() = getSubCategory())// 表格切换const onChange = (activeName) = req.value.sortField = activeName req.value.page = 1 getSubCategory()/scripttemplate el-tabs v-model=reqData.sortField @tab-change=tabChange el-tab-pane label=最新商品 name=publishTime/el-tab-pane el-tab-pane label=最高人气 name=orderNum/el-tab-pane el-tab-pane label=评论最多 name=evaluateNum/el-tab-pane /el-tabs/template 6.5 二级分类列表 src\\views\\SubCategory\\index.vue script setupimport GoodItem from ../Home/components/GoodItem.vueimport onMounted, ref from vueimport getCategoryFilterAPI, getSubCategoryAPI from @/apis/categoryimport useRoute from vue-routerconst route = useRoute()// 面包屑数据...// 二级分类列表数据...// 表格切换...// 滚动加载const disabled = ref(false)const load = async () = // 获取下一页的数据 req.value.page++ const res = await getSubCategoryAPI(req.value) goodList.value = [...goodList.value, ...res.result.items] // 加载完毕 停止监听 if (res.result.items.length === 0) disabled.value = true /scripttemplate div class=container !-- 面包屑 -- ... div class=sub-container !-- 分类筛选 -- ... div class=body v-infinite-scroll=load :infinite-scroll-disabled=disabled !-- 商品列表-- GoodItem v-for=good in goodList :goods=good :key=good.id / /div /div /div/template https://element-plus.org/zh-CN/component/infinite-scroll.html#%E6%8C%87%E4%BB%A4 v-infinite-scroll=load：滚动到底部时，加载更多数据 :infinite-scroll-disabled=disabled：是否禁用 核心实现逻辑：使用 elementPlus 提供的 v-infinite-scroll 指令监听是否满足触底条件，满足加载条件时让页数参数加一获取下一页数据，做新老数据拼接渲染。 6.6 定制路由scrollBehavior定制路由行为解决什么问题？ 在不同路由切换的时候，可以自动滚动到页面的顶部，而不是停留在原先的位置。 src\\router\\index.js // createRouter：创建router实例对象// createWebHistory：创建history模式的路由...const router = createRouter( history: createWebHistory(import.meta.env.BASE_URL), // path和component对应关系的位置 routes: [ ... ], scrollBehavior() return top: 0 ,)export default router 7.商品详情页7.1 静态模板 src\\views\\Detail\\index.vue script setup/scripttemplate div class=xtx-goods-page div class=container div class=bread-container el-breadcrumb separator= el-breadcrumb-item :to= path: / 首页/el-breadcrumb-item el-breadcrumb-item :to= path: / 母婴 /el-breadcrumb-item el-breadcrumb-item :to= path: / 跑步鞋 /el-breadcrumb-item el-breadcrumb-item抓绒保暖，毛毛虫子儿童运动鞋/el-breadcrumb-item /el-breadcrumb /div !-- 商品信息 -- div class=info-container div div class=goods-info div class=media !-- 图片预览区 -- !-- 统计数量 -- ul class=goods-sales li p销量人气/p p 100+ /p pi class=iconfont icon-task-filling/i销量人气/p /li li p商品评价/p p200+/p pi class=iconfont icon-comment-filling/i查看评价/p /li li p收藏人气/p p300+/p pi class=iconfont icon-favorite-filling/i收藏商品/p /li li p品牌信息/p p400+/p pi class=iconfont icon-dynamic-filling/i品牌主页/p /li /ul /div div class=spec !-- 商品信息区 -- p class=g-name 抓绒保暖，毛毛虫儿童鞋 /p p class=g-desc好穿 /p p class=g-price span200/span span 100/span /p div class=g-service dl dt促销/dt dd12月好物放送，App领券购买直降120元/dd /dl dl dt服务/dt dd span无忧退货/span span快速退款/span span免费包邮/span a href=javascript:;了解详情/a /dd /dl /div !-- sku组件 -- !-- 数据组件 -- !-- 按钮组件 -- div el-button size=large class=btn 加入购物车 /el-button /div /div /div div class=goods-footer div class=goods-article !-- 商品详情 -- div class=goods-tabs nav a商品详情/a /nav div class=goods-detail !-- 属性 -- ul class=attrs li v-for=item in 3 :key=item.value span class=dt白色/span span class=dd纯棉/span /li /ul !-- 图片 -- /div /div /div !-- 24热榜+专题推荐 -- div class=goods-aside /div /div /div /div /div /div/templatestyle scoped lang=scss.xtx-goods-page .goods-info min-height: 600px; background: #fff; display: flex; .media width: 580px; height: 600px; padding: 30px 50px; .spec flex: 1; padding: 30px 30px 30px 0; .goods-footer display: flex; margin-top: 20px; .goods-article width: 940px; margin-right: 20px; .goods-aside width: 280px; min-height: 1000px; .goods-tabs min-height: 600px; background: #fff; .goods-warn min-height: 600px; background: #fff; margin-top: 20px; .number-box display: flex; align-items: center; .label width: 60px; color: #999; padding-left: 10px; .g-name font-size: 22px; .g-desc color: #999; margin-top: 10px; .g-price margin-top: 10px; span ::before content: ¥; font-size: 14px; :first-child color: $priceColor; margin-right: 10px; font-size: 22px; :last-child color: #999; text-decoration: line-through; font-size: 16px; .g-service background: #f5f5f5; width: 500px; padding: 20px 10px 0 10px; margin-top: 10px; dl padding-bottom: 20px; display: flex; align-items: center; dt width: 50px; color: #999; dd color: #666; :last-child span margin-right: 10px; ::before content: •; color: $xtxColor; margin-right: 2px; a color: $xtxColor; .goods-sales display: flex; width: 400px; align-items: center; text-align: center; height: 140px; li flex: 1; position: relative; ~li::after position: absolute; top: 10px; left: 0; height: 60px; border-left: 1px solid #e4e4e4; content: ; p :first-child color: #999; :nth-child(2) color: $priceColor; margin-top: 10px; :last-child color: #666; margin-top: 10px; i color: $xtxColor; font-size: 14px; margin-right: 2px; :hover color: $xtxColor; cursor: pointer; .goods-tabs min-height: 600px; background: #fff; nav height: 70px; line-height: 70px; display: flex; border-bottom: 1px solid #f5f5f5; a padding: 0 40px; font-size: 18px; position: relative; span color: $priceColor; font-size: 16px; margin-left: 10px; .goods-detail padding: 40px; .attrs display: flex; flex-wrap: wrap; margin-bottom: 30px; li display: flex; margin-bottom: 10px; width: 50%; .dt width: 100px; color: #999; .dd flex: 1; color: #666; img width: 100%; .btn margin-top: 20px;.bread-container padding: 25px 0;/style 7.2 路由配置 src\\router\\index.js // createRouter：创建router实例对象// createWebHistory：创建history模式的路由...const router = createRouter( history: createWebHistory(import.meta.env.BASE_URL), // path和component对应关系的位置 routes: [ path: /, component: Layout, children: [ ... path: detail/:id, component: Detail, , ], , ... ], ...)export default router 界面跳转 src\\views\\Home\\components\\HomeNew.vue script setup.../scripttemplate HomePanel titile=新鲜好物 sub-title=新鲜出炉 品质靠谱 template #main ul class=goods-list li v-for=item in newList :key=item.id !-- 配置商品详情页跳转 -- RouterLink :to=`/detail/$item.id` !-- 使用自定义指令 -- img v-img-lazy=item.picture alt= / p class=name item.name /p p class=priceyen; item.price /p /RouterLink /li /ul /template /HomePanel/template 7.3 API src\\apis\\detail.js import http from @/utils/http/** * 获取商品详情 * @param Number id 商品id * @returns */export const getDetailAPI = (id) = return http( url: /goods, params: id, , ) 7.4 基础数据渲染script setupimport onMounted, ref from vueimport getDetailAPI from @/apis/detailimport useRoute from vue-router// 获取商品详细数const goodDetail = ref()const route = useRoute()const getDetail = async (id = route.params.id) = const res = await getDetailAPI(id) goodDetail.value = res.resultonMounted(() = getDetail())/scripttemplate div class=xtx-goods-page !-- 错误原因：goodDetail一开始 .categories - undefined - undefined[1] 1. 可选链的语法?. 2. v-if手动控制渲染时机 保证只有数据存在才渲染 -- div class=container v-if=goodDetail.details div class=bread-container el-breadcrumb separator= el-breadcrumb-item :to= path: / 首页/el-breadcrumb-item el-breadcrumb-item :to= path: `/category/sub/$goodDetail.categories[1].id` !-- 可选链 -- !-- goodDetail.categories?.[1].name -- goodDetail.categories[1].name /el-breadcrumb-item el-breadcrumb-item :to= path: `/category/sub/$goodDetail.categories[0].id` !-- goodDetail?.categories?.[0].name -- goodDetail.categories[0].name /el-breadcrumb-item el-breadcrumb-item goodDetail.name /el-breadcrumb-item /el-breadcrumb /div !-- 商品信息 -- div class=info-container div div class=goods-info div class=media !-- 图片预览区 -- ImageView :image-list=goodDetail.mainPictures/ImageView !-- 统计数量 -- ul class=goods-sales li p销量人气/p p goodDetail.salesCount /p p i class=iconfont icon-task-filling/i 销量人气 /p /li li p商品评价/p p goodDetail.commentCount /p p i class=iconfont icon-comment-filling/i 查看评价 /p /li li p收藏人气/p p goodDetail.collectCount /p p i class=iconfont icon-favorite-filling/i 收藏商品 /p /li li p品牌信息/p p goodDetail.brand.name /p p i class=iconfont icon-dynamic-filling/i 品牌主页 /p /li /ul /div div class=spec !-- 商品信息区 -- p class=g-name goodDetail.name /p p class=g-desc goodDetail.desc /p p class=g-price span goodDetail.oldPrice /span span goodDetail.price /span /p div class=g-service dl dt促销/dt dd12月好物放送,App领券购买直降120元/dd /dl dl dt服务/dt dd span无忧退货/span span快速退款/span span免费包邮/span a href=javascript:;了解详情/a /dd /dl /div !-- sku组件 -- !-- 数据组件 -- !-- 按钮组件 -- div el-button size=large class=btn加入购物车/el-button /div /div /div div class=goods-footer div class=goods-article !-- 商品详情 -- div class=goods-tabs nav a商品详情/a /nav div class=goods-detail !-- 属性 -- ul class=attrs li v-for=item in goodDetail.details.properties :key=item.value span class=dt item.name /span span class=dd item.value /span /li /ul !-- 详情图片 -- img v-for=img in goodDetail.details.pictures :src=img :key=img alt= /div /div /div !-- 24热榜+专题推荐 -- div class=goods-aside /div /div /div /div /div /div/template 7.5 热榜7.5.2 静态模板 src\\views\\Detail\\components\\DetailHot.vue script setup/scripttemplate div class=goods-hot h3周日榜单/h3 !-- 商品区块 -- RouterLink to=/ class=goods-item v-for=item in 3 :key=item.id img :src=item.picture alt= / p class=name ellipsis一双男鞋/p p class=desc ellipsis一双好穿的男鞋/p p class=priceyen;200.00/p /RouterLink /div/templatestyle scoped lang=scss.goods-hot h3 height: 70px; background: $helpColor; color: #fff; font-size: 18px; line-height: 70px; padding-left: 25px; margin-bottom: 10px; font-weight: normal; .goods-item display: block; padding: 20px 30px; text-align: center; background: #fff; img width: 160px; height: 160px; p padding-top: 10px; .name font-size: 16px; .desc color: #999; height: 29px; .price color: $priceColor; font-size: 20px; /style 7.5.1 API src\\apis\\detail.js /** * 获取热榜商品 * @param Number id - 商品id * @param Number type - 1代表24小时热销榜 2代表周热销榜 * @param Number limit - 获取个数 */export const getHotGoodsAPI = ( id, type, limit = 3 ) = return http( url: /goods/hot, params: id, type, limit, , ) 7.5.3 动态渲染 src\\views\\Detail\\components\\DetailHot.vue script setupimport getHotGoodsAPI from @/apis/detailimport onMounted, ref, computed from vueimport useRoute from vue-router// 热榜详细数据const goods = ref()const route = useRoute()const getHotGoods = async (id = route.params.id, type = 1) = const res = await getHotGoodsAPI(id, type) goods.value = res.resultonMounted(() = getHotGoods())/scripttemplate div class=goods-hot h324小时热榜/h3 !-- 商品区块 -- RouterLink to=/ class=goods-item v-for=item in goods :key=item.id img :src=item.picture alt= / p class=name ellipsis item.name /p p class=desc ellipsis item.desc /p p class=priceyen; item.price /p /RouterLink /div/template 7.5.4 动态适配热榜类型 src\\views\\Detail\\components\\DetailHot.vue script setupimport getHotGoodsAPI from @/apis/detailimport onMounted, ref, computed from vueimport useRoute from vue-routerconst props = defineProps( type: type: Number, default: 1, ,)// 热榜详细数据const goods = ref()const route = useRoute()const getHotGoods = async (id = route.params.id, type = props.type) = const res = await getHotGoodsAPI(id, type) goods.value = res.resultonMounted(() = getHotGoods())// 热榜标题const TITLEMAP = 1: 24小时热榜, 2: 周热榜,const title = computed(() = TITLEMAP[props.type])/scripttemplate div class=goods-hot h3 title /h3 !-- 商品区块 -- RouterLink to=/ class=goods-item v-for=item in goods :key=item.id img :src=item.picture alt= / p class=name ellipsis item.name /p p class=desc ellipsis item.desc /p p class=priceyen; item.price /p /RouterLink /div/template src\\views\\Detail\\index.vue script setupimport DetailHot from ./components/DetailHot.vue/scripttemplate...\t!-- 24热榜+周榜 -- div class=goods-aside DetailHot :type=1 / DetailHot :type=2 / /div.../template","tags":["vue3"]},{"title":"React基础","path":"/2024/09/26/React基础/","content":"1. 简介React 是一个用于构建用户界面（UI）的 JavaScript 库，用户界面由按钮、文本和图像等小单元内容构建而成。React 帮助你把它们组合成可重用、可嵌套的 组件。从 web 端网站到移动端应用，屏幕上的所有内容都可以被分解成组件。 React 的主要特点包括： 组件化：将 UI 拆分为可重用的组件，使得开发和维护更加高效。 虚拟 DOM：通过虚拟 DOM 提升性能，只在实际需要更新的部分进行重渲染，减少了与真实 DOM 的直接操作。 单向数据流：数据在应用中的流动是单向的，简化了数据管理，使得调试更为方便。 声明式编程：开发者只需描述想要的 UI 状态，React 会处理更新的细节。 2. 描述 UI2.1 组件2.1.1 UI构成在 Web 当中，HTML 允许我们使用其内置的标签集（如 h1 和 li）创建丰富的结构化文档： article h1我的第一个组件/h1 ol li组件：UI 构成要素/li li定义组件/li li使用组件/li /ol/article article 表示这篇文章，h1 表示文章的标题，ol 以有序列表的形式表示文章的（缩写的）目录。每一个侧边栏、头像、模态框、下拉框的背后是都是像这样的（结合了用于样式的 CSS 和用于交互的 JavaScript 的）标签——你在 Web 上看到的每一个 UI 模块。 React 允许你将标签、CSS 和 JavaScript 组合成自定义“组件”，即 应用程序中可复用的 UI 元素。上文中表示目录的代码可以改写成一个能够在每个页面中渲染的 TableOfContents / 组件。实际上，使用的依然是 article、h1 等相同的 HTML 标签。 就像使用 HTML 标签一样，你可以组合、排序和嵌套组件来绘制整个页面。 随着项目的发展，你会发现很多布局可以通过复用已经完成的组件来实现，从而加快开发进程。你可以使用 React 开源社区分享的大量组件（例如 Chakra UI 和 Material UI）来快速启动项目。 2.1.2 定义组件一直以来，创建网页时，Web 开发人员会用标签描述内容，然后通过 JavaScript 来增加交互。 这种在 Web 上添加交互的方式能产生出色的效果。现在许多网站和全部应用都需要交互。 React 最为重视交互性且使用了相同的处理方式：React 组件是一段可以使用标签进行扩展的 JavaScript 函数。 如下所示： export default function Profile() return ( img src=https://i.imgur.com/MK3eW3Am.jpg alt=Katherine Johnson / ) 以下是构建组件的步骤： 第一步：导出组件 export default 前缀是一种 JavaScript 标准语法（非 React 的特性）。它允许你导出一个文件中的主要函数以便你以后可以从其他文件引入它。欲了解更多关于导入的内容，请参阅 组件的导入与导出 章节！ 第二步：定义函数 使用 function Profile() 定义名为 Profile 的 JavaScript 函数。 React 组件是常规的 JavaScript 函数，但 组件的名称必须以大写字母开头，否则它们将无法运行！ 第三步：添加标签 这个组件返回一个带有 src 和 alt 属性的 img / 标签。img / 写得像 HTML，但实际上是 JavaScript！这种语法被称为 JSX，它允许你在 JavaScript 中嵌入标签。 返回语句可以全写在一行上，如下面组件中所示： return img src=https://i.imgur.com/MK3eW3As.jpg alt=Katherine Johnson /; 但是，如果你的标签和 return 关键字不在同一行，则必须把它包裹在一对括号中，如下所示： return ( div img src=https://i.imgur.com/MK3eW3As.jpg alt=Katherine Johnson / /div); 没有括号包裹的话，任何在 return 下一行的代码都 将被忽略！ 2.1.3 使用组件现在你已经定义了 Profile 组件，你可以在其他组件中使用它。例如，你可以导出一个内部使用了多个 Profile 组件的 Gallery 组件： function Profile() return ( img src=https://i.imgur.com/MK3eW3As.jpg alt=Katherine Johnson / );export default function Gallery() return ( section h1了不起的科学家/h1 Profile / Profile / Profile / /section ); !DOCTYPE htmlhtmlbody div id=root/div/body!-- This setup is not suitable for production. --!-- Only use it in development! --script src=https://unpkg.com/@babel/standalone/babel.min.js/scriptscript async src=https://ga.jspm.io/npm:es-module-shims@1.7.0/dist/es-module-shims.js/scriptscript type=importmap imports: react: https://esm.sh/react?dev, react-dom/client: https://esm.sh/react-dom/client?dev /scriptscript type=text/babel data-type=moduleimport React, StrictMode from react;import createRoot from react-dom/client;function Profile() return ( img src=https://i.imgur.com/MK3eW3As.jpg alt=Katherine Johnson / );let App = function Gallery() return ( section h1了不起的科学家/h1 Profile / Profile / Profile / /section );const root = createRoot(document.getElementById(root));root.render( StrictMode App / /StrictMode);/scriptstyle* box-sizing: border-box;body font-family: sans-serif; margin: 20px; padding: 0;h1 margin-top: 0; font-size: 22px;h2 margin-top: 0; font-size: 20px;h3 margin-top: 0; font-size: 18px;h4 margin-top: 0; font-size: 16px;h5 margin-top: 0; font-size: 14px;h6 margin-top: 0; font-size: 12px;code font-size: 1.2em;ul padding-inline-start: 20px;img margin: 0 10px 10px 0; height: 90px; /style/html 浏览器所看到的 注意下面两者的区别： section 是小写的，所以 React 知道我们指的是 HTML 标签。 Profile / 以大写 P 开头，所以 React 知道我们想要使用名为 Profile 的组件。 然而 Profile 包含更多的 HTML：img /。这是浏览器最后所看到的： section h1了不起的科学家/h1 img src=https://i.imgur.com/MK3eW3As.jpg alt=Katherine Johnson / img src=https://i.imgur.com/MK3eW3As.jpg alt=Katherine Johnson / img src=https://i.imgur.com/MK3eW3As.jpg alt=Katherine Johnson //section 2.1.4 嵌套和组织组件组件是常规的 JavaScript 函数，所以你可以将多个组件保存在同一份文件中。当组件相对较小或彼此紧密相关时，这是一种省事的处理方式。如果这个文件变得臃肿，你也可以随时将 Profile 移动到单独的文件中。你可以立即在 关于引入的页面 中学习如何做到这些。 因为 Profile 组件在 Gallery 组件中渲染——甚至好几次！——我们可以认为 Gallery 是一个 父组件，将每个 Profile 渲染为一个“孩子”。这是 React 的神奇之处：你可以只定义组件一次，然后按需多处和多次使用。 组件可以渲染其他组件，但是 请不要嵌套他们的定义： export default function Gallery() // 🔴 永远不要在组件中定义组件 function Profile() // ... // ... 上面这段代码 非常慢，并且会导致 bug 产生。因此，你应该在顶层定义每个组件： export default function Gallery() // ...// ✅ 在顶层声明组件function Profile() // ... 当子组件需要使用父组件的数据时，你需要 通过 props 的形式进行传递，而不是嵌套定义。 2.1.5 组件的导入与导出组件的神奇之处在于它们的可重用性：你可以创建一个由其他组件构成的组件。但当你嵌套了越来越多的组件时，则需要将它们拆分成不同的文件。这样可以使得查找文件更加容易，并且能在更多地方复用这些组件。 2.1.5.1 根组件在 你的第一个组件 中，你创建了一个 Profile 组件，并且渲染在 Gallery 组件里。 function Profile() return ( img src=https://i.imgur.com/MK3eW3As.jpg alt=Katherine Johnson / );export default function Gallery() return ( section h1了不起的科学家们/h1 Profile / Profile / Profile / /section ); 在此示例中，所有组件目前都定义在 根组件 App.js 文件中。具体还需根据项目配置决定，有些根组件可能会声明在其他文件中。如果你使用的框架基于文件进行路由，如 Next.js，那你每个页面的根组件都会不一样。 2.1.5.2 导入和导出组件如果将来需要在首页添加关于科学书籍的列表，亦或者需要将所有的资料信息移动到其他文件。这时将 Gallery 组件和 Profile 组件移出根组件文件会更加合理。这会使组件更加模块化，并且可在其他文件中复用。你可以根据以下三个步骤对组件进行拆分： 创建 一个新的 JS 文件来存放该组件。 导出 该文件中的函数组件（可以使用 默认导出 或 具名导出） 在需要使用该组件的文件中 导入（可以根据相应的导出方式使用 默认导入 或 具名导入）。 这里将 Profile 组件和 Gallery 组件，从 App.js 文件中移动到了 Gallery.js 文件中。修改后，即可在 App.js 中导入 Gallery.js 中的 Gallery 组件: function Profile() return ( img src=https://i.imgur.com/QIrZWGIs.jpg alt=Alan L. Hart / );export default function Gallery() return ( section h1了不起的科学家们/h1 Profile / Profile / Profile / /section ); import Gallery from ./Gallery.js;export default function App() return ( Gallery / ); 该示例中需要注意的是，如何将组件拆分成两个文件： Gallery.js 定义了 Profile 组件，该组件仅在该文件内使用，没有被导出。 使用 默认导出 的方式，将 Gallery 组件导出 App.js 使用 默认导入 的方式，从 Gallery.js 中导入 Gallery 组件。 使用 默认导出 的方式，将根组件 App 导出。 引入过程中，你可能会遇到一些文件并未添加 .js 文件后缀，如下所示： import Gallery from ./Gallery; 无论是 ./Gallery.js 还是 ./Gallery，在 React 里都能正常使用，只是前者更符合 原生 ES 模块。 默认导出与具名导出 这是 JavaScript 里两个主要用来导出值的方式：默认导出和具名导出。到目前为止，我们的示例中只用到了默认导出。但你可以在一个文件中，选择使用其中一种，或者两种都使用。一个文件里有且仅有一个 默认 导出，但是可以有任意多个 具名 导出。 组件的导出方式决定了其导入方式。当你用默认导入的方式，导入具名导出的组件时，就会报错。如下表格可以帮你更好地理解它们： 语法 导出语句 导入语句 默认 export default function Button() import Button from ./Button.js; 具名 export function Button() import Button from ./Button.js; 当使用默认导入时，你可以在 import 语句后面进行任意命名。比如 import Banana from ./Button.js，如此你能获得与默认导出一致的内容。相反，对于具名导入，导入和导出的名字必须一致。这也是称其为 具名 导入的原因！ 通常，文件中仅包含一个组件时，人们会选择默认导出，而当文件中包含多个组件或某个值需要导出时，则会选择具名导出。 无论选择哪种方式，请记得给你的组件和相应的文件命名一个有意义的名字。我们不建议创建未命名的组件，比如 export default () = ，因为这样会使得调试变得异常困难。 2.1.5.3 从同一文件导出和导入多个组件如果你只想展示一个 Profile 组，而不展示整个图集。你也可以导出 Profile 组件。但 Gallery.js 中已包含 默认 导出，此时，你不能定义 两个 默认导出。但你可以将其在新文件中进行默认导出，或者将 Profile 进行 具名 导出。同一文件中，有且仅有一个默认导出，但可以有多个具名导出！ 为了减少在默认导出和具名导出之间的混淆，一些团队会选择只使用一种风格（默认或者具名），或者禁止在单个文件内混合使用。这因人而异，选择最适合你的即可！ 首先，用具名导出的方式，将 Profile 组件从 Gallery.js 导出（不使用 default 关键字）： export function Profile() // ... 接着，用具名导入的方式，从 Gallery.js 文件中 导入 Profile 组件（用大括号）: import Profile from ./Gallery.js; 最后，在 App 组件里 渲染 Profile /： export default function App() return Profile /; 现在，Gallery.js 包含两个导出：一个是默认导出的 Gallery，另一个是具名导出的 Profile。App.js 中均导入了这两个组件。尝试将 Profile / 改成 Gallery /，回到示例中： export function Profile() return ( img src=https://i.imgur.com/QIrZWGIs.jpg alt=Alan L. Hart / );export default function Gallery() return ( section h1了不起的科学家们/h1 Profile / Profile / Profile / /section ); import Gallery from ./Gallery.js;import Profile from ./Gallery.js;export default function App() return ( Profile / ); 示例中混合使用了默认导出和具名导出： Gallery.js 使用 具名导出 的方式，将 Profile 组件导出，并取名为 Profile。 使用 默认导出 的方式，将 Gallery 组件导出。 App.js 使用 具名导入 的方式，从 Gallery.js 中导入 Profile 组件，并取名为 Profile。 使用 默认导入 的方式，从 Gallery.js 中导入 Gallery 组件。 使用 默认导出 的方式，将根组件 App 导出。 2.2 JSX标签语言JSX 是 JavaScript 语法扩展，可以让你在 JavaScript 文件中书写类似 HTML 的标签。虽然还有其它方式可以编写组件，但大部分 React 开发者更喜欢 JSX 的简洁性，并且在大部分代码库中使用它。 2.2.1 将标签引入 JavaScript网页是构建在 HTML、CSS 和 JavaScript 之上的。多年以来，web 开发者都是将网页内容存放在 HTML 中，样式放在 CSS 中，而逻辑则放在 JavaScript 中 —— 通常是在不同的文件中！页面的内容通过标签语言描述并存放在 HTML 文件中，而逻辑则单独存放在 JavaScript 文件中。 但随着 Web 的交互性越来越强，逻辑越来越决定页面中的内容。JavaScript 控制着 HTML 的内容！这也是为什么 在 React 中，渲染逻辑和标签共同存在于同一个地方——组件。 将一个按钮的渲染逻辑和标签放在一起可以确保它们在每次编辑时都能保持互相同步。反之，彼此无关的细节是互相隔离的，例如按钮的标签和侧边栏的标签。这样我们在修改其中任意一个组件时会更安全。 每个 React 组件都是一个 JavaScript 函数，它会返回一些标签，React 会将这些标签渲染到浏览器上。React 组件使用一种被称为 JSX 的语法扩展来描述这些标签。JSX 看起来和 HTML 很像，但它的语法更加严格并且可以动态展示信息。了解这些区别最好的方式就是将一些 HTML 标签转化为 JSX 标签。 JSX and React 是相互独立的 东西。但它们经常一起使用，但你 可以 单独使用它们中的任意一个，JSX 是一种语法扩展，而 React 则是一个 JavaScript 的库。 2.2.2 JSX 规则2.2.2.1 只能返回一个根元素如果想要在一个组件中包含多个元素，需要用一个父标签把它们包裹起来。 例如，你可以使用一个 div 标签： div h1海蒂·拉玛的待办事项/h1 img src=https://i.imgur.com/yXOvdOSs.jpg alt=Hedy Lamarr class=photo ul ... /ul/div 如果你不想在标签中增加一个额外的 div，可以用 和 / 元素来代替： h1海蒂·拉玛的待办事项/h1 img src=https://i.imgur.com/yXOvdOSs.jpg alt=Hedy Lamarr class=photo ul ... /ul/ 这个空标签被称作 *Fragment*。React Fragment 允许你将子元素分组，而不会在 HTML 结构中添加额外节点。 为什么多个 JSX 标签需要被一个父元素包裹？JSX 虽然看起来很像 HTML，但在底层其实被转化为了 JavaScript 对象，你不能在一个函数中返回多个对象，除非用一个数组把他们包装起来。这就是为什么多个 JSX 标签必须要用一个父元素或者 Fragment 来包裹。 2.2.2.2 标签必须闭合JSX 要求标签必须正确闭合。像 img 这样的自闭合标签必须书写成 img /，而像 lioranges 这样只有开始标签的元素必须带有闭合标签，需要改为 lioranges/li。 海蒂·拉玛的照片和待办事项的标签经修改后变为： img src=https://i.imgur.com/yXOvdOSs.jpg alt=Hedy Lamarr class=photo / ul li发明一种新式交通信号灯/li li排练一个电影场景/li li改进频谱技术/li /ul img src=https://i.imgur.com/yXOvdOSs.jpg alt=Hedy Lamarr class=photo / ul li发明一种新式交通信号灯/li li排练一个电影场景/li li改进频谱技术/li /ul// 2.2.2.3 使用驼峰式命名法JSX 最终会被转化为 JavaScript，而 JSX 中的属性也会变成 JavaScript 对象中的键值对。在你自己的组件中，经常会遇到需要用变量的方式读取这些属性的时候。但 JavaScript 对变量的命名有限制。例如，变量名称不能包含 - 符号或者像 class 这样的保留字。 这就是为什么在 React 中，大部分 HTML 和 SVG 属性都用驼峰式命名法表示。例如，需要用 strokeWidth 代替 stroke-width。由于 class 是一个保留字，所以在 React 中需要用 className 来代替。这也是 DOM 属性中的命名: img src=https://i.imgur.com/yXOvdOSs.jpg alt=Hedy Lamarr className=photo/ 你可以 在 React DOM 元素中找到所有对应的属性。如果你在编写属性时发生了错误，不用担心 —— React 会在 浏览器控制台 中打印一条可能的更正信息。 由于历史原因，aria-* 和 data-* 属性是以带 - 符号的 HTML 格式书写的。 2.2.3 将 HTML 转化为 JSX假设你现在有一些（完全有效的）HTML 标签： h1海蒂·拉玛的待办事项/h1img src=https://i.imgur.com/yXOvdOSs.jpg alt=Hedy Lamarr class=photoul li发明一种新式交通信号灯 li排练一个电影场景 li改进频谱技术/ul 而现在想要把这些标签迁移到组件中： export default function TodoList() return ( // ??? ) 如果直接复制到组件中，并不能正常工作： export default function TodoList() return ( // 这不起作用！ h1海蒂·拉玛的待办事项/h1 img src=https://i.imgur.com/yXOvdOSs.jpg alt=Hedy Lamarr class=photo ul li发明一种新式交通信号灯 li排练一个电影场景 li改进频谱技术 /ul ); 这是因为 JSX 语法更加严格并且相比 HTML 有更多的规则！上面的错误提示可以帮助你修复标签中的错误，当然也可以参考下面的指引。 大部分情况下，React 在屏幕上显示的错误提示就能帮你找到问题所在，如果在编写过程中遇到问题就参考一下提示吧。 将现有的 HTML 中的所有属性转化 JSX 的格式是很繁琐的。我们建议使用 转化器 将 HTML 和 SVG 标签转化为 JSX。这种转化器在实践中非常有用。但我们依然有必要去了解这种转化过程中发生了什么，这样你就可以编写自己的 JSX 了。 这是最终的结果： export default function TodoList() return ( h1海蒂·拉玛的待办事项/h1 img src=https://i.imgur.com/yXOvdOSs.jpg alt=Hedy Lamarr className=photo / ul li发明一种新式交通信号灯/li li排练一个电影场景/li li改进频谱技术/li /ul / ); 2.2.4 在 JSX 中通过大括号使用 JavaScriptJSX 允许你在 JavaScript 中编写类似 HTML 的标签，从而使渲染的逻辑和内容可以写在一起。 有时候，你可能想要在标签中添加一些 JavaScript 逻辑或者引用动态的属性。这种情况下，你可以在 JSX 的大括号内来编写 JavaScript。 2.2.4.1 使用引号传递字符串当你想把一个字符串属性传递给 JSX 时，把它放到单引号或双引号中： export default function Avatar() return ( img className=avatar src=https://i.imgur.com/7vQD0fPs.jpg alt=Gregorio Y. Zara / ); 这里的 https://i.imgur.com/7vQD0fPs.jpg 和 Gregorio Y. Zara 就是被作为字符串传递的。 但是如果你想要动态地指定 src 或 alt 的值呢？你可以 用 和 替代 和 以使用 JavaScript 变量 ： export default function Avatar() const avatar = https://i.imgur.com/7vQD0fPs.jpg; const description = Gregorio Y. Zara; return ( img className=avatar src=avatar alt=description / ); 请注意 className=avatar 和 src=avatar 之间的区别，className=avatar 指定了一个就叫 avatar 的使图片在样式上变圆的 CSS 类名，而 src=avatar 这种写法会去读取 JavaScript 中 avatar 这个变量的值。这是因为大括号可以使你直接在标签中使用 JavaScript！ 2.2.4.2 使用大括号：一扇进入 JavaScript 世界的窗户JSX 是一种编写 JavaScript 的特殊方式。这为在大括号 中使用 JavaScript 带来了可能。下面的示例中声明了科学家的名字，name，然后在 h1 后的大括号内嵌入它： export default function TodoList() const name = Gregorio Y. Zara; return ( h1names To Do List/h1 ); 试着将 name 的值从 Gregorio Y. Zara 更改成 Hedy Lamarr。看看这个 To Do List 的标题将如何变化？ 大括号内的任何 JavaScript 表达式都能正常运行，包括像 formatDate() 这样的函数调用： const today = new Date();function formatDate(date) return new Intl.DateTimeFormat( zh-CN, weekday: long ).format(date);export default function TodoList() return ( h1To Do List for formatDate(today)/h1 ); 在 JSX 中，只能在以下两种场景中使用大括号： 用作 JSX 标签内的文本：h1names To Do List/h1 是有效的，但是 tagGregorio Y. Zaras To Do List/tag 无效。 用作紧跟在 = 符号后的 属性：src=avatar 会读取 avatar 变量，但是 src=avatar 只会传一个字符串 avatar。 2.2.4.3 使用 “双大括号”：JSX 中的 CSS 和 对象除了字符串、数字和其它 JavaScript 表达式，你甚至可以在 JSX 中传递对象。对象也用大括号表示，例如 name: Hedy Lamarr, inventions: 5 。因此，为了能在 JSX 中传递，你必须用另一对额外的大括号包裹对象：person= name: \"Hedy Lamarr\", inventions: 5 。 你可能在 JSX 的内联 CSS 样式中就已经见过这种写法了。React 不要求你使用内联样式（使用 CSS 类就能满足大部分情况）。但是当你需要内联样式的时候，你可以给 style 属性传递一个对象： export default function TodoList() return ( ul style= backgroundColor: black, color: pink liImprove the videophone/li liPrepare aeronautics lectures/li liWork on the alcohol-fuelled engine/li /ul ); 所以当你下次在 JSX 中看到 ` 和 `时，就知道它只不过是包在大括号里的一个对象罢了！ 内联 style 属性 使用驼峰命名法编写。例如，HTML ul style=background-color: black 在你的组件里应该写成 ul style= backgroundColor: 'black' 。 2.2.4.4 JavaScript 对象和大括号的更多可能你可以将多个表达式合并到一个对象中，在 JSX 的大括号内分别使用它们： const person = name: Gregorio Y. Zara, theme: backgroundColor: black, color: pink ;export default function TodoList() return ( div style=person.theme h1person.names Todos/h1 img className=avatar src=https://i.imgur.com/7vQD0fPs.jpg alt=Gregorio Y. Zara / ul liImprove the videophone/li liPrepare aeronautics lectures/li liWork on the alcohol-fuelled engine/li /ul /div ); 现在你几乎了解了有关 JSX 的一切： JSX 引号内的值会作为字符串传递给属性。 大括号让你可以将 JavaScript 的逻辑和变量带入到标签中。 它们会在 JSX 标签中的内容区域或紧随属性的 = 后起作用。 ` 和 ` 并不是什么特殊的语法：它只是包在 JSX 大括号内的 JavaScript 对象。 2.3 父子组件属性传递React 组件使用 props 来互相通信。每个父组件都可以提供 props 给它的子组件，从而将一些信息传递给它。Props 可能会让你想起 HTML 属性，但你可以通过它们传递任何 JavaScript 值，包括对象、数组和函数。 2.3.1 简介Props 是你传递给 JSX 标签的信息。例如，className、src、alt、width 和 height 便是一些可以传递给 img 的 props： function Avatar() return ( img className=avatar src=https://i.imgur.com/1bX5QH6.jpg alt=Lin Lanying width=100 height=100 / );export default function Profile() return ( Avatar / ); 你可以传递给 img 标签的 props 是预定义的（ReactDOM 符合 HTML 标准）。但是你可以将任何 props 传递给 你自己的 组件，例如 Avatar ，以便自定义它们。 2.3.2 向组件传递 props在这段代码中， Profile 组件没有向它的子组件 Avatar 传递任何 props ： export default function Profile() return ( Avatar / ); 你可以分两步给 Avatar 一些 props。 步骤一：将 props 传递给子组件 首先，将一些 props 传递给 Avatar。例如，让我们传递两个 props：person（一个对象）和 size（一个数字）： export default function Profile() return ( Avatar person= name: Lin Lanying, imageId: 1bX5QH6 size=100 / ); 现在，你可以在 Avatar 组件中读取这些 props 了。 步骤二：在子组件中读取 props 你可以通过在 function Avatar 之后直接列出它们的名字 person, size 来读取这些 props。这些 props 在 ( 和 ) 之间，并由逗号分隔。这样，你可以在 Avatar 的代码中使用它们，就像使用变量一样。 function Avatar( person, size ) // 在这里 person 和 size 是可访问的 向使用 person 和 size props 渲染的 Avatar 添加一些逻辑，你就完成了。 现在你可以配置 Avatar ，通过不同的 props，使它能以多种不同的方式进行渲染。尝试变换值吧！ export function getImageUrl(person, size = s) return ( https://i.imgur.com/ + person.imageId + size + .jpg ); import getImageUrl from ./utils.js;function Avatar( person, size ) return ( img className=avatar src=getImageUrl(person) alt=person.name width=size height=size / );export default function Profile() return ( div Avatar size=100 person= name: Katsuko Saruhashi, imageId: YfeOqp2 / Avatar size=80 person= name: Aklilu Lemma, imageId: OKS67lh / /div ); Props 使你独立思考父组件和子组件。 例如，你可以改变 Profile 中的 person 或 size props，而无需考虑 Avatar 如何使用它们。 同样，你可以改变 Avatar 使用这些 props 的方式，不必考虑 Profile。 你可以将 props 想象成可以调整的“旋钮”。它们的作用与函数的参数相同 —— 事实上，props 正是 组件的唯一参数！ React 组件函数接受一个参数，一个 props 对象： function Avatar(props) let person = props.person; let size = props.size; // ... 通常你不需要整个 props 对象，所以可以将它解构为单独的 props。 在声明 props 时， 不要忘记 ( 和 ) 之间的一对花括号 和 ： function Avatar( person, size ) // ... 这种语法被称为 “解构”，等价于于从函数参数中读取属性： function Avatar(props) let person = props.person; let size = props.size; // ... 2.3.3 给 prop 指定一个默认值如果你想在没有指定值的情况下给 prop 一个默认值，你可以通过在参数后面写 = 和默认值来进行解构： function Avatar( person, size = 100 ) // ... 现在， 如果 Avatar person=... / 渲染时没有 size prop， size 将被赋值为 100。 默认值仅在缺少 size prop 或 size=undefined 时生效。 但是如果你传递了 size=null 或 size=0，默认值将 不 被使用。 2.3.4 使用 JSX 展开语法传递 props有时候，传递 props 会变得非常重复： function Profile( person, size, isSepia, thickBorder ) return ( div className=card Avatar person=person size=size isSepia=isSepia thickBorder=thickBorder / /div ); 重复代码没有错（它可以更清晰）。但有时你可能会重视简洁。一些组件将它们所有的 props 转发给子组件，正如 Profile 转给 Avatar 那样。因为这些组件不直接使用他们本身的任何 props，所以使用更简洁的“展开”语法是有意义的： function Profile(props) return ( div className=card Avatar ...props / /div ); 这会将 Profile 的所有 props 转发到 Avatar，而不列出每个名字。 请克制地使用展开语法。 如果你在所有其他组件中都使用它，那就有问题了。 通常，它表示你应该拆分组件，并将子组件作为 JSX 传递。 2.3.5 将 JSX 作为子组件传递嵌套浏览器内置标签是很常见的： div img //div 有时你会希望以相同的方式嵌套自己的组件： Card Avatar //Card 当将内容嵌套在 JSX 标签中时，父组件将在名为 children 的 prop 中接收到该内容。例如，下面的 Card 组件将接收一个被设为 Avatar / 的 children prop 并将其包裹在 div 中渲染： App.js import Avatar from ./Avatar.js;function Card( children ) return ( div className=card children /div );export default function Profile() return ( Card Avatar size=100 person= name: Katsuko Saruhashi, imageId: YfeOqp2 / /Card ); Avatar.js import getImageUrl from ./utils.js;export default function Avatar( person, size ) return ( img className=avatar src=getImageUrl(person) alt=person.name width=size height=size / ); utils.js export function getImageUrl(person, size = s) return ( https://i.imgur.com/ + person.imageId + size + .jpg ); 尝试用一些文本替换 Card 中的 Avatar，看看 Card 组件如何包裹任意嵌套内容。它不必“知道”其中渲染的内容。你会在很多地方看到这种灵活的模式。 可以将带有 children prop 的组件看作有一个“洞”，可以由其父组件使用任意 JSX 来“填充”。你会经常使用 children prop 来进行视觉包装：面板、网格等等。 2.3.6 Props 如何随时间变化下面的 Clock 组件从其父组件接收两个 props：color 和 time。（父组件的代码被省略，因为它使用 state，我们暂时不会深入研究。） 尝试在下面的选择框中更改颜色： export default function Clock( color, time ) return ( h1 style= color: color time /h1 ); 这个例子说明，一个组件可能会随着时间的推移收到不同的 props。 Props 并不总是静态的！在这里，time prop 每秒都在变化。当你选择另一种颜色时，color prop 也改变了。Props 反映了组件在任何时间点的数据，并不仅仅是在开始时。 然而，props 是 不可变的（一个计算机科学术语，意思是“不可改变”）。当一个组件需要改变它的 props（例如，响应用户交互或新数据）时，它不得不“请求”它的父组件传递 不同的 props —— 一个新对象！它的旧 props 将被丢弃，最终 JavaScript 引擎将回收它们占用的内存。 不要尝试“更改 props”。 当你需要响应用户输入（例如更改所选颜色）时，你可以“设置 state”，你可以在 State: 一个组件的内存 中继续了解。 2.4 条件渲染通常你的组件会需要根据不同的情况显示不同的内容。在 React 中，你可以通过使用 JavaScript 的 if 语句、 和 ? : 运算符来选择性地渲染 JSX。 2.4.1 条件返回 JSX假设有一个 PackingList 组件，里面渲染多个 Item 组件，每个物品可标记为打包与否： function Item( name, isPacked ) return li className=itemname/li;export default function PackingList() return ( section h1Sally Ride 的行李清单/h1 ul Item isPacked=true name=宇航服 / Item isPacked=true name=带金箔的头盔 / Item isPacked=false name=Tam 的照片 / /ul /section ); 需要注意的是，有些 Item 组件的 isPacked 属性是被设为 true 而不是 false。你可以在那些满足 isPacked=true 条件的物品旁加上一个勾选符号（✅）。 你可以用 ifelse 语句 去判断： if (isPacked) return li className=itemname ✅/li;return li className=itemname/li; 如果 isPacked 属性是 true，这段代码会返回一个不一样的 JSX。通过这样的改动，一些物品的名字后面会出现一个勾选符号： function Item( name, isPacked ) if (isPacked) return li className=itemname ✅/li; return li className=itemname/li;export default function PackingList() return ( section h1Sally Ride 的行李清单/h1 ul Item isPacked=true name=宇航服 / Item isPacked=true name=带金箔的头盔 / Item isPacked=false name=Tam 的照片 / /ul /section ); 留意这里你是怎么使用 JavaScript 的 if 和 return 语句来写分支逻辑。在 React 中，是由 JavaScript 来处理控制流的（比如条件）。 2.4.2 选择性返回 null在一些情况下，你不想有任何东西进行渲染。比如，你不想显示已经打包好的物品。但一个组件必须返回一些东西。这种情况下，你可以直接返回 null。 if (isPacked) return null;return li className=itemname/li; 如果组件的 isPacked 属性为 true，那么它将只返回 null。否则，它将返回相应的 JSX 用来渲染。 function Item( name, isPacked ) if (isPacked) return null; return li className=itemname/li;export default function PackingList() return ( section h1Sally Ride 的行李清单/h1 ul Item isPacked=true name=宇航服 / Item isPacked=true name=带金箔的头盔 / Item isPacked=false name=Tam 的照片 / /ul /section ); 实际上，在组件里返回 null 并不常见，因为这样会让想使用它的开发者感觉奇怪。通常情况下，你可以在父组件里选择是否要渲染该组件。让我们接着往下看吧！ 2.4.3 选择性地包含 JSX在之前的例子里，你在组件内部控制哪些 JSX 树（如果有的话！）会返回。你可能已经发现了在渲染输出里会有一些重复的内容： li className=itemname ✅/li 和下面的写法很像： li className=itemname/li 两个条件分支都会返回 li className=item.../li： if (isPacked) return li className=itemname ✅/li;return li className=itemname/li; 虽然这些重复的内容没什么害处，但这样可能会导致你的代码更难维护。比如你想更改 className？你就需要修改两个地方！针对这种情况，你可以通过选择性地包含一小段 JSX 来让你的代码更加 DRY。 三目运算符（? :） JavaScript 有一种紧凑型语法来实现条件判断表达式——条件运算符 又称“三目运算符”。 除了这样： if (isPacked) return li className=itemname ✅/li;return li className=itemname/li; 你还可以这样实现： return ( li className=item isPacked ? name + ✅ : name /li); 你可以认为，“如果 isPacked 为 true 时，则（?）渲染 name + ✅，否则（:）渲染 name。” 如果你之前是习惯面向对象开发的，你可能会认为上面的两个例子略有不同，因为其中一个可能会创建两个不同的 li “实例”。但 JSX 元素不是“实例”，因为它们没有内部状态也不是真实的 DOM 节点。它们只是一些简单的描述，就像图纸一样。所以上面这两个例子事实上是完全相同的。在 状态的保持和重置 里会深入探讨其原因。 现在，假如你想将对应物品的文本放到另一个 HTML 标签里，比如用 del 来显示删除线。你可以添加更多的换行和括号，以便在各种情况下更好地去嵌套 JSX： function Item( name, isPacked ) return ( li className=item isPacked ? ( del name + ✅ /del ) : ( name ) /li );export default function PackingList() return ( section h1Sally Ride 的行李清单/h1 ul Item isPacked=true name=宇航服 / Item isPacked=true name=带金箔的头盔 / Item isPacked=false name=Tam 的照片 / /ul /section ); 对于简单的条件判断，这样的风格可以很好地实现，但需要适量使用。如果你的组件里有很多的嵌套式条件表达式，则需要考虑通过提取为子组件来简化这些嵌套表达式。在 React 里，标签也是你代码中的一部分，所以你可以使用变量和函数来整理一些复杂的表达式。 2.4.4 与运算符（）你会遇到的另一个常见的快捷表达式是 [JavaScript 逻辑与（）运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_AND#:~:text=The logical AND ( %26%26 ) operator,it returns a Boolean value.)。在 React 组件里，通常用在当条件成立时，你想渲染一些 JSX，或者不做任何渲染。使用 ，你也可以实现仅当 isPacked 为 true 时，渲染勾选符号。 return ( li className=item name isPacked ✅ /li); 你可以认为，“当 isPacked 为真值时，则（）渲染勾选符号，否则，不渲染。” 下面为具体的例子： function Item( name, isPacked ) return ( li className=item name isPacked ✅ /li );export default function PackingList() return ( section h1Sally Ride 的行李清单/h1 ul Item isPacked=true name=宇航服 / Item isPacked=true name=带金箔的头盔 / Item isPacked=false name=Tam 的照片 / /ul /section ); 当 JavaScript 表达式 的左侧（我们的条件）为 true 时，它则返回其右侧的值（在我们的例子里是勾选符号）。但条件的结果是 false，则整个表达式会变成 false。在 JSX 里，React 会将 false 视为一个“空值”，就像 null 或者 undefined，这样 React 就不会在这里进行任何渲染。 切勿将数字放在 左侧. JavaScript 会自动将左侧的值转换成布尔类型以判断条件成立与否。然而，如果左侧是 0，整个表达式将变成左侧的值（0），React 此时则会渲染 0 而不是不进行渲染。 例如，一个常见的错误是 messageCount pNew messages/p。其原本是想当 messageCount 为 0 的时候不进行渲染，但实际上却渲染了 0。 为了更正，可以将左侧的值改成布尔类型：messageCount 0 pNew messages/p。 2.4.5 选择性地将 JSX 赋值给变量当这些快捷方式妨碍写普通代码时，可以考虑使用 if 语句和变量。因为你可以使用 let 进行重复赋值，所以一开始你可以将你想展示的（这里指的是物品的名字）作为默认值赋予给该变量。 let itemContent = name; 结合 if 语句，当 isPacked 为 true 时，将 JSX 表达式的值重新赋值给 itemContent： if (isPacked) itemContent = name + ✅; 在 JSX 中通过大括号使用 JavaScript。将变量用大括号嵌入在返回的 JSX 树中，来嵌套计算好的表达式与 JSX： li className=item itemContent/li 这种方式是最冗长的，但也是最灵活的。下面是相关的例子： function Item( name, isPacked ) let itemContent = name; if (isPacked) itemContent = name + ✅; return ( li className=item itemContent /li );export default function PackingList() return ( section h1Sally Ride 的行李清单/h1 ul Item isPacked=true name=宇航服 / Item isPacked=true name=带金箔的头盔 / Item isPacked=false name=Tam 的照片 / /ul /section ); 跟之前的一样，这个方式不仅仅适用于文本，任意的 JSX 均适用： function Item( name, isPacked ) let itemContent = name; if (isPacked) itemContent = ( del name + ✅ /del ); return ( li className=item itemContent /li );export default function PackingList() return ( section h1Sally Ride 的行李清单/h1 ul Item isPacked=true name=宇航服 / Item isPacked=true name=带金箔的头盔 / Item isPacked=false name=Tam 的照片 / /ul /section ); 如果对 JavaScript 不熟悉，这些不同的风格一开始可能会让你感到不知所措。但是，学习这些将有助于你理解和写任何的 JavaScript 代码，而不仅仅是 React 组件。一开始可以选择一个你喜欢的来用，然后当你忘记其他的怎么用时，可以再翻阅这份参考资料。 2.5 渲染列表你可能经常需要通过 JavaScript 的数组方法 来操作数组中的数据，从而将一个数据集渲染成多个相似的组件。在这篇文章中，你将学会如何在 React 中使用 filter() 筛选需要渲染的组件和使用 map() 把数组转换成组件数组。 2.5.1 从数组中渲染数据这里我们有一个列表。 ul li凯瑟琳·约翰逊: 数学家/li li马里奥·莫利纳: 化学家/li li穆罕默德·阿卜杜勒·萨拉姆: 物理学家/li li珀西·莱温·朱利亚: 化学家/li li苏布拉马尼扬·钱德拉塞卡: 天体物理学家/li/ul 可以看到，这些列表项之间唯一的区别就是其中的内容数据。未来你可能会碰到很多类似的情况，在那些场景中，你想基于不同的数据渲染出相似的组件，比如评论列表或者个人资料的图库。在这样的场景下，可以把要用到的数据存入 JavaScript 对象或数组，然后用 map() 或 filter() 这样的方法来渲染出一个组件列表。 这里给出一个由数组生成一系列列表项的简单示例： 首先，把数据 存储 到数组中： const people = [ 凯瑟琳·约翰逊: 数学家, 马里奥·莫利纳: 化学家, 穆罕默德·阿卜杜勒·萨拉姆: 物理学家, 珀西·莱温·朱利亚: 化学家, 苏布拉马尼扬·钱德拉塞卡: 天体物理学家,]; 遍历 people 这个数组中的每一项，并获得一个新的 JSX 节点数组 listItems： const listItems = people.map(person = liperson/li); 把 listItems 用 ul 包裹起来，然后 返回 它： return ullistItems/ul; 来看看运行的结果： const people = [ 凯瑟琳·约翰逊: 数学家, 马里奥·莫利纳: 化学家, 穆罕默德·阿卜杜勒·萨拉姆: 物理学家, 珀西·莱温·朱利亚: 化学家, 苏布拉马尼扬·钱德拉塞卡: 天体物理学家,];export default function List() const listItems = people.map(person = liperson/li ); return ullistItems/ul; 注意上面的沙盒可能会输出这样一个控制台错误。 等会我们会学到怎么修复它。在此之前，我们先来看看如何把这个数组变得更加结构化。 2.5.2 对数组项进行过滤让我们把 people 数组变得更加结构化一点。 const people = [ id: 0, name: 凯瑟琳·约翰逊, profession: 数学家,, id: 1, name: 马里奥·莫利纳, profession: 化学家,, id: 2, name: 穆罕默德·阿卜杜勒·萨拉姆, profession: 物理学家,, id: 3, name: 珀西·莱温·朱利亚, profession: 化学家,, id: 4, name: 苏布拉马尼扬·钱德拉塞卡, profession: 天体物理学家,]; 现在，假设你只想在屏幕上显示职业是 化学家 的人。那么你可以使用 JavaScript 的 filter() 方法来返回满足条件的项。这个方法会让数组的子项经过 “过滤器”（一个返回值为 true 或 false 的函数）的筛选，最终返回一个只包含满足条件的项的新数组。 既然你只想显示 profession 值是 化学家 的人，那么这里的 “过滤器” 函数应该长这样：(person) = person.profession === 化学家。下面我们来看看该怎么把它们组合在一起： 首先，创建 一个用来存化学家们的新数组 chemists，这里用到 filter() 方法过滤 people 数组来得到所有的化学家，过滤的条件应该是 person.profession === 化学家： const chemists = people.filter(person = person.profession === 化学家); 接下来 用 map 方法遍历 chemists 数组: const listItems = chemists.map(person = li img src=getImageUrl(person) alt=person.name / p bperson.name:/b + person.profession + 因person.accomplishment而闻名世界 /p /li); 最后，返回 listItems： return ullistItems/ul; App.js import people from ./data.js;import getImageUrl from ./utils.js;export default function List() const chemists = people.filter(person = person.profession === 化学家 ); const listItems = chemists.map(person = li img src=getImageUrl(person) alt=person.name / p bperson.name:/b + person.profession + 因person.accomplishment而闻名世界 /p /li ); return ullistItems/ul; data.js export const people = [ id: 0, name: 凯瑟琳·约翰逊, profession: 数学家, accomplishment: 太空飞行相关数值的核算, imageId: MK3eW3A, , id: 1, name: 马里奥·莫利纳, profession: 化学家, accomplishment: 北极臭氧空洞的发现, imageId: mynHUSa, , id: 2, name: 穆罕默德·阿卜杜勒·萨拉姆, profession: 物理学家, accomplishment: 关于基本粒子间弱相互作用和电磁相互作用的统一理论, imageId: bE7W1ji, , id: 3, name: 珀西·莱温·朱利亚, profession: 化学家, accomplishment: 开创性的可的松药物、类固醇和避孕药的研究, imageId: IOjWm71, , id: 4, name: 苏布拉马尼扬·钱德拉塞卡, profession: 天体物理学家, accomplishment: 白矮星质量计算, imageId: lrWQx8l, ,]; utils.js export function getImageUrl(person) return ( https://i.imgur.com/ + person.imageId + s.jpg ); 因为箭头函数会隐式地返回位于 = 之后的表达式，所以你可以省略 return 语句。 const listItems = chemists.map(person = li.../li // 隐式地返回！); 不过，如果你的 = 后面跟了一对花括号 ，那你必须使用 return 来指定返回值！ const listItems = chemists.map(person = // 花括号 return li.../li;); 箭头函数 = 后面的部分被称为 “块函数体”，块函数体支持多行代码的写法，但要用 return 语句才能指定返回值。假如你忘了写 return，那这个函数什么都不会返回！ 2.5.3 用 key 保持列表项的顺序如果把上面任何一个沙盒示例在新标签页打开，你就会发现控制台有这样一个报错： 这是因为你必须给数组中的每一项都指定一个 key——它可以是字符串或数字的形式，只要能唯一标识出各个数组项就行： li key=person.id.../li 直接放在 map() 方法里的 JSX 元素一般都需要指定 key 值！ 这些 key 会告诉 React，每个组件对应着数组里的哪一项，所以 React 可以把它们匹配起来。这在数组项进行移动（例如排序）、插入或删除等操作时非常重要。一个合适的 key 可以帮助 React 推断发生了什么，从而得以正确地更新 DOM 树。 用作 key 的值应该在数据中提前就准备好，而不是在运行时才随手生成： App.js import people from ./data.js;import getImageUrl from ./utils.js;export default function List() const listItems = people.map(person = li key=person.id img src=getImageUrl(person) alt=person.name / p bperson.name/b + person.profession + 因person.accomplishment而闻名世界 /p /li ); return ullistItems/ul; data.js export const people = [ id: 0, // 在 JSX 中作为 key 使用 name: 凯瑟琳·约翰逊, profession: 数学家, accomplishment: 太空飞行相关数值的核算, imageId: MK3eW3A, , id: 1, // 在 JSX 中作为 key 使用 name: 马里奥·莫利纳, profession: 化学家, accomplishment: 北极臭氧空洞的发现, imageId: mynHUSa, , id: 2, // 在 JSX 中作为 key 使用 name: 穆罕默德·阿卜杜勒·萨拉姆, profession: 物理学家, accomplishment: 关于基本粒子间弱相互作用和电磁相互作用的统一理论, imageId: bE7W1ji, , id: 3, // 在 JSX 中作为 key 使用 name: 珀西·莱温·朱利亚, profession: 化学家, accomplishment: 开创性的可的松药物、类固醇和避孕药, imageId: IOjWm71, , id: 4, // 在 JSX 中作为 key 使用 name: 苏布拉马尼扬·钱德拉塞卡, profession: 天体物理学家, accomplishment: 白矮星质量计算, imageId: lrWQx8l, ,]; 2.5.4 如何设置 key 值不同来源的数据往往对应不同的 key 值获取方式： 来自数据库的数据： 如果你的数据是从数据库中获取的，那你可以直接使用数据表中的主键，因为它们天然具有唯一性。 本地产生数据： 如果你数据的产生和保存都在本地（例如笔记软件里的笔记），那么你可以使用一个自增计数器或者一个类似 uuid 的库来生成 key。 key 需要满足的条件 key 值在兄弟节点之间必须是唯一的。 不过不要求全局唯一，在不同的数组中可以使用相同的 key。 key 值不能改变，否则就失去了使用 key 的意义！所以千万不要在渲染时动态地生成 key。 React 中为什么需要 key？ 设想一下，假如你桌面上的文件都没有文件名，取而代之的是，你需要通过文件的位置顺序来区分它们———第一个文件，第二个文件，以此类推。也许你也不是不能接受这种方式，可是一旦你删除了其中的一个文件，这种组织方式就会变得混乱无比。原来的第二个文件可能会变成第一个文件，第三个文件会成为第二个文件…… React 里需要 key 和文件夹里的文件需要有文件名的道理是类似的。它们（key 和文件名）都让我们可以从众多的兄弟元素中唯一标识出某一项（JSX 节点或文件）。而一个精心选择的 key 值所能提供的信息远远不止于这个元素在数组中的位置。即使元素的位置在渲染的过程中发生了改变，它提供的 key 值也能让 React 在整个生命周期中一直认得它。 你可能会想直接把数组项的索引当作 key 值来用，实际上，如果你没有显式地指定 key 值，React 确实默认会这么做。但是数组项的顺序在插入、删除或者重新排序等操作中会发生改变，此时把索引顺序用作 key 值会产生一些微妙且令人困惑的 bug。 与之类似，请不要在运行过程中动态地产生 key，像是 key=Math.random() 这种方式。这会导致每次重新渲染后的 key 值都不一样，从而使得所有的组件和 DOM 元素每次都要重新创建。这不仅会造成运行变慢的问题，更有可能导致用户输入的丢失。所以，使用能从给定数据中稳定取得的值才是明智的选择。 有一点需要注意，组件不会把 key 当作 props 的一部分。Key 的存在只对 React 本身起到提示作用。如果你的组件需要一个 ID，那么请把它作为一个单独的 prop 传给组件： Profile key=id userId=id /。 2.6 保持组件纯粹部分 JavaScript 函数是 纯粹 的，这类函数通常被称为纯函数。纯函数仅执行计算操作，不做其他操作。你可以通过将组件按纯函数严格编写，以避免一些随着代码库的增长而出现的、令人困扰的 bug 以及不可预测的行为。但为了获得这些好处，你需要遵循一些规则。 2.6.1 纯函数：组件作为公式在计算机科学中（尤其是函数式编程的世界中），纯函数 通常具有如下特征： 只负责自己的任务。它不会更改在该函数调用前就已存在的对象或变量。 输入相同，则输出相同。给定相同的输入，纯函数应总是返回相同的结果。 举个你非常熟悉的纯函数示例：数学中的公式。 考虑如下数学公式：y 2x。 若 x 2 则 y 4。永远如此。 若 x 3 则 y 6。永远如此。 若 x 3，那么 y 并不会因为时间或股市的影响，而有时等于 9 、 –1 或 2.5。 若 y 2x 且 x 3, 那么 y 永远 等于 6. 我们使用 JavaScript 的函数实现，看起来将会是这样： function double(number) return 2 * number; 上述例子中，double() 就是一个 纯函数。如果你传入 3 ，它将总是返回 6 。 React 便围绕着这个概念进行设计。React 假设你编写的所有组件都是纯函数。也就是说，对于相同的输入，你所编写的 React 组件必须总是返回相同的 JSX。 function Recipe( drinkers ) return ( ol liBoil drinkers cups of water./li liAdd drinkers spoons of tea and 0.5 * drinkers spoons of spice./li liAdd 0.5 * drinkers cups of milk to boil and sugar to taste./li /ol );export default function App() return ( section h1Spiced Chai Recipe/h1 h2For two/h2 Recipe drinkers=2 / h2For a gathering/h2 Recipe drinkers=4 / /section ); 当你给函数 Recipe 传入 drinkers=2 参数时，它将返回包含 2 cups of water 的 JSX。永远如此。 而当你传入 drinkers=4 时，它将返回包含 4 cups of water 的 JSX。永远如此。 就像数学公式一样。 你可以把你的组件当作食谱：如果你遵循它们，并且在烹饪过程中不引入新食材，你每次都会得到相同的菜肴。那这道 “菜肴” 就是组件用于 React 渲染 的 JSX。 2.6.2 副作用：（不符合）预期的后果React 的渲染过程必须自始至终是纯粹的。组件应该只 返回 它们的 JSX，而不 改变 在渲染前，就已存在的任何对象或变量 — 这将会使它们变得不纯粹！ 以下是违反这一规则的组件示例： let guest = 0;function Cup() // Bad：正在更改预先存在的变量！ guest = guest + 1; return h2Tea cup for guest #guest/h2;export default function TeaSet() return ( Cup / Cup / Cup / / ); 该组件正在读写其外部声明的 guest 变量。这意味着 多次调用这个组件会产生不同的 JSX！并且，如果 其他 组件读取 guest ，它们也会产生不同的 JSX，其结果取决于它们何时被渲染！这是无法预测的。 回到我们的公式 y 2x ，现在即使 x 2 ，我们也不能相信 y 4 。我们的测试可能会失败，我们的用户可能会感到困扰，飞机可能会从天空坠毁——你将看到这会引发多么扑朔迷离的 bugs！ 你可以 将 guest 作为 prop 传入 来修复此组件： function Cup( guest ) return h2Tea cup for guest #guest/h2;export default function TeaSet() return ( Cup guest=1 / Cup guest=2 / Cup guest=3 / / ); 现在你的组件就是纯粹的，因为它返回的 JSX 只依赖于 guest prop。 一般来说，你不应该期望你的组件以任何特定的顺序被渲染。调用 y 5x 和 y 2x 的先后顺序并不重要：这两个公式相互独立。同样地，每个组件也应该“独立思考”，而不是在渲染过程中试图与其他组件协调，或者依赖于其他组件。渲染过程就像是一场学校考试：每个组件都应该自己计算 JSX！ 尽管你可能还没使用过，但在 React 中，你可以在渲染时读取三种输入：props，state 和 context。你应该始终将这些输入视为只读。 当你想根据用户输入 更改 某些内容时，你应该 设置状态，而不是直接写入变量。当你的组件正在渲染时，你永远不应该改变预先存在的变量或对象。 React 提供了 “严格模式”，在严格模式下开发时，它将会调用每个组件函数两次。通过重复调用组件函数，严格模式有助于找到违反这些规则的组件。 我们注意到，原始示例显示的是 “Guest #2”、“Guest #4” 和 “Guest #6”，而不是 “Guest #1”、“Guest #2” 和 “Guest #3”。原来的函数并不纯粹，因此调用它两次就出现了问题。但对于修复后的纯函数版本，即使调用该函数两次也能得到正确结果。纯函数仅仅执行计算，因此调用它们两次不会改变任何东西 — 就像两次调用 double(2) 并不会改变返回值，两次求解 y 2x 不会改变 y 的值一样。相同的输入，总是返回相同的输出。 严格模式在生产环境下不生效，因此它不会降低应用程序的速度。如需引入严格模式，你可以用 React.StrictMode 包裹根组件。一些框架会默认这样做。 2.6.3 局部 mutation：组件的小秘密上述示例的问题出在渲染过程中，组件改变了 预先存在的 变量的值。为了让它听起来更可怕一点，我们将这种现象称为 突变（mutation） 。纯函数不会改变函数作用域外的变量、或在函数调用前创建的对象——这会使函数变得不纯粹！ 但是，你完全可以在渲染时更改你 刚刚 创建的变量和对象。在本示例中，你创建一个 [] 数组，将其分配给一个 cups 变量，然后 push 一打 cup 进去： function Cup( guest ) return h2Tea cup for guest #guest/h2;export default function TeaGathering() let cups = []; for (let i = 1; i = 12; i++) cups.push(Cup key=i guest=i /); return cups; 如果 cups 变量或 [] 数组是在 TeaGathering 函数之外创建的，这将是一个很大的问题！因为如果那样的话，当你调用数组的 push 方法时，就会更改 预先存在的 对象。 但是，这里不会有影响，因为每次渲染时，你都是在 TeaGathering 函数内部创建的它们。TeaGathering 之外的代码并不会知道发生了什么。这就被称为 “局部 mutation” — 如同藏在组件里的小秘密。 2.6.4 哪些地方 可能 引发副作用函数式编程在很大程度上依赖于纯函数，但 某些事物 在特定情况下不得不发生改变。这是编程的要义！这些变动包括更新屏幕、启动动画、更改数据等，它们被称为 副作用。它们是 “额外” 发生的事情，与渲染过程无关。 在 React 中，**副作用通常属于 事件处理程序**。事件处理程序是 React 在你执行某些操作（如单击按钮）时运行的函数。即使事件处理程序是在你的组件 内部 定义的，它们也不会在渲染期间运行！ 因此事件处理程序无需是纯函数。 如果你用尽一切办法，仍无法为副作用找到合适的事件处理程序，你还可以调用组件中的 useEffect 方法将其附加到返回的 JSX 中。这会告诉 React 在渲染结束后执行它。然而，这种方法应该是你最后的手段。 React 为何侧重于纯函数?编写纯函数需要遵循一些习惯和规程。但它开启了绝妙的机遇： 你的组件可以在不同的环境下运行 — 例如，在服务器上！由于它们针对相同的输入，总是返回相同的结果，因此一个组件可以满足多个用户请求。 你可以为那些输入未更改的组件来 跳过渲染，以提高性能。这是安全的做法，因为纯函数总是返回相同的结果，所以可以安全地缓存它们。 如果在渲染深层组件树的过程中，某些数据发生了变化，React 可以重新开始渲染，而不会浪费时间完成过时的渲染。纯粹性使得它随时可以安全地停止计算。 我们正在构建的每个 React 新特性都利用到了纯函数。从数据获取到动画再到性能，保持组件的纯粹可以充分释放 React 范式的能力。 2.6.5 摘要 一个组件必须是纯粹的，就意味着： 只负责自己的任务。 它不会更改在该函数调用前就已存在的对象或变量。 输入相同，则输出相同。 给定相同的输入，组件应该总是返回相同的 JSX。 渲染随时可能发生，因此组件不应依赖于彼此的渲染顺序。 你不应该改变任何用于组件渲染的输入。这包括 props、state 和 context。通过 “设置” state 来更新界面，而不要改变预先存在的对象。 努力在你返回的 JSX 中表达你的组件逻辑。当你需要“改变事物”时，你通常希望在事件处理程序中进行。作为最后的手段，你可以使用 useEffect。 编写纯函数需要一些练习，但它充分释放了 React 范式的能力。 2.7 将 UI 视为树当 React 应用程序逐渐成形时，许多组件会出现嵌套。那么 React 是如何跟踪应用程序组件结构的？ React 以及许多其他 UI 库，将 UI 建模为树。将应用程序视为树对于理解组件之间的关系以及调试性能和状态管理等未来将会遇到的一些概念非常有用。 2.7.1 树结构树是项目和 UI 之间的关系模型，通常使用树结构来表示 UI。例如，浏览器使用树结构来建模 HTML（DOM）与CSS（CSSOM）。移动平台也使用树来表示其视图层次结构。 React 从组件中创建 UI 树。在这个示例中，UI 树最后会用于渲染 DOM。 水平排列的三个部分的图表。第一部分有三个垂直堆叠的矩形，并分别标记为 Component A、Component B 和 Component C。向下一个窗格过渡的是一个带有 React 标志的箭头，标记为 React。中间部分包含一棵组件树，根节点标记为 A，有两个子节点分别标记为 B 和 C。下一个部分再次使用带有 React 标志的箭头进行过渡，标记为 React DOM。第三和最后一个部分是浏览器的线框图，包含一棵有 8 个节点的树，其中只有一个子集被突出显示（表示中间部分的子树）。 与浏览器和移动平台一样，React 还使用树结构来管理和建模 React 应用程序中组件之间的关系。这些树是有用的工具，用于理解数据如何在 React 应用程序中流动以及如何优化呈现和应用程序大小。 2.7.2 渲染树组件的一个主要特性是能够由其他组件组合而成。在 嵌套组件 中有父组件和子组件的概念，其中每个父组件本身可能是另一个组件的子组件。 当渲染 React 应用程序时，可以在一个称为渲染树的树中建模这种关系。 下面的 React 应用程序渲染了一些鼓舞人心的引语。 App.js import FancyText from ./FancyText;import InspirationGenerator from ./InspirationGenerator;import Copyright from ./Copyright;export default function App() return ( FancyText title text=Get Inspired App / InspirationGenerator Copyright year=2004 / /InspirationGenerator / ); FancyText.js export default function FancyText(title, text) return title ? h1 className=fancy titletext/h1 : h3 className=fancy cursivetext/h3 InspirationGenerator.js import * as React from react;import quotes from ./quotes;import FancyText from ./FancyText;export default function InspirationGenerator(children) const [index, setIndex] = React.useState(0); const quote = quotes[index]; const next = () = setIndex((index + 1) % quotes.length); return ( pYour inspirational quote is:/p FancyText text=quote / button onClick=nextInspire me again/button children / ); Copyright.js export default function Copyright(year) return p className=small©️ year/p; quotes.js export default [ Don’t let yesterday take up too much of today.” — Will Rogers, Ambition is putting a ladder against the sky., A joy thats shared is a joy made double., ]; 通过示例应用程序，可以构建上面的渲染树。 这棵树由节点组成，每个节点代表一个组件。例如，App、FancyText、Copyright 等都是我们树中的节点。 在 React 渲染树中，根节点是应用程序的 根组件。在这种情况下，根组件是 App，它是 React 渲染的第一个组件。树中的每个箭头从父组件指向子组件。 那么渲染树中的 HTML 标签在哪里呢？也许会注意到在上面的渲染树中，没有提到每个组件渲染的 HTML 标签。这是因为渲染树仅由 React 组件 组成。 React 是跨平台的 UI 框架。react.dev 展示了一些渲染到使用 HTML 标签作为 UI 原语的 web 的示例。但是 React 应用程序同样可以渲染到移动设备或桌面平台，这些平台可能使用不同的 UI 原语，如 UIView 或 FrameworkElement。 这些平台 UI 原语不是 React 的一部分。无论应用程序渲染到哪个平台，React 渲染树都可以为 React 应用程序提供见解。 渲染树表示 React 应用程序的单个渲染过程。在 条件渲染 中，父组件可以根据传递的数据渲染不同的子组件。 我们可以更新应用程序以有条件地渲染励志语录或颜色。 App.js import FancyText from ./FancyText;import InspirationGenerator from ./InspirationGenerator;import Copyright from ./Copyright;export default function App() return ( FancyText title text=Get Inspired App / InspirationGenerator Copyright year=2004 / /InspirationGenerator / ); FancyText.js export default function FancyText(title, text) return title ? h1 className=fancy titletext/h1 : h3 className=fancy cursivetext/h3 Color.js export default function Color(value) return div className=colorbox style=backgroundColor: value / InspirationGenerator.js import * as React from react;import inspirations from ./inspirations;import FancyText from ./FancyText;import Color from ./Color;export default function InspirationGenerator(children) const [index, setIndex] = React.useState(0); const inspiration = inspirations[index]; const next = () = setIndex((index + 1) % inspirations.length); return ( pYour inspirational inspiration.type is:/p inspiration.type === quote ? FancyText text=inspiration.value / : Color value=inspiration.value / button onClick=nextInspire me again/button children / ); Copyright.js export default function Copyright(year) return p className=small©️ year/p; inspirations.js export default [ type: quote, value: Don’t let yesterday take up too much of today.” — Will Rogers, type: color, value: #B73636, type: quote, value: Ambition is putting a ladder against the sky., type: color, value: #256266, type: quote, value: A joy thats shared is a joy made double., type: color, value: #F9F2B4,]; 在这个示例中，根据 inspiration.type 的值可能会渲染 FancyText 或 Color。每次渲染过程的渲染树可能都不同。 尽管渲染树可能在不同的渲染过程中有所不同，但通常这些树有助于识别 React 应用程序中的顶级和叶子组件。顶级组件是离根组件最近的组件，它们影响其下所有组件的渲染性能，通常包含最多复杂性。叶子组件位于树的底部，没有子组件，通常会频繁重新渲染。 识别这些组件类别有助于理解应用程序的数据流和性能。 2.7.3 模块依赖树在 React 应用程序中，可以使用树来建模的另一个关系是应用程序的模块依赖关系。当 拆分组件 和逻辑到不同的文件中时，就创建了 JavaScript 模块，在这些模块中可以导出组件、函数或常量。 模块依赖树中的每个节点都是一个模块，每个分支代表该模块中的 import 语句。 以之前的 Inspirations 应用程序为例，可以构建一个模块依赖树，简称依赖树。 树的根节点是根模块，也称为入口文件。它通常包含根组件的模块。 与同一应用程序的渲染树相比，存在相似的结构，但也有一些显著的差异： 构成树的节点代表模块，而不是组件。 非组件模块，如 inspirations.js，在这个树中也有所体现。渲染树仅封装组件。 Copyright.js 出现在 App.js 下，但在渲染树中，Copyright 作为 InspirationGenerator 的子组件出现。这是因为 InspirationGenerator 接受 JSX 作为 children props，因此它将 Copyright 作为子组件渲染，但不导入该模块。 依赖树对于确定运行 React 应用程序所需的模块非常有用。在为生产环境构建 React 应用程序时，通常会有一个构建步骤，该步骤将捆绑所有必要的 JavaScript 以供客户端使用。负责此操作的工具称为 bundler（捆绑器），并且 bundler 将使用依赖树来确定应包含哪些模块。 随着应用程序的增长，捆绑包大小通常也会增加。大型捆绑包大小对于客户端来说下载和运行成本高昂，并延迟 UI 绘制的时间。了解应用程序的依赖树可能有助于调试这些问题。 2.7.4 摘要 树是表示实体之间关系的常见方式，它们经常用于建模 UI。 渲染树表示单次渲染中 React 组件之间的嵌套关系。 使用条件渲染，渲染树可能会在不同的渲染过程中发生变化。使用不同的属性值，组件可能会渲染不同的子组件。 渲染树有助于识别顶级组件和叶子组件。顶级组件会影响其下所有组件的渲染性能，而叶子组件通常会频繁重新渲染。识别它们有助于理解和调试渲染性能问题。 依赖树表示 React 应用程序中的模块依赖关系。 构建工具使用依赖树来捆绑必要的代码以部署应用程序。 依赖树有助于调试大型捆绑包带来的渲染速度过慢的问题，以及发现哪些捆绑代码可以被优化。 3. 交互界面上的控件会根据用户的输入而更新。例如，点击按钮切换轮播图的展示。在 React 中，随时间变化的数据被称为状态（state）。你可以向任何组件添加状态，并按需进行更新。在本章节中，你将学习如何编写处理交互的组件，更新它们的状态，并根据时间变化显示不同的效果。 3.1 响应事件使用 React 可以在 JSX 中添加 事件处理函数。其中事件处理函数为自定义函数，它将在响应交互（如点击、悬停、表单输入框获得焦点等）时触发。 3.1.1 添加事件处理函数如需添加一个事件处理函数，你需要先定义一个函数，然后 将其作为 prop 传入 合适的 JSX 标签。例如，这里有一个没绑定任何事件的按钮： export default function Button() return ( button 未绑定任何事件 /button ); 按照如下三个步骤，即可让它在用户点击时显示消息： 在 Button 组件 内部 声明一个名为 handleClick 的函数。 实现函数内部的逻辑（使用 alert 来显示消息）。 添加 onClick=handleClick 到 button JSX 中。 export default function Button() function handleClick() alert(点击); return ( button onClick=handleClick 点击 /button ) 你可以定义 handleClick 函数然后 将其作为 prop 传入 button。其中 handleClick 是一个 事件处理函数 。事件处理函数有如下特点: 通常在你的组件 内部 定义。 名称以 handle 开头，后跟事件名称。 按照惯例，通常将事件处理程序命名为 handle，后接事件名。你会经常看到 onClick=handleClick，onMouseEnter=handleMouseEnter 等。 或者，你也可以在 JSX 中定义一个内联的事件处理函数： button onClick=function handleClick() alert(你点击了我！); 或者，直接使用更为简洁箭头函数： button onClick=() = alert(你点击了我！); 以上所有方式都是等效的。当函数体较短时，内联事件处理函数会很方便。 传递给事件处理函数的函数应直接传递，而非调用。例如： 传递一个函数（正确） 调用一个函数（错误） button onClick=handleClick button onClick=handleClick() 区别很微妙。在第一个示例中，handleClick 函数作为 onClick 事件处理函数传递。这会让 React 记住它，并且只在用户点击按钮时调用你的函数。 在第二个示例中，handleClick() 中最后的 () 会在 渲染 过程中 立即 触发函数，即使没有任何点击。这是因为位于 JSX 之间的 JavaScript 会立即执行。 当你编写内联代码时，同样的陷阱可能会以不同的方式出现： 传递一个函数（正确） 调用一个函数（错误） button onClick=() = alert(...) button onClick=alert(...) 如果按如下方式传递内联代码，并不会在点击时触发，而是会在每次组件渲染时触发： // 这个 alert 在组件渲染时触发，而不是点击时触发！button onClick=alert(你点击了我！) 如果你想要定义内联事件处理函数，请将其包装在匿名函数中，如下所示： button onClick=() = alert(你点击了我！) 这里创建了一个稍后调用的函数，而不会在每次渲染时执行其内部代码。 在这两种情况下，你都应该传递一个函数： button onClick=handleClick 传递了 handleClick 函数。 button onClick=() = alert(...) 传递了 () = alert(...) 函数。 了解更多箭头函数的信息。 3.1.2 在事件处理函数中读取 props由于事件处理函数声明于组件内部，因此它们可以直接访问组件的 props。示例中的按钮，当点击时会弹出带有 message prop 的 alert： function AlertButton( message, children ) return ( button onClick=() = alert(message) children /button );export default function Toolbar() return ( div AlertButton message=正在播放！ 播放电影 /AlertButton AlertButton message=正在上传！ 上传图片 /AlertButton /div ); 此处有两个按钮，会展示不同的消息。你可以尝试更改传递给它们的消息。 3.1.3 将事件处理函数作为 props 传递通常，我们会在父组件中定义子组件的事件处理函数。比如：置于不同位置的 Button 组件，可能最终执行的功能也不同 —— 也许是播放电影，也许是上传图片。 为此，将组件从父组件接收的 prop 作为事件处理函数传递，如下所示： function Button( onClick, children ) return ( button onClick=onClick children /button );function PlayButton( movieName ) function handlePlayClick() alert(`正在播放 $movieName！`); return ( Button onClick=handlePlayClick 播放 movieName /Button );function UploadButton() return ( Button onClick=() = alert(正在上传！) 上传图片 /Button );export default function Toolbar() return ( div PlayButton movieName=魔女宅急便 / UploadButton / /div ); 示例中，Toolbar 组件渲染了一个 PlayButton 组件和 UploadButton 组件： PlayButton 将 handlePlayClick 作为 onClick prop 传入 Button 组件内部。 UploadButton 将 () = alert(正在上传！) 作为 onClick prop 传入 Button 组件内部。 最后，你的 Button 组件接收一个名为 onClick 的 prop。它直接将这个 prop 以 onClick=onClick 方式传递给浏览器内置的 button。当点击按钮时，React 会调用传入的函数。 如果你遵循某个 设计系统 时，按钮之类的组件通常会包含样式，但不会指定行为。而 PlayButton 和 UploadButton 之类的组件则会向下传递事件处理函数。 3.1.4 命名事件处理函数 prop内置组件（button 和 div）仅支持 浏览器事件名称，例如 onClick。但是，当你构建自己的组件时，你可以按你个人喜好命名事件处理函数的 prop。 按照惯例，事件处理函数 props 应该以 on 开头，后跟一个大写字母。 例如，Button 组件的 onClick prop 本来也可以被命名为 onSmash： function Button( onSmash, children ) return ( button onClick=onSmash children /button );export default function App() return ( div Button onSmash=() = alert(正在播放！) 播放电影 /Button Button onSmash=() = alert(正在上传！) 上传图片 /Button /div ); 上述示例中，button onClick=onSmash 代表浏览器内置的 button（小写）仍然需要使用 onClick prop，而自定义的 Button 组件接收到的 prop 名称可由你决定！ 当你的组件支持多种交互时，你可以根据不同的应用程序命名事件处理函数 prop。例如，一个 Toolbar 组件接收 onPlayMovie 和 onUploadImage 两个事件处理函数： export default function App() return ( Toolbar onPlayMovie=() = alert(正在播放！) onUploadImage=() = alert(正在上传！) / );function Toolbar( onPlayMovie, onUploadImage ) return ( div Button onClick=onPlayMovie 播放电影 /Button Button onClick=onUploadImage 上传图片 /Button /div );function Button( onClick, children ) return ( button onClick=onClick children /button ); 请注意，App 组件并不需要知道 Toolbar 将会对 onPlayMovie 和 onUploadImage 做 什么 。上述示例是 Toolbar 的实现细节。其中，Toolbar 将它们作为 onClick 处理函数传递给了 Button 组件，其实还可以通过键盘快捷键来触发它们。根据应用程序特定的交互方式（如 onPlayMovie）来命名 prop ，可以让你灵活地更改以后使用它们的方式。 确保为事件处理程序使用适当的 HTML 标签。例如，要处理点击事件，请使用 而不是 div onClick=handleClick。使用真正的浏览器 button 启用内置的浏览器行为，如键盘导航。如果你不喜欢按钮的默认浏览器样式，并且想让它看起来更像一个链接或不同的 UI 元素，你可以使用 CSS 来实现。了解有关编写无障碍标签的更多信息。 3.1.5 事件传播事件处理函数还将捕获任何来自子组件的事件。通常，我们会说事件会沿着树向上“冒泡”或“传播”：它从事件发生的地方开始，然后沿着树向上传播。 下面这个 div 包含两个按钮。div 和每个按钮都有自己的 onClick 处理函数。你认为点击按钮时会触发哪些处理函数？ export default function Toolbar() return ( div className=Toolbar onClick=() = alert(你点击了 toolbar ！); button onClick=() = alert(正在播放！) 播放电影 /button button onClick=() = alert(正在上传！) 上传图片 /button /div ); 如果你点击任一按钮，它自身的 onClick 将首先执行，然后父级 div 的 onClick 会接着执行。因此会出现两条消息。如果你点击 toolbar 本身，将只有父级 div 的 onClick 会执行。 在 React 中所有事件都会传播，除了 onScroll，它仅适用于你附加到的 JSX 标签。 3.1.6 阻止传播事件处理函数接收一个 事件对象 作为唯一的参数。按照惯例，它通常被称为 e ，代表 “event”（事件）。你可以使用此对象来读取有关事件的信息。 这个事件对象还允许你阻止传播。如果你想阻止一个事件到达父组件，你需要像下面 Button 组件那样调用 e.stopPropagation() ： function Button( onClick, children ) return ( button onClick=e = e.stopPropagation(); onClick(); children /button );export default function Toolbar() return ( div className=Toolbar onClick=() = alert(你点击了 toolbar ！); Button onClick=() = alert(正在播放！) 播放电影 /Button Button onClick=() = alert(正在上传！) 上传图片 /Button /div ); 当你点击按钮时： React 调用了传递给 button 的 onClick 处理函数。 定义在Button中的处理函数执行了如下操作： 调用 e.stopPropagation()，阻止事件进一步冒泡。 调用 onClick 函数，它是从 Toolbar 组件传递过来的 prop。 在 Toolbar 组件中定义的函数，显示按钮对应的 alert。 由于传播被阻止，父级 div 的 onClick 处理函数不会执行。 由于调用了 e.stopPropagation()，点击按钮现在将只显示一个 alert（来自 button），而并非两个（分别来自 button 和父级 toolbar div）。点击按钮与点击周围的 toolbar 不同，因此阻止传播对这个 UI 是有意义的。 捕获阶段事件极少数情况下，你可能需要捕获子元素上的所有事件，即便它们阻止了传播。例如，你可能想对每次点击进行埋点记录，传播逻辑暂且不论。那么你可以通过在事件名称末尾添加 Capture 来实现这一点： div onClickCapture=() = /* 这会首先执行 */ button onClick=e = e.stopPropagation() / button onClick=e = e.stopPropagation() //div 每个事件分三个阶段传播： 它向下传播，调用所有的 onClickCapture 处理函数。 它执行被点击元素的 onClick 处理函数。 它向上传播，调用所有的 onClick 处理函数。 捕获事件对于路由或数据分析之类的代码很有用，但你可能不会在应用程序代码中使用它们。 3.1.7 传递处理函数作为事件传播的替代方案注意，此处的点击事件处理函数先执行了一行代码，然后调用了父组件传递的 onClick prop： function Button( onClick, children ) return ( button onClick=e = e.stopPropagation(); onClick(); children /button ); 你也可以在调用父元素 onClick 函数之前，向这个处理函数添加更多代码。此模式是事件传播的另一种 替代方案 。它让子组件处理事件，同时也让父组件指定一些额外的行为。与事件传播不同，它并非自动。但使用这种模式的好处是你可以清楚地追踪因某个事件的触发而执行的整条代码链。 如果你依赖于事件传播，而且很难追踪哪些处理程序在执行，及其执行的原因，可以尝试这种方法。 3.1.8 阻止默认行为某些浏览器事件具有与事件相关联的默认行为。例如，点击 form 表单内部的按钮会触发表单提交事件，默认情况下将重新加载整个页面： export default function Signup() return ( form onSubmit=() = alert(提交表单！) input / button发送/button /form ); 你可以调用事件对象中的 e.preventDefault() 来阻止这种情况发生： export default function Signup() return ( form onSubmit=e = e.preventDefault(); alert(提交表单！); input / button发送/button /form ); 不要混淆 e.stopPropagation() 和 e.preventDefault()。它们都很有用，但二者并不相关： e.stopPropagation() 阻止触发绑定在外层标签上的事件处理函数。 e.preventDefault() 阻止少数事件的默认浏览器行为。 3.1.9 事件处理函数可以包含副作用吗？当然可以！事件处理函数是执行副作用的最佳位置。 与渲染函数不同，事件处理函数不需要是 纯函数，因此它是用来 更改 某些值的绝佳位置。例如，更改输入框的值以响应键入，或者更改列表以响应按钮的触发。但是，为了更改某些信息，你首先需要某种方式存储它。在 React 中，这是通过 state（组件的记忆） 来完成的。 3.1.10 摘要 你可以通过将函数作为 prop 传递给元素如 button 来处理事件。 必须传递事件处理函数，而非函数调用！ onClick=handleClick ，不是 onClick=handleClick()。 你可以单独或者内联定义事件处理函数。 事件处理函数在组件内部定义，所以它们可以访问 props。 你可以在父组件中定义一个事件处理函数，并将其作为 prop 传递给子组件。 你可以根据特定于应用程序的名称定义事件处理函数的 prop。 事件会向上传播。通过事件的第一个参数调用 e.stopPropagation() 来防止这种情况。 事件可能具有不需要的浏览器默认行为。调用 e.preventDefault() 来阻止这种情况。 从子组件显式调用事件处理函数 prop 是事件传播的另一种优秀替代方案。 3.2 State：组件的记忆组件通常需要根据交互更改屏幕上显示的内容。输入表单应该更新输入字段，单击轮播图上的“下一个”应该更改显示的图片，单击“购买”应该将商品放入购物车。组件需要“记住”某些东西：当前输入值、当前图片、购物车。在 React 中，这种组件特有的记忆被称为 state。 3.2.1 当普通的变量无法满足时以下是一个渲染雕塑图片的组件。点击 “Next” 按钮应该显示下一个雕塑并将 index 更改为 1，再次点击又更改为 2，以此类推。但这个组件现在不起作用： data.js export const sculptureList = [ name: Homenaje a la Neurocirugía, artist: Marta Colvin Andrade, description: Although Colvin is predominantly known for abstract themes that allude to pre-Hispanic symbols, this gigantic sculpture, an homage to neurosurgery, is one of her most recognizable public art pieces., url: https://i.imgur.com/Mx7dA2Y.jpg, alt: A bronze statue of two crossed hands delicately holding a human brain in their fingertips. , name: Floralis Genérica, artist: Eduardo Catalano, description: This enormous (75 ft. or 23m) silver flower is located in Buenos Aires. It is designed to move, closing its petals in the evening or when strong winds blow and opening them in the morning., url: https://i.imgur.com/ZF6s192m.jpg, alt: A gigantic metallic flower sculpture with reflective mirror-like petals and strong stamens.]; App.js import sculptureList from ./data.js;export default function Gallery() let index = 0; function handleClick() index = index + 1; let sculpture = sculptureList[index]; return ( button onClick=handleClick Next /button h2 isculpture.name /i by sculpture.artist /h2 h3 (index + 1 of sculptureList.length) /h3 img src=sculpture.url alt=sculpture.alt / p sculpture.description /p / ); handleClick() 事件处理函数正在更新局部变量 index。但存在两个原因使得变化不可见： 局部变量无法在多次渲染中持久保存。 当 React 再次渲染这个组件时，它会从头开始渲染——不会考虑之前对局部变量的任何更改。 更改局部变量不会触发渲染。 React 没有意识到它需要使用新数据再次渲染组件。 要使用新数据更新组件，需要做两件事： 保留 渲染之间的数据。 触发 React 使用新数据渲染组件（重新渲染）。 useState Hook 提供了这两个功能： State 变量 用于保存渲染间的数据。 State setter 函数 更新变量并触发 React 再次渲染组件。 3.2.2 添加一个 state 变量要添加 state 变量，先从文件顶部的 React 中导入 useState： import useState from react; 然后，替换这一行： let index = 0; 将其修改为 const [index, setIndex] = useState(0); index 是一个 state 变量，setIndex 是对应的 setter 函数。 这里的 [ 和 ] 语法称为数组解构，它允许你从数组中读取值。 useState 返回的数组总是正好有两项。 以下展示了它们在 handleClick() 中是如何共同起作用的： function handleClick() setIndex(index + 1); 现在点击 “Next” 按钮切换当前雕塑： import useState from react;import sculptureList from ./data.js;export default function Gallery() const [index, setIndex] = useState(0); function handleClick() setIndex(index + 1); let sculpture = sculptureList[index]; return ( button onClick=handleClick Next /button h2 isculpture.name /i by sculpture.artist /h2 h3 (index + 1 of sculptureList.length) /h3 img src=sculpture.url alt=sculpture.alt / p sculpture.description /p / ); 3.2.3 遇见你的第一个 Hook在 React 中，useState 以及任何其他以“use”开头的函数都被称为 Hook。 Hook 是特殊的函数，只在 React 渲染时有效（我们将在下一节详细介绍）。它们能让你 “hook” 到不同的 React 特性中去。 State 只是这些特性中的一个，你之后还会遇到其他 Hook。 Hooks ——以 use 开头的函数——只能在组件或自定义 Hook 的最顶层调用。 你不能在条件语句、循环语句或其他嵌套函数内调用 Hook。Hook 是函数，但将它们视为关于组件需求的无条件声明会很有帮助。在组件顶部 “use” React 特性，类似于在文件顶部“导入”模块。 3.2.4 剖析 useState当你调用 useState 时，你是在告诉 React 你想让这个组件记住一些东西： const [index, setIndex] = useState(0); 在这个例子里，你希望 React 记住 index。 惯例是将这对返回值命名为 const [thing, setThing]。你也可以将其命名为任何你喜欢的名称，但遵照约定俗成能使跨项目合作更易理解。 useState 的唯一参数是 state 变量的初始值。在这个例子中，index 的初始值被useState(0)设置为 0。 每次你的组件渲染时，useState 都会给你一个包含两个值的数组： state 变量 (index) 会保存上次渲染的值。 state setter 函数 (setIndex) 可以更新 state 变量并触发 React 重新渲染组件。 以下是实际发生的情况： const [index, setIndex] = useState(0); 组件进行第一次渲染。 因为你将 0 作为 index 的初始值传递给 useState，它将返回 [0, setIndex]。 React 记住 0 是最新的 state 值。 你更新了 state。当用户点击按钮时，它会调用 setIndex(index + 1)。 index 是 0，所以它是 setIndex(1)。这告诉 React 现在记住 index 是 1 并触发下一次渲染。 组件进行第二次渲染。React 仍然看到 useState(0)，但是因为 React 记住 了你将 index 设置为了 1，它将返回 [1, setIndex]。 以此类推！ 3.2.5 赋予一个组件多个 state 变量你可以在一个组件中拥有任意多种类型的 state 变量。该组件有两个 state 变量，一个数字 index 和一个布尔值 showMore，点击 “Show Details” 会改变 showMore 的值： data.js export const sculptureList = [ name: Homenaje a la Neurocirugía, artist: Marta Colvin Andrade, description: Although Colvin is predominantly known for abstract themes that allude to pre-Hispanic symbols, this gigantic sculpture, an homage to neurosurgery, is one of her most recognizable public art pieces., url: https://i.imgur.com/Mx7dA2Y.jpg, alt: A bronze statue of two crossed hands delicately holding a human brain in their fingertips. , name: Floralis Genérica, artist: Eduardo Catalano, description: This enormous (75 ft. or 23m) silver flower is located in Buenos Aires. It is designed to move, closing its petals in the evening or when strong winds blow and opening them in the morning., url: https://i.imgur.com/ZF6s192m.jpg, alt: A gigantic metallic flower sculpture with reflective mirror-like petals and strong stamens.]; App.js import useState from react;import sculptureList from ./data.js;export default function Gallery() const [index, setIndex] = useState(0); const [showMore, setShowMore] = useState(false); function handleNextClick() setIndex(index + 1); function handleMoreClick() setShowMore(!showMore); let sculpture = sculptureList[index]; return ( button onClick=handleNextClick Next /button h2 isculpture.name /i by sculpture.artist /h2 h3 (index + 1 of sculptureList.length) /h3 button onClick=handleMoreClick showMore ? Hide : Show details /button showMore psculpture.description/p img src=sculpture.url alt=sculpture.alt / / ); 如果它们不相关，那么存在多个 state 变量是一个好主意，例如本例中的 index 和 showMore。但是，如果你发现经常同时更改两个 state 变量，那么最好将它们合并为一个。例如，如果你有一个包含多个字段的表单，那么有一个值为对象的 state 变量比每个字段对应一个 state 变量更方便。 选择 state 结构在这方面有更多提示。 React 如何知道返回哪个 state你可能已经注意到，useState 在调用时没有任何关于它引用的是哪个 state 变量的信息。没有传递给 useState 的“标识符”，它是如何知道要返回哪个 state 变量呢？它是否依赖于解析函数之类的魔法？答案是否定的。 相反，为了使语法更简洁，在同一组件的每次渲染中，Hooks 都依托于一个稳定的调用顺序。这在实践中很有效，因为如果你遵循上面的规则（“只在顶层调用 Hooks”），Hooks 将始终以相同的顺序被调用。此外，linter 插件也可以捕获大多数错误。 在 React 内部，为每个组件保存了一个数组，其中每一项都是一个 state 对。它维护当前 state 对的索引值，在渲染之前将其设置为 “0”。每次调用 useState 时，React 都会为你提供一个 state 对并增加索引值。你可以在文章 React Hooks: not magic, just arrays中阅读有关此机制的更多信息。 这个例子没有使用 React，但它让你了解 useState 在内部是如何工作的： button id=nextButton Next/buttonh3 id=header/h3button id=moreButton/buttonp id=description/pimg id=imagestyle* box-sizing: border-box; body font-family: sans-serif; margin: 20px; padding: 0; button display: block; margin-bottom: 10px; /style let componentHooks = [];let currentHookIndex = 0;// useState 在 React 中是如何工作的（简化版）function useState(initialState) let pair = componentHooks[currentHookIndex]; if (pair) // 这不是第一次渲染 // 所以 state pair 已经存在 // 将其返回并为下一次 hook 的调用做准备 currentHookIndex++; return pair; // 这是我们第一次进行渲染 // 所以新建一个 state pair 然后存储它 pair = [initialState, setState]; function setState(nextState) // 当用户发起 state 的变更， // 把新的值放入 pair 中 pair[0] = nextState; updateDOM(); // 存储这个 pair 用于将来的渲染 // 并且为下一次 hook 的调用做准备 componentHooks[currentHookIndex] = pair; currentHookIndex++; return pair;function Gallery() // 每次调用 useState() 都会得到新的 pair const [index, setIndex] = useState(0); const [showMore, setShowMore] = useState(false); function handleNextClick() setIndex(index + 1); function handleMoreClick() setShowMore(!showMore); let sculpture = sculptureList[index]; // 这个例子没有使用 React，所以 // 返回一个对象而不是 JSX return onNextClick: handleNextClick, onMoreClick: handleMoreClick, header: `$sculpture.name by $sculpture.artist`, counter: `$index + 1 of $sculptureList.length`, more: `$showMore ? Hide : Show details`, description: showMore ? sculpture.description : null, imageSrc: sculpture.url, imageAlt: sculpture.alt ;function updateDOM() // 在渲染组件之前 // 重置当前 Hook 的下标 currentHookIndex = 0; let output = Gallery(); // 更新 DOM 以匹配输出结果 // 这部分工作由 React 为你完成 nextButton.onclick = output.onNextClick; header.textContent = output.header; moreButton.onclick = output.onMoreClick; moreButton.textContent = output.more; image.src = output.imageSrc; image.alt = output.imageAlt; if (output.description !== null) description.textContent = output.description; description.style.display = ; else description.style.display = none; let nextButton = document.getElementById(nextButton);let header = document.getElementById(header);let moreButton = document.getElementById(moreButton);let description = document.getElementById(description);let image = document.getElementById(image);let sculptureList = [ name: Homenaje a la Neurocirugía, artist: Marta Colvin Andrade, description: Although Colvin is predominantly known for abstract themes that allude to pre-Hispanic symbols, this gigantic sculpture, an homage to neurosurgery, is one of her most recognizable public art pieces., url: https://i.imgur.com/Mx7dA2Y.jpg, alt: A bronze statue of two crossed hands delicately holding a human brain in their fingertips. , name: Floralis Genérica, artist: Eduardo Catalano, description: This enormous (75 ft. or 23m) silver flower is located in Buenos Aires. It is designed to move, closing its petals in the evening or when strong winds blow and opening them in the morning., url: https://i.imgur.com/ZF6s192m.jpg, alt: A gigantic metallic flower sculpture with reflective mirror-like petals and strong stamens.];// 使 UI 匹配当前 stateupdateDOM(); 你不必理解它就可以使用 React，但你可能会发现这是一个有用的心智模型。 3.2.6 State 是隔离且私有的App.js import Gallery from ./Gallery.js;export default function Page() return ( div className=Page Gallery / Gallery / /div ); Gallery.js import useState from react;import sculptureList from ./data.js;export default function Gallery() const [index, setIndex] = useState(0); const [showMore, setShowMore] = useState(false); function handleNextClick() setIndex(index + 1); function handleMoreClick() setShowMore(!showMore); let sculpture = sculptureList[index]; return ( section button onClick=handleNextClick Next /button h2 isculpture.name /i by sculpture.artist /h2 h3 (index + 1 of sculptureList.length) /h3 button onClick=handleMoreClick showMore ? Hide : Show details /button showMore psculpture.description/p img src=sculpture.url alt=sculpture.alt / /section ); data.js export const sculptureList = [ name: Homenaje a la Neurocirugía, artist: Marta Colvin Andrade, description: Although Colvin is predominantly known for abstract themes that allude to pre-Hispanic symbols, this gigantic sculpture, an homage to neurosurgery, is one of her most recognizable public art pieces., url: https://i.imgur.com/Mx7dA2Y.jpg, alt: A bronze statue of two crossed hands delicately holding a human brain in their fingertips. , name: Floralis Genérica, artist: Eduardo Catalano, description: This enormous (75 ft. or 23m) silver flower is located in Buenos Aires. It is designed to move, closing its petals in the evening or when strong winds blow and opening them in the morning., url: https://i.imgur.com/ZF6s192m.jpg, alt: A gigantic metallic flower sculpture with reflective mirror-like petals and strong stamens.]; 这就是 state 与声明在模块顶部的普通变量不同的原因。 State 不依赖于特定的函数调用或在代码中的位置，它的作用域“只限于”屏幕上的某块特定区域。你渲染了两个 Gallery / 组件，所以它们的 state 是分别存储的。 还要注意 Page 组件“不知道”关于 Gallery state 的任何信息，甚至不知道它是否有任何 state。与 props 不同，state 完全私有于声明它的组件。父组件无法更改它。这使你可以向任何组件添加或删除 state，而不会影响其他组件。 如果你希望两个画廊保持其 states 同步怎么办？在 React 中执行此操作的正确方法是从子组件中删除 state 并将其添加到离它们最近的共享父组件中。接下来的几节将专注于组织单个组件的 state，但我们将在组件间共享 state 中回到这个主题。 3.2.7 摘要 当一个组件需要在多次渲染间“记住”某些信息时使用 state 变量。 State 变量是通过调用 useState Hook 来声明的。 Hook 是以 use 开头的特殊函数。它们能让你 “hook” 到像 state 这样的 React 特性中。 Hook 可能会让你想起 import：它们需要在非条件语句中调用。调用 Hook 时，包括 useState，仅在组件或另一个 Hook 的顶层被调用才有效。 useState Hook 返回一对值：当前 state 和更新它的函数。 你可以拥有多个 state 变量。在内部，React 按顺序匹配它们。 State 是组件私有的。如果你在两个地方渲染它，则每个副本都有独属于自己的 state。 3.3 渲染和提交组件显示到屏幕之前，其必须被 React 渲染。理解这些处理步骤将帮助你思考代码的执行过程并能解释其行为。 想象一下，你的组件是厨房里的厨师，把食材烹制成美味的菜肴。在这种场景下，React 就是一名服务员，他会帮客户们下单并为他们送来所点的菜品。这种请求和提供 UI 的过程总共包括三个步骤： 触发 一次渲染（把客人的点单分发到厨房） 渲染 组件（在厨房准备订单） 提交 到 DOM（将菜品放在桌子上） 3.3.1 步骤 1: 触发一次渲染有两种原因会导致组件的渲染: 组件的 初次渲染。 组件（或者其祖先之一）的 状态发生了改变。 初次渲染 当应用启动时，会触发初次渲染。框架和沙箱有时会隐藏这部分代码，但它是通过调用 createRoot 方法并传入目标 DOM 节点，然后用你的组件调用 render 函数完成的： index.js import Image from ./Image.js;import createRoot from react-dom/client;const root = createRoot(document.getElementById(root))root.render(Image /); image.js export default function Image() return ( img src=https://i.imgur.com/ZF6s192.jpg alt=Floralis Genérica by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals / ); 试着注释掉 root.render()，然后你将会看到组件消失。 状态更新时重新渲染 一旦组件被初次渲染，你就可以通过使用 set 函数 更新其状态来触发之后的渲染。更新组件的状态会自动将一次渲染送入队列。（你可以把这种情况想象成餐厅客人在第一次下单之后又点了茶、点心和各种东西，具体取决于他们的胃口。） 3.3.2 步骤 2: React 渲染你的组件在你触发渲染后，React 会调用你的组件来确定要在屏幕上显示的内容。“渲染中” 即 React 在调用你的组件。 在进行初次渲染时, React 会调用根组件。 对于后续的渲染, React 会调用内部状态更新触发了渲染的函数组件。 这个过程是递归的：如果更新后的组件会返回某个另外的组件，那么 React 接下来就会渲染 那个 组件，而如果那个组件又返回了某个组件，那么 React 接下来就会渲染 那个 组件，以此类推。这个过程会持续下去，直到没有更多的嵌套组件并且 React 确切知道哪些东西应该显示到屏幕上为止。 在接下来的例子中，React 将会调用 Gallery() 和 Image() 若干次： index.js import Gallery from ./Gallery.js;import createRoot from react-dom/client;const root = createRoot(document.getElementById(root))root.render(Gallery /); Gallery.js export default function Gallery() return ( section h1鼓舞人心的雕塑/h1 Image / Image / Image / /section );function Image() return ( img src=https://i.imgur.com/ZF6s192.jpg alt=Floralis Genérica by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals / ); 在初次渲染中， React 将会为section、h1 和三个 img 标签 创建 DOM 节点。 在一次重渲染过程中, React 将计算它们的哪些属性（如果有的话）自上次渲染以来已更改。在下一步（提交阶段）之前，它不会对这些信息执行任何操作。 渲染必须始终是一次 纯计算: 输入相同，输出相同。 给定相同的输入，组件应始终返回相同的 JSX。（当有人点了西红柿沙拉时，他们不应该收到洋葱沙拉！） 只做它自己的事情。 它不应更改任何存在于渲染之前的对象或变量。（一个订单不应更改其他任何人的订单。） 否则，随着代码库复杂性的增加，你可能会遇到令人困惑的错误和不可预测的行为。在 “严格模式” 下开发时，React 会调用每个组件的函数两次，这可以帮助发现由不纯函数引起的错误。 性能优化如果更新的组件在树中的位置非常高，渲染更新后的组件内部所有嵌套组件的默认行为将不会获得最佳性能。如果你遇到了性能问题，性能 章节描述了几种可选的解决方案 。不要过早进行优化！ 3.3.3 步骤 3: React 把更改提交到 DOM 上在渲染（调用）你的组件之后，React 将会修改 DOM。 对于初次渲染， React 会使用 appendChild() DOM API 将其创建的所有 DOM 节点放在屏幕上。 对于重渲染， React 将应用最少的必要操作（在渲染时计算！），以使得 DOM 与最新的渲染输出相互匹配。 React 仅在渲染之间存在差异时才会更改 DOM 节点。 例如，有一个组件，它每秒使用从父组件传递下来的不同属性重新渲染一次。注意，你可以添加一些文本到 input 标签，更新它的 value，但是文本不会在组件重渲染时消失： export default function Clock( time ) return ( h1time/h1 input / / ); 这个例子之所以会正常运行，是因为在最后一步中，React 只会使用最新的 time 更新 h1 标签的内容。它看到 input 标签出现在 JSX 中与上次相同的位置，因此 React 不会修改 input 标签或它的 value！ 3.3.4 尾声：浏览器绘制在渲染完成并且 React 更新 DOM 之后，浏览器就会重新绘制屏幕。尽管这个过程被称为“浏览器渲染”（“browser rendering”），但我们还是将它称为“绘制”（“painting”），以避免在这些文档的其余部分中出现混淆。 3.3.5 摘要 在一个 React 应用中一次屏幕更新都会发生以下三个步骤： 触发 渲染 提交 你可以使用严格模式去找到组件中的错误 如果渲染结果与上次一样，那么 React 将不会修改 DOM 3.4 state 如同一张快照也许 state 变量看起来和一般的可读写的 JavaScript 变量类似。但 state 在其表现出的特性上更像是一张快照。设置它不会更改你已有的 state 变量，但会触发重新渲染。 3.4.1 设置 state 会触发渲染你可能会认为你的用户界面会直接对点击之类的用户输入做出响应并发生变化。在 React 中，它的工作方式与这种思维模型略有不同。在上一页中，你看到了来自 React 的重新渲染和提交。这意味着要使界面对输入做出反应，你需要设置其 state。 在这个例子中，当你按下 “send” 时，setIsSent(true) 会通知 React 重新渲染 UI： import useState from react;export default function Form() const [isSent, setIsSent] = useState(false); const [message, setMessage] = useState(Hi!); if (isSent) return h1Your message is on its way!/h1 return ( form onSubmit=(e) = e.preventDefault(); setIsSent(true); sendMessage(message); textarea placeholder=Message value=message onChange=e = setMessage(e.target.value) / button type=submitSend/button /form );function sendMessage(message) // ... 当你单击按钮时会发生以下情况： 执行 onSubmit 事件处理函数。 setIsSent(true) 将 isSent 设置为 true 并排列一个新的渲染。 React 根据新的 isSent 值重新渲染组件。 让我们仔细看看 state 和渲染之间的关系。 3.4.2 渲染会及时生成一张快照“正在渲染” 就意味着 React 正在调用你的组件——一个函数。你从该函数返回的 JSX 就像是在某个时间点上 UI 的快照。它的 props、事件处理函数和内部变量都是 根据当前渲染时的 state 被计算出来的。 与照片或电影画面不同，你返回的 UI “快照”是可交互的。它其中包括类似事件处理函数的逻辑，这些逻辑用于指定如何对输入作出响应。React 随后会更新屏幕来匹配这张快照，并绑定事件处理函数。因此，按下按钮就会触发你 JSX 中的点击事件处理函数。 当 React 重新渲染一个组件时： React 会再次调用你的函数 函数会返回新的 JSX 快照 React 会更新界面以匹配返回的快照 作为一个组件的记忆，state 不同于在你的函数返回之后就会消失的普通变量。state 实际上“活”在 React 本身中——就像被摆在一个架子上！——位于你的函数之外。当 React 调用你的组件时，它会为特定的那一次渲染提供一张 state 快照。你的组件会在其 JSX 中返回一张包含一整套新的 props 和事件处理函数的 UI 快照 ，其中所有的值都是 根据那一次渲染中 state 的值 被计算出来的！ 这里有个向你展示其运行原理的小例子。在这个例子中，你可能会以为点击“+3”按钮会调用 setNumber(number + 1) 三次从而使计数器递增三次。 看看你点击“+3”按钮时会发生什么? export default function Counter() const [number, setNumber] = useState(0); return ( h1number/h1 button onClick=() = setNumber(number + 1); setNumber(number + 1); setNumber(number + 1); +3/button / )// 每次点击只会+1 请注意，每次点击只会让 number 递增一次！ 设置 state 只会为下一次渲染变更 state 的值。在第一次渲染期间，number 为 0。这也就解释了为什么在 那次渲染中的 onClick 处理函数中，即便在调用了 setNumber(number + 1) 之后，number 的值也仍然是 0： button onClick=() = setNumber(number + 1); setNumber(number + 1); setNumber(number + 1);+3/button 以下是这个按钮的点击事件处理函数通知 React 要做的事情： setNumber(number + 1)：number 是 0 所以 setNumber(0 + 1)。 React 准备在下一次渲染时将 number 更改为 1。 setNumber(number + 1)：number 是0 所以 setNumber(0 + 1)。 React 准备在下一次渲染时将 number 更改为 1。 setNumber(number + 1)：number 是0 所以 setNumber(0 + 1)。 React 准备在下一次渲染时将 number 更改为 1。 尽管你调用了三次 setNumber(number + 1)，但在 这次渲染的 事件处理函数中 number 会一直是 0，所以你会三次将 state 设置成 1。这就是为什么在你的事件处理函数执行完以后，React 重新渲染的组件中的 number 等于 1 而不是 3。 你还可以通过在心里把 state 变量替换成它们在你代码中的值来想象这个过程。由于 这次渲染 中的 state 变量 number 是 0，其事件处理函数看起来会像这样： button onClick=() = setNumber(0 + 1); setNumber(0 + 1); setNumber(0 + 1);+3/button 对于下一次渲染来说，number 是 1，因此 那次渲染中的 点击事件处理函数看起来会像这样： button onClick=() = setNumber(1 + 1); setNumber(1 + 1); setNumber(1 + 1);+3/button 这就是为什么再次点击按钮会将计数器设置为 2，下次点击时会设为 3，依此类推。 3.4.4 随时间变化的 state好的，刚才那些很有意思。试着猜猜点击这个按钮会发出什么警告： import useState from react;export default function Counter() const [number, setNumber] = useState(0); return ( h1number/h1 button onClick=() = setNumber(number + 5); alert(number); +5/button / )// alert显示0, number渲染为5 如果你使用之前替换的方法，你就能猜到这个提示框将会显示 “0”： setNumber(0 + 5);alert(0); 但如果你在这个提示框上加上一个定时器， 使得它在组件重新渲染 之后 才触发，又会怎样呢？是会显示 “0” 还是 “5” ？猜一猜！ import useState from react;export default function Counter() const [number, setNumber] = useState(0); return ( h1number/h1 button onClick=() = setNumber(number + 5); setTimeout(() = alert(number); , 3000); +5/button / ) 到提示框运行时，React 中存储的 state 可能已经发生了更改，但它是使用用户与之交互时状态的快照进行调度的！ 一个 state 变量的值永远不会在一次渲染的内部发生变化， 即使其事件处理函数的代码是异步的。在 那次渲染的 onClick 内部，number 的值即使在调用 setNumber(number + 5) 之后也还是 0。它的值在 React 通过调用你的组件“获取 UI 的快照”时就被“固定”了。 这里有个示例能够说明上述特性会使你的事件处理函数更不容易出现计时错误。下面是一个会在五秒延迟之后发送一条消息的表单。想象以下场景： 你按下“发送”按钮，向 Alice 发送“你好”。 在五秒延迟结束之前，将“To”字段的值更改为“Bob”。 你觉得 alert 会显示什么？它是会显示“你向 Alice 说了你好“还是会显示“你向 Bob 说了你好”？根据你已经学到的知识猜一猜，然后动手试一试： import useState from react;export default function Form() const [to, setTo] = useState(Alice); const [message, setMessage] = useState(你好); function handleSubmit(e) e.preventDefault(); setTimeout(() = alert(`你向 $to 说了$message`); , 5000); return ( form onSubmit=handleSubmit label To: select value=to onChange=e = setTo(e.target.value) option value=AliceAlice/option option value=BobBob/option /select /label textarea placeholder=Message value=message onChange=e = setMessage(e.target.value) / button type=submit发送/button /form ); React 会使 state 的值始终“固定”在一次渲染的各个事件处理函数内部。你无需担心代码运行时 state 是否发生了变化。 但是，万一你想在重新渲染之前读取最新的 state 怎么办？你应该使用 状态更新函数！ 3.4.5 摘要 设置 state 请求一次新的渲染。 React 将 state 存储在组件之外，就像在架子上一样。 当你调用 useState 时，React 会为你提供该次渲染 的一张 state 快照。 变量和事件处理函数不会在重渲染中“存活”。每个渲染都有自己的事件处理函数。 每个渲染（以及其中的函数）始终“看到”的是 React 提供给这个 渲染的 state 快照。 你可以在心中替换事件处理函数中的 state，类似于替换渲染的 JSX。 过去创建的事件处理函数拥有的是创建它们的那次渲染中的 state 值。 3.5 把一系列 state 更新加入队列设置组件 state 会把一次重新渲染加入队列。但有时你可能会希望在下次渲染加入队列之前对 state 的值执行多次操作。为此，了解 React 如何批量更新 state 会很有帮助。 3.5.1 React 会对 state 更新进行批处理在下面的示例中，你可能会认为点击 “+3” 按钮会使计数器递增三次，因为它调用了 setNumber(number + 1) 三次： import useState from react;export default function Counter() const [number, setNumber] = useState(0); return ( h1number/h1 button onClick=() = setNumber(number + 1); setNumber(number + 1); setNumber(number + 1); +3/button / ) 但是，你可能还记得上一节中的内容，每一次渲染的 state 值都是固定的，因此无论你调用多少次 setNumber(1)，在第一次渲染的事件处理函数内部的 number 值总是 0 ： setNumber(0 + 1);setNumber(0 + 1);setNumber(0 + 1); 但是这里还有另外一个影响因素需要讨论。React 会等到事件处理函数中的 所有 代码都运行完毕再处理你的 state 更新。 这就是重新渲染只会发生在所有这些 setNumber() 调用 之后 的原因。 这可能会让你想起餐厅里帮你点菜的服务员。服务员不会在你说第一道菜的时候就跑到厨房！相反，他们会让你把菜点完，让你修改菜品，甚至会帮桌上的其他人点菜。 这让你可以更新多个 state 变量——甚至来自多个组件的 state 变量——而不会触发太多的 重新渲染。但这也意味着只有在你的事件处理函数及其中任何代码执行完成 之后，UI 才会更新。这种特性也就是 批处理，它会使你的 React 应用运行得更快。它还会帮你避免处理只更新了一部分 state 变量的令人困惑的“半成品”渲染。 React 不会跨 多个 需要刻意触发的事件（如点击）进行批处理——每次点击都是单独处理的。请放心，React 只会在一般来说安全的情况下才进行批处理。这可以确保，例如，如果第一次点击按钮会禁用表单，那么第二次点击就不会再次提交它。 3.5.2 在下次渲染前多次更新同一个 state这是一个不常见的用例，但是如果你想在下次渲染之前多次更新同一个 state，你可以像 setNumber(n = n + 1) 这样传入一个根据队列中的前一个 state 计算下一个 state 的 函数，而不是像 setNumber(number + 1) 这样传入 下一个 state 值。这是一种告诉 React “用 state 值做某事”而不是仅仅替换它的方法。 现在尝试递增计数器： import useState from react;export default function Counter() const [number, setNumber] = useState(0); return ( h1number/h1 button onClick=() = setNumber(n = n + 1); setNumber(n = n + 1); setNumber(n = n + 1); +3/button / ) 在这里，n = n + 1 被称为 更新函数。当你将它传递给一个 state 设置函数时： React 会将此函数加入队列，以便在事件处理函数中的所有其他代码运行后进行处理。 在下一次渲染期间，React 会遍历队列并给你更新之后的最终 state。 setNumber(n = n + 1);setNumber(n = n + 1);setNumber(n = n + 1); 下面是 React 在执行事件处理函数时处理这几行代码的过程： setNumber(n = n + 1)：n = n + 1 是一个函数。React 将它加入队列。 setNumber(n = n + 1)：n = n + 1 是一个函数。React 将它加入队列。 setNumber(n = n + 1)：n = n + 1 是一个函数。React 将它加入队列。 当你在下次渲染期间调用 useState 时，React 会遍历队列。之前的 number state 的值是 0，所以这就是 React 作为参数 n 传递给第一个更新函数的值。然后 React 会获取你上一个更新函数的返回值，并将其作为 n 传递给下一个更新函数，以此类推： 更新队列 n 返回值 n = n + 1 0 0 + 1 = 1 n = n + 1 1 1 + 1 = 2 n = n + 1 2 2 + 1 = 3 React 会保存 3 为最终结果并从 useState 中返回。 这就是为什么在上面的示例中点击“+3”正确地将值增加“+3”。 3.5.3 如果你在替换 state 后更新 state 会发生什么?这个事件处理函数会怎么样？你认为 number 在下一次渲染中的值是什么？ button onClick=() = setNumber(number + 5); setNumber(n = n + 1); import useState from react;export default function Counter() const [number, setNumber] = useState(0); return ( h1number/h1 button onClick=() = setNumber(number + 5); setNumber(n = n + 1); 增加数字/button / ) 这是事件处理函数告诉 React 要做的事情： setNumber(number + 5)：number 为 0，所以 setNumber(0 + 5)。React 将 “替换为 5” 添加到其队列中。 setNumber(n = n + 1)：n = n + 1 是一个更新函数。 React 将 该函数 添加到其队列中。 在下一次渲染期间，React 会遍历 state 队列： 更新队列 n 返回值 “替换为 5” 0（未使用） 5 n = n + 1 5 5 + 1 = 6 React 会保存 6 为最终结果并从 useState 中返回。 你可能已经注意到，setState(x) 实际上会像 setState(n = x) 一样运行，只是没有使用 n！ 3.5.4 如果你在更新 state 后替换 state 会发生什么 ?让我们再看一个例子。你认为 number 在下一次渲染中的值是什么？ button onClick=() = setNumber(number + 5); setNumber(n = n + 1); setNumber(42); import useState from react;export default function Counter() const [number, setNumber] = useState(0); return ( h1number/h1 button onClick=() = setNumber(number + 5); setNumber(n = n + 1); setNumber(42); alert(number) 增加数字/button / ) 以下是 React 在执行事件处理函数时处理这几行代码的过程： setNumber(number + 5)：number 为 0，所以 setNumber(0 + 5)。React 将 “替换为 5” 添加到其队列中。 setNumber(n = n + 1)：n = n + 1 是一个更新函数。React 将该函数添加到其队列中。 setNumber(42)：React 将 “替换为 42” 添加到其队列中。 在下一次渲染期间，React 会遍历 state 队列： 更新队列 n 返回值 “替换为 5” 0（未使用） 5 n = n + 1 5 5 + 1 = 6 “替换为 42” 6（未使用） 42 然后 React 会保存 42 为最终结果并从 useState 中返回。 总而言之，以下是你可以考虑传递给 setNumber state 设置函数的内容： 一个更新函数（例如：n = n + 1）会被添加到队列中。 任何其他的值（例如：数字 5）会导致“替换为 5”被添加到队列中，已经在队列中的内容会被忽略。 事件处理函数执行完成后，React 将触发重新渲染。在重新渲染期间，React 将处理队列。更新函数会在渲染期间执行，因此 更新函数必须是 纯函数 并且只 返回 结果。不要尝试从它们内部设置 state 或者执行其他副作用。在严格模式下，React 会执行每个更新函数两次（但是丢弃第二个结果）以便帮助你发现错误。 3.5.5 命名惯例通常可以通过相应 state 变量的第一个字母来命名更新函数的参数： setEnabled(e = !e);setLastName(ln = ln.reverse());setFriendCount(fc = fc * 2); 如果你喜欢更冗长的代码，另一个常见的惯例是重复使用完整的 state 变量名称，如 setEnabled(enabled = !enabled)，或使用前缀，如 setEnabled(prevEnabled = !prevEnabled)。 3.5.6 摘要 设置 state 不会更改现有渲染中的变量，但会请求一次新的渲染。 React 会在事件处理函数执行完成之后处理 state 更新。这被称为批处理。 要在一个事件中多次更新某些 state，你可以使用 setNumber(n = n + 1) 更新函数。 3.6 更新 state 中的对象state 中可以保存任意类型的 JavaScript 值，包括对象。但是，你不应该直接修改存放在 React state 中的对象。相反，当你想要更新一个对象时，你需要创建一个新的对象（或者将其拷贝一份），然后将 state 更新为此对象。 3.6.1 什么是 mutation？你可以在 state 中存放任意类型的 JavaScript 值。 const [x, setX] = useState(0); 到目前为止，你已经尝试过在 state 中存放数字、字符串和布尔值，这些类型的值在 JavaScript 中是不可变（immutable）的，这意味着它们不能被改变或是只读的。你可以通过替换它们的值以触发一次重新渲染。 setX(5); state x 从 0 变为 5，但是数字 0 本身并没有发生改变。在 JavaScript 中，无法对内置的原始值，如数字、字符串和布尔值，进行任何更改。 现在考虑 state 中存放对象的情况： const [position, setPosition] = useState( x: 0, y: 0 ); 从技术上来讲，可以改变对象自身的内容。当你这样做时，就制造了一个 mutation： position.x = 5; 然而，虽然严格来说 React state 中存放的对象是可变的，但你应该像处理数字、布尔值、字符串一样将它们视为不可变的。因此你应该替换它们的值，而不是对它们进行修改。 3.6.2 将 state 视为只读的换句话说，你应该 把所有存放在 state 中的 JavaScript 对象都视为只读的。 在下面的例子中，我们用一个存放在 state 中的对象来表示指针当前的位置。当你在预览区触摸或移动光标时，红色的点本应移动。但是实际上红点仍停留在原处： import useState from react;export default function MovingDot() const [position, setPosition] = useState( x: 0, y: 0 ); return ( div onPointerMove=e = position.x = e.clientX; position.y = e.clientY; style= position: relative, width: 100vw, height: 100vh, div style= position: absolute, backgroundColor: red, borderRadius: 50%, transform: `translate($position.xpx, $position.ypx)`, left: -10, top: -10, width: 20, height: 20, / /div ); 问题出在下面这段代码中。 onPointerMove=e = position.x = e.clientX; position.y = e.clientY; 这段代码直接修改了 上一次渲染中 分配给 position 的对象。但是因为并没有使用 state 的设置函数，React 并不知道对象已更改。所以 React 没有做出任何响应。这就像在吃完饭之后才尝试去改变要点的菜一样。虽然在一些情况下，直接修改 state 可能是有效的，但我们并不推荐这么做。你应该把在渲染过程中可以访问到的 state 视为只读的。 在这种情况下，为了真正地 触发一次重新渲染，你需要创建一个新对象并把它传递给 state 的设置函数： onPointerMove=e = setPosition( x: e.clientX, y: e.clientY ); 通过使用 setPosition，你在告诉 React： 使用这个新的对象替换 position 的值 然后再次渲染这个组件 现在你可以看到，当你在预览区触摸或移动光标时，红点会跟随着你的指针移动： import useState from react;export default function MovingDot() const [position, setPosition] = useState( x: 0, y: 0 ); return ( div onPointerMove=e = setPosition( x: e.clientX, y: e.clientY ); style= position: relative, width: 100vw, height: 100vh, div style= position: absolute, backgroundColor: red, borderRadius: 50%, transform: `translate($position.xpx, $position.ypx)`, left: -10, top: -10, width: 20, height: 20, / /div ); 局部 mutation 是可以接受的像这样的代码是有问题的，因为它改变了 state 中现有的对象： position.x = e.clientX;position.y = e.clientY; 但是像这样的代码就 没有任何问题，因为你改变的是你刚刚创建的一个新的对象： const nextPosition = ;nextPosition.x = e.clientX;nextPosition.y = e.clientY;setPosition(nextPosition); 事实上，它完全等同于下面这种写法： setPosition( x: e.clientX, y: e.clientY); 只有当你改变已经处于 state 中的 现有 对象时，mutation 才会成为问题。而修改一个你刚刚创建的对象就不会出现任何问题，因为 还没有其他的代码引用它。改变它并不会意外地影响到依赖它的东西。这叫做“局部 mutation”。你甚至可以 在渲染的过程中 进行“局部 mutation”的操作。这种操作既便捷又没有任何问题！ 3.6.3 使用展开语法复制对象在之前的例子中，始终会根据当前指针的位置创建出一个新的 position 对象。但是通常，你会希望把 现有 数据作为你所创建的新对象的一部分。例如，你可能只想要更新表单中的一个字段，其他的字段仍然使用之前的值。 下面的代码中，输入框并不会正常运行，因为 onChange 直接修改了 state ： import useState from react;export default function Form() const [person, setPerson] = useState( firstName: Barbara, lastName: Hepworth, email: bhepworth@sculpture.com ); function handleFirstNameChange(e) person.firstName = e.target.value; function handleLastNameChange(e) person.lastName = e.target.value; function handleEmailChange(e) person.email = e.target.value; return ( label First name: input value=person.firstName onChange=handleFirstNameChange / /label label Last name: input value=person.lastName onChange=handleLastNameChange / /label label Email: input value=person.email onChange=handleEmailChange / /label p person.firstName person.lastName (person.email) /p / ); 例如，下面这行代码修改了上一次渲染中的 state： person.firstName = e.target.value; 想要实现你的需求，最可靠的办法就是创建一个新的对象并将它传递给 setPerson。但是在这里，你还需要 把当前的数据复制到新对象中，因为你只改变了其中一个字段： setPerson( firstName: e.target.value, // 从 input 中获取新的 first name lastName: person.lastName, email: person.email); 你可以使用 ... 对象展开 语法，这样你就不需要单独复制每个属性。 setPerson( ...person, // 复制上一个 person 中的所有字段 firstName: e.target.value // 但是覆盖 firstName 字段 ); 现在表单可以正常运行了！ 可以看到，你并没有为每个输入框单独声明一个 state。对于大型表单，将所有数据都存放在同一个对象中是非常方便的——前提是你能够正确地更新它！ import useState from react;export default function Form() const [person, setPerson] = useState( firstName: Barbara, lastName: Hepworth, email: bhepworth@sculpture.com ); function handleFirstNameChange(e) setPerson( ...person, firstName: e.target.value ); function handleLastNameChange(e) setPerson( ...person, lastName: e.target.value ); function handleEmailChange(e) setPerson( ...person, email: e.target.value ); return ( label First name: input value=person.firstName onChange=handleFirstNameChange / /label label Last name: input value=person.lastName onChange=handleLastNameChange / /label label Email: input value=person.email onChange=handleEmailChange / /label p person.firstName person.lastName (person.email) /p / ); 请注意 ... 展开语法本质是是“浅拷贝”——它只会复制一层。这使得它的执行速度很快，但是也意味着当你想要更新一个嵌套属性时，你必须得多次使用展开语法。 使用一个事件处理函数来更新多个字段你也可以在对象的定义中使用 [ 和 ] 括号来实现属性的动态命名。下面是同一个例子，但它使用了一个事件处理函数而不是三个： import useState from react;export default function Form() const [person, setPerson] = useState( firstName: Barbara, lastName: Hepworth, email: bhepworth@sculpture.com ); function handleChange(e) setPerson( ...person, [e.target.name]: e.target.value ); return ( label First name: input name=firstName value=person.firstName onChange=handleChange / /label label Last name: input name=lastName value=person.lastName onChange=handleChange / /label label Email: input name=email value=person.email onChange=handleChange / /label p person.firstName person.lastName (person.email) /p / ); 在这里，e.target.name 引用了 input 这个 DOM 元素的 name 属性。 3.6.4 更新一个嵌套对象考虑下面这种结构的嵌套对象： const [person, setPerson] = useState( name: Niki de Saint Phalle, artwork: title: Blue Nana, city: Hamburg, image: https://i.imgur.com/Sd1AgUOm.jpg, ); 如果你想要更新 person.artwork.city 的值，用 mutation 来实现的方法非常容易理解： person.artwork.city = New Delhi; 但是在 React 中，你需要将 state 视为不可变的！为了修改 city 的值，你首先需要创建一个新的 artwork 对象（其中预先填充了上一个 artwork 对象中的数据），然后创建一个新的 person 对象，并使得其中的 artwork 属性指向新创建的 artwork 对象： const nextArtwork = ...person.artwork, city: New Delhi ;const nextPerson = ...person, artwork: nextArtwork ;setPerson(nextPerson); 或者，写成一个函数调用： setPerson( ...person, // 复制其它字段的数据 artwork: // 替换 artwork 字段 ...person.artwork, // 复制之前 person.artwork 中的数据 city: New Delhi // 但是将 city 的值替换为 New Delhi！ ); 这虽然看起来有点冗长，但对于很多情况都能有效地解决问题： import useState from react;export default function Form() const [person, setPerson] = useState( name: Niki de Saint Phalle, artwork: title: Blue Nana, city: Hamburg, image: https://i.imgur.com/Sd1AgUOm.jpg, ); function handleNameChange(e) setPerson( ...person, name: e.target.value ); function handleTitleChange(e) setPerson( ...person, artwork: ...person.artwork, title: e.target.value ); function handleCityChange(e) setPerson( ...person, artwork: ...person.artwork, city: e.target.value ); function handleImageChange(e) setPerson( ...person, artwork: ...person.artwork, image: e.target.value ); return ( label Name: input value=person.name onChange=handleNameChange / /label label Title: input value=person.artwork.title onChange=handleTitleChange / /label label City: input value=person.artwork.city onChange=handleCityChange / /label label Image: input value=person.artwork.image onChange=handleImageChange / /label p iperson.artwork.title/i by person.name br / (located in person.artwork.city) /p img src=person.artwork.image alt=person.artwork.title / / ); 对象并非是真正嵌套的下面这个对象从代码上来看是“嵌套”的： let obj = name: Niki de Saint Phalle, artwork: title: Blue Nana, city: Hamburg, image: https://i.imgur.com/Sd1AgUOm.jpg, ; 然而，当我们思考对象的特性时，“嵌套”并不是一个非常准确的方式。当这段代码运行的时候，不存在“嵌套”的对象。你实际上看到的是两个不同的对象： let obj1 = title: Blue Nana, city: Hamburg, image: https://i.imgur.com/Sd1AgUOm.jpg,;let obj2 = name: Niki de Saint Phalle, artwork: obj1; 对象 obj1 并不处于 obj2 的“内部”。例如，下面的代码中，obj3 中的属性也可以指向 obj1： let obj1 = title: Blue Nana, city: Hamburg, image: https://i.imgur.com/Sd1AgUOm.jpg,;let obj2 = name: Niki de Saint Phalle, artwork: obj1;let obj3 = name: Copycat, artwork: obj1; 如果你直接修改 obj3.artwork.city，就会同时影响 obj2.artwork.city 和 obj1.city。这是因为 obj3.artwork、obj2.artwork 和 obj1 都指向同一个对象。当你用“嵌套”的方式看待对象时，很难看出这一点。相反，它们是相互独立的对象，只不过是用属性“指向”彼此而已。 3.6.5 使用 Immer 编写简洁的更新逻辑如果你的 state 有多层的嵌套，你或许应该考虑 将其扁平化。但是，如果你不想改变 state 的数据结构，你可能更喜欢用一种更便捷的方式来实现嵌套展开的效果。Immer 是一个非常流行的库，它可以让你使用简便但可以直接修改的语法编写代码，并会帮你处理好复制的过程。通过使用 Immer，你写出的代码看起来就像是你“打破了规则”而直接修改了对象： updatePerson(draft = draft.artwork.city = Lagos;); 但是不同于一般的 mutation，它并不会覆盖之前的 state！ Immer 是如何运行的？由 Immer 提供的 draft 是一种特殊类型的对象，被称为 Proxy，它会记录你用它所进行的操作。这就是你能够随心所欲地直接修改对象的原因所在！从原理上说，Immer 会弄清楚 draft 对象的哪些部分被改变了，并会依照你的修改创建出一个全新的对象。 尝试使用 Immer: 运行 npm install use-immer 添加 Immer 依赖 用 import useImmer from use-immer 替换掉 import useState from react 下面我们把上面的例子用 Immer 实现一下： import useImmer from use-immer;export default function Form() const [person, updatePerson] = useImmer( name: Niki de Saint Phalle, artwork: title: Blue Nana, city: Hamburg, image: https://i.imgur.com/Sd1AgUOm.jpg, ); function handleNameChange(e) updatePerson(draft = draft.name = e.target.value; ); function handleTitleChange(e) updatePerson(draft = draft.artwork.title = e.target.value; ); function handleCityChange(e) updatePerson(draft = draft.artwork.city = e.target.value; ); function handleImageChange(e) updatePerson(draft = draft.artwork.image = e.target.value; ); return ( label Name: input value=person.name onChange=handleNameChange / /label label Title: input value=person.artwork.title onChange=handleTitleChange / /label label City: input value=person.artwork.city onChange=handleCityChange / /label label Image: input value=person.artwork.image onChange=handleImageChange / /label p iperson.artwork.title/i by person.name br / (located in person.artwork.city) /p img src=person.artwork.image alt=person.artwork.title / / ); 可以看到，事件处理函数变得更简洁了。你可以随意在一个组件中同时使用 useState 和 useImmer。如果你想要写出更简洁的更新处理函数，Immer 会是一个不错的选择，尤其是当你的 state 中有嵌套，并且复制对象会带来重复的代码时。 为什么在 React 中不推荐直接修改 state？有以下几个原因： 调试：如果你使用 console.log 并且不直接修改 state，你之前日志中的 state 的值就不会被新的 state 变化所影响。这样你就可以清楚地看到两次渲染之间 state 的值发生了什么变化 优化：React 常见的 优化策略 依赖于如果之前的 props 或者 state 的值和下一次相同就跳过渲染。如果你从未直接修改 state ，那么你就可以很快看到 state 是否发生了变化。如果 prevObj === obj，那么你就可以肯定这个对象内部并没有发生改变。 新功能：我们正在构建的 React 的新功能依赖于 state 被 像快照一样看待 的理念。如果你直接修改 state 的历史版本，可能会影响你使用这些新功能。 需求变更：有些应用功能在不出现任何修改的情况下会更容易实现，比如实现撤销恢复、展示修改历史，或是允许用户把表单重置成某个之前的值。这是因为你可以把 state 之前的拷贝保存到内存中，并适时对其进行再次使用。如果一开始就用了直接修改 state 的方式，那么后面要实现这样的功能就会变得非常困难。 更简单的实现：React 并不依赖于 mutation ，所以你不需要对对象进行任何特殊操作。它不需要像很多“响应式”的解决方案一样去劫持对象的属性、总是用代理把对象包裹起来，或者在初始化时做其他工作。这也是 React 允许你把任何对象存放在 state 中——不管对象有多大——而不会造成有任何额外的性能或正确性问题的原因。 在实践中，你经常可以“侥幸”直接修改 state 而不出现什么问题，但是我们强烈建议你不要这样做，这样你就可以使用我们秉承着这种理念开发的 React 新功能。未来的贡献者甚至是你未来的自己都会感谢你的！ 3.6.6 摘要 将 React 中所有的 state 都视为不可直接修改的。 当你在 state 中存放对象时，直接修改对象并不会触发重渲染，并会改变前一次渲染“快照”中 state 的值。 不要直接修改一个对象，而要为它创建一个 新 版本，并通过把 state 设置成这个新版本来触发重新渲染。 你可以使用这样的 ...obj, something: newValue 对象展开语法来创建对象的拷贝。 对象的展开语法是浅层的：它的复制深度只有一层。 想要更新嵌套对象，你需要从你更新的位置开始自底向上为每一层都创建新的拷贝。 想要减少重复的拷贝代码，可以使用 Immer。 3.7 更新 state 中的数组数组是另外一种可以存储在 state 中的 JavaScript 对象，它虽然是可变的，但是却应该被视为不可变。同对象一样，当你想要更新存储于 state 中的数组时，你需要创建一个新的数组（或者创建一份已有数组的拷贝值），并使用新数组设置 state。 3.7.1 在没有 mutation 的前提下更新数组在 JavaScript 中，数组只是另一种对象。同对象一样，你需要将 React state 中的数组视为只读的。这意味着你不应该使用类似于 arr[0] = bird 这样的方式来重新分配数组中的元素，也不应该使用会直接修改原始数组的方法，例如 push() 和 pop()。 相反，每次要更新一个数组时，你需要把一个新的数组传入 state 的 setting 方法中。为此，你可以通过使用像 filter() 和 map() 这样不会直接修改原始值的方法，从原始数组生成一个新的数组。然后你就可以将 state 设置为这个新生成的数组。 下面是常见数组操作的参考表。当你操作 React state 中的数组时，你需要避免使用左列的方法，而首选右列的方法： 避免使用 (会改变原始数组) 推荐使用 (会返回一个新数组） 添加元素 push，unshift concat，[...arr] 展开语法（例子） 删除元素 pop，shift，splice filter，slice（例子） 替换元素 splice，arr[i] = ... 赋值 map（例子） 排序 reverse，sort 先将数组复制一份（例子） 或者，你可以使用 Immer ，这样你便可以使用表格中的所有方法了。 不幸的是，虽然 slice 和 splice 的名字相似，但作用却迥然不同： slice 让你可以拷贝数组或是数组的一部分。 splice 会直接修改 原始数组（插入或者删除元素）。 在 React 中，更多情况下你会使用 slice（没有 p ！），因为你不想改变 state 中的对象或数组。更新对象这一章节解释了什么是 mutation，以及为什么不推荐在 state 里这样做。 3.7.2 向数组中添加元素push() 会直接修改原始数组，而你不希望这样： import useState from react;let nextId = 0;export default function List() const [name, setName] = useState(); const [artists, setArtists] = useState([]); return ( h1振奋人心的雕塑家们：/h1 input value=name onChange=e = setName(e.target.value) / button onClick=() = artists.push( id: nextId++, name: name, ); 添加/button ul artists.map(artist = ( li key=artist.idartist.name/li )) /ul / ); 相反，你应该创建一个 新 数组，其包含了原始数组的所有元素 以及 一个在末尾的新元素。这可以通过很多种方法实现，最简单的一种就是使用 ... 数组展开 语法： setArtists( // 替换 state [ // 是通过传入一个新数组实现的 ...artists, // 新数组包含原数组的所有元素 id: nextId++, name: name // 并在末尾添加了一个新的元素 ]); import useState from react;let nextId = 0;export default function List() const [name, setName] = useState(); const [artists, setArtists] = useState([]); return ( h1振奋人心的雕塑家们：/h1 input value=name onChange=e = setName(e.target.value) / button onClick=() = setArtists([ ...artists, id: nextId++, name: name ]); 添加/button ul artists.map(artist = ( li key=artist.idartist.name/li )) /ul / ); 数组展开运算符还允许你把新添加的元素放在原始的 ...artists 之前： setArtists([ id: nextId++, name: name , ...artists // 将原数组中的元素放在末尾]); 这样一来，展开操作就可以完成 push() 和 unshift() 的工作，将新元素添加到数组的末尾和开头。 3.7.3 从数组中删除元素从数组中删除一个元素最简单的方法就是将它过滤出去。换句话说，你需要生成一个不包含该元素的新数组。这可以通过 filter 方法实现，例如： import useState from react;let initialArtists = [ id: 0, name: Marta Colvin Andrade , id: 1, name: Lamidi Olonade Fakeye, id: 2, name: Louise Nevelson,];export default function List() const [artists, setArtists] = useState( initialArtists ); return ( h1振奋人心的雕塑家们：/h1 ul artists.map(artist = ( li key=artist.id artist.name button onClick=() = setArtists( artists.filter(a = a.id !== artist.id ) ); 删除 /button /li )) /ul / ); 点击“删除”按钮几次，并且查看按钮处理点击事件的代码。 setArtists( artists.filter(a = a.id !== artist.id)); 这里，artists.filter(s = s.id !== artist.id) 表示“创建一个新的数组，该数组由那些 ID 与 artists.id 不同的 artists 组成”。换句话说，每个 artist 的“删除”按钮会把 那一个 artist 从原始数组中过滤掉，并使用过滤后的数组再次进行渲染。注意，filter 并不会改变原始数组。 3.7.4 转换数组如果你想改变数组中的某些或全部元素，你可以用 map() 创建一个新数组。你传入 map 的函数决定了要根据每个元素的值或索引（或二者都要）对元素做何处理。 在下面的例子中，一个数组记录了两个圆形和一个正方形的坐标。当你点击按钮时，仅有两个圆形会向下移动 100 像素。这是通过使用 map() 生成一个新数组实现的。 import useState from react;let initialShapes = [ id: 0, type: circle, x: 50, y: 100 , id: 1, type: square, x: 150, y: 100 , id: 2, type: circle, x: 250, y: 100 ,];export default function ShapeEditor() const [shapes, setShapes] = useState( initialShapes ); function handleClick() const nextShapes = shapes.map(shape = if (shape.type === square) // 不作改变 return shape; else // 返回一个新的圆形，位置在下方 50px 处 return ...shape, y: shape.y + 50, ; ); // 使用新的数组进行重渲染 setShapes(nextShapes); return ( button onClick=handleClick 所有圆形向下移动！ /button shapes.map(shape = ( div key=shape.id style= background: purple, position: absolute, left: shape.x, top: shape.y, borderRadius: shape.type === circle ? 50% : , width: 20, height: 20, / )) / ); 3.7.5 替换数组中的元素想要替换数组中一个或多个元素是非常常见的。类似 arr[0] = bird 这样的赋值语句会直接修改原始数组，所以在这种情况下，你也应该使用 map。 要替换一个元素，请使用 map 创建一个新数组。在你的 map 回调里，第二个参数是元素的索引。使用索引来判断最终是返回原始的元素（即回调的第一个参数）还是替换成其他值： import useState from react;let initialCounters = [ 0, 0, 0];export default function CounterList() const [counters, setCounters] = useState( initialCounters ); function handleIncrementClick(index) const nextCounters = counters.map((c, i) = if (i === index) // 递增被点击的计数器数值 return c + 1; else // 其余部分不发生变化 return c; ); setCounters(nextCounters); return ( ul counters.map((counter, i) = ( li key=i counter button onClick=() = handleIncrementClick(i); +1/button /li )) /ul ); 3.7.6 向数组中插入元素有时，你也许想向数组特定位置插入一个元素，这个位置既不在数组开头，也不在末尾。为此，你可以将数组展开运算符 ... 和 slice() 方法一起使用。slice() 方法让你从数组中切出“一片”。为了将元素插入数组，你需要先展开原数组在插入点之前的切片，然后插入新元素，最后展开原数组中剩下的部分。 下面的例子中，插入按钮总是会将元素插入到数组中索引为 1 的位置。 import useState from react;let nextId = 3;const initialArtists = [ id: 0, name: Marta Colvin Andrade , id: 1, name: Lamidi Olonade Fakeye, id: 2, name: Louise Nevelson,];export default function List() const [name, setName] = useState(); const [artists, setArtists] = useState( initialArtists ); function handleClick() const insertAt = 1; // 可能是任何索引 const nextArtists = [ // 插入点之前的元素： ...artists.slice(0, insertAt), // 新的元素： id: nextId++, name: name , // 插入点之后的元素： ...artists.slice(insertAt) ]; setArtists(nextArtists); setName(); return ( h1振奋人心的雕塑家们：/h1 input value=name onChange=e = setName(e.target.value) / button onClick=handleClick 插入 /button ul artists.map(artist = ( li key=artist.idartist.name/li )) /ul / ); 3.7.7 其他改变数组的情况总会有一些事，是你仅仅依靠展开运算符和 map() 或者 filter() 等不会直接修改原值的方法所无法做到的。例如，你可能想翻转数组，或是对数组排序。而 JavaScript 中的 reverse() 和 sort() 方法会改变原数组，所以你无法直接使用它们。 然而，你可以先拷贝这个数组，再改变这个拷贝后的值。 例如： import useState from react;const initialList = [ id: 0, title: Big Bellies , id: 1, title: Lunar Landscape , id: 2, title: Terracotta Army ,];export default function List() const [list, setList] = useState(initialList); function handleClick() const nextList = [...list]; nextList.reverse(); setList(nextList); return ( button onClick=handleClick 翻转 /button ul list.map(artwork = ( li key=artwork.idartwork.title/li )) /ul / ); 在这段代码中，你先使用 [...list] 展开运算符创建了一份数组的拷贝值。当你有了这个拷贝值后，你就可以使用像 nextList.reverse() 或 nextList.sort() 这样直接修改原数组的方法。你甚至可以通过 nextList[0] = something 这样的方式对数组中的特定元素进行赋值。 然而，即使你拷贝了数组，你还是不能直接修改其内部的元素。这是因为数组的拷贝是浅拷贝——新的数组中依然保留了与原始数组相同的元素。因此，如果你修改了拷贝数组内部的某个对象，其实你正在直接修改当前的 state。举个例子，像下面的代码就会带来问题。 const nextList = [...list];nextList[0].seen = true; // 问题：直接修改了 list[0] 的值setList(nextList); 虽然 nextList 和 list 是两个不同的数组，**nextList[0] 和 list[0] 却指向了同一个对象**。因此，通过改变 nextList[0].seen，list[0].seen 的值也被改变了。这是一种 state 的 mutation 操作，你应该避免这么做！你可以用类似于 更新嵌套的 JavaScript 对象 的方式解决这个问题——拷贝想要修改的特定元素，而不是直接修改它。下面是具体的操作。 3.7.8 更新数组内部的对象对象并不是 真的 位于数组“内部”。可能他们在代码中看起来像是在数组“内部”，但其实数组中的每个对象都是这个数组“指向”的一个存储于其它位置的值。这就是当你在处理类似 list[0] 这样的嵌套字段时需要格外小心的原因。其他人的艺术品清单可能指向了数组的同一个元素！ 当你更新一个嵌套的 state 时，你需要从想要更新的地方创建拷贝值，一直这样，直到顶层。 让我们看一下这该怎么做。 在下面的例子中，两个不同的艺术品清单有着相同的初始 state。他们本应该互不影响，但是因为一次 mutation，他们的 state 被意外地共享了，勾选一个清单中的事项会影响另外一个清单： import useState from react;let nextId = 3;const initialList = [ id: 0, title: Big Bellies, seen: false , id: 1, title: Lunar Landscape, seen: false , id: 2, title: Terracotta Army, seen: true ,];export default function BucketList() const [myList, setMyList] = useState(initialList); const [yourList, setYourList] = useState( initialList ); function handleToggleMyList(artworkId, nextSeen) const myNextList = [...myList]; const artwork = myNextList.find( a = a.id === artworkId ); artwork.seen = nextSeen; setMyList(myNextList); function handleToggleYourList(artworkId, nextSeen) const yourNextList = [...yourList]; const artwork = yourNextList.find( a = a.id === artworkId ); artwork.seen = nextSeen; setYourList(yourNextList); return ( h1艺术愿望清单/h1 h2我想看的艺术清单：/h2 ItemList artworks=myList onToggle=handleToggleMyList / h2你想看的艺术清单：/h2 ItemList artworks=yourList onToggle=handleToggleYourList / / );function ItemList( artworks, onToggle ) return ( ul artworks.map(artwork = ( li key=artwork.id label input type=checkbox checked=artwork.seen onChange=e = onToggle( artwork.id, e.target.checked ); / artwork.title /label /li )) /ul ); 问题出在下面这段代码中: const myNextList = [...myList];const artwork = myNextList.find(a = a.id === artworkId);artwork.seen = nextSeen; // 问题：直接修改了已有的元素setMyList(myNextList); 虽然 myNextList 这个数组是新的，但是其内部的元素本身与原数组 myList 是相同的。因此，修改 artwork.seen，其实是在修改原始的 artwork 对象。而这个 artwork 对象也被 yourList 使用，这样就带来了 bug。这样的 bug 可能难以想到，但好在如果你避免直接修改 state，它们就会消失。 你可以使用 map 在没有 mutation 的前提下将一个旧的元素替换成更新的版本。 setMyList(myList.map(artwork = if (artwork.id === artworkId) // 创建包含变更的 新 对象 return ...artwork, seen: nextSeen ; else // 没有变更 return artwork; )); 此处的 ... 是一个对象展开语法，被用来创建一个对象的拷贝. 通过这种方式，没有任何现有的 state 中的元素会被改变，bug 也就被修复了。 import useState from react;let nextId = 3;const initialList = [ id: 0, title: Big Bellies, seen: false , id: 1, title: Lunar Landscape, seen: false , id: 2, title: Terracotta Army, seen: true ,];export default function BucketList() const [myList, setMyList] = useState(initialList); const [yourList, setYourList] = useState( initialList ); function handleToggleMyList(artworkId, nextSeen) setMyList(myList.map(artwork = if (artwork.id === artworkId) // 创建包含变更的*新*对象 return ...artwork, seen: nextSeen ; else // 没有变更 return artwork; )); function handleToggleYourList(artworkId, nextSeen) setYourList(yourList.map(artwork = if (artwork.id === artworkId) // 创建包含变更的*新*对象 return ...artwork, seen: nextSeen ; else // 没有变更 return artwork; )); return ( h1艺术愿望清单/h1 h2我想看的艺术清单：/h2 ItemList artworks=myList onToggle=handleToggleMyList / h2你想看的艺术清单：/h2 ItemList artworks=yourList onToggle=handleToggleYourList / / );function ItemList( artworks, onToggle ) return ( ul artworks.map(artwork = ( li key=artwork.id label input type=checkbox checked=artwork.seen onChange=e = onToggle( artwork.id, e.target.checked ); / artwork.title /label /li )) /ul ); 通常来讲，你应该只直接修改你刚刚创建的对象。如果你正在插入一个新的 artwork，你可以修改它，但是如果你想要改变的是 state 中已经存在的东西，你就需要先拷贝一份了。 3.7.9 使用 Immer 编写简洁的更新逻辑在没有 mutation 的前提下更新嵌套数组可能会变得有点重复。就像对对象一样: 通常情况下，你应该不需要更新处于非常深层级的 state 。如果你有此类需求，你或许需要调整一下数据的结构，让数据变得扁平一些。 如果你不想改变 state 的数据结构，你也许会更喜欢使用 Immer ，它让你可以继续使用方便的，但会直接修改原值的语法，并负责为你生成拷贝值。 下面是我们用 Immer 来重写的艺术愿望清单的例子： import useState from react;import useImmer from use-immer;let nextId = 3;const initialList = [ id: 0, title: Big Bellies, seen: false , id: 1, title: Lunar Landscape, seen: false , id: 2, title: Terracotta Army, seen: true ,];export default function BucketList() const [myList, updateMyList] = useImmer( initialList ); const [yourList, updateYourList] = useImmer( initialList ); function handleToggleMyList(id, nextSeen) updateMyList(draft = const artwork = draft.find(a = a.id === id ); artwork.seen = nextSeen; ); function handleToggleYourList(artworkId, nextSeen) updateYourList(draft = const artwork = draft.find(a = a.id === artworkId ); artwork.seen = nextSeen; ); return ( h1艺术愿望清单/h1 h2我想看的艺术清单：/h2 ItemList artworks=myList onToggle=handleToggleMyList / h2你想看的艺术清单：/h2 ItemList artworks=yourList onToggle=handleToggleYourList / / );function ItemList( artworks, onToggle ) return ( ul artworks.map(artwork = ( li key=artwork.id label input type=checkbox checked=artwork.seen onChange=e = onToggle( artwork.id, e.target.checked ); / artwork.title /label /li )) /ul ); 请注意当使用 Immer 时，类似 artwork.seen = nextSeen 这种会产生 mutation 的语法不会再有任何问题了： updateMyTodos(draft = const artwork = draft.find(a = a.id === artworkId); artwork.seen = nextSeen;); 这是因为你并不是在直接修改原始的 state，而是在修改 Immer 提供的一个特殊的 draft 对象。同理，你也可以为 draft 的内容使用 push() 和 pop() 这些会直接修改原值的方法。 在幕后，Immer 总是会根据你对 draft 的修改来从头开始构建下一个 state。这使得你的事件处理程序非常的简洁，同时也不会直接修改 state。 3.7.10 摘要 你可以把数组放入 state 中，但你不应该直接修改它。 不要直接修改数组，而是创建它的一份 新的 拷贝，然后使用新的数组来更新它的状态。 你可以使用 [...arr, newItem] 这样的数组展开语法来向数组中添加元素。 你可以使用 filter() 和 map() 来创建一个经过过滤或者变换的数组。 你可以使用 Immer 来保持代码简洁。","tags":["React"],"categories":["前端"]},{"title":"rpc基础","path":"/2024/09/06/rpc基础/","content":"1. 简介1.1 概述RPC（Remote Procedure Call，远程过程调用）是一种用于实现不同计算机或进程之间通信的协议或机制，使得程序可以像调用本地函数一样调用远程计算机上的函数。RPC 的核心目的是使得分布式系统的组件之间的交互变得简洁和透明。 核心概念 客户端: 发起 RPC 调用的程序或应用。它构造一个请求，调用一个远程服务的函数。 服务器端: 提供远程服务的程序或应用。它接收来自客户端的请求，执行相应的函数，并返回结果。 代理（Stub）: 客户端代理（或称为客户端存根）和服务器端代理（或称为服务器端存根）是分别在客户端和服务器端生成的代码，用于处理调用的序列化和反序列化、数据传输等任务。客户端代理将调用请求转换为网络消息，服务器端代理则将网络消息转换为实际的函数调用。 通信协议: 定义客户端和服务器端之间的消息传递格式和方式。常见的通信协议包括 HTTP、gRPC、JSON-RPC 等。 在远程调用时，我们需要执行的函数体是在远程的机器上的，也就是说，add是在另一个进程中执行的。这就带来了几个新问题： Call ID映射。我们怎么告诉远程机器我们要调用add，而不是sub或者Foo呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用add，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 – Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。 序列化和反序列化。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。 网络传输。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。 解决了上面三个机制，就能实现RPC了，具体过程如下： client端解决的问题： 1. 将这个调用映射为Call ID。这里假设用最简单的字符串当Call ID的方法2. 将Call ID，a和b序列化。可以直接将它们的值以二进制形式打包3. 把2中得到的数据包发送给ServerAddr，这需要使用网络传输层4. 等待服务器返回结果4. 如果服务器调用成功，那么就将结果反序列化，并赋给total server端解决的问题 1. 在本地维护一个Call ID到函数指针的映射call_id_map，可以用dict完成2. 等待请求，包括多线程的并发处理能力3. 得到一个请求后，将其数据包反序列化，得到Call ID4. 通过在call_id_map中查找，得到相应的函数指针5. 将a和rb反序列化后，在本地调用add函数，得到结果6. 将结果序列化后通过网络返回给Client 所以要实现一个RPC框架，其实只需要按以上流程实现就基本完成了。 其中： Call ID映射可以直接使用函数字符串，也可以使用整数ID。映射表一般就是一个哈希表。 序列化反序列化可以自己写，也可以使用Protobuf或者FlatBuffers之类的。 网络传输库可以自己写socket，或者用asio，ZeroMQ，Netty之类。 实际上真正的开发过程中，除了上面的基本功能以外还需要更多的细节：网络错误、流量控制、超时和重试等。 1.2 rpc开发要素分析1.2.1 rpc开发的四大要素RPC技术在架构设计上有四部分组成，分别是：客户端、客户端存根、服务端、服务端存根。 客户端(Client)：服务调用发起方，也称为服务消费者。 客户端存根(Client Stub)：该程序运行在客户端所在的计算机机器上，主要用来存储要调用的服务器的地址，另外，该程序还负责将客户端请求远端服务器程序的数据信息打包成数据包，通过网络发送给服务端Stub程序；其次，还要接收服务端Stub程序发送的调用结果数据包，并解析返回给客户端。 服务端(Server)：远端的计算机机器上运行的程序，其中有客户端要调用的方法。 服务端存根(Server Stub)：接收客户Stub程序通过网络发送的请求消息数据包，并调用服务端中真正的程序功能方法，完成功能调用；其次，将服务端执行调用的结果进行数据处理打包发送给客户端Stub程序。 了解完了RPC技术的组成结构我们来看一下具体是如何实现客户端到服务端的调用的。实际上，如果我们想要在网络中的任意两台计算机上实现远程调用过程，要解决很多问题，比如： 两台物理机器在网络中要建立稳定可靠的通信连接。 两台服务器的通信协议的定义问题，即两台服务器上的程序如何识别对方的请求和返回结果。也就是说两台计算机必须都能够识别对方发来的信息，并且能够识别出其中的请求含义和返回含义，然后才能进行处理。这其实就是通信协议所要完成的工作。 在上述图中，通过1-10的步骤图解的形式，说明了RPC每一步的调用过程。具体描述为： 1、客户端想要发起一个远程过程调用，首先通过调用本地客户端Stub程序的方式调用想要使用的功能方法名； 2、客户端Stub程序接收到了客户端的功能调用请求，将客户端请求调用的方法名，携带的参数等信息做序列化操作，并打包成数据包。 3、客户端Stub查找到远程服务器程序的IP地址，调用Socket通信协议，通过网络发送给服务端。 4、服务端Stub程序接收到客户端发送的数据包信息，并通过约定好的协议将数据进行反序列化，得到请求的方法名和请求参数等信息。 5、服务端Stub程序准备相关数据，调用本地Server对应的功能方法进行，并传入相应的参数，进行业务处理。 6、服务端程序根据已有业务逻辑执行调用过程，待业务执行结束，将执行结果返回给服务端Stub程序。 7、服务端Stub程序将程序调用结果按照约定的协议进行序列化，并通过网络发送回客户端Stub程序。 8、客户端Stub程序接收到服务端Stub发送的返回数据，对数据进行反序列化操作，并将调用返回的数据传递给客户端请求发起者。 9、客户端请求发起者得到调用结果，整个RPC调用过程结束。 1.2.2 rpc需要使用到的术语通过上文一系列的文字描述和讲解，我们已经了解了RPC的由来和RPC整个调用过程。我们可以看到RPC是一系列操作的集合，其中涉及到很多对数据的操作，以及网络通信。因此，我们对RPC中涉及到的技术做一个总结和分析： 1、动态代理技术： 上文中我们提到的Client Stub和Sever Stub程序，在具体的编码和开发实践过程中，都是使用动态代理技术自动生成的一段程序。 2、序列化和反序列化： 在RPC调用的过程中，我们可以看到数据需要在一台机器上传输到另外一台机器上。在互联网上，所有的数据都是以字节的形式进行传输的。而我们在编程的过程中，往往都是使用数据对象，因此想要在网络上将数据对象和相关变量进行传输，就需要对数据对象做序列化和反序列化的操作。 序列化：把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。 反序列化：把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。 我们常见的Json,XML等相关框架都可以对数据做序列化和反序列化编解码操作。后面我们要学习的Protobuf协议，这也是一种数据编解码的协议，在RPC框架中使用的更广泛。 2. go rpc 开发Go语言的RPC包的路径为netrpc，也就是放在了net包目录下面。 2.1 hello world2.1.1 服务端package mainimport ( net net/rpc)type HelloService struct func (s *HelloService) Hello(request string, reply *string) error *reply = hello + request return nilfunc main() _ = rpc.RegisterName(HelloService, HelloService) listener, err := net.Listen(tcp, :1234) if err != nil panic(监听端口失败) conn, err := listener.Accept() if err != nil panic(建立链接失败) rpc.ServeConn(conn) 其中Hello方法必须满足Go语言的RPC规则：方法只能有两个可序列化的参数，其中第二个参数是指针类型，并且返回一个error类型，同时必须是公开的方法。 然后就可以将HelloService类型的对象注册为一个RPC服务：(TCP RPC服务)。 其中rpc.Register函数调用会将对象类型中所有满足RPC规则的对象方法注册为RPC函数，所有注册的方法会放在“HelloService”服务空间之下。然后我们建立一个唯一的TCP链接，并且通过rpc.ServeConn函数在该TCP链接上为对方提供RPC服务。 2.1.2 客户端func main() client, err := rpc.Dial(tcp, localhost:1234) if err != nil log.Fatal(dialing:, err) var reply string err = client.Call(HelloService.Hello, world, reply) if err != nil log.Fatal(err) fmt.Println(reply) 首先是通过rpc.Dial拨号RPC服务，然后通过client.Call调用具体的RPC方法。在调用client.Call时，第一个参数是用点号链接的RPC服务名字和方法名字，第二和第三个参数分别我们定义RPC方法的两个参数。 2.2 rpc 支持 json标准库的RPC默认采用Go语言特有的gob编码，因此从其它语言调用Go语言实现的RPC服务将比较困难。在互联网的微服务时代，每个RPC以及服务的使用者都可能采用不同的编程语言，因此跨语言是互联网时代RPC的一个首要条件。得益于RPC的框架设计，Go语言的RPC其实也是很容易实现跨语言支持的。 Go语言的RPC框架有两个比较有特色的设计：一个是RPC数据打包时可以通过插件实现自定义的编码和解码；另 一个是RPC建立在抽象的io.ReadWriteCloser接口之上的，我们可以将RPC架设在不同的通讯协议之上。这里我们将尝试通过官方自带的net/rpc/jsonrpc扩展实现一个跨语言的PPC。 2.2.1 服务端package mainimport ( net net/rpc net/rpc/jsonrpc)type HelloService struct func (s *HelloService) Hello(request string, reply *string) error *reply = hello + request return nilfunc main() rpc.RegisterName(HelloService, new(HelloService)) listener, err := net.Listen(tcp, :1234) if err != nil panic(启动错误) for conn, err := listener.Accept() if err != nil panic(接收) go rpc.ServeCodec(jsonrpc.NewServerCodec(conn)) 代码中最大的变化是用rpc.ServeCodec函数替代了rpc.ServeConn函数，传入的参数是针对服务端的json编解码器。 2.2.2 客户端package mainimport ( fmt net net/rpc net/rpc/jsonrpc)func main() conn, err := net.Dial(tcp, localhost:1234) if err != nil panic(连接错误) client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn)) var reply string err = client.Call(HelloService.Hello, imooc, reply) if err != nil panic(调用错误) fmt.Println(reply) 2.3 改进 rpc 调用前面的rpc调用虽然简单，但是和普通的http的调用差异不大，这次我们解决下面的问题： 2.3.1 serviceName统一和名称冲突的问题 server端和client端如何统一serviceName 多个server的包中serviceName同名的问题 新建handlerhandler.go文件内容如下： 为什么要新建一个文件？ - 解耦 package handlerconst HelloServiceName = handler/HelloService 服务端 package mainimport ( net net/rpc start/rpc_ch01/handler)type HelloService struct func (s *HelloService) Hello(request string, reply *string) error *reply = hello + request return nilfunc main() _ = rpc.RegisterName(handler.HelloServiceName, HelloService) listener, err := net.Listen(tcp, :1234) if err != nil panic(监听端口失败) conn, err := listener.Accept() if err != nil panic(建立链接失败) rpc.ServeConn(conn) 客户端 package mainimport ( fmt net/rpc start/rpc_ch01/handler)func main() client, err := rpc.Dial(tcp, localhost:1234) if err != nil panic(连接到服务器失败) var reply string err = client.Call(handler.HelloServiceName+.Hello, imooc, reply) if err != nil panic(服务调用失败) fmt.Println(reply) 2.3.2 屏蔽HelloServiceName和Hello函数名称1.新建Handler package handlertype HelloService structfunc (s *HelloService) Hello(request string, reply *string) error *reply = hello + request return nil handler里封装处理逻辑。 2.服务端代理 package server_proxyimport net/rpcconst HelloServiceName = handler/HelloServicetype HelloServiceInterface interface Hello(request string, reply *string) errorfunc RegisterHelloService(srv HelloServiceInterface) error return rpc.RegisterName(HelloServiceName, srv) 将注册 rpc 服务逻辑交给代理。 3.服务端 package mainimport ( net net/rpc start/rpc_ch01/handler start/rpc_ch01/server_proxy)func main() hellohandler := handler.HelloService // 直接使用代理注册 rpc 服务 _ = server_proxy.RegisterHelloService(hellohandler) listener, err := net.Listen(tcp, :1234) if err != nil panic(监听端口失败) conn, err := listener.Accept() if err != nil panic(建立链接失败) rpc.ServeConn(conn) 4.客户端代理 package client_proxyimport net/rpcconst HelloServiceName = handler/HelloServicetype HelloServiceClient struct *rpc.Clientfunc NewClient(address string) HelloServiceClient conn, err := rpc.Dial(tcp, address) if err != nil panic(连接服务器错误) return HelloServiceClientconnfunc (c *HelloServiceClient) Hello(request string, reply *string) error err := c.Call(HelloServiceName+.Hello, request, reply) if err != nil return err return nil 客户端代理封装调用逻辑。 5.客户端 package mainimport ( fmt start/rpc_ch01/client_proxy)func main() client := client_proxy.NewClient(localhost:1234) var reply string // 通过代理直接传参调用 err := client.Hello(bobby,reply) if err != nil panic(调用失败) fmt.Println(reply) 3. grpc入门3.1 grpc和protobuf3.1.1 grpcgRPC 是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP2 设计。目前提供 C、Java 和 Go 语言版本，分别是：grpc, grpc-java, grpc-go. 其中 C 版本支持 C, C++, Node.js, Python, Ruby, Objective-C, PHP 和 C# 支持. 3.1.2 protobufprotobuf 即 Protocol Buffers，是一种轻便高效的结构化数据存储格式，与语言、平台无关，可扩展可序列化。protobuf 性能和效率大幅度优于 JSON、XML 等其他的结构化数据格式。protobuf 是以二进制方式存储的，占用空间小，但也带来了可读性差的缺点。protobuf 在通信协议和数据存储等领域应用广泛。例如著名的分布式缓存工具 Memcached 的 Go 语言版本groupcache 就使用了 protobuf 作为其 RPC 数据格式。 Protobuf 在 .proto 定义需要处理的结构化数据，可以通过 protoc 工具，将 .proto 文件转换为 C、C++、Golang、Java、Python 等多种语言的代码，兼容性好，易于使用。 java中的dubbo dubbormihessian messagepack 如果你懂了协议完全有能力自己去实现一个协议 Protocol Buffer 其实 是 Google出品的一种轻量 高效的结构化数据存储格式，性能比 Json、XML 真的强！太！多！ protobuf经历了protobuf2和protobuf3，pb3比pb2简化了很多，目前主流的版本是pb3 3.2 go使用protobuf3.2.1 安装protoc下载 protoc https://github.com/protocolbuffers/protobuf/releases 添加 protoc 环境变量 检查 protoc --version 安装 vscode 插件 3.2.2 使用1.编写proto文件 syntax = proto3;option go_package = .;proto;// this is a commentmessage Student string name = 1; bool male = 2; repeated int32 scores = 3; 2.生成源码 protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative Student.proto 3.调用代码 package mainimport ( encoding/json fmt log pb protobuf/proto google.golang.org/protobuf/proto)func main() student := pb.Student Name: geektutu, Male: true, Scores: []int3298, 85, 88, data, err := proto.Marshal(student) if err != nil log.Fatal(marshaling error: , err) data2, err := json.Marshal(student) if err != nil log.Fatal(marshaling error: , err) // protobuf data is: geektutubUX, len is: 17 fmt.Printf(protobuf data is: %s, len is: %d , string(data), len(data)) // json data is: name:geektutu,male:true,scores:[98,85,88], len is: 51 fmt.Printf(json data is: %s, len is: %d , string(data2), len(data2)) newStudent := pb.Student err = proto.Unmarshal(data, newStudent) if err != nil log.Fatal(unmarshaling error: , err) // Now student and newStudent contain the same data. if student.GetName() != newStudent.GetName() log.Fatalf(data mismatch %q != %q, student.GetName(), student.GetName()) 3.3 go 使用 grpc1.下载依赖 go get github.com/golang/protobuf/protoc-gen-go 2.proto文件 syntax = proto3;option go_package = .;proto;service Greeter rpc SayHello (HelloRequest) returns (HelloReply);message HelloRequest string name = 1;message HelloReply string message = 1; 3.生成go代码 protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative Hello.proto 4.服务端 package mainimport ( context fmt google.golang.org/grpc grpc_demo/hello net)type Server struct func (s *Server) SayHello(ctx context.Context,request *hello.HelloRequest)(*hello.HelloReply,error) return hello.HelloReplyMessage:Hello +request.Name,nilfunc main() g := grpc.NewServer() s := Server hello.RegisterGreeterServer(g,s) lis, err := net.Listen(tcp, fmt.Sprintf(:8080)) if err != nil panic(failed to listen: +err.Error()) g.Serve(lis) 5.客户端 package mainimport ( context fmt google.golang.org/grpc grpc_demo/proto)func main() conn,err := grpc.Dial(127.0.0.1:8080,grpc.WithInsecure()) if err!=nil panic(err) defer conn.Close() c := hello.NewGreeterClient(conn) r,err := c.SayHello(context.Background(),hello.HelloRequestName:bobby) if err!=nil panic(err) fmt.Println(r.Message)","tags":["rpc、grpc"],"categories":["Go"]},{"title":"protobuf基础","path":"/2024/09/06/protobuf基础/","content":"简介概述Protocol Buffers（protobuf）是由 Google 开发的一种语言中立、平台中立、可扩展的序列化结构数据的方法。 它用于将结构化数据序列化为字节流，并在网络中传输或存储到文件中。protobuf 的主要优点是高效、简单和支持跨语言互操作性。 https://protobuf.dev/programming-guides/proto3/ https://grpc.io/docs/languages/go/quickstart/ 安装下载 protoc： https://github.com/protocolbuffers/protobuf/releases 添加 protoc 环境变量： 检查： protoc --version 安装 vscode 插件 Hello World新建 grpc 项目# 初始化go.mod执行 go mod init grpc# 安装 Go 的协议编译器插件go install google.golang.org/protobuf/cmd/protoc-gen-go@latestgo install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest 生成 grpc go程序syntax = proto3;option go_package=.;proto;service Greeter rpc SayHello (HelloRequest) returns (HelloReply);message HelloRequest string name = 1;// 1是编号 int32 age = 2; repeated string coures = 3;message HelloReply string message = 1;// protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative Hello.proto 在Hello.proto目录执行生成命令 protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative Hello.proto 1.3.3 编写 Serverpackage mainimport ( context grpc/proto net google.golang.org/grpc)type Server struct proto.UnimplementedGreeterServer// SayHello implements proto.GreeterServer.func (s Server) SayHello(ctx context.Context, req *proto.HelloRequest) (*proto.HelloReply, error) return proto.HelloReplyMessage: hello + req.Name, nilfunc main() gServer := grpc.NewServer() proto.RegisterGreeterServer(gServer, Server) lis, err := net.Listen(tcp, :8080) if err != nil panic(err) gServer.Serve(lis)package mainimport ( context grpc/proto net google.golang.org/grpc)type Server struct proto.UnimplementedGreeterServer// SayHello implements proto.GreeterServer.func (s Server) SayHello(ctx context.Context, req *proto.HelloRequest) (*proto.HelloReply, error) return proto.HelloReplyMessage: hello + req.Name, nilfunc main() gServer := grpc.NewServer() proto.RegisterGreeterServer(gServer, Server) lis, err := net.Listen(tcp, :8080) if err != nil panic(err) gServer.Serve(lis) 1.3.4 编写 Clientpackage mainimport ( context fmt grpc/proto google.golang.org/grpc google.golang.org/grpc/credentials/insecure)func main() conn, err := grpc.NewClient(localhost:8080, grpc.WithTransportCredentials(insecure.NewCredentials())) if err != nil panic(err) defer conn.Close() c := proto.NewGreeterClient(conn) reply, _ := c.SayHello(context.Background(), proto.HelloRequestName: nige) fmt.Println(reply.Message) 1.3.5 运行程序 2. 定义一个消息https://protobuf.dev/programming-guides/proto3/ 2.1 定义消息类型先来看一个非常简单的例子。假设你想定义一个”搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的查询结果所在的页数，以及每一页多少条查询结果。可以采用如下的方式来定义消息类型的.proto文件了： syntax = proto3;message SearchRequest string query = 1; // 编号 int32 page_number = 2; // 编号 int32 result_per_page = 3; // 编号 文件的第一行指定了你正在使用 proto3 语法：如果你没有指定这个，编译器会使用 proto2。这个指定语法行必须是文件的非空非注释的第一个行。 SearchRequest 消息格式有3个字段，在消息中承载的数据分别对应于每一个字段。其中每个字段都有一个名字和一种类型。 2.2 指定字段类型在上面的例子中，所有字段都是标量类型：两个整型（page_number和result_per_page），一个string类型（query）。当然，也可以为字段指定其他的类型，包括枚举（enumerations）或其他复合消息类型。 2.3 分配编号必须在消息定义中为每个字段指定一个介于1和536,870,911之间的数字，并附带以下限制: 给定的数字在该消息的所有字段中必须是唯一的。 协议缓冲编号19,000至19,999是预留作实施之用。如果在消息中使用这些保留字段号之一，协议缓冲区编译器将发出告警。 不能使用任何以前保留的字段号或分配给扩展名的任何字段号。 编号不应该被重用。永远不要从保留列表中取出字段编号，以便用新的字段定义重用。请参见重用字段数的后果。 https://protobuf.dev/programming-guides/proto3/#consequences 使用消息类型时，不能更改此编号，因为它以消息连接格式标识字段。“更改”字段编号等同于删除该字段并创建具有相同类型但具有新编号的新字段。有关如何正确执行此操作的信息，请参见删除字段。 https://protobuf.dev/programming-guides/proto3/#deleting 注：[1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]内的标识号则占用2个字节。所以应该为那些频繁出现的消息元素保留 [1,15]之内的标识号。切记：要为将来有能添加的、频繁出现的标识号预留一些标识号。 2.4 指定字段标签类型在 Protocol Buffers（protobuf）中，消息字段可以是以下几种类型： optional（可选字段）: 状态 已设置: 如果字段被显式设置或从传输数据中解析出来，它会被序列化到数据流中。 未设置: 如果字段没有被设置，它会返回默认值，并且不会被序列化到数据流中。 检查: 你可以检查一个可选字段是否被显式设置。 repeated（重复字段）: 特性: 这个字段可以在消息中出现零次或多次。所有的重复值的顺序都会被保留。 map（映射字段）: 特性: 这是一个键值对的字段类型，用于表示映射关系。具体细节可以参考有关映射字段的文档。 隐式字段存在: 默认状态: 如果没有显式指定字段标签，则假定字段为“隐式字段存在”状态。你不能显式设置一个字段为这种状态。 特性: 一个消息中可以有零个或一个这样的字段，但不能多于一个。你也不能确定这种类型的字段是否是从数据流中解析出来的。一个隐式存在的字段会被序列化到数据流中，除非它是默认值。 proto3 中的默认打包编码: 对于 proto3 中的标量数值类型的重复字段，默认使用打包编码（packed encoding）。你可以了解更多关于打包编码的内容在 Protocol Buffer 编码文档中。 这些字段类型和特性帮助定义和控制如何在 Protocol Buffers 中处理数据。 2.5 添加更多消息类型在一个.proto文件中可以定义多个消息类型。在定义多个相关的消息的时候，这一点特别有用——例如，如果想定义与SearchResponse消息类型对应的回复消息格式的话，你可以将它添加到相同的.proto文件中，如： message SearchRequest string query = 1; int32 page_number = 2; int32 result_per_page = 3;message SearchResponse string message = 1; 2.6 添加注释向.proto文件添加注释，可以使用CC++java风格的双斜杠（） 语法格式，如： message SearchRequest string query = 1; int32 page_number = 2; // Which page number do we want? int32 result_per_page = 3; // Number of results to return per page. 2.7 删除字段如果删除操作不当，可能会导致严重的问题。 当不再需要某个字段并且已经从客户端代码中删除了所有引用时，可以从消息中删除字段定义。但是，必须保留已删除的字段号。如果不保留字段编号，那么开发人员将来可以重用该编号。 还应该保留字段名，以允许继续解析消息的 JSON 和 TextFormat 编码。 2.8 保留标识符（Reserved）如果通过完全删除字段或注释掉字段来更新消息类型，未来的开发人员在对类型进行更新时可以重用字段编号。这可能导致严重的问题，如重用字段数字的后果所述。要确保这种情况不会发生，请将已删除的字段号添加到保留列表中。 如果未来的开发人员试图使用这些保留字段编号，则协议编译器将生成错误消息。现在有一种确保不会发生这种情况的方法就是指定保留标识符，protocol buffer的编译器会警告未来尝试使用这些字段标识符的用户。 message Foo reserved 2, 15, 9 to 11; reserved foo, bar; 注：不要在同一行reserved声明中同时声明字段名字和标识号 2.9 从.proto文件生成了什么？当用protocol buffer编译器来运行.proto文件时，编译器将生成所选择语言的代码，这些代码可以操作在.proto文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息。 对于 Java，编译器生成一个。Java 文件，其中包含用于每种消息类型的类，以及用于创建消息类实例的特殊 Builder 类。 对于 Go，编译器为文件中的每个消息类型生成一个. pb.Go 文件。 你可以从如下的文档链接中获取每种语言更多API。API Reference 2.10 标量数值类型一个标量消息字段可以含有一个如下的类型——该表格展示了定义于.proto文件中的类型，以及与之对应的、在自动生成的访问类中定义的类型： .proto Type Notes Python Type Go Type double float float64 float float float32 int32 使用变长编码，对于负值的效率很低，如果你的域有可能有负值，请使用sint64替代 int int32 uint32 使用变长编码 int uint32 uint64 使用变长编码 int uint64 sint32 使用变长编码，这些编码在负值时比int32高效的多 int int32 sint64 使用变长编码，有符号的整型值。编码时比通常的int64高效。 int int64 fixed32 总是4个字节，如果数值总是比总是比228大的话，这个类型会比uint32高效。 int uint32 fixed64 总是8个字节，如果数值总是比总是比256大的话，这个类型会比uint64高效。 int uint64 sfixed32 总是4个字节 int int32 sfixed64 总是8个字节 int int64 bool bool bool string 一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。 str string bytes 可能包含任意顺序的字节数据。 str []byte 你可以在文章Protocol Buffer 编码中，找到更多“序列化消息时各种类型如何编码”的信息。 在java中，无符号32位和64位整型被表示成他们的整型对应形似，最高位被储存在标志位中。 对于所有的情况，设定值会执行类型检查以确保此值是有效。 64位或者无符号32位整型在解码时被表示成为ilong，但是在设置时可以使用int型值设定，在所有的情况下，值必须符合其设置其类型的要求。 python中string被表示成在解码时表示成unicode。但是一个ASCIIstring可以被表示成str类型。 Integer在64位的机器上使用，string在32位机器上使用。 2.11 默认值在解析消息时，如果编码的消息不包含特定的隐式存在元素，则访问解析对象中的相应字段将返回该字段的默认值。这些默认值是特定于类型的: 对于strings，默认是一个空string 对于bytes，默认是一个空的bytes 对于bools，默认是false 对于数值类型，默认是0 对于枚举，默认是第一个定义的枚举值，必须为0; 对于消息字段，字段没有被设置，确切的值是根据语言确定的，详见generated code guide 对于可重复字段的默认值是空（通常情况下是对应语言中空列表）。 注意，对于标量消息字段，一旦解析了消息，就无法判断字段是显式设置为默认值(例如，布尔值是否设置为 false) ，还是根本没有设置: 在定义消息类型时应该记住这一点。例如，如果不希望某些行为在默认情况下也会发生，那么就不要有一个布尔值在设置为 false 时打开某些行为。还要注意，如果将标量消息字段设置为默认值，则该值将不会序列化。如果将浮点数或双精度值设置为 + 0，则不会序列化它，但 -0被认为是不同的，将被序列化。 2.12 枚举在定义消息类型时，可能希望其中一个字段只包含预定义的值列表中的一个。例如，假设你想为每个 SearchRequest 添加一个语料库字段，其中的语料库可以是 UNIVERSAL、 WEB、 IMAGES、 LOCAL、 NEWS、 PRODUCTS 或 VIDEO。可以非常简单地通过向消息定义添加枚举，并为每个可能的值添加一个常量来实现这一点。 enum Corpus CORPUS_UNSPECIFIED = 0; CORPUS_UNIVERSAL = 1; CORPUS_WEB = 2; CORPUS_IMAGES = 3; CORPUS_LOCAL = 4; CORPUS_NEWS = 5; CORPUS_PRODUCTS = 6; CORPUS_VIDEO = 7;message SearchRequest string query = 1; int32 page_number = 2; int32 results_per_page = 3; Corpus corpus = 4; Corpus 枚举的第一个常量映射为零: 每个枚举定义必须包含一个常量，该常量作为其第一个元素映射为零。这是因为: 必须有一个零值，这样我们就可以使用0作为数字默认值。 零值需要成为第一个元素，以便与 Proto2语义兼容，其中第一个枚举值是默认值，除非显式指定了不同的值。 可以通过为不同的枚举常数赋相同的值来定义别名。为此，您需要将 allow _ alias 选项设置为 true。否则，当发现别名时，协议缓冲区编译器将生成警告消息。尽管所有别名值在反序列化过程中都是有效的，但在序列化过程中始终使用第一个值。 enum EnumAllowingAlias option allow_alias = true; EAA_UNSPECIFIED = 0; EAA_STARTED = 1; EAA_RUNNING = 1; EAA_FINISHED = 2;enum EnumNotAllowingAlias ENAA_UNSPECIFIED = 0; ENAA_STARTED = 1; // ENAA_RUNNING = 1; // Uncommenting this line will cause a warning message. ENAA_FINISHED = 2; 枚举常量必须在32位整型值的范围内。因为enum值是使用可变编码方式的，对负数不够高效，因此不推荐在enum中使用负数。如上例所示，可以在 一个消息定义的内部或外部定义枚举——这些枚举可以在.proto文件中的任何消息定义里重用。当然也可以在一个消息中声明一个枚举类型，而在另一个不同 的消息中使用它——采用MessageType.EnumType的语法格式。 当对一个使用了枚举的.proto文件运行protocol buffer编译器的时候，生成的代码中将有一个对应的enum（对Java或C++来说），或者一个特殊的EnumDescriptor类（对 Python来说），它被用来在运行时生成的类中创建一系列的整型值符号常量（symbolic constants）。 在反序列化的过程中，无法识别的枚举值会被保存在消息中，虽然这种表示方式需要依据所使用语言而定。在那些支持开放枚举类型超出指定范围之外的语言中（例如C++和Go），为识别的值会被表示成所支持的整型。在使用封闭枚举类型的语言中（Java），使用枚举中的一个类型来表示未识别的值，并且可以使用所支持整型来访问。在其他情况下，如果解析的消息被序列号，未识别的值将保持原样。 关于如何在你的应用程序的消息中使用枚举的更多信息，请查看所选择的语言generated code guide 3. 使用其他类型消息3.1 导入定义在上面的例子中，Result消息类型与SearchResponse是定义在同一文件中的。如果想要使用的消息类型已经在其他.proto文件中已经定义过了呢？ 你可以通过导入（importing）其他.proto文件中的定义来使用它们。要导入其他.proto文件的定义，你需要在你的文件中添加一个导入声明，如： import myproject/other_protos.proto; 默认情况下你只能使用直接导入的.proto文件中的定义. 然而， 有时候你需要移动一个.proto文件到一个新的位置， 可以不直接移动.proto文件， 只需放入一个伪 .proto 文件在老的位置， 然后使用import public转向新的位置。import public 依赖性会通过任意导入包含import public声明的proto文件传递。例如： // 这是新的proto// All definitions are moved here // 这是旧的proto// 这是所有客户端正在导入的包import public new.proto;import other.proto; // 客户端protoimport old.proto;// 现在你可以使用新旧两种包的proto定义了。 通过在编译器命令行参数中使用-I/--proto_pathprotocal 编译器会在指定目录搜索要导入的文件。如果没有给出标志，编译器会搜索编译命令被调用的目录。通常你只要指定proto_path标志为你的工程根目录就好。并且指定好导入的正确名称就好。 3.2 嵌套类型你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Result消息就定义在SearchResponse消息内，如： message SearchResponse message Result string url = 1; string title = 2; repeated string snippets = 3; repeated Result results = 1; 如果你想在它的父消息类型的外部重用这个消息类型，你需要以Parent.Type的形式使用它，如： message SomeOtherMessage SearchResponse.Result result = 1; 当然，你也可以将消息嵌套任意多层，如： message Outer // Level 0 message MiddleAA // Level 1 message Inner // Level 2 int64 ival = 1; bool booly = 2; message MiddleBB // Level 1 message Inner // Level 2 int32 ival = 1; bool booly = 2; 4. 定义服务如果想要将消息类型用在RPC(远程方法调用)系统中，可以在.proto文件中定义一个RPC服务接口，protocol buffer编译器将会根据所选择的不同语言生成服务接口代码及存根。如，想要定义一个RPC服务并具有一个方法，该方法能够接收 SearchRequest并返回一个SearchResponse，此时可以在.proto文件中进行如下定义： service SearchService rpc Search (SearchRequest) returns (SearchResponse); 最直观的使用protocol buffer的RPC系统是gRPC一个由谷歌开发的语言和平台中的开源的PRC系统，gRPC在使用protocl buffer时非常有效，如果使用特殊的protocol buffer插件可以直接为您从.proto文件中产生相关的RPC代码。 如果你不想使用gRPC，也可以使用protocol buffer用于自己的RPC实现，你可以从proto2语言指南中找到更多信息 还有一些第三方开发的PRC实现使用Protocol Buffer。参考第三方插件wiki查看这些实现的列表。","tags":["protobuf、Go"],"categories":["Go"]},{"title":"Gorm基础学习","path":"/2024/09/04/Gorm基础学习/","content":"1. 简介1.1 概述GORM 是一个 Go 语言编写的对象关系映射（ORM）库，用于简化与数据库的交互。它允许开发者使用 Go 语言中的结构体来表示数据 库中的表，从而通过结构体和方法来执行数据库操作，比如查询、插入、更新和删除记录。 1.2 安装go get -u gorm.io/gormgo get -u gorm.io/driver/mysql 1.3 快速入门package mainimport ( gorm.io/gorm gorm.io/driver/sqlite)type Product struct gorm.Model Code string Price uintfunc main() db, err := gorm.Open(sqlite.Open(test.db), gorm.Config) if err != nil panic(failed to connect database) // 如果表不存在，它会创建一个新表；如果表已经存在，它会对表进行必要的更新，以匹配结构体中的字段和标签。 db.AutoMigrate(Product) // Create db.Create(ProductCode: D42, Price: 100) // Read var product Product db.First(product, 1) // 根据整型主键查找 db.First(product, code = ?, D42) // 查找 code 字段值为 D42 的记录 // Update - 将 product 的 price 更新为 200 db.Model(product).Update(Price, 200) // Update - 更新多个字段 db.Model(product).Updates(ProductPrice: 200, Code: F42) // 仅更新非零值字段 db.Model(product).Updates(map[string]interfacePrice: 200, Code: F42) // Delete - 删除 product db.Delete(product, 1) 1.4 特性 全功能 ORM 关联 (Has One，Has Many，Belongs To，Many To Many，多态，单表继承) Create，Save，Update，Delete，Find 中钩子方法 支持 Preload、Joins 的预加载 事务，嵌套事务，Save Point，Rollback To Saved Point Context、预编译模式、DryRun 模式 批量插入，FindInBatches，FindCreate with Map，使用 SQL 表达式、Context Valuer 进行 CRUD SQL 构建器，Upsert，数据库锁，OptimizerIndexComment Hint，命名参数，子查询 复合主键，索引，约束 Auto Migration 自定义 Logger 灵活的可扩展插件 API：Database Resolver（多数据库，读写分离）、Prometheus… 每个特性都经过了测试的重重考验 开发者友好 2. 模型GORM 通过将 Go 结构体（Go structs） 映射到数据库表来简化数据库交互。 了解如何在GORM中定义模型，是充分利用GORM全部功 能的基础。 2.1 模型定义模型是使用普通结构体定义的。 这些结构体可以包含具有基本Go类型、指针或这些类型的别名，甚至是自定义类型（只需要实现 database/sql 包中的Scanner和Valuer接口）。 考虑以下 user 模型的示例： type User struct ID uint // Standard field for the primary key Name string // 一个常规字符串字段 Email *string // 一个指向字符串的指针, allowing for null values Age uint8 // 一个未签名的8位整数 Birthday *time.Time // A pointer to time.Time, can be null MemberNumber sql.NullString // Uses sql.NullString to handle nullable strings ActivatedAt sql.NullTime // Uses sql.NullTime for nullable time fields CreatedAt time.Time // 创建时间（由GORM自动管理） UpdatedAt time.Time // 最后一次更新时间（由GORM自动管理） 在此模型中： 具体数字类型如 uint、string和 uint8 直接使用。 指向 *string 和 *time.Time 类型的指针表示可空字段。 来自 database/sql 包的 sql.NullString 和 sql.NullTime 用于具有更多控制的可空字段。 CreatedAt 和 UpdatedAt 是特殊字段，当记录被创建或更新时，GORM 会自动向内填充当前时间。 2.2 约定 主键：GORM 使用一个名为ID 的字段作为每个模型的默认主键。 表名：默认情况下，GORM 将结构体名称转换为 snake_case 并为表名加上复数形式。 例如，一个 User 结构体在数据库中的表名变为 users 。 列名：GORM 自动将结构体字段名称转换为 snake_case 作为数据库中的列名。 时间戳字段：GORM使用字段 CreatedAt 和 UpdatedAt 来自动跟踪记录的创建和更新时间。 遵循这些约定可以大大减少需要编写的配置或代码量。 但是，GORM也具有灵活性，允许根据自己的需求自定义这些设置。 可以在GORM的约定文档中了解更多关于自定义这些约定的信息。 2.3 gorm.ModelGORM提供了一个预定义的结构体，名为gorm.Model，其中包含常用字段： // gorm.Model 的定义type Model struct ID uint `gorm:primaryKey` CreatedAt time.Time UpdatedAt time.Time DeletedAt gorm.DeletedAt `gorm:index` 将其嵌入在您的结构体中: 您可以直接在您的结构体中嵌入 gorm.Model ，以便自动包含这些字段。 这对于在不同模型之间保持一致性并利用GORM内置的约定非常有用，请参考嵌入结构。 包含的字段： ID ：每个记录的唯一标识符（主键）。 CreatedAt ：在创建记录时自动设置为当前时间。 UpdatedAt：每当记录更新时，自动更新为当前时间。 DeletedAt：用于软删除（将记录标记为已删除，而实际上并未从数据库中删除）。 2.4 高级选项2.4.1 嵌入结构体对于匿名字段，GORM 会将其字段包含在父结构体中，例如： type User struct gorm.Model Name string// 等效于type User struct ID uint `gorm:primaryKey` CreatedAt time.Time UpdatedAt time.Time DeletedAt gorm.DeletedAt `gorm:index` Name string 对于正常的结构体字段，你也可以通过标签 embedded 将其嵌入，例如： type Author struct Name string Email stringtype Blog struct ID int Author Author `gorm:embedded` Upvotes int32// 等效于type Blog struct ID int64 Name string Email string Upvotes int32 并且，您可以使用标签 embeddedPrefix 来为 db 中的字段名添加前缀，例如： type Blog struct ID int Author Author `gorm:embedded;embeddedPrefix:author_` Upvotes int32// 等效于type Blog struct ID int64 AuthorName string AuthorEmail string Upvotes int32 2.4.2 字段标签 标签名 说明 column 指定 db 列名 type 列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：not null、size, autoIncrement… 像 varbinary(8) 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：MEDIUMINT UNSIGNED not NULL AUTO_INCREMENT serializer 指定将数据序列化或反序列化到数据库中的序列化器, 例如: serializer:json/gob/unixtime size 定义列数据类型的大小或长度，例如 size: 256 primaryKey 将列定义为主键 unique 将列定义为唯一键 default 定义列的默认值 precision 指定列的精度 scale 指定列大小 not null 指定列为 NOT NULL autoIncrement 指定列为自动增长 autoIncrementIncrement 自动步长，控制连续记录之间的间隔 embedded 嵌套字段 embeddedPrefix 嵌入字段的列名前缀 autoCreateTime 创建时追踪当前时间，对于 int 字段，它会追踪时间戳秒数，您可以使用 nanomilli 来追踪纳秒、毫秒时间戳，例如：autoCreateTime:nano autoUpdateTime 创建更新时追踪当前时间，对于 int 字段，它会追踪时间戳秒数，您可以使用 nanomilli 来追踪纳秒、毫秒时间戳，例如：autoUpdateTime:milli index 根据参数创建索引，多个字段使用相同的名称则创建复合索引，查看 索引 获取详情 uniqueIndex 与 index 相同，但创建的是唯一索引 check 创建检查约束，例如 check:age 13，查看 约束 获取详情 - 设置字段写入的权限， -:create 只创建、-:update 只更新、-:false 无写入权限、- 创建和更新权限 - 设置字段读的权限，-:false 无读权限 - 忽略该字段，- 表示无读写，-:migration 表示无迁移权限，-:all 表示无读写迁移权限 comment 迁移时为字段添加注释 GORM 允许通过标签为关联配置外键、约束、many2many 表，详情请参考 关联部分 type Order struct ID uint `gorm:primaryKey;autoIncrement` OrderNumber string `gorm:type:varchar(50);uniqueIndex;not null` // 订单号，唯一，不能为空 Amount float64 `gorm:type:decimal(12,2);not null` // 金额，最多 12 位，2 位小数，不能为空 Status string `gorm:type:varchar(20);default:pending` // 状态，默认值 pending UserID uint `gorm:index` // 外键索引 User User `gorm:foreignKey:UserID` // 关联 User 表 CreatedAt time.Time UpdatedAt time.Time 3. CRUD3.1 创建3.1.1 创建记录package mainimport (\tfmt\ttime\tgorm.io/driver/mysql\tgorm.io/gorm)type User struct ID uint `gorm:primaryKey` // 主键\tName string `gorm:size:100;not null` // 字符串字段，最大长度 100，不能为空\tAge int `gorm:default:18` // 默认值 18\tBirthday time.Time\tCreatedAt time.Time\tUpdatedAt time.Timefunc main() dsn := root:strong_root_password@tcp(www.devlop.com:3306)/test?charset=utf8mb4parseTime=Trueloc=Local\tdb, err := gorm.Open(mysql.Open(dsn), gorm.Config)\tif err != nil panic(failed to connect database) user := UserName: 张三, Age: 18, Birthday: time.Now()\tdb.AutoMigrate(User) res := db.Create(user) fmt.Println(user.ID) // 返回插入数据的主键\tfmt.Println(res.Error) // 返回 error\tfmt.Println(res.RowsAffected) // 返回插入记录的条数 users := []User Name: 里斯, Age: 19, Birthday: time.Now(), Name: 里斯2, Age: 191, Birthday: time.Now(), // 创建多条记录\tres := db.Create(users) 注意：传递过去的是结构体指针 3.1.2 用指定字段创建记录package mainimport (\ttime\tgorm.io/driver/mysql\tgorm.io/gorm)type User struct ID uint `gorm:primaryKey` // 主键\tName string `gorm:size:100;not null` // 字符串字段，最大长度 100，不能为空\tAge int `gorm:default:18` // 默认值 18\tBirthday time.Time\tCreatedAt time.Time\tUpdatedAt time.Timefunc main() dsn := root:strong_root_password@tcp(www.devlop.com:3306)/test?charset=utf8mb4parseTime=Trueloc=Local\tdb, err := gorm.Open(mysql.Open(dsn), gorm.Config)\tif err != nil panic(failed to connect database) user := UserName: Jinzhu, Age: 18, Birthday: time.Now() // 创建记录并为指定字段赋值 // INSERT INTO `users` (`name`,`age`,`created_at`) VALUES (jinzhu, 18, 2024-09-04 17:31:05.456)\tdb.Select(Name, Age, CreatedAt).Create(user) // 创建记录并忽略传递给 ‘Omit’ 的字段值 // INSERT INTO `users` (`birthday`,`updated_at`) VALUES (2024-09-04 17:31:05.456, 2024-09-04 17:31:05.456) db.Omit(Name, Age, CreatedAt).Create(user) 3.1.3 使用Map创建GORM支持通过 map[string]interface 与 []map[string]interface来创建记录。 db.Model(User).Create(map[string]interface Name: jinzhu, Age: 18,)// batch insert from `[]map[string]interface`db.Model(User).Create([]map[string]interface Name: jinzhu_1, Age: 18, Name: jinzhu_2, Age: 20,) 注意当使用map来创建时，钩子方法不会执行，关联不会被保存且不会回写主键。 3.1.4 批量插入package mainimport (\tfmt\ttime\tgorm.io/driver/mysql\tgorm.io/gorm)type User struct ID uint `gorm:primaryKey` // 主键\tName string `gorm:size:100;not null` // 字符串字段，最大长度 100，不能为空\tAge int `gorm:default:18` // 默认值 18\tCreatedAt time.Time\tUpdatedAt time.Timefunc main() dsn := root:strong_root_password@tcp(www.devlop.com:3306)/test?charset=utf8mb4parseTime=Trueloc=Local\tdb, err := gorm.Open(mysql.Open(dsn), gorm.Config)\tif err != nil panic(failed to connect database) var users = []UserName: jinzhu1, Name: jinzhu2, Name: jinzhu3\tdb.Create(users)\tfor _, user := range users fmt.Println(user.ID) // 1,2,3 可以通过db.CreateInBatches方法来指定批量插入的批次大小。 var users = []UserName: jinzhu1, Name: jinzhu2, Name: jinzhu3// batch size 2// 这里可以用users或usersdb.CreateInBatches(users, 2) 注意 使用CreateBatchSize 选项初始化GORM实例后，此后进行创建 关联操作时所有的INSERT行为都会遵循初始化时的配置。 db, err := gorm.Open(sqlite.Open(gorm.db), gorm.Config CreateBatchSize: 1000,)db := db.Session(gorm.SessionCreateBatchSize: 1000)users = [5000]UserName: jinzhu, Pets: []Petpet1, pet2, pet3...db.Create(users)// INSERT INTO users xxx (5 batches)// INSERT INTO pets xxx (15 batches) 3.1.5 创建钩子GROM允许用户通过实现这些接口 BeforeSave, BeforeCreate, AfterSave, AfterCreate来自定义钩子。 这些钩子方法会在创建一条记录时被调用，关于钩子的生命周期请参阅Hooks。 func (u *User) BeforeCreate(tx *gorm.DB) (err error) u.UUID = uuid.New() if u.Role == admin return errors.New(invalid role) return 如果你想跳过Hooks方法，可以使用SkipHooks会话模式，例子如下 DB.Session(gorm.SessionSkipHooks: true).Create(user)DB.Session(gorm.SessionSkipHooks: true).Create(users)DB.Session(gorm.SessionSkipHooks: true).CreateInBatches(users, 100) 3.2 查询3.2.1 查询单个对象GORM 提供了 First、Take、Last 方法，以便从数据库中检索单个对象。当查询数据库时它添加了 LIMIT 1 条件，且没有找到记录时，它会返回 ErrRecordNotFound 错误。 package mainimport (\tfmt\ttime\tgorm.io/driver/mysql\tgorm.io/gorm)type User struct ID uint `gorm:primaryKey` // 主键\tName string `gorm:size:100;not null` // 字符串字段，最大长度 100，不能为空\tAge int `gorm:default:18` // 默认值 18\tCreatedAt time.Time\tUpdatedAt time.Timefunc main() dsn := root:strong_root_password@tcp(www.devlop.com:3306)/test?charset=utf8mb4parseTime=Trueloc=Local\tdb, err := gorm.Open(mysql.Open(dsn), gorm.Config)\tif err != nil panic(failed to connect database) var user User // 获取第一条记录（主键升序） db.First(user) // SELECT * FROM users ORDER BY id LIMIT 1; fmt.Println(user) // 21 jinzhu 19 0001-01-01 00:00:00 +0000 UTC 0001-01-01 00:00:00 +0000 UTC // 获取一条记录，没有指定排序字段 db.Take(user) // SELECT * FROM users LIMIT 1; fmt.Println(user) // 21 jinzhu 19 0001-01-01 00:00:00 +0000 UTC 0001-01-01 00:00:00 +0000 UTC // 获取最后一条记录（主键降序） db.Last(user) // SELECT * FROM users ORDER BY id DESC LIMIT 1; result := db.First(user) result.RowsAffected // 返回找到的记录数 result.Error // returns error or nil // 检查 ErrRecordNotFound 错误 errors.Is(result.Error, gorm.ErrRecordNotFound) 如果你想避免ErrRecordNotFound错误，你可以使用Find，比如db.Limit(1).Find(user)，Find方法可以接受struct和slice的数据。 对单个对象使用Find而不带limit，db.Find(user)将会查询整个表并且只返回第一个对象，只是性能不高并且不确定的。 First and Last 方法会按主键排序找到第一条记录和最后一条记录 (分别)。 只有在目标 struct 是指针或者通过 db.Model() 指定的 model 时，该方法才有效。 此外，如果相关 model 没有定义主键，那么将按 model 的第一个字段进行排序。 例如： var user Uservar users []User// works because destination struct is passed in// 这里使用了user模型，能够正常执行db.First(user)// SELECT * FROM `users` ORDER BY `users`.`id` LIMIT 1// works because model is specified using `db.Model()`result := map[string]interface// 这里使用了db.Model()能够正常执行db.Model(User).First(result)// SELECT * FROM `users` ORDER BY `users`.`id` LIMIT 1// doesnt work// 两者都没用使用First查询不会正常执行result := map[string]interfacedb.Table(users).First(result)// works with Takeresult := map[string]interface// 使用take方法正常执行// map[age:19 birthday:nil created_at:nil id:21 name:jinzhu updated_at:nil]db.Table(users).Take(result)// no primary key defined, results will be ordered by first field (i.e., `Code`)type Language struct Code string Name stringdb.First(Language)// SELECT * FROM `languages` ORDER BY `languages`.`code` LIMIT 1 3.2.2 根据主键查询如果主键是数字类型，可以使用 内联条件 来检索对象。 当使用字符串时，需要额外的注意来避免SQL注入；查看 Security 部分来了解详情。 db.First(user, 10)// SELECT * FROM users WHERE id = 10;db.First(user, 10)// SELECT * FROM users WHERE id = 10;db.Find(users, []int1,2,3)// SELECT * FROM users WHERE id IN (1,2,3); 如果主键是字符串(例如像uuid)，查询将被写成如下： db.First(user, id = ?, 1b74413f-f3b8-409f-ac47-e8c062e3472a)// SELECT * FROM users WHERE id = 1b74413f-f3b8-409f-ac47-e8c062e3472a; 当目标对象有一个主键值时，将使用主键构建查询条件，例如： var user = UserID: 10db.First(user)// SELECT * FROM users WHERE id = 10;var result Userdb.Model(UserID: 10).First(result)// SELECT * FROM users WHERE id = 10; NOTE: 如果使用 gorm 的特定字段类型（例如 gorm.DeletedAt），它将运行不同的查询来检索对象。 type User struct ID string `gorm:primarykey;size:16` Name string `gorm:size:24` DeletedAt gorm.DeletedAt `gorm:index`var user = UserID: 15db.First(user)// SELECT * FROM `users` WHERE `users`.`id` = 15 AND `users`.`deleted_at` IS NUL 3.2.3 查询全部对象package mainimport (\tfmt\ttime\tgorm.io/driver/mysql\tgorm.io/gorm)type User struct ID uint `gorm:primaryKey` // 主键\tName string `gorm:size:100;not null` // 字符串字段，最大长度 100，不能为空\tAge int `gorm:default:18` // 默认值 18\tCreatedAt time.Time\tUpdatedAt time.Timefunc main() dsn := root:strong_root_password@tcp(www.devlop.com:3306)/test?charset=utf8mb4parseTime=Trueloc=Local\tdb, err := gorm.Open(mysql.Open(dsn), gorm.Config)\tif err != nil panic(failed to connect database) var users []User // SELECT * FROM users; result := db.Find(users)\tfmt.Println(users) result.RowsAffected // returns found records count, equals `len(users)`\tresult.Error // returns error 3.2.4 条件查询3.2.4.1 string// Get first matched recorddb.Where(name = ?, jinzhu).First(user)// SELECT * FROM users WHERE name = jinzhu ORDER BY id LIMIT 1;// Get all matched recordsdb.Where(name ?, jinzhu).Find(users)// SELECT * FROM users WHERE name jinzhu;// INdb.Where(name IN ?, []stringjinzhu, jinzhu 2).Find(users)// SELECT * FROM users WHERE name IN (jinzhu,jinzhu 2);// LIKEdb.Where(name LIKE ?, %jin%).Find(users)// SELECT * FROM users WHERE name LIKE %jin%;// ANDdb.Where(name = ? AND age = ?, jinzhu, 22).Find(users)// SELECT * FROM users WHERE name = jinzhu AND age = 22;// Timedb.Where(updated_at ?, lastWeek).Find(users)// SELECT * FROM users WHERE updated_at 2000-01-01 00:00:00;// BETWEENdb.Where(created_at BETWEEN ? AND ?, lastWeek, today).Find(users)// SELECT * FROM users WHERE created_at BETWEEN 2000-01-01 00:00:00 AND 2000-01-08 00:00:00; 如果对象设置了主键，条件查询将不会覆盖主键的值，而是用 And 连接条件。 例如： var user = UserID: 10db.Where(id = ?, 20).First(user)// SELECT * FROM users WHERE id = 10 and id = 20 ORDER BY id ASC LIMIT 1 这个查询将会给出record not found错误 所以，在你想要使用例如 user 这样的变量从数据库中获取新值前，需要将例如 id 这样的主键设置为nil。 3.2.4.2 sturcmap// Structdb.Where(UserName: jinzhu, Age: 20).First(user)// SELECT * FROM users WHERE name = jinzhu AND age = 20 ORDER BY id LIMIT 1;// Mapdb.Where(map[string]interfacename: jinzhu, age: 20).Find(users)// SELECT * FROM users WHERE name = jinzhu AND age = 20;// Slice of primary keysdb.Where([]int6420, 21, 22).Find(users)// SELECT * FROM users WHERE id IN (20, 21, 22); NOTE When querying with struct, GORM will only query with non-zero fields, that means if your field’s value is 0, , false or other zero values, it won’t be used to build query conditions, for example: 当使用 struct 模式查询且字段为0值时，这个字段不会出现再构建的 sql 语句中： db.Where(UserName: jinzhu, Age: 0).Find(users)// SELECT * FROM users WHERE name = jinzhu; To include zero values in the query conditions, you can use a map, which will include all key-values as query conditions, for example: 如果要包含零值字段作为查询条件，可以使用 map： db.Where(map[string]interfaceName: jinzhu, Age: 0).Find(users)// SELECT * FROM users WHERE name = jinzhu AND age = 0; 也可以在 struct 中指定字段： db.Where(UserName: jinzhu, name, Age).Find(users)// SELECT * FROM users WHERE name = jinzhu AND age = 0;db.Where(UserName: jinzhu, Age).Find(users)// SELECT * FROM users WHERE age = 0; 3.2.4.3 内联查询查询条件可以以类似于 Where 的方式内联到 First 和 Find 等方法中。 // Get by primary key if it were a non-integer typedb.First(user, id = ?, string_primary_key)// SELECT * FROM users WHERE id = string_primary_key;// Plain SQLdb.Find(user, name = ?, jinzhu)// SELECT * FROM users WHERE name = jinzhu;db.Find(users, name ? AND age ?, jinzhu, 20)// SELECT * FROM users WHERE name jinzhu AND age 20;// Structdb.Find(users, UserAge: 20)// SELECT * FROM users WHERE age = 20;// Mapdb.Find(users, map[string]interfaceage: 20)// SELECT * FROM users WHERE age = 20; 3.2.4.4 Notdb.Not(name = ?, jinzhu).First(user)// SELECT * FROM users WHERE NOT name = jinzhu ORDER BY id LIMIT 1;// Not Indb.Not(map[string]interfacename: []stringjinzhu, jinzhu 2).Find(users)// SELECT * FROM users WHERE name NOT IN (jinzhu, jinzhu 2);// Structdb.Not(UserName: jinzhu, Age: 18).First(user)// SELECT * FROM users WHERE name jinzhu AND age 18 ORDER BY id LIMIT 1;// Not In slice of primary keysdb.Not([]int641,2,3).First(user)// SELECT * FROM users WHERE id NOT IN (1,2,3) ORDER BY id LIMIT 1; 3.2.4.5 Ordb.Where(role = ?, admin).Or(role = ?, super_admin).Find(users)// SELECT * FROM users WHERE role = admin OR role = super_admin;// Structdb.Where(name = jinzhu).Or(UserName: jinzhu 2, Age: 18).Find(users)// SELECT * FROM users WHERE name = jinzhu OR (name = jinzhu 2 AND age = 18);// Mapdb.Where(name = jinzhu).Or(map[string]interfacename: jinzhu 2, age: 18).Find(users)// SELECT * FROM users WHERE name = jinzhu OR (name = jinzhu 2 AND age = 18); 3.2.4.5 选择特定字段Gorm 可以选择指定要从数据库检索的字段。否则，将默认选择所有字段。 db.Select(name, age).Find(users)// SELECT name, age FROM users;db.Select([]stringname, age).Find(users)// SELECT name, age FROM users;db.Table(users).Select(COALESCE(age,?), 42).Rows()// SELECT COALESCE(age,42) FROM users; 3.2.4.6 排序db.Order(age desc, name).Find(users)// SELECT * FROM users ORDER BY age desc, name;// Multiple ordersdb.Order(age desc).Order(name).Find(users)// SELECT * FROM users ORDER BY age desc, name; 3.2.4.7 Limit Offsetdb.Limit(3).Find(users)// SELECT * FROM users LIMIT 3;// Cancel limit condition with -1db.Limit(10).Find(users1)// SELECT * FROM users LIMIT 10; (users1)db.Limit(-1).Find(users2)// SELECT * FROM users; (users2)db.Offset(3).Find(users)// SELECT * FROM users OFFSET 3;db.Limit(10).Offset(5).Find(users)// SELECT * FROM users OFFSET 5 LIMIT 10;// Cancel offset condition with -1db.Offset(10).Find(users1).Offset(-1).Find(users2)// SELECT * FROM users OFFSET 10; (users1)// SELECT * FROM users; (users2) 3.2.4.8 Group By Havingtype result struct Date time.Time Total intdb.Model(User).Select(name, sum(age) as total).Where(name LIKE ?, group%).Group(name).First(result)// SELECT name, sum(age) as total FROM `users` WHERE name LIKE group% GROUP BY `name` LIMIT 1db.Model(User).Select(name, sum(age) as total).Group(name).Having(name = ?, group).Find(result)// SELECT name, sum(age) as total FROM `users` GROUP BY `name` HAVING name = group 3.2.4.9 Distinctdb.Distinct(name, age).Order(name, age desc).Find(results) 3.2.4.9 Scantype Result struct Name string Age intvar result Resultdb.Table(users).Select(name, age).Where(name = ?, Antonio).Scan(result)// Raw SQLdb.Raw(SELECT name, age FROM users WHERE name = ?, Antonio).Scan(result) 3.2.4.10 Joinstype result struct Name string Email stringdb.Model(User).Select(users.name, emails.email).Joins(left join emails on emails.user_id = users.id).Scan(result)// SELECT users.name, emails.email FROM `users` left join emails on emails.user_id = users.idrows, err := db.Table(users).Select(users.name, emails.email).Joins(left join emails on emails.user_id = users.id).Rows()for rows.Next() ...db.Table(users).Select(users.name, emails.email).Joins(left join emails on emails.user_id = users.id).Scan(results)// multiple joins with parameterdb.Joins(JOIN emails ON emails.user_id = users.id AND emails.email = ?, jinzhu@example.org).Joins(JOIN credit_cards ON credit_cards.user_id = users.id).Where(credit_cards.number = ?, 411111111111).Find(user) 4. 高级查询4.1 ScopeGORM中的 Scopes 是一个强大的特性，允许将常用的查询条件定义为可重用的方法，使代码更加模块化和可读。 4.1.1 查询Scope 查询示例： func AmountGreaterThan1000(db *gorm.DB) *gorm.DB return db.Where(amount ?, 1000)func PaidWithCreditCard(db *gorm.DB) *gorm.DB return db.Where(pay_mode_sign = ?, C)func PaidWithCod(db *gorm.DB) *gorm.DB return db.Where(pay_mode_sign = ?, C)func OrderStatus(status []string) func (db *gorm.DB) *gorm.DB return func (db *gorm.DB) *gorm.DB return db.Where(status IN (?), status) db.Scopes(AmountGreaterThan1000, PaidWithCreditCard).Find(orders)// 查找所有金额大于 1000 的信用卡订单db.Scopes(AmountGreaterThan1000, PaidWithCod).Find(orders)// 查找所有金额大于 1000 的 COD 订单db.Scopes(AmountGreaterThan1000, OrderStatus([]stringpaid, shipped)).Find(orders)// 查找所有金额大于1000 的已付款或已发货订单 4.1.2 分页func Paginate(r *http.Request) func(db *gorm.DB) *gorm.DB return func (db *gorm.DB) *gorm.DB q := r.URL.Query() page, _ := strconv.Atoi(q.Get(page)) if page = 0 page = 1 pageSize, _ := strconv.Atoi(q.Get(page_size)) switch case pageSize 100: pageSize = 100 case pageSize = 0: pageSize = 10 offset := (page - 1) * pageSize return db.Offset(offset).Limit(pageSize) db.Scopes(Paginate(r)).Find(users)db.Scopes(Paginate(r)).Find(articles) 4.2 CountGORM中的 Count 方法用于检索匹配给定查询的记录数。 这是了解数据集大小的一个有用的功能，特别是在涉及有条件查询或数据分析的情况下。 4.2.1 得到匹配记录的 Count可以使用 Count 来确定符合您的查询中符合特定标准的记录的数量。 var count int64// 计数 有着特定名字的 usersdb.Model(User).Where(name = ?, jinzhu).Or(name = ?, jinzhu 2).Count(count)// SQL: SELECT count(1) FROM users WHERE name = jinzhu OR name = jinzhu 2// 计数 有着单一名字条件（single name condition）的 usersdb.Model(User).Where(name = ?, jinzhu).Count(count)// SQL: SELECT count(1) FROM users WHERE name = jinzhu// 在不同的表中对记录计数db.Table(deleted_users).Count(count)// SQL: SELECT count(1) FROM deleted_users 4.2.2 **配合 Distinct 和 Group **GORM还允许对不同的值进行计数并对结果进行分组。 // 为不同 name 计数db.Model(User).Distinct(name).Count(count)// SQL: SELECT COUNT(DISTINCT(`name`)) FROM `users`// 使用自定义选择（custom select）计数不同的值db.Table(deleted_users).Select(count(distinct(name))).Count(count)// SQL: SELECT count(distinct(name)) FROM deleted_users// 分组记录计数users := []User Name: name1, Name: name2, Name: name3, Name: name3,db.Model(User).Group(name).Count(count)// 按名称分组后计数// count = 3","tags":["Go、Gorm"]},{"title":"Gin基础学习","path":"/2024/09/03/Gin基础学习/","content":"1. 简介1.1 概述Gin 是一个用 Go (Golang) 编写的 HTTP Web 框架。它具有类似 Martini 的 API，由于使用 httprouter，性能比 Martini 快 40 倍。 1.2 安装1.下载并安装 gin： go get -u github.com/gin-gonic/gin 2.将 gin 引入到代码中： import github.com/gin-gonic/gin 1.3 Hello Worldpackage mainimport ( net/http github.com/gin-gonic/gin)func main() r := gin.Default() r.GET(/hello, func(ctx *gin.Context) ctx.String(http.StatusOK, hello world) ) r.Run(:8000) 2. 路由2.1 概述在Gin框架中，”路由”（Router）是处理HTTP请求并将其分发到适当处理程序的机制。 在Gin中，你可以定义各种HTTP请求方法（如GET、POST、PUT、DELETE等）的路由。每个路由都关联一个特定 的处理函数（handler）。例如： r := gin.Default()r.GET(/ping, func(c *gin.Context) c.JSON(200, gin.H message: pong, )) 2.2 路由规则一条路由规则由三部分组成： http请求方法 url路径 控制器函数 http请求方法 常用的http请求方法有下面4种: GET POST PUT DELETE url路径 url路径有三种写法： 静态url路径 带路径参数的url路径 带星号（*）模糊匹配参数的url路径 // 例子1， 静态Url路径, 即不带任何参数的url路径/users/center/user/111/food/12// 例子2，带路径参数的url路径，url路径上面带有参数,参数由冒号（:）跟着一个字符串定义。// 路径参数值可以是数值，也可以是字符串//定义参数:id， 可以匹配/user/1, /user/899 /user/xiaoli 这类Url路径/user/:id//定义参数:id， 可以匹配/food/2, /food/100 /food/apple 这类Url路径/food/:id//定义参数:type和:page， 可以匹配/foods/2/1, /food/100/25 /food/apple/30 这类Url路径/foods/:type/:page// 例子3. 带星号（*）模糊匹配参数的url路径// 星号代表匹配任意路径的意思, 必须在*号后面指定一个参数名，后面可以通过这个参数获取*号匹配的内容。//以/foods/ 开头的所有路径都匹配//匹配：/foods/1， /foods/200, /foods/1/20, /foods/apple/1 /foods/*path//可以通过path参数获取*号匹配的内容。 控制器函数 控制器函数定义： func HandlerFunc(c *gin.Context) 控制器函数接受一个上下文参数。可以通过上下文参数，获取http请求参数，响应http请求。 2.3 路由定义例子//实例化gin实例对象。r := gin.Default() //定义post请求, url路径为：/users, 绑定saveUser控制器函数r.POST(/users, saveUser)//定义get请求，url路径为：/users/:id （:id是参数，例如: /users/10, 会匹配这个url模式），绑定getUser控制器函数r.GET(/users/:id, getUser)//定义put请求r.PUT(/users/:id, updateUser)//定义delete请求r.DELETE(/users/:id, deleteUser)//控制器函数实现func saveUser(c *gin.Context) ...忽略实现...func getUser(c *gin.Context) ...忽略实现...func updateUser(c *gin.Context) ...忽略实现...func deleteUser(c *gin.Context) ...忽略实现... 2.4 分组路由在做api开发的时候，如果要支持多个api版本，我们可以通过分组路由来实现api版本处理。 func main() router := gin.Default() // 创建v1组 v1 := router.Group(/v1) // 在v1这个分组下，注册路由 v1.POST(/login, loginEndpoint) v1.POST(/submit, submitEndpoint) v1.POST(/read, readEndpoint) // 创建v2组 v2 := router.Group(/v2) // 在v2这个分组下，注册路由 v2.POST(/login, loginEndpoint) v2.POST(/submit, submitEndpoint) v2.POST(/read, readEndpoint) router.Run(:8080) 上面的例子将会注册下面的路由信息： v1login v1submit v1read v2login v2submit v2read 路由分组，其实就是设置了同一类路由的url前缀。 3. Gin处理请求参数3.1 处理Get请求参数3.1.1 获取API参数 可以通过Context的Param方法来获取API参数 localhost:8000xxxzhangsan package mainimport ( net/http strings github.com/gin-gonic/gin)func main() r := gin.Default() // http://localhost:8000/user/gege/daji r.GET(/user/:name/*action, func(c *gin.Context) name := c.Param(name) action := c.Param(action) //截取/ action = strings.Trim(action, /) c.String(http.StatusOK, name+ is +action) ) //默认为监听8080端口 r.Run(:8000) 3.1.2 获取url参数Get请求url例子：*path?id1234nameManuvalue*111 获取Get请求参数的常用函数： func (c *Context) Query(key string) string func (c *Context) DefaultQuery(key, defaultValue string) string func (c *Context) GetQuery(key string) (string, bool) func Handler(c *gin.Context) //获取name参数, 通过Query获取的参数值是String类型。 name := c.Query(name) //获取name参数, 跟Query函数的区别是，可以通过第二个参数设置默认值。 value := c.DefaultQuery(value, vvv) //获取id参数, 通过GetQuery获取的参数值也是String类型, // 区别是GetQuery返回两个参数，第一个是参数值，第二个参数是参数是否存在的bool值，可以用来判断参数是否存在。 id, ok := c.GetQuery(id) if !ok // 参数不存在 提示：GetQuery函数，判断参数是否存在的逻辑是，参数值为空，参数也算存在，只有没有提交参数，才算参数不存在。 3.2 处理Post请求参数表单传输为post请求，http常见的传输格式为四种： applicationjson applicationx-www-form-urlencoded applicationxml multipartform-data 获取Post请求参数的常用函数： func (c *Context) PostForm(key string) string func (c *Context) DefaultPostForm(key, defaultValue string) string PostForm的区别是可以通过第二个参数设置参数默认值 func (c *Context) GetPostForm(key string) (string, bool) GetPostForm返回两个参数，第一个是参数值，第二个参数是参数是否存在的bool值 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta name=viewport content=width=device-width, initial-scale=1.0 meta http-equiv=X-UA-Compatible content=ie=edge titleDocument/title/headbody form action=http://localhost:8080/form method=post action=application/x-www-form-urlencoded 用户名：input type=text name=username placeholder=请输入你的用户名 br 密nbsp;nbsp;nbsp;码：input type=password name=userpassword placeholder=请输入你的密码 br input type=submit value=提交 /form/body/html package mainimport ( fmt net/http github.com/gin-gonic/gin)func main() r := gin.Default() r.POST(/form, func(c *gin.Context) types := c.DefaultPostForm(type, post) username := c.PostForm(username) userpassword := c.PostForm(userpassword) c.String(http.StatusOK, fmt.Sprintf(username:%s, password:%s, type:%s, username, userpassword, types)) ) r.Run() 4. 数据解析和绑定4.1 Json 数据解析和绑定客户端传参，后端接收并解析到结构体 package mainimport ( github.com/gin-gonic/gin net/http)// 定义接收数据的结构体type Login struct // binding:required修饰的字段，若接收为空值，则报错，是必须字段 User string `form:username json:user uri:user xml:user binding:required` Pssword string `form:password json:password uri:password xml:password binding:required`func main() // 1.创建路由 // 默认使用了2个中间件Logger(), Recovery() r := gin.Default() // JSON绑定 r.POST(loginJSON, func(c *gin.Context) // 声明接收的变量 var json Login // 将request的body中的数据，自动按照json格式解析到结构体 if err := c.ShouldBindJSON(json); err != nil // 返回错误信息 // gin.H封装了生成json数据的工具 c.JSON(http.StatusBadRequest, gin.Herror: err.Error()) return // 判断用户名密码是否正确 if json.User != root || json.Pssword != admin c.JSON(http.StatusBadRequest, gin.Hstatus: 304) return c.JSON(http.StatusOK, gin.Hstatus: 200) ) r.Run(:8000) curl http://localhost:8000/loginJSON -H content-type:application/json -d \\user\\:\\root\\,\\password\\:\\root\\ -X POST` 4.2 表单数据解析和绑定!DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta name=viewport content=width=device-width, initial-scale=1.0 meta http-equiv=X-UA-Compatible content=ie=edge titleDocument/title/headbody form action=http://localhost:8000/loginForm method=post enctype=application/x-www-form-urlencoded 用户名input type=text name=usernamebr 密码input type=password name=password input type=submit value=提交 /form/body/html package mainimport ( net/http github.com/gin-gonic/gin)// 定义接收数据的结构体type Login struct // binding:required修饰的字段，若接收为空值，则报错，是必须字段 User string `form:username json:user uri:user xml:user binding:required` Pssword string `form:password json:password uri:password xml:password binding:required`func main() // 1.创建路由 // 默认使用了2个中间件Logger(), Recovery() r := gin.Default() // JSON绑定 r.POST(/loginForm, func(c *gin.Context) // 声明接收的变量 var form Login // Bind()默认解析并绑定form格式 // 根据请求头中content-type自动推断 if err := c.Bind(form); err != nil c.JSON(http.StatusBadRequest, gin.Herror: err.Error()) return // 判断用户名密码是否正确 if form.User != root || form.Pssword != admin c.JSON(http.StatusBadRequest, gin.Hstatus: 304) return c.JSON(http.StatusOK, gin.Hstatus: 200) ) r.Run(:8000) 4.3 url数据解析和绑定package mainimport ( net/http github.com/gin-gonic/gin)// 定义接收数据的结构体type Login struct // binding:required修饰的字段，若接收为空值，则报错，是必须字段 User string `form:username json:user uri:user xml:user binding:required` Pssword string `form:password json:password uri:password xml:password binding:required`func main() // 1.创建路由 // 默认使用了2个中间件Logger(), Recovery() r := gin.Default() // JSON绑定 r.GET(/:user/:password, func(c *gin.Context) // 声明接收的变量 var login Login // ShouldBindUri()默认解析并绑定uri格式 // 根据请求头中content-type自动推断 if err := c.ShouldBindUri(login); err != nil c.JSON(http.StatusBadRequest, gin.Herror: err.Error()) return // 判断用户名密码是否正确 if login.User != root || login.Pssword != admin c.JSON(http.StatusBadRequest, gin.Hstatus: 304) return c.JSON(http.StatusOK, gin.Hstatus: 200) ) r.Run(:8000) 5. Gin处理请求响应Gin框架支持以字符串、json、xml、文件等格式响应请求。 gin.Context上下文对象支持多种返回处理结果，下面分别介绍不同的响应方式。 5.1 字符串响应通过String函数返回字符串。 函数定义： func (c *Context) String(code int, format string, values ...interface) 参数说明： 参数 说明 code http状态码 format 返回结果，支持类似Sprintf函数一样的字符串格式定义，例如,%d 代表插入整数，%s代表插入字符串 values 任意个format参数定义的字符串格式参数 package mainimport ( net/http github.com/gin-gonic/gin)func main() r := gin.Default() r.GET(string, func(c *gin.Context) c.String(http.StatusOK, hello 你好好！) c.String(http.StatusOK, 欢迎%s, 你是%s, 赵大妈, 最靓的仔！) ) r.Run() 5.2 Json格式响应package mainimport ( net/http github.com/gin-gonic/gin)func main() r := gin.Default() r.GET(/json, func(c *gin.Context) c.JSON(http.StatusOK, gin.Hmessage: json, status: 200) ) r.GET(/struct, func(c *gin.Context) var msg struct Name string Message string Number int msg.Name = root msg.Message = message msg.Number = 123 c.JSON(200, msg) ) r.Run() 5.3 XML格式响应package mainimport github.com/gin-gonic/gin// User 定义, 默认struct的名字就是xml的根节点名字，这里转换成xml后根节点的名字为User.type User struct Name string `xml:name` // 通过xml标签定义struct字段转换成xml字段的名字。 Email string `xml:email`func main() r := gin.Default() r.GET(xml, func(c *gin.Context) //初始化user对象 u := User Name: tizi365, Email: tizi@tizi365.com, //返回xml数据 //返回结果： // ?xml version=1.0 encoding=UTF-8? // Usernametizi365/nameemailtizi@tizi365.com/email/User c.XML(200, u) ) r.Run() 6. 文件上传下载6.1 文件上传!doctype htmlhtml lang=enhead meta charset=utf-8 titleSingle file upload/title/headbodyh1上传文件演示/h1form action=http://localhost:8080/upload method=post enctype=multipart/form-data 文件: input type=file name=filebrbr input type=submit value=上传文件/form/body/html package mainimport ( fmt log net/http github.com/gin-gonic/gin)func main() r := gin.Default() // 设置文件上传大小限制，默认是32m r.MaxMultipartMemory = 64 20 r.POST(/upload, func(c *gin.Context) // 获取上传文件，返回的是multipart.FileHeader对象，代表一个文件，里面包含了文件名之类的详细信息 // file是表单字段名字 file, _ := c.FormFile(file) log.Println(file.Filename) // 将上传的文件，保存到./data/1.txt 文件中 err := c.SaveUploadedFile(file, ./data/1.txt) if err != nil fmt.Println(err.Error()) c.String(http.StatusBadRequest, fmt.Sprintf(%s upload failed, file.Filename)) return c.String(http.StatusOK, fmt.Sprintf(%s uploaded, file.Filename)) ) r.Run() 6.2 文件下载package mainimport github.com/gin-gonic/ginfunc main() r := gin.Default() r.GET(down1, func(c *gin.Context) //通过File函数，直接返回本地文件，参数为本地文件地址。 //函数说明：c.File(文件路径) //在浏览器中直接显示 c.File(./data/1.txt) ) r.GET(down2, func(c *gin.Context) //通过FileAttachment函数，返回本地文件，类似File函数，区别是可以指定下载的文件名。 //函数说明: c.FileAttachment(文件路径, 下载的文件名) //在浏览器中直接下载 c.FileAttachment(./data/1.txt, 2.txt) ) r.Run() 7. Gin中间件7.1 概述在Gin框架中，中间件（Middleware）指的是可以拦截http请求-响应生命周期的特殊函数，在请求-响应生命周期中可以注册多个中间件，每个中间件执行不同的功能，一个中间执行完再轮到下一个中间件执行。 中间件的常见应用场景如下： 请求限速 api接口签名处理 权限校验 统一错误处理 提示：如果你想拦截所有请求做一些事情都可以开发一个中间件函数去实现。 Gin支持设置全局中间件和针对路由分组设置中间件，设置全局中间件意思就是会拦截所有请求，针对分组路由设置中间件，意思就是仅对这个分组下的路由起作用。 7.2 全局中间件package main// 导入gin包import ( log time github.com/gin-gonic/gin)// 自定义个日志中间件func Logger() gin.HandlerFunc return func(c *gin.Context) t := time.Now() // 可以通过上下文对象，设置一些依附在上下文对象里面的键/值数据 c.Set(example, 12345) // 在这里处理请求到达控制器函数之前的逻辑 // 调用下一个中间件，或者控制器处理函数，具体得看注册了多少个中间件。 c.Next() // 在这里可以处理请求返回给用户之前的逻辑 latency := time.Since(t) log.Print(latency) // 例如，查询请求状态吗 status := c.Writer.Status() log.Println(status) func main() r := gin.New() // 注册上面自定义的日志中间件 r.Use(Logger()) r.GET(/test, func(c *gin.Context) // 查询我们之前在日志中间件，注入的键值数据 example := c.MustGet(example).(string) // it would print: 12345 log.Println(example) ) // Listen and serve on 0.0.0.0:8080 r.Run(:8080) 7.3 局部中间件package mainimport ( fmt time github.com/gin-gonic/gin)func MiddleWare() gin.HandlerFunc return func(c *gin.Context) t := time.Now() fmt.Println(中间件开始执行了) // 设置变量到Context的key中，可以通过Get()取 c.Set(request, 中间件) // 执行函数 c.Next() // 中间件执行完后续的一些事情 status := c.Writer.Status() fmt.Println(中间件执行完毕, status) t2 := time.Since(t) fmt.Println(time:, t2) func main() // 1.创建路由 // 默认使用了2个中间件Logger(), Recovery() r := gin.Default() // 局部中间键使用,注册到了方法处理函数上 r.GET(/ce, MiddleWare(), func(c *gin.Context) // 取值 req, _ := c.Get(request) fmt.Println(request:, req) // 页面接收 c.JSON(200, gin.Hrequest: req) ) r.Run() 8. 会话控制8.1 Cookie介绍 HTTP是无状态协议，服务器不能记录浏览器的访问状态，也就是说服务器不能区分两次请求是否由同一个客户端发出 Cookie就是解决HTTP协议无状态的方案之一，中文是小甜饼的意思 Cookie实际上就是服务器保存在浏览器上的一段信息。浏览器有了Cookie之后，每次向服务器发送请求时都会同时将该信息发送给服务器，服务器收到请求后，就可以根据该信息处理请求 Cookie由服务器创建，并发送给浏览器，最终由浏览器保存 8.2 Cookie使用SetCookie函数定义： func (c *Context) SetCookie(name, value string, maxAge int, path, domain string, secure, httpOnly bool) 参数说明： 参数名 类型 说明 name string cookie名字 value string cookie值 maxAge int 有效时间，单位是秒，MaxAge0 忽略MaxAge属性，MaxAge0 相当于删除cookie, 通常可以设置-1代表删除，MaxAge0 多少秒后cookie失效 path string cookie路径 domain string cookie作用域 secure bool Securetrue，那么这个cookie只能用https协议发送给服务器 httpOnly bool 设置HttpOnlytrue的cookie不能被js获取到 package mainimport ( github.com/gin-gonic/gin fmt)func main() // 1.创建路由 // 默认使用了2个中间件Logger(), Recovery() r := gin.Default() // 服务端要给客户端cookie r.GET(cookie, func(c *gin.Context) // 获取客户端是否携带cookie cookie, err := c.Cookie(key_cookie) if err != nil cookie = NotSet // 给客户端设置cookie // maxAge int, 单位为秒 // path,cookie所在目录 // domain string,域名 // secure 是否智能通过https访问 // httpOnly bool 是否允许别人通过js获取自己的cookie c.SetCookie(key_cookie, value_cookie, 60, /, localhost, false, true) fmt.Printf(cookie的值是： %s , cookie) ) r.Run() 9. 参数验证9.1 结构体验证用gin框架的数据验证，可以不用解析数据，减少if else，会简洁许多。 package mainimport ( fmt time github.com/gin-gonic/gin)// Person ..type Person struct //不能为空并且大于10 Age int `form:age binding:required,gt=10` Name string `form:name binding:required` Birthday time.Time `form:birthday time_format:2006-01-02 time_utc:1`func main() r := gin.Default() r.GET(/validate, func(c *gin.Context) var person Person if err := c.ShouldBind(person); err != nil c.String(500, fmt.Sprint(err)) return c.String(200, fmt.Sprintf(%#v, person)) ) r.Run() 9.2 自定义验证package mainimport ( net/http github.com/gin-gonic/gin github.com/gin-gonic/gin/binding github.com/go-playground/validator/v10)/* 对绑定解析到结构体上的参数，自定义验证功能 比如我们要对 name 字段做校验，要不能为空，并且不等于 admin ，类似这种需求，就无法 binding 现成的方法 需要我们自己验证方法才能实现 官网示例（https://godoc.org/gopkg.in/go-playground/validator.v10#hdr-Custom_Functions） 这里需要下载引入下 gopkg.in/go-playground/validator.v10*/type Person struct Age int `form:age binding:required,gt=10` // 2、在参数 binding 上使用自定义的校验方法函数注册时候的名称 Name string `form:name binding:NotNullAndAdmin` Address string `form:address binding:required`// 1、自定义的校验方法func nameNotNullAndAdmin(fl validator.FieldLevel) bool if value, ok := fl.Field().Interface().(string); ok // 字段不能为空，并且不等于 admin return value != !(admin == value) return truefunc main() r := gin.Default() // 3、将我们自定义的校验方法注册到 validator中 if v, ok := binding.Validator.Engine().(*validator.Validate); ok // 这里的 key 和 fn 可以不一样最终在 struct 使用的是 key v.RegisterValidation(NotNullAndAdmin, nameNotNullAndAdmin) /* http://127.0.0.1:8080/testing?name=age=12address=beijing http://127.0.0.1:8080/testing?name=adminage=12address=beijing http://127.0.0.1:8080/testing?name=gagaage=12address=beijing */ r.GET(/testing, func(c *gin.Context) var person Person if e := c.ShouldBind(person); e == nil c.String(http.StatusOK, %v, person) else c.String(http.StatusOK, person bind err:%v, e.Error()) ) r.Run() 9.3 多语言翻译当业务系统对验证信息有特殊需求时，例如：返回信息需要自定义，手机端返回的信息需要是中文而pc端发挥返回的信息需要时英文，如 何做到请求一个接口满足上述三种情况。 package mainimport ( fmt github.com/gin-gonic/gin github.com/go-playground/locales/en github.com/go-playground/locales/zh ut github.com/go-playground/universal-translator en_translations github.com/go-playground/validator/v10/translations/en zh_translations github.com/go-playground/validator/v10/translations/zh github.com/go-playground/validator/v10)var ( Uni *ut.UniversalTranslator Validate *validator.Validate)type User struct Username string `form:user_name validate:required` Tagline string `form:tag_line validate:required,lt=10` Tagline2 string `form:tag_line2 validate:required,gt=1`func main() en := en.New() zh := zh.New() Uni = ut.New(en, zh, en) Validate = validator.New() route := gin.Default() route.GET(/test, startPage) route.POST(/test, startPage) route.Run(:8080)func startPage(c *gin.Context) //这部分应放到中间件中 locale := c.DefaultQuery(locale, zh) trans, _ := Uni.GetTranslator(locale) switch locale case zh: zh_translations.RegisterDefaultTranslations(Validate, trans) break case en: en_translations.RegisterDefaultTranslations(Validate, trans) break default: zh_translations.RegisterDefaultTranslations(Validate, trans) break //自定义错误内容 Validate.RegisterTranslation(required, trans, func(ut ut.Translator) error return ut.Add(required, 0 must have a value!, true) // see universal-translator for details , func(ut ut.Translator, fe validator.FieldError) string t, _ := ut.T(required, fe.Field()) return t ) //这块应该放到公共验证方法中 user := User c.ShouldBind(user) fmt.Println(user) err := Validate.Struct(user) if err != nil errs := err.(validator.ValidationErrors) sliceErrs := []string for _, e := range errs sliceErrs = append(sliceErrs, e.Translate(trans)) c.String(200, fmt.Sprintf(%#v, sliceErrs)) c.String(200, fmt.Sprintf(%#v, user)) 正确的链接：http://localhost:8080/test?user_name=枯藤tag_line=9tag_line2=33locale=zh返回英文的验证信息:http://localhost:8080/test?user_name=枯藤tag_line=9tag_line2=3locale=en http://localhost:8080/test?user_name=枯藤tag_line=9tag_line2=3locale=zh 返回中文的验证信息","tags":["Gin、GO"],"categories":["Go"]},{"title":"Docker+jenkins+Springboot部署服务","path":"/2024/08/22/Docker-jenkins-Springboot部署服务/","content":"1. Docker安装Docker CE 是免费的 Docker 产品的新名称，Docker CE 包含了完整的 Docker 平台，非常适合开发人员和运维团队构建容器 APP。 CentOS 7（使用 yum 进行安装） # step 1: 安装必要的一些系统工具sudo yum install -y yum-utils device-mapper-persistent-data lvm2## 这步如果拉取超时可以修改yum源#下载 ali yum 源#http://mirrors.aliyun.com/repo/Centos-7.repo#cd /etc/yum.repos.d#cp CentOS-Base.repo CentOS-Base.repo.bak#替换repo#mv Centos-7.repo CentOS-Base.repo#yum clean all yum makecache#yum -y update# Step 2: 添加软件源信息sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# PS:如果出现如下错误信息Loaded plugins: fastestmirroradding repo from: https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repograbbing file https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.repoCould not fetch/save url https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo to file /etc/yum.repos.d/docker-ce.repo: [Errno 14] curl#60 - Peers Certificate issuer is not recognized.# 编辑 /etc/yum.conf 文件, 在 [main] 下面添加 sslverify=0 参数vi /etc/yum.conf# 配置如下----------------------[main]sslverify=0# -----------------------------# Step 3: 更新并安装Docker-CEsudo yum makecache fastsudo yum -y install docker-ce# Step 4: 开启Docker服务sudo service docker start# Step 5: 设置开机启动systemctl start dockersystemctl enable docker# 注意：# 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，您可以通过以下方式开启。同理可以开启各种测试版本等。# vim /etc/yum.repos.d/docker-ee.repo# 将[docker-ce-test]下方的enabled=0修改为enabled=1## 安装指定版本的Docker-CE:# Step 1: 查找Docker-CE的版本:# yum list docker-ce.x86_64 --showduplicates | sort -r# Loading mirror speeds from cached hostfile# Loaded plugins: branch, fastestmirror, langpacks# docker-ce.x86_64 17.03.1.ce-1.el7.centos docker-ce-stable# docker-ce.x86_64 17.03.1.ce-1.el7.centos @docker-ce-stable# docker-ce.x86_64 17.03.0.ce-1.el7.centos docker-ce-stable# Available Packages# Step2: 安装指定版本的Docker-CE: (VERSION例如上面的17.03.0.ce.1-1.el7.centos)# sudo yum -y install docker-ce-[VERSION] 2. 添加Docker镜像源加速镜像地址：https://status.1panel.top/status/docker sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json -EOF registry-mirrors: [ https://docker.1panel.top, https://registry-1.docker.io, https://docker.m.daocloud.io ]EOFsudo systemctl daemon-reloadsudo systemctl restart docker# 重启dockerservice docker restart 3. 安装docker compose# github: https://github.com/docker/compose/releases/tag/v2.20.2 # 国内下载地址：https://gitee.com/smilezgy/compose/releases/tag/v2.20.2curl -SL \\https://github.com/docker/compose/releases/download/v2.20.2/docker-compose-linux-x86_64 \\-o /usr/local/bin/docker-compose # 或者手动下载, 上传到服务器后执行如下指令(use)# 在 docker-compose-linux-x86_64 文件同一目录下执行cp docker-compose-linux-x86_64 /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-compose# 注意docker版本 4. 安装jenkins编写Dockercompose.yml version: 3.8# 执行脚本；docker-compose -f docker-compose-v1.0.yml up -dservices: jenkins: image: jenkins/jenkins:2.473 container_name: jenkins privileged: true user: root ports: - 9090:8080 - 50001:50000 volumes: - ./jenkins_home:/var/jenkins_home # 如果不配置到云服务器路径下，则可以配置 jenkins_home 会创建一个数据卷使用 - /var/run/docker.sock:/var/run/docker.sock - /usr/bin/docker:/usr/local/bin/docker # 这两个配置是jenkins使用宿主机docker environment: - JAVA_OPTS=-Djenkins.install.runSetupWizard=false # 禁止安装向导「如果需要密码则不要配置」docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword restart: unless-stoppedvolumes: jenkins_home: 执行安装 docker-compose -f Dockercompose.yml up -d 5. 配置 jenkis获取登录密码 账号：admindocker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword 添加插件 1~2步，设置镜像源，设置后重启一下 Jenkins。 镜像源地址：https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json 3~4步，下载插件，先下载安装 chinese 汉化插件，方便不太熟悉 Jenkins 的伙伴更好的知道页面都是啥内容。 5步，所有的插件安装完成后，都需要重启才会生效。安装完 chinese 插件，重启在进入到 Jenkins 就是汉化的页面了 除了以上步骤，你还需要同样的方式安装 maven、git、docker 插件。 上传maven 在宿主机中上传maven并拷贝到容器中 修改maven中config配置 ?xml version=1.0 encoding=UTF-8?!--Licensed to the Apache Software Foundation (ASF) under oneor more contributor license agreements. See the NOTICE filedistributed with this work for additional informationregarding copyright ownership. The ASF licenses this fileto you under the Apache License, Version 2.0 (theLicense); you may not use this file except in compliancewith the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing,software distributed under the License is distributed on anAS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANYKIND, either express or implied. See the License for thespecific language governing permissions and limitationsunder the License.--!-- | This is the configuration file for Maven. It can be specified at two levels: | | 1. User Level. This settings.xml file provides configuration for a single user, | and is normally provided in $user.home/.m2/settings.xml. | | NOTE: This location can be overridden with the CLI option: | | -s /path/to/user/settings.xml | | 2. Global Level. This settings.xml file provides configuration for all Maven | users on a machine (assuming theyre all using the same Maven | installation). Its normally provided in | $maven.conf/settings.xml. | | NOTE: This location can be overridden with the CLI option: | | -gs /path/to/global/settings.xml | | The sections in this sample file are intended to give you a running start at | getting the most out of your Maven installation. Where appropriate, the default | values (values used when the setting is not specified) are provided. | |--settings xmlns=http://maven.apache.org/SETTINGS/1.2.0 xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation=http://maven.apache.org/SETTINGS/1.2.0 https://maven.apache.org/xsd/settings-1.2.0.xsd !-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $user.home/.m2/repository localRepository/path/to/local/repo/localRepository -- localRepository/user/local/maven/repository/localRepository !-- interactiveMode | This will determine whether maven prompts you when it needs input. If set to false, | maven will use a sensible default value, perhaps based on some other setting, for | the parameter in question. | | Default: true interactiveModetrue/interactiveMode -- !-- offline | Determines whether maven should attempt to connect to the network when executing a build. | This will have an effect on artifact downloads, artifact deployment, and others. | | Default: false offlinefalse/offline -- !-- pluginGroups | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e. | when invoking a command line like mvn prefix:goal. Maven will automatically add the group identifiers | org.apache.maven.plugins and org.codehaus.mojo if these are not already contained in the list. |-- pluginGroups !-- pluginGroup | Specifies a further group identifier to use for plugin lookup. pluginGroupcom.your.plugins/pluginGroup -- /pluginGroups !-- proxies | This is a list of proxies which can be used on this machine to connect to the network. | Unless otherwise specified (by system property or command-line switch), the first proxy | specification in this list marked as active will be used. |-- proxies !-- proxy | Specification for one proxy, to be used in connecting to the network. | proxy idoptional/id activetrue/active protocolhttp/protocol usernameproxyuser/username passwordproxypass/password hostproxy.host.net/host port80/port nonProxyHostslocal.net|some.host.com/nonProxyHosts /proxy -- /proxies !-- servers | This is a list of authentication profiles, keyed by the server-id used within the system. | Authentication profiles can be used whenever maven must make a connection to a remote server. |-- servers !-- server | Specifies the authentication information to use when connecting to a particular server, identified by | a unique name within the system (referred to by the id attribute below). | | NOTE: You should either specify username/password OR privateKey/passphrase, since these pairings are | used together. | server iddeploymentRepo/id usernamerepouser/username passwordrepopwd/password /server -- !-- Another sample, using keys to authenticate. server idsiteServer/id privateKey/path/to/private/key/privateKey passphraseoptional; leave empty if not used./passphrase /server -- /servers !-- mirrors | This is a list of mirrors to be used in downloading artifacts from remote repositories. | | It works like this: a POM may declare a repository to use in resolving certain artifacts. | However, this repository may have problems with heavy traffic at times, so people have mirrored | it to several places. | | That repository definition will have a unique id, so we can create a mirror reference for that | repository, to be used as an alternate download site. The mirror site will be the preferred | server for that repository. |-- mirrors !-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | mirror idmirrorId/id mirrorOfrepositoryId/mirrorOf nameHuman Readable Name for this Mirror./name urlhttp://my.repository.com/repo/path/url /mirror mirror idmaven-default-http-blocker/id mirrorOfexternal:http:*/mirrorOf namePseudo repository to mirror external repositories initially using HTTP./name urlhttp://0.0.0.0//url blockedtrue/blocked /mirror -- mirror idalimaven/id namealiyun maven/name urlhttp://maven.aliyun.com/nexus/content/groups/public//url mirrorOfcentral/mirrorOf /mirror /mirrors !-- profiles | This is a list of profiles which can be activated in a variety of ways, and which can modify | the build process. Profiles provided in the settings.xml are intended to provide local machine- | specific paths and repository locations which allow the build to work in the local environment. | | For example, if you have an integration testing plugin - like cactus - that needs to know where | your Tomcat instance is installed, you can provide a variable here such that the variable is | dereferenced during the build process to configure the cactus plugin. | | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles | section of this document (settings.xml) - will be discussed later. Another way essentially | relies on the detection of a system property, either matching a particular value for the property, | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a | value of 1.4 might activate a profile when the build is executed on a JDK version of 1.4.2_07. | Finally, the list of active profiles can be specified directly from the command line. | | NOTE: For profiles defined in the settings.xml, you are restricted to specifying only artifact | repositories, plugin repositories, and free-form properties to be used as configuration | variables for plugins in the POM. | |-- profiles !-- profile | Specifies a set of introductions to the build process, to be activated using one or more of the | mechanisms described above. For inheritance purposes, and to activate profiles via activatedProfiles/ | or the command line, profiles have to have an ID that is unique. | | An encouraged best practice for profile identification is to use a consistent naming convention | for profiles, such as env-dev, env-test, env-production, user-jdcasey, user-brett, etc. | This will make it more intuitive to understand what the set of introduced profiles is attempting | to accomplish, particularly when you only have a list of profile ids for debug. | | This profile example uses the JDK version to trigger activation, and provides a JDK-specific repo. profile idjdk-1.4/id activation jdk1.4/jdk /activation repositories repository idjdk14/id nameRepository for JDK 1.4 builds/name urlhttp://www.myhost.com/maven/jdk14/url layoutdefault/layout snapshotPolicyalways/snapshotPolicy /repository /repositories /profile -- !-- | Here is another profile, activated by the system property target-env with a value of dev, | which provides a specific path to the Tomcat instance. To use this, your plugin configuration | might hypothetically look like: | | ... | plugin | groupIdorg.myco.myplugins/groupId | artifactIdmyplugin/artifactId | | configuration | tomcatLocation$tomcatPath/tomcatLocation | /configuration | /plugin | ... | | NOTE: If you just wanted to inject this configuration whenever someone set target-env to | anything, you could just leave off the value/ inside the activation-property. | profile idenv-dev/id activation property nametarget-env/name valuedev/value /property /activation properties tomcatPath/path/to/tomcat/instance/tomcatPath /properties /profile -- /profiles !-- activeProfiles | List of profiles that are active for all builds. | activeProfiles activeProfilealwaysActiveProfile/activeProfile activeProfileanotherAlwaysActiveProfile/activeProfile /activeProfiles --/settings docker cp apache-maven-3.9.9 jenkins:/opt/maven 全局工具配置 6. 部署流水线新建任务 配置流水线 注意：如果是拉取Github代码需要配置SSH方式，pw方式Github不支持 # 先删除之前的容器和镜像文件if [ $(docker ps -a | grep zuqiushequguanlixitong) ]; thendocker stop zuqiushequguanlixitongdocker rm zuqiushequguanlixitongfiif [ $(docker images -q zuqiushequguanlixitong) ]; thendocker rmi zuqiushequguanlixitongfi# 重新生成cd /var/jenkins_home/workspace/zuqiushequguanlixitongdocker build -t lianyutian/zuqiushequguanlixitong .docker run -itd -p 8091:8091 --name zuqiushequguanlixitong lianyutian/zuqiushequguanlixitong 执行部署","tags":["CICD"]},{"title":"ArrayBlockingQueue详解","path":"/2024/05/31/ArrayBlockingQueue详解/","content":"使用场景有这么一个场景，两个线程需要交换数据。一个线程生产数据，一个线程消费数据。最简单的方法就是使用队列。 /** * @author lm * @since 2024-06-03 16:34:54 * @version 1.0 */public class QueueTest public static void main(String[] args) throws IOException ArrayDequeString arrayDeque = new ArrayDeque(10); Product product = new Product(arrayDeque); Consumer consumer = new Consumer(arrayDeque); new Thread(product).start(); new Thread(consumer).start(); static class Product implements Runnable private final ArrayDequeString queue; public Product(ArrayDequeString arrayQueue) this.queue = arrayQueue; @Override public void run() while (true) queue.offer(测试消息); System.out.println(queue.size()); static class Consumer implements Runnable private ArrayDequeString queue; public Consumer(ArrayDequeString arrayQueue) this.queue = arrayQueue; @Override public void run() try while (true) Thread.sleep(1000); System.out.println(queue.poll()); catch (InterruptedException e) e.printStackTrace(); 在上面代码中，我们一个线程生产消息，一个线程消费消息。但是这里存在2个问题： 我们控制不了队列的存储数据的上限，当队列中数据超出初始化大小时，队列会自动扩容； 当队列数据为空时，消费线程还是会不断尝试拉取数据使得CPU空转； 所以我们需要使用ArrayBlockingQueue来进行改造。 /** * @author lm * @since 2024-06-03 16:34:54 * @version 1.0 */public class ArrayBlockTest public static void main(String[] args) throws IOException ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue(10); Product product = new Product(arrayBlockingQueue); Consumer consumer = new Consumer(arrayBlockingQueue); new Thread(product).start(); new Thread(consumer).start(); static class Product implements Runnable private ArrayBlockingQueue queue; public Product(ArrayBlockingQueue arrayBlockingQueue) this.queue = arrayBlockingQueue; @Override public void run() try while (true) queue.put(测试消息); System.out.println(queue.size()); catch (InterruptedException e) e.printStackTrace(); static class Consumer implements Runnable private ArrayBlockingQueue queue; public Consumer(ArrayBlockingQueue arrayBlockingQueue) this.queue = arrayBlockingQueue; @Override public void run() try while (true) Thread.sleep(1000); System.out.println(queue.take()); catch (InterruptedException e) e.printStackTrace(); ArrayBlockingQueue是一个阻塞队列。我们来解析下阻塞队列这四个字，队列是一个先进先出的数据机构，阻塞是当队列为空时获取队列数据操作会被阻塞，当队列满时入队列操作会被阻塞。通过阻塞，我们可以解决上述两个问题。通过初始化容量控制队列大小，通过阻塞防止CPU空转。 原理解析入队列流程/** * Inserts the specified element at the tail of this queue, waiting * for space to become available if the queue is full. * * @throws InterruptedException @inheritDoc * @throws NullPointerException @inheritDoc */public void put(E e) throws InterruptedException // 判断数据是否为空,为空抛出NullPointerException Objects.requireNonNull(e); final ReentrantLock lock = this.lock; // 这里使用ReentrantLock锁住,因为可能存在多个线程往该队列中存放数据 // 锁住为了并发安全且可响应中断操作 lock.lockInterruptibly(); try // 判断当前队列中的数据是否已满 while (count == items.length) // 满了就将notFull这个Condition条件队列阻塞住 notFull.await(); // 将数据存入队列 enqueue(e); finally lock.unlock(); 我们模拟生产线程第一次往队列插入数据, 所以接下来看enqueue(e)方法 /** * Inserts element at current put position, advances, and signals. * Call only when holding lock. */private void enqueue(E e) // assert lock.isHeldByCurrentThread(); // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; // ArrayBlockingQueue底层数据结构是数组,这里获取到存放数据的数组 final Object[] items = this.items; // 将数据存入数组,putIndex是存入组数队列中的数据索引 items[putIndex] = e; // 注意这里是个循环队列，计算下标 if (++putIndex == items.length) putIndex = 0; // 队列存储数据量+1 count++; // 唤醒notEmpty这个Condition条件队列，调用take()方法时没有数据会调用notEmpty.await(); notEmpty.signal(); 接下来看下队列如果满了，流程进入notFull.await();方法： /** * Implements interruptible condition wait. * ol * liIf current thread is interrupted, throw InterruptedException. * liSave lock state returned by @link #getState. * liInvoke @link #release with saved state as argument, * throwing IllegalMonitorStateException if it fails. * liBlock until signalled or interrupted. * liReacquire by invoking specialized version of * @link #acquire with saved state as argument. * liIf interrupted while blocked in step 4, throw InterruptedException. * /ol */public final void await() throws InterruptedException if (Thread.interrupted()) throw new InterruptedException(); // 创建一个ConditionNode ConditionNode node = new ConditionNode(); int savedState = enableWait(node); LockSupport.setCurrentBlocker(this); // for back-compatibility boolean interrupted = false, cancelled = false, rejected = false; while (!canReacquire(node)) if (interrupted |= Thread.interrupted()) if (cancelled = (node.getAndUnsetStatus(COND) COND) != 0) break; // else interrupted after signal else if ((node.status COND) != 0) try if (rejected) node.block(); else ForkJoinPool.managedBlock(node); catch (RejectedExecutionException ex) rejected = true; catch (InterruptedException ie) interrupted = true; else Thread.onSpinWait(); // awoke while enqueuing LockSupport.setCurrentBlocker(null); node.clearStatus(); acquire(node, savedState, false, false, false, 0L); if (interrupted) if (cancelled) unlinkCancelledWaiters(node); throw new InterruptedException(); Thread.currentThread().interrupt(); 来看下await()方法做了些什么，首先判断线程是否被中断了如果被中断直接抛出中断异常。 接下来创建了一个ConditionNode，看下ConditionNode结构： // Concrete classes tagged by typestatic final class ExclusiveNode extends Node static final class SharedNode extends Node static final class ConditionNode extends Node implements ForkJoinPool.ManagedBlocker ConditionNode nextWaiter; // link to next waiting node /** * Allows Conditions to be used in ForkJoinPools without * risking fixed pool exhaustion. This is usable only for * untimed Condition waits, not timed versions. */ public final boolean isReleasable() return status = 1 || Thread.currentThread().isInterrupted(); public final boolean block() while (!isReleasable()) LockSupport.park(); return true; 和ExclusiveNode、SharedNode一样还是继承Node类，不过额外继承了ForkJoinPool.ManagedBlocker且提供了isReleasable()和block()两个方法。 接下来看下int savedState = enableWait(node); /** * Adds node to condition list and releases lock. * * @param node the node * @return savedState to reacquire after wait */private int enableWait(ConditionNode node) // 判断获取到锁的是否是当前线程 if (isHeldExclusively()) // 将当前线程赋值给node的waiter node.waiter = Thread.currentThread(); // 设置节点的status状态为3 // 10 (COND, 二进制) | 01 (WAITING, 二进制) // 11 (结果, 即 3 in decimal) node.setStatusRelaxed(COND | WAITING); // 设置尾节点 ConditionNode last = lastWaiter; if (last == null) firstWaiter = node; else last.nextWaiter = node; lastWaiter = node; // 获取当前state值 int savedState = getState(); // 尝试下释放锁 if (release(savedState)) return savedState; // 节点状态设置为取消 node.status = CANCELLED; // lock not held or inconsistent throw new IllegalMonitorStateException(); 根据方法描述可以直到这个方法主要作用就是将当前线程封装入ConditionNode并放入condition条件队列中，然后释放锁。 主要看下release(savedState)这个方法： /** * Releases in exclusive mode. Implemented by unblocking one or * more threads if @link #tryRelease returns true. * This method can be used to implement method @link Lock#unlock. * * @param arg the release argument. This value is conveyed to * @link #tryRelease but is otherwise uninterpreted and * can represent anything you like. * @return the value returned from @link #tryRelease */public final boolean release(int arg) // 尝试释放锁 if (tryRelease(arg)) // 如果释放锁成功，回去唤醒条件队列中的等待的节点 signalNext(head); return true; return false;private static void signalNext(Node h) Node s; if (h != null (s = h.next) != null s.status != 0) s.getAndUnsetStatus(WAITING); LockSupport.unpark(s.waiter); 接下来回到await()方法中： /** * Implements interruptible condition wait. * ol * liIf current thread is interrupted, throw InterruptedException. * liSave lock state returned by @link #getState. * liInvoke @link #release with saved state as argument, * throwing IllegalMonitorStateException if it fails. * liBlock until signalled or interrupted. * liReacquire by invoking specialized version of * @link #acquire with saved state as argument. * liIf interrupted while blocked in step 4, throw InterruptedException. * /ol */public final void await() throws InterruptedException if (Thread.interrupted()) throw new InterruptedException(); // 创建一个ConditionNode ConditionNode node = new ConditionNode(); // 将node节点加入条件队列并释放锁 int savedState = enableWait(node); LockSupport.setCurrentBlocker(this); // for back-compatibility boolean interrupted = false, cancelled = false, rejected = false; while (!canReacquire(node)) if (interrupted |= Thread.interrupted()) if (cancelled = (node.getAndUnsetStatus(COND) COND) != 0) break; // else interrupted after signal else if ((node.status COND) != 0) try if (rejected) node.block(); else ForkJoinPool.managedBlock(node); catch (RejectedExecutionException ex) rejected = true; catch (InterruptedException ie) interrupted = true; else Thread.onSpinWait(); // awoke while enqueuing LockSupport.setCurrentBlocker(null); node.clearStatus(); acquire(node, savedState, false, false, false, 0L); if (interrupted) if (cancelled) unlinkCancelledWaiters(node); throw new InterruptedException(); Thread.currentThread().interrupt(); 我们来看下canReacquire方法作用： /** * Returns true if a node that was initially placed on a condition * queue is now ready to reacquire on sync queue. * @param node the node * @return true if is reacquiring */private boolean canReacquire(ConditionNode node) // check links, not status to avoid enqueue race return node != null node.prev != null isEnqueued(node);/** Returns true if node is found in traversal from tail */final boolean isEnqueued(Node node) for (Node t = tail; t != null; t = t.prev) if (t == node) return true; return false; 这里的代码要结合唤醒的代码来看： /** * Moves the longest-waiting thread, if one exists, from the * wait queue for this condition to the wait queue for the * owning lock. * * @throws IllegalMonitorStateException if @link #isHeldExclusively * returns @code false */public final void signal() ConditionNode first = firstWaiter; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); if (first != null) // 移动条件队列中等待节点到同步队列中 doSignal(first, false);/** * Removes and transfers one or all waiters to sync queue. */private void doSignal(ConditionNode first, boolean all) while (first != null) ConditionNode next = first.nextWaiter; if ((firstWaiter = next) == null) lastWaiter = null; if ((first.getAndUnsetStatus(COND) COND) != 0) enqueue(first); if (!all) break; first = next; /** * Enqueues the node unless null. (Currently used only for * ConditionNodes; other cases are interleaved with acquires.) */final void enqueue(Node node) if (node != null) for (;;) // 同步队列中尾节点赋值给t Node t = tail; node.setPrevRelaxed(t); // avoid unnecessary fence if (t == null) // initialize // 初始化同步队列 tryInitializeHead(); // 将同步队列中尾节点tail设置为条件队列中的节点 else if (casTail(t, node)) // 将原尾节点next指向当前节点 t.next = node; if (t.status 0) // wake up to clean link LockSupport.unpark(node.waiter); break; 结合来看，canReacquire()方法就是判断当前节点是否在同步队列中。 接着往下看，如果节点不在同步队列中则进入while代码块： public final void await() throws InterruptedException if (Thread.interrupted()) throw new InterruptedException(); // 创建一个ConditionNode ConditionNode node = new ConditionNode(); // 将node节点加入条件队列并释放锁 int savedState = enableWait(node); LockSupport.setCurrentBlocker(this); // for back-compatibility boolean interrupted = false, cancelled = false, rejected = false; while (!canReacquire(node)) // 判断线程是否中断 if (interrupted |= Thread.interrupted()) if (cancelled = (node.getAndUnsetStatus(COND) COND) != 0) break; // else interrupted after signal // 判断节点状态是否是wait状态 else if ((node.status COND) != 0) try if (rejected) node.block(); else // 阻塞当前线程 ForkJoinPool.managedBlock(node); catch (RejectedExecutionException ex) rejected = true; catch (InterruptedException ie) interrupted = true; else // 如果节点状态既不是COND，也不是在入队时被唤醒的，则调用Thread.onSpinWait()进行自旋等待。 Thread.onSpinWait(); // awoke while enqueuing // 这里的代码是在同步队列中被唤醒的线程会继续执行 LockSupport.setCurrentBlocker(null); node.clearStatus(); // 尝试获取锁 acquire(node, savedState, false, false, false, 0L); if (interrupted) if (cancelled) unlinkCancelledWaiters(node); throw new InterruptedException(); Thread.currentThread().interrupt(); 总结下整个入队列的流程： 获取ReentrantLock锁 判断队列容量是否已满 容量不满则将对象放入队列，队列容量count加1 唤醒notEmpty条件队列上等待的节点线程 如果队列容量满了 调用notEmpty条件队列的await方法 将当前线程封装成ConditionNode 判断节点是否在同步队里中（调用notFull.signal()方法会将条件队列中的节点移动到同步队列中） 不在同步队列中，阻塞当前线程 出队列流程类似就不再详细看了。 入队出队API入队APIput、offer、add /** * Inserts the specified element at the tail of this queue, waiting * for space to become available if the queue is full. * * @throws InterruptedException @inheritDoc * @throws NullPointerException @inheritDoc */public void put(E e) throws InterruptedException Objects.requireNonNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try while (count == items.length) notFull.await(); enqueue(e); finally lock.unlock(); /** * Inserts the specified element at the tail of this queue if it is * possible to do so immediately without exceeding the queues capacity, * returning @code true upon success and @code false if this queue * is full. This method is generally preferable to method @link #add, * which can fail to insert an element only by throwing an exception. * * @throws NullPointerException if the specified element is null */public boolean offer(E e) Objects.requireNonNull(e); final ReentrantLock lock = this.lock; lock.lock(); try if (count == items.length) return false; else enqueue(e); return true; finally lock.unlock(); /** * Inserts the specified element into this queue if it is possible to do so * immediately without violating capacity restrictions, returning * @code true upon success and throwing an @code IllegalStateException * if no space is currently available. * * pThis implementation returns @code true if @code offer succeeds, * else throws an @code IllegalStateException. * * @param e the element to add * @return @code true (as specified by @link Collection#add) * @throws IllegalStateException if the element cannot be added at this * time due to capacity restrictions * @throws ClassCastException if the class of the specified element * prevents it from being added to this queue * @throws NullPointerException if the specified element is null and * this queue does not permit null elements * @throws IllegalArgumentException if some property of this element * prevents it from being added to this queue */public boolean add(E e) if (offer(e)) return true; else throw new IllegalStateException(Queue full); 三者区别： put在队列满时会阻塞 offer在队列满时会直接返回false add还是调用offer，不过队列满时会抛出异常 出队APItake、poll、peek public E take() throws InterruptedException final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try while (count == 0) notEmpty.await(); return dequeue(); finally lock.unlock(); public E poll() final ReentrantLock lock = this.lock; lock.lock(); try return (count == 0) ? null : dequeue(); finally lock.unlock(); public E peek() final ReentrantLock lock = this.lock; lock.lock(); try return itemAt(takeIndex); // null when queue is empty finally lock.unlock(); 三者区别： take在队列空时会阻塞 poll在队列空时会直接返回null peek直接返回takeIndex下标对应的数据","tags":["ArrayBlockingQueue"],"categories":["队列"]},{"title":"ReentrantLock详解","path":"/2024/05/29/ReentrantLock详解/","content":"1. 锁示例 基于JDK17 今天来看下ReentrantLock锁实现的原理，不多BB先看一段代码。 /** * ReentrantLockTest * * @author lm * @since 2024-05-29 16:45:43 * @version 1.0 */public class ReentrantLockTest public static void main(String[] args) TicketCenter ticketCenter = new TicketCenter(); new Thread(new Consumer(ticketCenter), 1号售票窗口).start(); new Thread(new Consumer(ticketCenter), 2号售票窗口).start(); new Thread(new Consumer(ticketCenter), 3号售票窗口).start(); /** * 售票中心 */class TicketCenter // 根据需求：定义50张车票 private int capacity = 50; // 根据需求：sale 方法创建 public void sale() try //没有票的情况下，停止售票 while (capacity == 0) System.out.println(警告：线程( + Thread.currentThread().getName() + )准备售票，但当前没有剩余车票); Thread.sleep(10000000000L); //如果有票，则售卖 -1 capacity--; System.out.println(线程( + Thread.currentThread().getName() + )售出一张票。 + 当前剩余票数 + capacity + 个); catch (InterruptedException e) throw new RuntimeException(e); /** * 售票窗口 */class Consumer implements Runnable private TicketCenter TicketCenter; public Consumer(TicketCenter TicketCenter) this.TicketCenter = TicketCenter; public void run() while (true) //调用sale 方法 TicketCenter.sale(); 这是一段很简单的代码，定义个售票中心。售票中心里定义了共享变量capacity车票数。再定义一个售票窗口类，负责车票的售卖。很明显此时会有多线程并发问题，多个窗口同时卖票时sale()方法未加锁，多个线程会同时操作capacity变量。此时会导致超卖的现象。所以我们要对sale方法加把锁。 class TicketCenter private ReentrantLock lock = new ReentrantLock(); // 根据需求：sale 方法创建 public void sale() try lock.lock(); // 售票逻辑 ... finally lock.unlock(); 加锁后同一时间只能有一个线程来访问下面的售票逻辑，不会导致超卖现象。接下来就让我们深入lock()方法，探究下lock()的加锁逻辑。 2. 加锁流程/** * Acquires the lock. * * pAcquires the lock if it is not held by another thread and returns * immediately, setting the lock hold count to one. * * pIf the current thread already holds the lock then the hold * count is incremented by one and the method returns immediately. * * pIf the lock is held by another thread then the * current thread becomes disabled for thread scheduling * purposes and lies dormant until the lock has been acquired, * at which time the lock hold count is set to one. */public void lock() sync.lock(); 来看下这个方法的定义： 申请一把锁 如果锁没有被其他线程持有，那么立马返回并锁定也就是设置state1 如果锁已经被当前线程持有了，那么state+1然后立马返回 如果锁被其他线程持有，那么当前线程就不可用（阻塞）直到申请到锁。同时也会设置state1 再来看下实现： final void lock() if (!initialTryLock()) acquire(1); initialTryLock()该方法有两个实现，公平锁和非公平锁： 我们先看非公平锁： final boolean initialTryLock() Thread current = Thread.currentThread(); if (compareAndSetState(0, 1)) // first attempt is unguarded setExclusiveOwnerThread(current); return true; else if (getExclusiveOwnerThread() == current) int c = getState() + 1; if (c 0) // overflow throw new Error(Maximum lock count exceeded); setState(c); return true; else return false; 首先获取当前线程 直接尝试使用CAS去加锁（这也是为什么称为非公平的原因） 加锁成功，设置持有这把锁的线程为当前线程 返回true加锁成功 else if (getExclusiveOwnerThread() == current)这一行判断就是重入逻辑了，如果持有这把锁的就是当前线程那么将state值+1然后返回true加锁成功。 剩余就是加锁失败了。 好，现在根据返回值再返回看看： final void lock() if (!initialTryLock()) acquire(1); 加锁成功返回true，没啥可说的。 加锁失败时，就去执行acquire(1)方法。 接下来就看这个方法acquire(1)： public final void acquire(int arg) if (!tryAcquire(arg)) acquire(null, arg, false, false, false, 0L); 进入方法先看tryAcquire(arg)，这个是AQS提供的一个模板方法，主要还是看具体实现。还是以非公平为例： protected final boolean tryAcquire(int acquires) if (getState() == 0 compareAndSetState(0, acquires)) setExclusiveOwnerThread(Thread.currentThread()); return true; return false; 这段代码有上面基础很容易就看懂了，首先获取state值。state0就说明当前锁没有被持有，然后尝试加锁（因为是多线程环境可能上一秒你的getState() 0 下一秒state的值就被改了，所以需要使用CAS尝试该值加锁）。成功就设置持有锁的是当前线程然后返回加锁成功，失败返回false。 回到acquire(arg)方法，先看下方法的定义： /** * 主要获取锁的方法，被所有导出的获取方法调用。 * * @param node 锁节点 * @param arg 加锁值 * @param shared 如果为true，则为共享模式，否则为独占模式 * @param interruptible 是否需要中断 * @param timed 如果为true，则使用定时等待 * @param time 如果定时，表示超时时间 * @return 如果加锁成功返回正数，如果超时返回0，如果中断返回负数 */final int acquire(Node node, int arg, boolean shared, boolean interruptible, boolean timed, long time) 完整的方法： /** * Main acquire method, invoked by all exported acquire methods. * * @param node null unless a reacquiring Condition * @param arg the acquire argument * @param shared true if shared mode else exclusive * @param interruptible if abort and return negative on interrupt * @param timed if true use timed waits * @param time if timed, the System.nanoTime value to timeout * @return positive if acquired, 0 if timed out, negative if interrupted */final int acquire(Node node, int arg, boolean shared, boolean interruptible, boolean timed, long time) Thread current = Thread.currentThread(); byte spins = 0, postSpins = 0; // retries upon unpark of first thread boolean interrupted = false, first = false; Node pred = null; // predecessor of node when enqueued /* * Repeatedly: * Check if node now first * if so, ensure head stable, else ensure valid predecessor * if node is first or not yet enqueued, try acquiring * else if node not yet created, create it * else if not yet enqueued, try once to enqueue * else if woken from park, retry (up to postSpins times) * else if WAITING status not set, set and retry * else park and clear WAITING status, and check cancellation */ for (;;) if (!first (pred = (node == null) ? null : node.prev) != null !(first = (head == pred))) if (pred.status 0) cleanQueue(); // predecessor cancelled continue; else if (pred.prev == null) Thread.onSpinWait(); // ensure serialization continue; if (first || pred == null) boolean acquired; try if (shared) acquired = (tryAcquireShared(arg) = 0); else acquired = tryAcquire(arg); catch (Throwable ex) cancelAcquire(node, interrupted, false); throw ex; if (acquired) if (first) node.prev = null; head = node; pred.next = null; node.waiter = null; if (shared) signalNextIfShared(node); if (interrupted) current.interrupt(); return 1; if (node == null) // allocate; retry before enqueue if (shared) node = new SharedNode(); else node = new ExclusiveNode(); else if (pred == null) // try to enqueue node.waiter = current; Node t = tail; node.setPrevRelaxed(t); // avoid unnecessary fence if (t == null) tryInitializeHead(); else if (!casTail(t, node)) node.setPrevRelaxed(null); // back out else t.next = node; else if (first spins != 0) --spins; // reduce unfairness on rewaits Thread.onSpinWait(); else if (node.status == 0) node.status = WAITING; // enable signal and recheck else long nanos; spins = postSpins = (byte)((postSpins 1) | 1); if (!timed) LockSupport.park(this); else if ((nanos = time - System.nanoTime()) 0L) LockSupport.parkNanos(this, nanos); else break; node.clearStatus(); if ((interrupted |= Thread.interrupted()) interruptible) break; return cancelAcquire(node, interrupted, interruptible); 我们假设锁已经被第一个线程占有了，且锁还未释放。以第二个线程进入该方法的视角走下这个流程： Thread current = Thread.currentThread();byte spins = 0, postSpins = 0; // retries upon unpark of first threadboolean interrupted = false, first = false;Node pred = null; // predecessor of node when enqueued 首先获取到当前线程并设置给current变量，先不管spins、postSpins的含义。first代表是否是第一个节点，pred就是前置节点。 进入for循环，开始第一次循环： if (!first (pred = (node == null) ? null : node.prev) != null !(first = (head == pred))) pred = null不满足!=null的条件，所以进入第二个条件： if (first || pred == null) 经过第一个if条件pred还是被设置为了null，所以条件满足进入if代码： //node,arg,shared,interruptible,timed,timeacquire(null, arg, false, false, false, 0L); if (first || pred == null) boolean acquired; try if (shared) acquired = (tryAcquireShared(arg) = 0); else acquired = tryAcquire(arg); catch (Throwable ex) cancelAcquire(node, interrupted, false); throw ex; if (acquired) if (first) node.prev = null; head = node; pred.next = null; node.waiter = null; if (shared) signalNextIfShared(node); if (interrupted) current.interrupt(); return 1; shared为false，所以走tryAcquire(arg)，这个方法上面已经介绍了。主要功能就是去判断是锁是否被释放，如果锁被释放了就尝试去加下锁。我们假设的是锁还未被释放，所以该方法返回false。那么接下来的if (acquired)下的逻辑就不走了。接着往下看： if (node == null) if (shared) node = new SharedNode(); else node = new ExclusiveNode(); node传递过来时是为null的，所以进入if逻辑。node被包装成一个独占的ExclusiveNode。后续都是else if或else都不走，那么第一次循环结束。 开始第二次for循环： if (!first (pred = (node == null) ? null : node.prev) != null !(first = (head == pred))) 还是这个判断，不过这次node不为null了。node = new ExclusiveNode()，所以pred = node.prev，也就是null，所以又在这中断了。 if (first || pred == null) pred == null条件符合，还是进入该if逻辑，又去尝试获取锁（我们的前提锁没释放）所以加锁失败继续往下走。 if (node == null) 第二次循环，这个条件就不成立了。node = new ExclusiveNode()走else if分支： else if (pred == null) pred此时还是为null的，这个分支满足，走该逻辑： else if (pred == null) // try to enqueue node.waiter = current; Node t = tail; // 将尾节点设置为node的前置节点 node.setPrevRelaxed(t); // avoid unnecessary fence if (t == null) tryInitializeHead(); else if (!casTail(t, node)) node.setPrevRelaxed(null); // back out else t.next = node; 将node.waiter设置为当前线程，将尾节点赋值给t，将尾节点设置为node的前置节点。此时tail节点还是null，所以走tryInitializeHead()尝试初始化头节点。看下这个方法： private void tryInitializeHead() Node h = new ExclusiveNode(); if (U.compareAndSetReference(this, HEAD, null, h)) tail = h; 赋值h为一个独占节点，将对象的HEAD字段的值从null更新为h，但只有当HEAD字段当前的值为null时才能成功更新(我们已第二个线程第一次进入这个方法为前提)。所以是更新成功的，并将尾节点也指向了h，此时HEAD tail h。接下来的分支就不走了。 开始第三次for循环： if (!first (pred = (node == null) ? null : node.prev) != null !(first = (head == pred))) node.prev还是null，不满足走下一个分支： if (first || pred == null) pred还是null，和第二次循环一致，申请锁失败继续走。node不为null，pred为null所以走这个分支： else if (pred == null) // try to enqueue node.waiter = current; Node t = tail; // 将尾节点设置为node的前置节点 node.setPrevRelaxed(t); // avoid unnecessary fence if (t == null) tryInitializeHead(); else if (!casTail(t, node)) node.setPrevRelaxed(null); // back out else t.next = node; 此时tail不为null了，tail h new ExclusiveNode()，所以 node.setPrevRelaxed(t)这个方法将 node.prev = tail = h，继续走 else if (!casTail(t, node)) private boolean casTail(Node c, Node v) return U.compareAndSetReference(this, TAIL, c, v); casTail(t, node)是一个原子操作，尝试将当前链表的尾节点“TAIL”更新为“node”，只有在“t”等于期望值时才会成功更新，并返回true；否则，返回false。 我们假设的是单线程环境，所以更新是一会成功的。所以此时TAIL node ，HEAD t 所以该判断会返回flase继续走else分支： else t.next = node; 走完该逻辑，此时链表为HEAD - node = TAIL。 开始第四次for循环： if (!first (pred = (node == null) ? null : node.prev) != null !(first = (head == pred))) 此时node ! null，node.prev HEAD，所以pred HEAD，!(first = (head == pred))此时head是等于pred的所以在此中断，first被赋值为true。继续往下走： if (first || pred == null) 此时firsttrue，pred ! null所以还是去尝试获取锁，和第三次循环一致，申请锁失败继续走。node不为null，pred不为null，spins 0所以走这个分支： else if (node.status == 0) node.status = WAITING; 将node的状态设置为等待标识。 开始第五次for循环： 简要说下过程，还是尝试去获取锁然后失败，最后走到最后的else分支。 else long nanos; spins = postSpins = (byte)((postSpins 1) | 1); if (!timed) LockSupport.park(this); else if ((nanos = time - System.nanoTime()) 0L) LockSupport.parkNanos(this, nanos); else break; node.clearStatus(); if ((interrupted |= Thread.interrupted()) interruptible) break; 关注这一行LockSupport.park(this);如果没设置时间那么就一直park下去，如果设置了时间就park定时的时间。什么时候唤醒park的线程，这个等我们去看unlock()的代码就会知道。 现在我们总结下整个加锁流程： 调用lock()方法尝试加锁； 加锁不成功调用acquire(1)； 调用tryAcquire(arg)再尝试获取锁； 获取锁失败调用acquire(null, arg, false, false, false, 0L); 进行5轮for循环； 第一轮for循环：将node赋值为一个独占的ExclusiveNode； 第二轮for循环：node.waiter设置为当前线程，赋值h为一个独占节点，将对象的HEAD字段的值从null更新为h，此时HEAD TAIL h； 第三轮for循环：走完循环，此时链表为HEAD - node = TAIL。 第四轮for循环：将node的状态设置为等待标识。 第五轮for循环：将当前线程park。 3. 多线程下加锁现在我们回过头来看下，如果多个线程去加锁会发生什么场景？跳过其他方法，主要看下acquire方法。我们假设锁还是未被释放，同时还有2个线程并行执行这个方法： 执行第一轮循环，两个线程都将node变量赋值为ExclusiveNode； 执行第二轮循环： // 我们假设两个线程执行时间是同步的else if (pred == null) // try to enqueue node.waiter = current; // 此时t = tail = null Node t = tail; // node.prev = t = null node.setPrevRelaxed(t); // avoid unnecessary fence if (t == null) tryInitializeHead(); else if (!casTail(t, node)) node.setPrevRelaxed(null); // back out else t.next = node; // 同时进入该方法private void tryInitializeHead() Node h = new ExclusiveNode(); // 这里使用cas,只有一个线程能执行成功。假设A线程执行成功，所以此时A线程中tail = h，B线程中tail = h // (tail是个volatile修饰的变量，B线程会放弃自己工作内存中的值，刷新为A线程修改后的值) // 因为HEAD是个共享变量，所以A、B两个线程中的HEAD = h if (U.compareAndSetReference(this, HEAD, null, h)) tail = h; 执行第三轮循环： // 还是同时进入该分支else if (pred == null) // try to enqueue node.waiter = current; // 此时A线程tA = tail = h，B线程tB = tail = h Node t = tail; // nodeA.prev = t = h // nodeB.prev = t = h node.setPrevRelaxed(t); // avoid unnecessary fence if (t == null) tryInitializeHead(); // 这里又是cas，只有一个线程能更新成功，我们还是假设A线程更新成功 // 此时变成了A线程：tail = nodeA，B线程中：tail = nodeA else if (!casTail(t, node)) // B线程因为更新失败，会进入该分支：nodeB.prev = t，更新为nodeB.prev = null node.setPrevRelaxed(null); // back out else // A线程进入这个分支，h.next = nodeA。链表为 h - nodeA t.next = node; 执行第四轮循环： // 还是A、B线程同时进入，A线程中nodeA.prev = h，B线程中nodeB.prev = null。// 所以predA = h，predB = null。// 所以firstA = true，firstB = false。if (!first (pred = (node == null) ? null : node.prev) != null !(first = (head == pred))) 此时B线程会进入该分支： // B线程进入该分支else if (pred == null) // try to enqueue node.waiter = current; // tB = tail = nodeA Node t = tail; // nodeB.prev = t = tail = nodeA node.setPrevRelaxed(t); // avoid unnecessary fence if (t == null) tryInitializeHead(); // 这里又是cas，只有一个线程能更新成功，这次是B线程更新成功 // tail = nodeB else if (!casTail(t, node)) node.setPrevRelaxed(null); // back out else // B线程进入这个分支，nodeA.next = nodeB。此时链表为 h - nodeA - nodeB t.next = node; 我们可以看到在执行到第四轮循环的时候就已经形成了一个链表后续唤醒的时候也是根据这个链表的顺序来进行唤醒线程操作的 此时A线程会进入该分支将node的状态设置为WAITING（1） else if (node.status == 0) node.status = WAITING; A、B线程进入第五轮循环，A线程在该轮循环中会进入park状态，B线程会重复A线程中第四轮循环将自身node状态设置为WAITING并在下轮循环中也进入park状态。 4. 公平锁加锁public final boolean hasQueuedThreads() for (Node p = tail, h = head; p != h p != null; p = p.prev) if (p.status = 0) return true; return false; 主要就是多了这么一个判断，通过从后向前遍历判断链表中是否有正在等待的线程节点。如果有就不去CAS抢锁，没有等待节点就尝试去获取锁。 5. 解锁流程/** * Attempts to release this lock. * * pIf the current thread is the holder of this lock then the hold * count is decremented. If the hold count is now zero then the lock * is released. If the current thread is not the holder of this * lock then @link IllegalMonitorStateException is thrown. * * @throws IllegalMonitorStateException if the current thread does not * hold this lock */public void unlock() sync.release(1); 释放一把锁 如果是持有锁的当前线程那么将state - 1，当state值为0的时候释放锁。 如果不是持有锁的线程进入该方法那么抛出异常 public final boolean release(int arg) if (tryRelease(arg)) signalNext(head); return true; return false; protected final boolean tryRelease(int releases) // 获取state当前值 - 1 int c = getState() - releases; // 判断持有锁的线程是否是当前线程 if (getExclusiveOwnerThread() != Thread.currentThread()) throw new IllegalMonitorStateException(); boolean free = (c == 0); if (free) // 当state = 0，释放锁并将ExclusiveOwnerThread设为null setExclusiveOwnerThread(null); // 将state设为0 setState(c); return free; private static void signalNext(Node h) Node s; // 获取到node节点 if (h != null (s = h.next) != null s.status != 0) // 标记为status s.getAndUnsetStatus(WAITING); // 唤醒node节点上等待的线程 LockSupport.unpark(s.waiter); 唤醒后的线程会从lock中LockSupport.park(this)处开始执行，再次开始for循环 else long nanos; spins = postSpins = (byte)((postSpins 1) | 1); if (!timed) LockSupport.park(this); else if ((nanos = time - System.nanoTime()) 0L) LockSupport.parkNanos(this, nanos); else break; // 将status状态置为0 node.clearStatus(); if ((interrupted |= Thread.interrupted()) interruptible) break; // first是为true的if (first || pred == null) boolean acquired; try if (shared) acquired = (tryAcquireShared(arg) = 0); else // 尝试获取锁 acquired = tryAcquire(arg); catch (Throwable ex) cancelAcquire(node, interrupted, false); throw ex; // 加锁成功 if (acquired) if (first) // 断开nodeA指向head的指针(方便GC) node.prev = null; // head = nodeA head = node; // 断开head指向nodeA的指针(方便GC) pred.next = null; node.waiter = null; if (shared) signalNextIfShared(node); if (interrupted) current.interrupt(); return 1; ReentrantLock的加解锁流程到这就说的差不多了，ReentrantLock使用的是AQS中的独占模型。共享模型可以看下CountDownLatch。","tags":["ReentrantLock"],"categories":["锁"]},{"title":"硅谷甄选","path":"/2024/01/04/2024-01-04-硅谷甄选/","content":"1. 项目初始化1.1 环境准备 node v16.19.1 pnpm 8.12.1 npm i -g pnpm 1.2 初始化项目 pnpm create vite 选择vue、TypeScript 进入项目 // 安装依赖pnpm i// 安装完依赖运行程序pnpm run dev 2. 项目配置2.1 eslint配置 作用 eslint中文官网:http://eslint.cn/ ESLint最初是由Nicholas C. Zakas 于2013年6月创建的开源项目。它的目标是提供一个插件化的javascript代码检测工具 步骤 首先安装eslint pnpm i eslint -D 生成配置文件:.eslint.cjs npx eslint --init .eslint.cjs配置文件解析 module.exports = //运行环境 env: browser: true,//浏览器端 es2021: true,//es2021 , //规则继承 extends: [ //全部规则默认是关闭的,这个配置项开启推荐规则,推荐规则参照文档 //比如:函数不能重名、对象不能出现重复key eslint:recommended, //vue3语法规则 plugin:vue/vue3-essential, //ts语法规则 plugin:@typescript-eslint/recommended ], //要为特定类型的文件指定处理器 overrides: [ ], //指定解析器:解析器 //Esprima 默认解析器 //Babel-ESLint babel解析器 //@typescript-eslint/parser ts解析器 parser: @typescript-eslint/parser, //指定解析器选项 parserOptions: ecmaVersion: latest,//校验ECMA最新版本 sourceType: module//设置为script（默认），或者module代码在ECMAScript模块中 , //ESLint支持使用第三方插件。在使用插件之前，您必须使用npm安装它 //该eslint-plugin-前缀可以从插件名称被省略 plugins: [ vue, @typescript-eslint ], //eslint规则 rules: 安装vue3环境代码校验插件 插件作用 # 让所有与prettier规则存在冲突的Eslint rules失效，并使用prettier进行代码检查eslint-config-prettier,eslint-plugin-import,eslint-plugin-node,# 运行更漂亮的Eslint，使prettier规则优先级更高，Eslint优先级低eslint-plugin-prettier,# vue.js的Eslint插件（查找vue语法错误，发现错误指令，查找违规风格指南eslint-plugin-vue,# 该解析器允许使用Eslint校验所有babel code@babel/eslint-parser, 安装指令 pnpm install -D eslint-plugin-import eslint-plugin-vue eslint-plugin-node eslint-plugin-prettier eslint-config-prettier eslint-plugin-node @babel/eslint-parser 修改.eslintrc.cjs配置文件 // @see https://eslint.bootcss.com/docs/rules/module.exports = env: browser: true, es2021: true, node: true, jest: true, , /* 指定如何解析语法 */ parser: vue-eslint-parser, /** 优先级低于 parse 的语法解析配置 */ parserOptions: ecmaVersion: latest, sourceType: module, parser: @typescript-eslint/parser, jsxPragma: React, ecmaFeatures: jsx: true, , , /* 继承已有的规则 */ extends: [ eslint:recommended, plugin:vue/vue3-essential, plugin:@typescript-eslint/recommended, plugin:prettier/recommended, ], plugins: [vue, @typescript-eslint], /* * off 或 0 == 关闭规则 * warn 或 1 == 打开的规则作为警告（不影响代码执行） * error 或 2 == 规则作为一个错误（代码不能执行，界面报错） */ rules: // eslint（https://eslint.bootcss.com/docs/rules/） no-var: error, // 要求使用 let 或 const 而不是 var no-multiple-empty-lines: [warn, max: 1 ], // 不允许多个空行 no-console: process.env.NODE_ENV === production ? error : off, no-debugger: process.env.NODE_ENV === production ? error : off, no-unexpected-multiline: error, // 禁止空余的多行 no-useless-escape: off, // 禁止不必要的转义字符 // typeScript (https://typescript-eslint.io/rules) @typescript-eslint/no-unused-vars: error, // 禁止定义未使用的变量 @typescript-eslint/prefer-ts-expect-error: error, // 禁止使用 @ts-ignore @typescript-eslint/no-explicit-any: off, // 禁止使用 any 类型 @typescript-eslint/no-non-null-assertion: off, @typescript-eslint/no-namespace: off, // 禁止使用自定义 TypeScript 模块和命名空间。 @typescript-eslint/semi: off, // eslint-plugin-vue (https://eslint.vuejs.org/rules/) vue/multi-word-component-names: off, // 要求组件名称始终为 “-” 链接的单词 vue/script-setup-uses-vars: error, // 防止script setup使用的变量template被标记为未使用 vue/no-mutating-props: off, // 不允许组件 prop的改变 vue/attribute-hyphenation: off, // 对模板中的自定义组件强制执行属性命名样式 , 配置忽略文件 新建.eslintignore忽略文件添加忽略 distnode_modules 修改运行脚本 scripts: // 执行`pnpm run dev`直接打开浏览器 dev: vite --open, ... // eslint检查src目录下源码 lint: eslint src, // eslint修复src目录下源码 fix: eslint src --fix 2.2 prettier配置 作用 有了eslint，为什么还要有prettier？eslint针对的是javascript，他是一个检测工具，包含js语法以及少部分格式问题，在eslint看来，语法对了就能保证代码正常运行，格式问题属于其次； 而prettier属于格式化工具，它看不惯格式不统一，所以它就把eslint没干好的事接着干，另外，prettier支持包含js在内的多种语言。 总结起来，eslint和prettier这俩兄弟一个保证js代码质量，一个保证代码美观。 安装依赖 pnpm install -D eslint-plugin-prettier prettier eslint-config-prettier 添加规则 新建.prettierrc.json文件添加规则 singleQuote: true, semi: false, bracketSpacing: true, htmlWhitespaceSensitivity: ignore, endOfLine: auto, trailingComma: all, tabWidth: 2 添加忽略 新建.prettierignore文件添加忽略文件 /dist/*/html/*.local/node_modules/****/*.svg**/*.sh/public/* 修复代码 通过pnpm run lint去检测语法，如果出现不规范格式,通过pnpm run fix修改 2.3 stylelint配置 作用 stylelint为css的lint工具。可格式化css代码，检查css语法错误与不合理的写法，指定css书写顺序等。 安装依赖 本项目中使用scss作为预处理器，安装以下依赖 pnpm add sass sass-loader stylelint postcss postcss-scss postcss-html stylelint-config-prettier stylelint-config-recess-order stylelint-config-recommended-scss stylelint-config-standard stylelint-config-standard-vue stylelint-scss stylelint-order stylelint-config-standard-scss -D 配置文件 新建.stylelintrc.cjs配置文件 官网:https://stylelint.bootcss.com/ // @see https://stylelint.bootcss.com/module.exports = extends: [ stylelint-config-standard, // 配置stylelint拓展插件 stylelint-config-html/vue, // 配置 vue 中 template 样式格式化 stylelint-config-standard-scss, // 配置stylelint scss插件 stylelint-config-recommended-vue/scss, // 配置 vue 中 scss 样式格式化 stylelint-config-recess-order, // 配置stylelint css属性书写顺序插件, stylelint-config-prettier, // 配置stylelint和prettier兼容 ], overrides: [ files: [**/*.(scss|css|vue|html)], customSyntax: postcss-scss, , files: [**/*.(html|vue)], customSyntax: postcss-html, , ], ignoreFiles: [ **/*.js, **/*.jsx, **/*.tsx, **/*.ts, **/*.json, **/*.md, **/*.yaml, ], /** * null = 关闭该规则 * always = 必须 */ rules: value-keyword-case: null, // 在 css 中使用 v-bind，不报错 no-descending-specificity: null, // 禁止在具有较高优先级的选择器后出现被其覆盖的较低优先级的选择器 function-url-quotes: always, // 要求或禁止 URL 的引号 always(必须加上引号)|never(没有引号) no-empty-source: null, // 关闭禁止空源码 selector-class-pattern: null, // 关闭强制选择器类名的格式 property-no-unknown: null, // 禁止未知的属性(true 为不允许) block-opening-brace-space-before: always, //大括号之前必须有一个空格或不能有空白符 value-no-vendor-prefix: null, // 关闭 属性值前缀 --webkit-box property-no-vendor-prefix: null, // 关闭 属性前缀 -webkit-mask selector-pseudo-class-no-unknown: [ // 不允许未知的选择器 true, ignorePseudoClasses: [global, v-deep, deep], // 忽略属性，修改element默认样式的时候能使用到 , ], , 配置忽略 新建.stylelintignore忽略文件 /node_modules/*/dist/*/html/*/public/* 新增运行脚本 scripts: lint:style: stylelint src/**/*.css,scss,vue --cache --fix 同一配置 最后配置统一的prettier来格式化我们的js和css，html代码 scripts: dev: vite --open, build: vue-tsc vite build, preview: vite preview, lint: eslint src, fix: eslint src --fix, format: prettier --write \\./**/*.html,vue,ts,js,json,md\\, lint:eslint: eslint src/**/*.ts,vue --cache --fix, lint:style: stylelint src/**/*.css,scss,vue --cache --fix, 当我们运行pnpm run format的时候，会把代码直接格式化 2.4 husky配置 作用 在上面我们已经集成好了我们代码校验工具，但是需要每次手动的去执行命令才会格式化我们的代码。如果有人没有格式化就提交了远程仓库中，那这个规范就没什么用。所以我们需要强制让开发人员按照代码规范来提交。 要做到这件事情，就需要利用husky在代码提交之前触发git hook(git在客户端的钩子)，然后执行pnpm run format来自动的格式化我们的代码。 安装 husky pnpm install -D husky 初始化 npx husky-init 会在根目录下生成个一个.husky目录，在这个目录下面会有一个pre-commit文件，这个文件里面的命令在我们执行commit的时候就会执行 在.husky/pre-commit文件添加如下命令 #!/usr/bin/env sh. $(dirname -- $0)/_/husky.shpnpm run format 当我们对代码进行commit操作的时候，就会执行命令，对代码进行格式化，然后再提交。 2.5 commitlint配置 作用 对于我们的commit信息，也是有统一规范的，不能随便写,要让每个人都按照统一的标准来执行，我们可以利用commitlint来实现。 安装依赖 pnpm add @commitlint/config-conventional @commitlint/cli -D 添加配置 新建commitlint.config.cjs(注意是cjs) module.exports = extends: [@commitlint/config-conventional], // 校验规则 rules: type-enum: [ 2, always, [ feat, fix, docs, style, refactor, perf, test, chore, revert, build, ], ], type-case: [0], type-empty: [0], scope-empty: [0], scope-case: [0], subject-full-stop: [0, never], subject-case: [0, never], header-max-length: [0, always, 72], , 在package.json中配置scripts命令 # 在scrips中添加下面的代码scripts: commitlint: commitlint --config commitlint.config.cjs -e -V , 配置结束，现在当我们填写commit信息的时候，前面就需要带着下面的subject feat,//新特性、新功能fix,//修改bugdocs,//文档修改style,//代码格式修改, 注意不是 css 修改refactor,//代码重构perf,//优化相关，比如提升性能、体验test,//测试用例修改chore,//其他修改, 比如改变构建流程、或者增加依赖库、工具等revert,//回滚到上一个版本build,//编译相关的修改，例如发布版本、对项目构建或者依赖的改动 配置husky npx husky add .husky/commit-msg 在生成的commit-msg文件中添加下面的命令 #!/usr/bin/env sh. $(dirname -- $0)/_/husky.shpnpm commitlint 当我们 commit 提交信息时，就不能再随意写了，必须是 git commit -m ‘fix: xxx’ 符合类型的才可以 需要注意的是类型的后面需要用英文的 :，并且冒号后面是需要空一格的，这个是不能省略的 2.6 强制使用pnpm包管理器工具 作用 团队开发项目的时候，需要统一包管理器工具,因为不同包管理器工具下载同一个依赖,可能版本不一样,导致项目出现bug问题,因此包管理器工具需要统一管理！！！ 创建配置 在根目录创建scritps/preinstall.js文件，添加下面的内容 if (!/pnpm/.test(process.env.npm_execpath || )) console.warn( `\\u001b[33mThis repository must using pnpm as the package manager ` + ` for scripts to work properly.\\u001b[39m `, ) process.exit(1) 配置命令 scripts: preinstall: node ./scripts/preinstall.js 当我们使用npm或者yarn来安装包的时候，就会报错了。原理就是在install的时候会触发preinstall（npm提供的生命周期钩子）这个文件里面的代码。 3. 项目集成3.1 集成element-plus 官网 官网地址:https://element-plus.gitee.io/zh-CN/ 安装依赖 pnpm install element-plus@2.3.4 @element-plus/icons-vue 配置 入口文件main.ts全局安装element-plus,element-plus默认支持语言英语设置为中文 import createApp from vueimport App from ./App.vueimport ElementPlus from element-plusimport element-plus/dist/index.css//@ts-expect-error忽略当前文件ts类型的检测否则有红色提示(打包会失败)import zhCn from element-plus/dist/locale/zh-cn.mjsconst app = createApp(App)app .use(ElementPlus, locale: zhCn, ) .mount(#app) 指定全局组件类型 在 tsconfig.json 中通过 compilerOptions.type 指定全局组件类型 // tsconfig.json compilerOptions: // ... types: [element-plus/global] 3.2 src别名的配置 配置vite.config.ts 在开发项目的时候文件与文件关系可能很复杂，因此我们需要给src文件夹配置一个别名！！！ // vite.config.tsimport defineConfig from viteimport vue from @vitejs/plugin-vueimport path from pathexport default defineConfig( plugins: [vue()], resolve: alias: @: path.resolve(./src) // 相对路径别名配置，使用 @ 代替 src ) tsconfig.json配置 // tsconfig.json compilerOptions: baseUrl: ./, // 解析非相对模块的基地址，默认是当前目录 paths: //路径映射，相对于baseUrl @/*: [src/*] 3.3 环境变量配置 作用 项目开发过程中，至少会经历开发环境、测试环境和生产环境(即正式环境)三个阶段。不同阶段请求的状态(如接口地址等)不尽相同，若手动切换接口地址是相当繁琐且易出错的。于是环境变量配置的需求就应运而生，我们只需做简单的配置，把环境状态切换的工作交给代码。 环境 开发环境（development） 顾名思义，开发使用的环境，每位开发人员在自己的dev分支上干活，开发到一定程度，同事会合并代码，进行联调。 测试环境（testing） 测试同事干活的环境啦，一般会由测试同事自己来部署，然后在此环境进行测试 生产环境（production） 生产环境是指正式提供对外服务的，一般会关掉错误报告，打开错误日志。(正式提供给客户使用的环境) 配置 项目根目录分别添加 开发、生产和测试环境的文件! .env.development.env.production.env.test 添加配置 .env.development # 变量必须以 VITE_ 为前缀才能暴露给外部读取NODE_ENV = developmentVITE_APP_TITLE = 后台开发模板VITE_APP_BASE_API = /dev-api .env.production NODE_ENV = productionVITE_APP_TITLE = 后台开发模板VITE_APP_BASE_API = /prod-api .env.test # 变量必须以 VITE_ 为前缀才能暴露给外部读取NODE_ENV = testVITE_APP_TITLE = 后台开发模板VITE_APP_BASE_API = /test-api 配置运行命令：package.json scripts: build:test: vue-tsc vite build --mode test, build:pro: vue-tsc vite build --mode production , 通过import.meta.env获取环境变量 template divHello/div/templatescript lang=tsconsole.log(import.meta.env)export default /scriptstyle/style 3.4 SVG图标配置3.4.1 图标配置 作用 在开发项目的时候经常会用到svg矢量图,而且我们使用SVG以后，页面上加载的不再是图片资源。 这对页面性能来说是个很大的提升，而且我们SVG文件比img要小的很多，放在项目中几乎不占用资源。 安装依赖 pnpm install vite-plugin-svg-icons -D 配置 在vite.config.ts中配置插件 import createSvgIconsPlugin from vite-plugin-svg-iconsimport path from pathexport default () = return plugins: [ createSvgIconsPlugin( // Specify the icon folder to be cached iconDirs: [path.resolve(process.cwd(), src/assets/icons)], // Specify symbolId format symbolId: icon-[dir]-[name], ), ], 入口文件导入 // main.tsimport virtual:svg-icons-register 3.4.2 封装为全局组件 作用 因为项目很多模块需要使用图标,因此把它封装为全局组件！！！ 示例 在srccomponents目录下创建一个SvgIcon组件 template div svg :style= width: width, height: height use :xlink:href=prefix + name :fill=color/use /svg /div/templatescript setup lang=tsdefineProps( //xlink:href属性值的前缀 prefix: type: String, default: #icon-, , //svg矢量图的名字 name: String, //svg图标的颜色 color: type: String, default: , , //svg宽度 width: type: String, default: 16px, , //svg高度 height: type: String, default: 16px, ,)/scriptstyle scoped/style 注册全局组件 在srccomponents文件夹目录下创建一个index.ts文件：用于注册components文件夹内部全部全局组件！！！ // index.tsimport SvgIcon from ./SvgIcon/index.vue;import type App, Component from vue;const components: [name: string]: Component = SvgIcon ;export default install(app: App) Object.keys(components).forEach((key: string) = app.component(key, components[key]); ) 入口文件使用自定义插件 import gloablComponent from ./components/index;app.use(gloablComponent); 3.5 集成sass 作用 我们目前在组件内部已经可以使用scss样式,因为在配置styleLint工具的时候，项目当中已经安装过sass sass-loader,因此我们再组件内可以使用scss语法！！！需要加上lang”scss” style scoped lang=scss/style 全局样式 在srcstyles目录下创建一个index.scss文件，当然项目中需要用到清除默认样式，因此在index.scss引入reset.scss reset.scss *,*:after,*:before box-sizing: border-box; outline: none;html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video font: inherit; font-size: 100%; margin: 0; padding: 0; vertical-align: baseline; border: 0;article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section display: block;body line-height: 1;ol,ul list-style: none;blockquote,q quotes: none; :before, :after content: ; content: none; sub,sup font-size: 75%; line-height: 0; position: relative; vertical-align: baseline;sup top: -.5em;sub bottom: -.25em;table border-spacing: 0; border-collapse: collapse;input,textarea,button font-family: inhert; font-size: inherit; color: inherit;select text-indent: .01px; text-overflow: ; border: 0; border-radius: 0; -webkit-appearance: none; -moz-appearance: none;select::-ms-expand display: none;code,pre font-family: monospace, monospace; font-size: 1em; index.scss //引入清除默认样式@import ./reset.scss;//滚动条外观设置::-webkit-scrollbar width: 10px;::-webkit-scrollbar-track background: $base-menu-background;::-webkit-scrollbar-thumb width: 10px; background-color: yellowgreen; border-radius: 10px; 入口文件引入 // main.tsimport @/styles 但是你会发现在srcstylesindex.scss全局样式文件中没有办法使用$变量.因此需要给项目中引入全局变量$. 在stylevariable.scss创建一个variable.scss文件！ 在vite.config.ts文件配置如下: export default defineConfig((config) = css: preprocessorOptions: scss: javascriptEnabled: true, additionalData: @import ./src/styles/variable.scss;, , , , @import ./src/styles/variable.less;后面的;不要忘记，不然会报错! 配置完毕你会发现scss提供这些全局变量可以在组件样式中使用了！！！ 3.6 mock数据 安装依赖 https://www.npmjs.com/package/vite-plugin-mock pnpm install vite-plugin-mock@2.9.6 -D 配置启用插件 // vite.config.js//mock插件提供方法import viteMockServe from vite-plugin-mockexport default defineConfig(( command ) = return plugins: [ viteMockServe( localEnabled: command === serve, //保证开发阶段可以使用mock接口 ), ], ) 测试 在根目录创建mock文件夹:去创建我们需要mock数据与接口！！！ 在mock文件夹内部创建一个user.ts文件 //createUserList:次函数执行会返回一个数组,数组里面包含两个用户信息function createUserList() return [ userId: 1, avatar: https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif, username: admin, password: 111111, desc: 平台管理员, roles: [平台管理员], buttons: [cuser.detail], routes: [home], token: Admin Token, , userId: 2, avatar: https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif, username: system, password: 111111, desc: 系统管理员, roles: [系统管理员], buttons: [cuser.detail, cuser.user], routes: [home], token: System Token, , ]//对外暴露一个数组:数组里面包含两个接口//登录假的接口//获取用户信息的假的接口export default [ // 用户登录接口 url: /api/user/login, //请求地址 method: post, //请求方式 response: ( body ) = //获取请求体携带过来的用户名与密码 const username, password = body //调用获取用户信息函数,用于判断是否有此用户 const checkUser = createUserList().find( (item) = item.username === username item.password === password, ) //没有用户返回失败信息 if (!checkUser) return code: 201, data: message: 账号或者密码不正确 //如果有返回成功信息 const token = checkUser return code: 200, data: token , , // 获取用户信息 url: /api/user/info, method: get, response: (request) = //获取请求头携带token const token = request.headers.token //查看用户信息是否包含有次token用户 const checkUser = createUserList().find((item) = item.token === token) //没有返回失败的信息 if (!checkUser) return code: 201, data: message: 获取用户信息失败 //如果有返回成功信息 return code: 200, data: checkUser , ,] 安装axios pnpm install axios 测试 // main.tsimport axios from axiosaxios( url: /api/user/login, method: post, data: username: admin, password: 111111, ,) 3.7 axios二次封装 作用 使用请求拦截器，可以在请求拦截器中处理一些业务(开始进度条、请求头携带公共参数) 使用响应拦截器，可以在响应拦截器中处理一些业务(进度条结束、简化服务器返回的数据、处理http网络错误) 示例 在根目录下创建utilsrequest.ts import axios from axiosimport ElMessage from element-plus//创建axios实例const request = axios.create( baseURL: import.meta.env.VITE_APP_BASE_API, timeout: 5000,)//请求拦截器request.interceptors.request.use((config) = return config)//响应拦截器request.interceptors.response.use( (response) = return response.data , (error) = //处理网络错误 let msg = const status = error.response.status switch (status) case 401: msg = token过期 break case 403: msg = 无权访问 break case 404: msg = 请求地址错误 break case 500: msg = 服务器出现问题 break default: msg = 无网络 ElMessage( type: error, message: msg, ) return Promise.reject(error) ,)export default request 4. 路由配置 安装依赖 pnpm i vue-router 路由雏形 以src\\views\\login\\index.vue为例，创建路由界面 template div一级路由login/div/templatescript setup lang=ts/scriptstyle lang=scss/style 创建路由src\\router\\router.ts文件，定义路由 // 对外暴露配置路由(常量路由)export const constantRoute = [ //登录路由 path: /login, component: () = import(@/views/login/index.vue), name: login, //命名路由 , // 登录成功以后展示数据的路由 path: /, component: () = import(@/views/home/index.vue), name: layout, , path: /404, component: () = import(@/views/404/index.vue), name: 404, , // 重定向 path: /:pathMatch(.*)*, redirect: /404, name: Any, ,] 创建src\\router\\index.ts路由 // 通过vue-router插件实现模板路由配置import createRouter, createWebHashHistory from vue-routerimport constantRoute from ./router// 创建路由器const router = createRouter( // 路由模式hash history: createWebHashHistory(), routes: constantRoute, // 滚动行为 scrollBehavior() return left: 0, top: 0, ,)export default router 在main.ts中挂载路由 // 导入路由组件import router from ./router// 获取应用实例对象const app = createApp(App)// 使用路由组件app.use(router) 指定路由出口 !-- App.vue --template divrouter-view/router-view/div/templatescript setup lang=ts/scriptstyle/style 5. 登录模块5.1 登录界面 编写登录界面 !-- src/views/login/index.vue --template div class=login_container el-row el-col :span=12 :xs=0/el-col el-col :span=12 :xs=24 el-form class=login_form h1Hello/h1 h2欢迎来到XXX/h2 el-form-item el-input :prefix-icon=User v-model=loginForm.username /el-input /el-form-item el-form-item el-input type=password :prefix-icon=Lock v-model=loginForm.password show-password /el-input /el-form-item el-form-item el-button :loading=loadType class=login_btn type=primary size=default @click=login 登录 /el-button /el-form-item /el-form /el-col /el-row /div/templatescript setup lang=tsimport User, Lock from @element-plus/icons-vueimport reactive from vue// 登录效果let loadType = ref(false)//收集账号与密码数据let loginForm = reactive( username: admin, password: 111111 )/scriptstyle lang=scss scoped.login_container width: 100%; height: 100vh; background: url(@/assets/images/background.jpg) no-repeat; background-size: cover; .login_form position: relative; width: 80%; top: 30vh; background: url(@/assets/images/login_form.png) no-repeat; background-size: cover; padding: 40px; h1 color: white; font-size: 40px; h2 color: white; font-size: 20px; margin: 20px 0px; .login_btn width: 100%; /style 5.2 编写请求登录API 接口请求参数及返回类型 // 用户登录接口 url: /dev-api/user/login, //请求地址 method: post, //请求方式 response: ( body ) = //获取请求体携带过来的用户名与密码 const username, password = body //调用获取用户信息函数,用于判断是否有此用户 const checkUser = createUserList().find( (item) = item.username === username item.password === password, ) //没有用户返回失败信息 if (!checkUser) return code: 201, data: message: 账号或者密码不正确 //如果有返回成功信息 const token = checkUser return code: 200, data: token ,, // 登录接口返回数据类型 userId: 1, avatar: https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif, username: admin, password: 111111, desc: 平台管理员, roles: [平台管理员], buttons: [cuser.detail], routes: [home], token: Admin Token,, 根据登录接口编写数据类型type // src/api/user/type.ts// 登录接口需要携带参数ts类型export interface loginForm username: string password: string// ? 可选参数export interface dataType token?: string message?: string// 登录接口返回数据类型export interface loginResponseData code: number data: dataType 编写登录接口 // src/api/user/index.ts// 同一管理用户相关的接口import request from @/utils/requestimport loginForm, loginResponseData from ./type// 统一管理APIenum API LOGIN_URL = /user/login,// 暴露请求函数// 登录接口export const reqLogin = (data: loginForm) = request.postany, loginResponseData(API.LOGIN_URL, data) 5.3 用户数据存储pinia 安装依赖 pnpm i pinia@2.0.34 创建pinia仓库 // src/store/index.ts//仓库大仓库import createPinia from pinia//创建大仓库const pinia = createPinia()//对外暴露：入口文件需要安装仓库export default pinia 挂载pinia // main.ts// 导入piniaimport pinia from ./storeapp.use(pinia) 创建UserState数据类型 // src/store/modules/type/type.tsexport interface UserState token: string | null token相关工具方法 // src/utils/token.ts// 封装本地存储和读取数据的方法export const SET_TOKEN = (token: string) = localStorage.setItem(TOKEN, token)export const GET_TOKEN = (): string | null = return localStorage.getItem(TOKEN) 创建用户相关仓库 // src/store/modules/user.ts// 创建用户相关的小仓库import defineStore from piniaimport loginForm, loginResponseData from @/api/user/typeimport reqLogin from @/api/userimport GET_TOKEN, SET_TOKEN from @/utils/tokenimport UserState from ./type/type// 创建用户小仓库const useUserStore = defineStore(User, // 用户仓库存储数据地方 state(): UserState return token: GET_TOKEN(), , // 处理异步|逻辑地方 actions: async userLogin(data: loginForm) const result: loginResponseData = await reqLogin(data) console.log(result) if (result.code === 200) this.token = result.data.token as string //localStorage.setItem(TOKEN, this.token) SET_TOKEN(this.token) return OK else return Promise.reject(new Error(result.data.message)) , , getters: ,)// 对外暴露小仓库export default useUserStore 5.4 登录按钮点击事件 登录 !-- src/views/login/index.vue --script setup lang=tsimport User, Lock from @element-plus/icons-vueimport reactive, ref from vueimport useUserStore from @/store/modules/userimport useRouter from vue-routerimport ElNotification from element-plus// 登录效果let loadType = ref(false)//收集账号与密码数据let loginForm = reactive( username: admin, password: 111111 )const router = useRouter()let userStore = useUserStore()// 登录const login = async () = loadType.value = true try await userStore.userLogin(loginForm) router.push(/) ElNotification( type: success, message: 登录成功, ) loadType.value = false catch (error) loadType.value = false ElNotification( type: error, message: (error as Error).message, ) /script 5.5 登录提示 需求 修改登录提示 提供时间函数 // src/utils/time.tsexport const getTime = () = let message = const hours = new Date().getHours() if (hours = 9) message = 早上 else if (hours = 12) message = 上午 else if (hours = 18) message = 下午 else message = 晚上 return message 修改提示 // 登录const login = async () = loadType.value = true try await userStore.userLogin(loginForm) router.push(/) ElNotification( type: success, message: 欢迎回来, // 修改提示 title: `HI,$getTime()好`, ) loadType.value = false catch (error) loadType.value = false ElNotification( type: error, message: (error as Error).message, ) 5.6 登录表单校验 绑定表单 https://element-plus.org/zh-CN/component/form.html#%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C el-form class=login_form !-- 表单规则 -- :rules=rules !-- 表单数据 -- :model=loginForm !-- 通过ref获取表单组件 -- ref=loginFormRef 定义规则 //定义表单校验需要的配置对象const rules = username: [ //规则对象属性: required: true, // required,代表这个字段务必要校验的 min: 5, //min:文本长度至少多少位 max: 10, // max:文本长度最多多少位 message: 长度应为6-10位, // message:错误的提示信息 trigger: change, //trigger:触发校验表单的时机 change-文本发生变化触发校验, blur:失去焦点的时候触发校验规则 , ], password: [ required: true, min: 6, max: 10, message: 长度应为6-15位, trigger: change, , ],// 获取表单组件const loginFormRef = ref() 执行校验 // 登录const login = async () = //保证全部表单项校验通过 await loginFormRef.value.validate() ... 5.7 自定义校验 自定义规则 有时候默认的校验规则不满足校验要求，这个时候可以自定义校验规则函数 //自定义校验规则函数const validatorUserName = (_rule: any, value: any, callback: any) = //rule：校验规则对象 //value:表单元素文本内容 //callback:符合条件，callback放行通过，不符合：注入错误提示信息 if (value.length = 5) callback() else callback(new Error(账号长度至少5位)) const validatorPassword = (_rule: any, value: any, callback: any) = if (value.length = 6) callback() else callback(new Error(密码长度至少6位)) 添加规则 //定义表单校验需要的配置对象const rules = username: [ validator: validatorUserName, trigger: change , ], password: [ validator: validatorPassword, trigger: change , ], 6. Layout模块6.1 主界面 主界面 !-- src/layout/index.vue --template div class=layout_container !-- 左侧菜单 -- div class=layout_slider/div !-- 顶部导航 -- div class=layout_tabbar/div !-- 内容展示区域 -- div class=layout_main p style=height: 1000000px/p /div /div/templatescript setup lang=ts/scriptstyle lang=scss scoped.layout_container width: 100%; height: 100vh; .layout_slider width: $base-menu-width; height: 100vh; background: $base-menu-background; .layout_tabbar position: fixed; width: calc(100% - $base-menu-width); height: $base-tabbar-height; background: cyan; top: 0; left: $base-menu-width; .layout_main position: absolute; width: calc(100% - $base-menu-width); height: calc(100vh - $base-tabbar-height); background-color: yellowgreen; left: $base-menu-width; top: $base-tabbar-height; padding: 20px; overflow: auto; /style 定义全局变量 // scr/styles/variable.scss// 项目提供scss全局变量//左侧的菜单的宽度$base-menu-width:260px;//左侧菜单的背景颜色$base-menu-background:#001529;$base-menu-min-width:50px;// 顶部导航的高度$base-tabbar-height:50px; 定义滚动条样式 // scr/styles/index.scss//引入清除默认样式@import ./reset.scss;//滚动条外观设置::-webkit-scrollbar width: 10px;::-webkit-scrollbar-thumb width: 10px; background-color: yellowgreen; border-radius: 10px; 6.2 封装LOGO 创建logo组件 !-- src/layout/logo/index.vue --template div class=logo img src=../../../../public/logo.png alt= / pxxx后台管理/p /div/templatescript setup lang=ts/scriptstyle lang=scss scoped.logo width: 100%; height: $base-menu-logo-height; color: white; display: flex; align-items: center; padding: 20px; img width: 40px; height: 40px; p font-size: $base-logo-title-fontSize; margin-left: 10px; /style 添加logo全局变量 // scr/styles/variable.scss//左侧菜单logo高度设置$base-menu-logo-height:50px;//左侧菜单logo右侧文字大小$base-logo-title-fontSize:20px; 引入logo组件 template div class=layout_container !-- 左侧菜单 -- div class=layout_slider !-- 引入logo -- Logo/Logo /div !-- 顶部导航 -- div class=layout_tabbar/div !-- 内容展示区域 -- div class=layout_main p style=height: 1000000px/p /div /div/templatescript setup lang=tsimport Logo from @/views/layout/logo/index.vue/script 抽取配置 为了方便以后对logo以及标题的修改，可以将logo内容抽取到配置文件中 // src/setting.ts//用于项目logo|标题配置export default title: 硅谷甄选运营平台, //项目的标题 logo: /public/logo.png, //项目logo设置 logoHidden: true, //logo组件是否隐藏 修改logo组件 template div class=logo v-if=!setting.logoHidden img :src=setting.logo alt= / p setting.title /p /div/templatescript setup lang=tsimport setting from @/setting/script 6.3 左侧静态菜单组件 左侧滚动条 https://element-plus.org/zh-CN/component/scrollbar.html template div class=layout_container !-- 左侧菜单 -- div class=layout_slider !-- logo -- Logo/Logo !-- 滚动组件 -- el-scrollbar class=scrollbar p v-for=item in 2000 :key=item class=scrollbar-demo-item item /p /el-scrollbar /div !-- 顶部导航 -- div class=layout_tabbar/div !-- 内容展示区域 -- div class=layout_main p style=height: 1000000px/p /div /div/templatestyle lang=scss scoped.layout_container width: 100%; height: 100vh; // 设置字体颜色 color: white; .layout_slider width: $base-menu-width; height: 100vh; background: $base-menu-background; // 设置滚动条样式 .scrollbar width: 100%; height: calc(100vh - $base-menu-logo-height); // 消除滚动border .el-menu border-right: 0; .layout_tabbar position: fixed; width: calc(100% - $base-menu-width); height: $base-tabbar-height; background: cyan; top: 0; left: $base-menu-width; .layout_main position: absolute; width: calc(100% - $base-menu-width); height: calc(100vh - $base-tabbar-height); background-color: yellowgreen; left: $base-menu-width; top: $base-tabbar-height; padding: 20px; overflow: auto; /style 菜单组件 https://element-plus.org/zh-CN/component/menu.html template div class=layout_container !-- 左侧菜单 -- div class=layout_slider !-- logo -- Logo/Logo !-- 滚动组件 -- el-scrollbar !-- 菜单组件 -- el-menu background-color=#001529 text-color=white el-menu-item index=1首页/el-menu-item el-menu-item index=2数据大屏/el-menu-item !-- 折叠菜单 -- el-sub-menu index=3 template #title span权限管理/span /template el-menu-item index=3-1用户管理/el-menu-item el-menu-item index=3-2角色管理/el-menu-item el-menu-item index=3-3菜单管理/el-menu-item /el-sub-menu /el-menu /el-scrollbar /div !-- 顶部导航 -- div class=layout_tabbar/div !-- 内容展示区域 -- div class=layout_main p style=height: 1000000px/p /div /div/template 6.4 动态菜单组件 封装组件 src\\layout\\menu\\index.vue template !-- 菜单组件 -- el-menu background-color=#001529 text-color=white el-menu-item index=1首页/el-menu-item el-menu-item index=2数据大屏/el-menu-item !-- 折叠菜单 -- el-sub-menu index=3 template #title span权限管理/span /template el-menu-item index=3-1用户管理/el-menu-item el-menu-item index=3-2角色管理/el-menu-item el-menu-item index=3-3菜单管理/el-menu-item /el-sub-menu /el-menu/templatescript setup lang=ts/scriptstyle lang=scss scoped/style src\\layout\\index.vue template div class=layout_container !-- 左侧菜单 -- div class=layout_slider !-- logo -- Logo/Logo !-- 滚动组件 -- el-scrollbar class=scrollbar Menu/Menu /el-scrollbar /div !-- 顶部导航 -- div class=layout_tabbar/div !-- 内容展示区域 -- div class=layout_main p style=height: 1000000px/p /div /div/templatescript setup lang=tsimport Logo from ./logo/index.vueimport Menu from ./menu/index.vue/script 路由信息存入pinia 定义路由类型 src\\store\\modules\\type\\type.ts import RouteRecordRaw from vue-routerexport interface UserState token: string | null menuRoutes: RouteRecordRaw[] // 路由类型 路由信息存入state import constantRoute from @/router/router// 创建用户仓库const useUserStore = defineStore(User, // 用户仓库存储数据地方 state(): UserState return token: GET_TOKEN(), menuRoutes: constantRoute, , ...) 路由添加meta信息 src\\router\\router.ts // 对外暴露配置路由(常量路由)export const constantRoute = [ //登录 path: /login, component: () = import(@/views/login/index.vue), name: login, meta: title: 登录, //菜单标题 , , //登录成功以后展示数据的路由 path: /, component: () = import(@/layout/index.vue), name: layout, meta: title: layout, , redirect: /home, children: [ path: /home, component: () = import(@/views/home/index.vue), meta: title: 首页, , , path: /home2, component: () = import(@/views/home/index.vue), meta: title: 首页2, , , ], , //404 path: /404, component: () = import(@/views/404/index.vue), name: 404, meta: title: 404, , ,] 父组件获取路由信息并传递给子组件 src\\layout\\index.vue template div class=layout_container !-- 左侧菜单 -- div class=layout_slider !-- logo -- Logo/Logo !-- 滚动组件 -- el-scrollbar class=scrollbar el-menu background-color=#001529 text-color=white // 传递路由数据 Menu :menuList=userStore.menuRoutes/Menu /el-menu /el-scrollbar /div !-- 顶部导航 -- div class=layout_tabbar/div !-- 内容展示区域 -- div class=layout_main p style=height: 1000000px/p /div /div/templatescript setup lang=tsimport Logo from ./logo/index.vueimport Menu from ./menu/index.vueimport useUserStore from @/store/modules/user// 获取用户仓库const userStore = useUserStore()/script 子组件根据路由数据动态创建菜单 src\\layout\\menu\\index.vue template template v-for=item in menuList :key=item.path !-- 没有子路由 -- el-menu-item v-if=!item.children :index=item.path template #title span标/span span item.meta.title /span /template /el-menu-item !-- 有子路由但只有一个子路由 -- el-menu-item v-if=item.children item.children.length === 1 :index=item.children[0].path template #title span标/span span item.children[0].meta.title /span /template /el-menu-item !-- 有子路由且个数大于一个 -- el-sub-menu :index=item.path v-if=item.children item.children.length = 2 template #title span item.meta.title /span /template !-- 递归创建菜单 -- Menu :menuList=item.children/Menu /el-sub-menu /template/templatescript setup lang=ts//获取父组件传递过来的全部路由数组defineProps([menuList])/scriptscript lang=tsexport default // eslint-disable-next-line vue/no-reserved-component-names name: Menu,/scriptstyle lang=scss scoped/style 注意：当子路由个数大于等于一个时，并且或许子路由还有后代路由时。这里我们使用了递归组件。递归组件需要命名（另外使用一个script标签，vue2格式）。 菜单隐藏 添加meta信息 src\\router\\router.ts // 对外暴露配置路由(常量路由)export const constantRoute = [ //登录 path: /login, component: () = import(@/views/login/index.vue), name: login, meta: title: 登录, //菜单标题 hidden: true, //代表路由标题在菜单中是否隐藏 true:隐藏 false:不隐藏 , , //登录成功以后展示数据的路由 path: /, component: () = import(@/layout/index.vue), name: layout, meta: title: layout, hidden: false, , redirect: /home, children: [ path: /home, component: () = import(@/views/home/index.vue), meta: title: 首页, hidden: false, , , path: /home2, component: () = import(@/views/home/index.vue), meta: title: 首页2, hidden: false, icon: HomeFilled, , , ], , //404 path: /404, component: () = import(@/views/404/index.vue), name: 404, meta: title: 404, hidden: true, , ,] 为方便判断修改menu组件 src\\layout\\menu\\index.vue template template v-for=item in menuList :key=item.path !-- 没有子路由 -- template v-if=!item.children el-menu-item v-if=!item.meta.hidden :index=item.path template #title span标/span span item.meta.title /span /template /el-menu-item /template !-- 有子路由但只有一个子路由 -- template v-if=item.children item.children.length === 1 el-menu-item v-if=!item.children[0].meta.hidden :index=item.children[0].path template #title span标/span span item.children[0].meta.title /span /template /el-menu-item /template !-- 有子路由且个数大于一个 -- el-sub-menu v-if=item.children item.children.length = 2 :index=item.path template #title span item.meta.title /span /template !-- 递归创建菜单 -- Menu :menuList=item.children/Menu /el-sub-menu /template/templatescript setup lang=ts//获取父组件传递过来的全部路由数组defineProps([menuList])/scriptscript lang=tsexport default // eslint-disable-next-line vue/no-reserved-component-names name: Menu,/scriptstyle lang=scss scoped/style 添加菜单图标 注册图标组件 src\\components\\index.ts import SvgIcon from ./SvgIcon/index.vueimport type App, Component from vue//引入element-plus提供全部图标组件import * as ElementPlusIconsVue from @element-plus/icons-vueconst components: [name: string]: Component = SvgIcon //对外暴露插件对象export default //务必叫做install方法 install(app: App) //注册项目全部的全局组件 Object.keys(components).forEach((key) = //注册为全局组件 app.component(key, components[key]) ) //将element-plus提供全部图标注册为全局组件 for (const [key, component] of Object.entries(ElementPlusIconsVue)) app.component(key, component) , 添加meta信息 https://element-plus.org/zh-CN/component/icon.html src\\router\\router.ts // 对外暴露配置路由(常量路由)export const constantRoute = [ //登录 path: /login, component: () = import(@/views/login/index.vue), name: login, meta: title: 登录, //菜单标题 hidden: false, //代表路由标题在菜单中是否隐藏 true:隐藏 false:不隐藏 icon: Promotion, //菜单文字左侧的图标,支持element-plus全部图标 , , //登录成功以后展示数据的路由 path: /, component: () = import(@/layout/index.vue), name: layout, meta: title: , hidden: false, icon: , , redirect: /home, children: [ path: /home, component: () = import(@/views/home/index.vue), meta: title: 首页, hidden: false, icon: HomeFilled, , , ], , //404 path: /404, component: () = import(@/views/404/index.vue), name: 404, meta: title: 404, hidden: false, icon: DocumentDelete, , ,] 修改menu组件 src\\layout\\menu\\index.vue template template v-for=item in menuList :key=item.path !--没有子路由-- template v-if=!item.children el-menu-item :index=item.path v-if=!item.meta.hidden !-- 图标 -- el-icon component :is=item.meta.icon/component /el-icon template #title span item.meta.title /span /template /el-menu-item /template !-- 有子路由但是只有一个子路由 -- template v-if=item.children item.children.length == 1 el-menu-item :index=item.children[0].path v-if=!item.children[0].meta.hidden !-- 图标 -- el-icon component :is=item.children[0].meta.icon/component /el-icon template #title span item.children[0].meta.title /span /template /el-menu-item /template !-- 有子路由且个数大于一个1 -- el-sub-menu :index=item.path v-if=item.children item.children.length 1 template #title !-- 图标 -- el-icon component :is=item.meta.icon/component /el-icon span item.meta.title /span /template Menu :menuList=item.children/Menu /el-sub-menu /template/templatescript setup lang=ts//获取父组件传递过来的全部路由数组defineProps([menuList])/scriptscript lang=tsexport default // eslint-disable-next-line vue/no-reserved-component-names name: Menu,/scriptstyle lang=scss scoped/style 路由跳转 点击菜单时需要跳转至对应路由界面，@click=goRoute(item.path) template template v-for=item in menuList :key=item.path !--没有子路由-- template v-if=!item.children el-menu-item :index=item.path v-if=!item.meta.hidden @click=goRoute(item.path) el-icon !-- 图标 -- component :is=item.meta.icon/component /el-icon template #title span item.meta.title /span /template /el-menu-item /template !-- 有子路由但是只有一个子路由 -- template v-if=item.children item.children.length == 1 el-menu-item :index=item.children[0].path v-if=!item.children[0].meta.hidden @click=goRoute(item.children[0].path) el-icon component :is=item.children[0].meta.icon/component /el-icon template #title span item.children[0].meta.title /span /template /el-menu-item /template !-- 有子路由且个数大于一个1 -- el-sub-menu :index=item.path v-if=item.children item.children.length 1 template #title el-icon component :is=item.meta.icon/component /el-icon span item.meta.title /span /template Menu :menuList=item.children/Menu /el-sub-menu /template/templatescript setup lang=tsimport useRouter from vue-router// 获取父组件传递过来的全部路由数组defineProps([menuList])const route = useRouter()// 根据路由路径跳转const goRoute = (path: string) = route.push(path)/scriptscript lang=tsexport default // eslint-disable-next-line vue/no-reserved-component-names name: Menu,/scriptstyle lang=scss scoped/style 6.5 封装Main组件 封装内容展示区域组件，添加路由跳转动画 https://router.vuejs.org/zh/guide/advanced/transitions.html src\\layout\\main\\index.vue template !-- 路由组件出口的位置 -- router-view v-slot= Component transition name=fade !-- 渲染layout一级路由的子路由 -- component :is=Component / /transition /router-view/templatescript setup lang=ts/scriptstyle lang=scss scoped.fade-enter-from opacity: 0;.fade-enter-active transition: all 0.3s;.fade-enter-to opacity: 1;/style 修改layout src\\layout\\index.vue template div class=layout_container !-- 左侧菜单 -- div class=layout_slider !-- logo -- Logo/Logo !-- 滚动组件 -- el-scrollbar class=scrollbar el-menu background-color=#001529 text-color=white Menu :menuList=userStore.menuRoutes/Menu /el-menu /el-scrollbar /div !-- 顶部导航 -- div class=layout_tabbar/div !-- 内容展示区域 -- div class=layout_main Main/Main /div /div/template 6.6 配置全路由 配置路由 src\\router\\router.ts // 对外暴露配置路由(常量路由)export const constantRoute = [ //登录 path: /login, component: () = import(@/views/login/index.vue), name: login, meta: title: 登录, //菜单标题 hidden: true, //代表路由标题在菜单中是否隐藏 true:隐藏 false:不隐藏 icon: Promotion, //菜单文字左侧的图标,支持element-plus全部图标 , , //登录成功以后展示数据的路由 path: /, component: () = import(@/layout/index.vue), name: layout, meta: title: , hidden: false, icon: , , redirect: /home, children: [ path: /home, component: () = import(@/views/home/index.vue), meta: title: 首页, hidden: false, icon: HomeFilled, , , ], , //404 path: /404, component: () = import(@/views/404/index.vue), name: 404, meta: title: 404, hidden: true, icon: DocumentDelete, , , path: /acl, component: () = import(@/layout/index.vue), name: Acl, meta: hidden: false, title: 权限管理, icon: Lock, , redirect: /acl/user, children: [ path: /acl/user, component: () = import(@/views/acl/user/index.vue), name: User, meta: hidden: false, title: 用户管理, icon: User, , , path: /acl/role, component: () = import(@/views/acl/role/index.vue), name: Role, meta: hidden: false, title: 角色管理, icon: UserFilled, , , path: /acl/permission, component: () = import(@/views/acl/permission/index.vue), name: Permission, meta: hidden: false, title: 菜单管理, icon: Monitor, , , ], , path: /product, component: () = import(@/layout/index.vue), name: Product, meta: title: 商品管理, icon: Goods, , redirect: /product/trademark, children: [ path: /product/trademark, component: () = import(@/views/product/trademark/index.vue), name: Trademark, meta: title: 品牌管理, icon: ShoppingCartFull, , , path: /product/attr, component: () = import(@/views/product/attr/index.vue), name: Attr, meta: title: 属性管理, icon: ChromeFilled, , , path: /product/spu, component: () = import(@/views/product/spu/index.vue), name: Spu, meta: title: SPU管理, icon: Calendar, , , path: /product/sku, component: () = import(@/views/product/sku/index.vue), name: Sku, meta: title: SKU管理, icon: Orange, , , ], ,] 创建相应组件 6.7 菜单刷新展示 问题 当页面刷新时，菜单会自动收起。使用element-plus的default-active 处理 处理 https://element-plus.org/zh-CN/component/menu.html#menu-attributes template div class=layout_container !-- 左侧菜单 -- div class=layout_slider !-- logo -- Logo/Logo !-- 滚动组件 -- el-scrollbar class=scrollbar el-menu background-color=#001529 text-color=white :default-active=route.path Menu :menuList=userStore.menuRoutes/Menu /el-menu /el-scrollbar /div !-- 顶部导航 -- div class=layout_tabbar/div !-- 内容展示区域 -- div class=layout_main Main/Main /div /div/templatescript setup lang=tsimport Logo from ./logo/index.vueimport Menu from ./menu/index.vueimport useUserStore from @/store/modules/userimport Main from ./main/index.vueimport useRoute from vue-routerconst userStore = useUserStore()// 获取路由const route = useRoute()/script 6.8 顶部tabbar组件 添加静态界面 https://element-plus.org/zh-CN/component/breadcrumb.html https://element-plus.org/zh-CN/component/dropdown.html src\\layout\\tabbar\\index.vue template div class=tabbar div class=tabbar_left !-- 顶部左侧的图标 -- el-icon style=margin-right: 10px Expand/Expand /el-icon !-- 左侧的面包屑 -- el-breadcrumb separator-icon=ArrowRight el-breadcrumb-item权限管理/el-breadcrumb-item el-breadcrumb-item用户管理/el-breadcrumb-item /el-breadcrumb /div div class=tabbar_right el-button size=small icon=Refresh circle/el-button el-button size=small icon=FullScreen circle/el-button el-button size=small icon=Setting circle/el-button img src=../../../public/logo.png style=width: 24px; height: 24px; margin: 0px 10px / !-- 下拉菜单 -- el-dropdown span class=el-dropdown-link admin el-icon class=el-icon--right arrow-down / /el-icon /span template #dropdown el-dropdown-menu el-dropdown-item退出登陆/el-dropdown-item /el-dropdown-menu /template /el-dropdown /div /div/templatescript setup lang=ts/scriptstyle lang=scss scoped.tabbar width: 100%; height: 100%; display: flex; justify-content: space-between; background-image: linear-gradient( to right, rgb(236, 229, 229), rgb(151, 136, 136), rgb(240, 234, 234) ); .tabbar_left display: flex; align-items: center; margin-left: 20px; .tabbar_right display: flex; align-items: center; /style 拆分组件 src\\layout\\tabbar\\breadcrumb\\index.vue template !-- 顶部左侧的图标 -- el-icon style=margin-right: 10px Expand/Expand /el-icon !-- 左侧的面包屑 -- el-breadcrumb separator-icon=ArrowRight el-breadcrumb-item权限挂历/el-breadcrumb-item el-breadcrumb-item用户管理/el-breadcrumb-item /el-breadcrumb/templatescript setup lang=ts/scriptstyle lang=scss scoped/style src\\layout\\tabbar\\setting\\index.vue template el-button size=small icon=Refresh circle/el-button el-button size=small icon=FullScreen circle/el-button el-button size=small icon=Setting circle/el-button img src=../../../../public/logo.png style=width: 24px; height: 24px; margin: 0px 10px / !-- 下拉菜单 -- el-dropdown span class=el-dropdown-link admin el-icon class=el-icon--right arrow-down / /el-icon /span template #dropdown el-dropdown-menu el-dropdown-item退出登陆/el-dropdown-item /el-dropdown-menu /template /el-dropdown/templatescript setup lang=ts/scriptstyle lang=scss scoped/style src\\layout\\tabbar\\index.vue template div class=tabbar div class=tabbar_left Breadcrumb/Breadcrumb /div div class=tabbar_right Setting/Setting /div /div/templatescript setup lang=tsimport Breadcrumb from ./breadcrumb/index.vueimport Setting from ./setting/index.vue/script 6.9 菜单折叠 修改折叠图标 添加点击事件根据折叠状态判断，展示不同图标 https://cn.vuejs.org/guide/essentials/component-basics.html#dynamic-components src\\layout\\tabbar\\breadcrumb\\index.vue template !-- 顶部左侧的图标 -- el-icon style=margin-right: 10px @click=changeIcon !-- 动态切换图标 -- component :is=settingStore.fold ? Fold : Expand/component /el-icon !-- 左侧的面包屑 -- el-breadcrumb separator-icon=ArrowRight el-breadcrumb-item权限管理/el-breadcrumb-item el-breadcrumb-item用户管理/el-breadcrumb-item /el-breadcrumb/templatescript setup lang=tsimport useSettingStore from @/store/modules/setting//获取layout配置相关的仓库let settingStore = useSettingStore()const changeIcon = () = console.log(settingStore.fold) settingStore.fold = !settingStore.fold/scriptstyle lang=scss scoped/style 因为整个左侧栏、顶部tabbar栏和main界面都受到折叠效果影响，所以将折叠状态存入pinia 新建setting仓库 src\\store\\modules\\setting.ts //小仓库：layout组件相关配置仓库import defineStore from piniaconst useSettingStore = defineStore(SettingStore, state: () = return fold: false, //用户控制菜单折叠还是收起的控制 ,)export default useSettingStore 联动更新左侧菜单栏 点击折叠时，动态修改左侧菜单栏宽度。 添加全局属性 src\\styles\\variable.scss //左侧菜单最小宽度$base-menu-min-width:50px; 绑定动态属性 src\\layout\\index.vue template div class=layout_container !-- 左侧菜单 -- div class=layout_slider :class= fold: settingStore.fold ? true : false /div /div/templatescript setup lang=tsimport useSettingStore from @/store/modules/settingconst settingStore = useSettingStore()/scriptstyle lang=scss scoped.layout_container width: 100%; height: 100vh; color: white; .layout_slider width: $base-menu-width; height: 100vh; background: $base-menu-background; transition: all 0.1s; // 添加左侧菜单最小宽度 .fold width: $base-menu-min-width; .scrollbar width: 100%; height: calc(100vh - $base-menu-logo-height); .el-menu border-right: 0; /style 左侧菜单栏修改折叠状态：collapse https://element-plus.org/zh-CN/component/menu.html#menu-attributes src\\layout\\index.vue template div class=layout_container !-- 左侧菜单 -- div class=layout_slider :class= fold: settingStore.fold ? true : false !-- logo -- Logo/Logo !-- 滚动组件 -- el-scrollbar class=scrollbar el-menu background-color=#001529 text-color=white :default-active=route.path :collapse=settingStore.fold Menu :menuList=userStore.menuRoutes/Menu /el-menu /el-scrollbar /div /div/template 联动更新tabbar template div class=layout_container !-- 顶部导航 -- div class=layout_tabbar :class= fold: settingStore.fold ? true : false Tabbar/Tabbar /div /div/templatescript setup lang=tsimport useSettingStore from @/store/modules/setting const settingStore = useSettingStore()/scriptstyle lang=scss scoped .layout_tabbar position: fixed; width: calc(100% - $base-menu-width); height: $base-tabbar-height; background: cyan; top: 0; left: $base-menu-width; transition: all 0.1s; .fold // 宽度 = 界面宽度 - 折叠后菜单栏所占宽度 width: calc(100vw - $base-menu-min-width); // 距离折叠后菜单栏宽度 left: $base-menu-min-width; /style 联动更新main template div class=layout_container !-- 内容展示区域 -- div class=layout_main :class= fold: settingStore.fold ? true : false Main/Main /div /div/templatescript setup lang=tsimport useSettingStore from @/store/modules/settingconst settingStore = useSettingStore()/scriptstyle lang=scss scoped .layout_main position: absolute; width: calc(100% - $base-menu-width); height: calc(100vh - $base-tabbar-height); background-color: yellowgreen; left: $base-menu-width; top: $base-tabbar-height; padding: 20px; overflow: auto; transition: all 0.1s; .fold width: calc(100vw - $base-menu-min-width); left: $base-menu-min-width; /style 6.10 动态更新面包屑 获取路由 使用route.matched函数，此函数能得到当前路由的信息 修改界面 src\\layout\\tabbar\\breadcrumb\\index.vue template !-- 左侧的面包屑 -- el-breadcrumb separator-icon=ArrowRight el-breadcrumb-item v-for=(item, index) in route.matched :key=index v-show=item.meta.title :to=item.path item.meta.title /el-breadcrumb-item /el-breadcrumb/templatescript setup lang=tsimport useSettingStore from @/store/modules/settingimport useRoute from vue-router// 获取layout配置相关的仓库let settingStore = useSettingStore()// 路由const route = useRoute()const changeIcon = () = console.log(settingStore.fold) settingStore.fold = !settingStore.fold/scriptstyle lang=scss scoped/style v-show控制无标题时不显示 设置点击权限管理时自动跳转到用户管理 src\\router\\router.ts path: /acl, component: () = import(@/layout/index.vue), name: Acl, meta: hidden: false, title: 权限管理, icon: Lock, , redirect: /acl/user, 6.11 刷新功能实现 在setting仓库添加refresh属性 src\\store\\modules\\setting.ts //小仓库：layout组件相关配置仓库import defineStore from piniaconst useSettingStore = defineStore(SettingStore, state: () = return fold: false, //用户控制菜单折叠还是收起的控制 refresh: false, //用于控制刷新效果 ,)export default useSettingStore 在setting.vue组件中配置刷新按钮点击事件 src\\layout\\tabbar\\setting\\index.vue template el-button size=small icon=Refresh circle @click=updateRefresh /el-button/templatescript setup lang=tsimport useSettingStore from @/store/modules/settingconst settingStore = useSettingStore()const updateRefresh = () = settingStore.refresh = !settingStore.refresh/scriptstyle lang=scss scoped/style 在main组件中监听按钮状态值，状态值变化就重建路由组件 src\\layout\\main\\index.vue template !-- 路由组件出口的位置 -- router-view v-slot= Component transition name=fade div v-if=flag !-- 渲染layout一级路由的子路由 -- component :is=Component / /div /transition /router-view/templatescript setup lang=tsimport ref, watch, nextTick from vueimport useSettingStore from @/store/modules/settingconst settingStore = useSettingStore()//控制当前组件是否销毁重建let flag = ref(true)//监听仓库内部的数据是否发生变化，如果发生变化，说明用户点击过刷新按钮watch( () = settingStore.refresh, () = //点击刷新按钮：路由组件销毁 flag.value = false // 异步刷新，vue重建DOM后会调用该方法 // https://lianyutian.github.io/posts/dd58b23f.html 9.5章节 nextTick(() = flag.value = true ) ,)/script 6.12 全屏功能实现 绑定全屏按钮点击事件 src\\layout\\tabbar\\setting\\index.vue template el-button size=small icon=FullScreen circle @click=fullScreen /el-buttonscript setup lang=ts// 全屏功能const fullScreen = () = // DOM对象的一个属性：可以用来判断当前是不是全屏的模式【全屏：true，不是全屏：false】 let full = document.fullscreenElement // 切换成全屏 if (!full) // 文档根节点的方法requestFullscreen实现全屏 document.documentElement.requestFullscreen() else // 退出全屏 document.exitFullscreen() /scriptstyle lang=scss scoped/style 7. 登录功能完善7.1 获取用户信息 添加用户state存储类型和属性 src\\store\\modules\\type\\type.ts import RouteRecordRaw from vue-routerexport interface UserState token: string | null menuRoutes: RouteRecordRaw[] username: string avatar: string src\\store\\modules\\user.ts // 创建用户小仓库const useUserStore = defineStore(UserStore, // 用户仓库存储数据地方 state(): UserState return token: GET_TOKEN(), menuRoutes: constantRoute, username: , avatar: , // 用户头像 , 添加获取信息方法 userInfoAction src\\store\\modules\\user.ts // src/store/modules/user.ts// 创建用户相关的仓库import defineStore from piniaimport loginForm, loginResponseData from @/api/user/typeimport reqLogin, reqUserInfo from @/api/userimport GET_TOKEN, SET_TOKEN from @/utils/tokenimport UserState from ./type/typeimport constantRoute from @/router/router// 创建用户小仓库const useUserStore = defineStore(UserStore, // 用户仓库存储数据地方 state(): UserState return token: GET_TOKEN(), menuRoutes: constantRoute, username: , avatar: , , // 处理异步|逻辑地方 actions: // 获取用户信息 async userInfoAction() const result = await reqUserInfo() if (result.code === 200) this.username = result.data.checkUser.username this.avatar = result.data.checkUser.avatar , , getters: ,)// 对外暴露小仓库export default useUserStore 修改请求携带token信息 此前获取用户信息，未携带token会获取不到用户信息 src\\utils\\request.ts import axios from axiosimport ElMessage from element-plusimport useUserStore from @/store/modules/user//创建axios实例const request = axios.create( baseURL: import.meta.env.VITE_APP_BASE_API, timeout: 5000,)//请求拦截器request.interceptors.request.use((config) = //获取用户相关的小仓库，获取token，登录成功以后携带个i服务器 const userStore = useUserStore() if (userStore.token) config.headers.token = userStore.token //config配置对象，headers请求头，经常给服务器端携带公共参数 //返回配置对象 return config) home组件挂载获取用户信息 登录之后页面（home）上来就要获取用户信息。并且将它使用到页面中 src\\views\\home\\index.vue template div一级路由home/div/templatescript setup lang=tsimport onMounted from vueimport useUserStore from @/store/modules/userconst userStore = useUserStore()onMounted(() = userStore.userInfoAction())/script 修改设置组件中的用户信息 src\\layout\\tabbar\\setting\\index.vue template img :src=userStore.avatar style=width: 24px; height: 24px; margin: 0px 10px / !-- 下拉菜单 -- el-dropdown span class=el-dropdown-link userStore.username el-icon class=el-icon--right arrow-down / /el-icon /span template #dropdown el-dropdown-menu el-dropdown-item退出登陆/el-dropdown-item /el-dropdown-menu /template /el-dropdown/templatescript setup lang=tsimport useSettingStore from @/store/modules/settingimport useUserStore from @/store/modules/userimport useStore from element-plus/es/components/table/src/store/index.mjsconst userStore = useUserStore()/script 7.2 退出登录 绑定退出登录按钮点击事件 src\\layout\\tabbar\\setting\\index.vue template !-- 下拉菜单 -- el-dropdown template #dropdown el-dropdown-menu el-dropdown-item @click=logout退出登陆/el-dropdown-item /el-dropdown-menu /template /el-dropdown/templatescript setup lang=tsimport useSettingStore from @/store/modules/settingimport useUserStore from @/store/modules/userimport useRouter, useRoute from vue-routerconst userStore = useUserStore()// 退出登录const router = useRouter()const route = useRoute()const logout = () = //第一件事：需要项服务器发请求【退出登录接口】（我们这里没有） //第二件事：仓库当中和关于用户的相关的数据清空 userStore.userLogoutAction() //第三件事：跳转到登陆页面 router.push( path: /login, query: redirect: route.path )/script 携带的query参数方便下次登陆时直接跳转到当时推出的界面 清空用户信息 src\\store\\modules\\user.ts // src/store/modules/user.ts// 创建用户相关的仓库import defineStore from piniaimport loginForm, loginResponseData from @/api/user/typeimport reqLogin, reqUserInfo from @/api/userimport GET_TOKEN, SET_TOKEN, REMOVE_TOKEN from @/utils/tokenimport UserState from ./type/typeimport constantRoute from @/router/router// 创建用户小仓库const useUserStore = defineStore(UserStore, // 用户仓库存储数据地方 state(): UserState return token: GET_TOKEN(), menuRoutes: constantRoute, username: , avatar: , // 用户头像 , // 处理异步|逻辑地方 actions: // 退出登录 userLogoutAction() //当前没有mock接口（不做）：服务器数据token失效 //本地数据清空 this.token = this.username = this.avatar = REMOVE_TOKEN() , , getters: ,)// 对外暴露小仓库export default useUserStore 添加清除token方法 src\\utils\\token.ts export const REMOVE_TOKEN = () = localStorage.removeItem(TOKEN) 登录时判断是否有query参数 src\\views\\login\\index.vue script setup lang=tsconst router = useRouter()const route = useRoute()let userStore = useUserStore()// 登录const login = async () = //保证全部表单项校验通过 await loginFormRef.value.validate() loadType.value = true try await userStore.userLoginAction(loginForm) //编程式导航跳转到展示数据首页 //判断登录的时候,路由路径当中是否有query参数，如果有就往query参数挑战，没有跳转到首页 let redirect: any = route.query.redirect router.push( path: redirect || / ) ElNotification( type: success, message: 欢迎回来, title: `HI,$getTime()好`, ) loadType.value = false catch (error) loadType.value = false ElNotification( type: error, message: (error as Error).message, ) /script 此时不在首页界面退出登录会有登录后再登录获取不到用户信息的bug，后面修复 7.3 路由鉴权 安装进度条组件 pnpm i nprogress 新建permisstion.ts src\\permisstion.ts //路由鉴权：鉴权：项目当中路由能不能被访问的权限import router from @/routerimport setting from ./settingimport nprogress from nprogress//引入进度条样式import nprogress/nprogress.css//进度条的加载圆圈不要nprogress.configure( showSpinner: false )//获取用户相关的小仓库内部token数据，去判断用户是否登陆成功import useUserStore from @/store/modules/user//为什么要引piniaimport pinia from ./storeconst userStore = useUserStore(pinia)//全局前置守卫router.beforeEach(async (to: any, from: any, next: any) = //网页的名字 document.title = `$setting.title-$to.meta.title` //访问某一个路由之前的守卫 nprogress.start() //获取token，去判断用户登录、还是未登录 const token = userStore.token //获取用户名字 const username = userStore.username //用户登录判断 if (token) //登陆成功，访问login。指向首页 if (to.path == /login) next(/home) else //登陆成功访问其余的，放行 //有用户信息 if (username) //放行 next() else //如果没有用户信息，在收尾这里发请求获取到了用户信息再放行 try //获取用户信息 await userStore.userInfoAction() next() catch (error) //token过期|用户手动处理token //退出登陆-用户相关的数据清空 userStore.userLogoutAction() next( path: /login, query: redirect: to.path ) else //用户未登录 if (to.path == /login) next() else next( path: /login, query: redirect: to.path ) next())//全局后置守卫router.afterEach((to: any, from: any) = // to and from are both route objects. nprogress.done())//第一个问题：任意路由切换实现进度条业务 ----nprogress//第二个问题：路由鉴权//全部路由组件 ：登录|404|任意路由|首页|权限管理（三个子路由）|//用户未登录 ：可以访问login 其余都不行//登陆成功：不可以访问login 其余都可以 问题？ 不引入pinia时 全局路由守卫将获取用户信息的请求放在了跳转之前。实现了刷新后用户信息丢失的功能 7.4 替代真实接口 修改服务名 .env.development VITE_SERVE = http://sph-api.atguigu.cn .env.production VITE_SERVE = http://sph-api.atguigu.cn .env.test VITE_SERVE = http://sph-api.atguigu.cn 代理跨域 https://cn.vitejs.dev/config/server-options.html#server-proxy vite.config.ts // vite.config.tsimport defineConfig, loadEnv from viteexport default defineConfig(( command, mode ) = //获取各种环境下的对应的变量 const env = loadEnv(mode, process.cwd()) return //代理跨域 server: proxy: [env.VITE_APP_BASE_API]: //获取数据服务器地址的设置 target: env.VITE_SERVE, //需要代理跨域 changeOrigin: true, //路径重写 rewrite: (path) = path.replace(/^\\/api/, ), , [env.VITE_APP_BASE_API]: //获取数据服务器地址的设置 target: env.VITE_SERVE, //需要代理跨域 changeOrigin: true, //路径重写 rewrite: (path) = path.replace(/^\\/api/, ), , , , ) 根据接口文档重写数据类型 http://139.198.104.58:8212/swagger-ui.html#!/index45controller/loginUsingPOST src\\api\\user\\type.ts //登录接口需要携带参数类型export interface loginFormData username: string password: string//定义全部接口返回数据都有的数据类型export interface ResponseData code: number message: string ok: boolean//定义登录接口返回数据类型export interface loginResponseData extends ResponseData data: string//定义获取用户信息返回的数据类型export interface userInfoResponseData extends ResponseData data: routes: string[] button: string[] roles: string[] name: string avatar: string 修改登录请求数据类型 src\\api\\user\\index.ts // 同一管理用户相关的接口import request from @/utils/requestimport loginFormData, loginResponseData, userInfoResponseData from ./type// 统一管理APIenum API // LOGIN_URL = /user/login, // USERINFO_URL = user/info, LOGIN_URL = /admin/acl/index/login, USERINFO_URL = /admin/acl/index/info, LOGOUT_URL = /admin/acl/index/logout,// 暴露请求函数// 登录接口export const reqLogin = (data: loginFormData) = request.postany, loginResponseData(API.LOGIN_URL, data)// 获取用户信息接口export const reqUserInfo = () = request.getany, userInfoResponseData(API.USERINFO_URL) src\\store\\modules\\user.ts // src/store/modules/user.ts// 创建用户相关的仓库import defineStore from piniaimport loginFormData, loginResponseData, userInfoResponseData, from @/api/user/typeimport reqLogin, reqUserInfo from @/api/userimport GET_TOKEN, SET_TOKEN, REMOVE_TOKEN from @/utils/tokenimport UserState from ./type/typeimport constantRoute from @/router/router// 创建用户小仓库const useUserStore = defineStore(UserStore, // 用户仓库存储数据地方 state(): UserState return token: GET_TOKEN(), menuRoutes: constantRoute, username: , avatar: , // 用户头像 , // 处理异步|逻辑地方 actions: // 用户登录 async userLoginAction(data: loginFormData) const result: loginResponseData = await reqLogin(data) if (result.code === 200) this.token = result.data as string //localStorage.setItem(TOKEN, this.token) SET_TOKEN(this.token) return OK else return Promise.reject(new Error(result.data)) , // 获取用户信息 async userInfoAction() const result: userInfoResponseData = await reqUserInfo() if (result.code === 200) this.username = result.data.name this.avatar = result.data.avatar else return Promise.reject(new Error(result.message)) , // 退出登录 userLogoutAction() //当前没有mock接口（不做）：服务器数据token失效 //本地数据清空 this.token = this.username = this.avatar = REMOVE_TOKEN() , , getters: ,)// 对外暴露小仓库export default useUserStore 7.5 退出登录 添加退出登录API src\\api\\user\\index.ts // 同一管理用户相关的接口import request from @/utils/requestimport ResponseData, from ./type// 统一管理APIenum API LOGOUT_URL = /admin/acl/index/logout,//退出登录export const reqLogout = () = return request.postany, ResponseData(API.LOGOUT_URL) 修改退出登录点击事件 src\\layout\\tabbar\\setting\\index.vue template !-- 下拉菜单 -- el-dropdown span class=el-dropdown-link userStore.username el-icon class=el-icon--right arrow-down / /el-icon /span template #dropdown el-dropdown-menu el-dropdown-item @click=logout退出登陆/el-dropdown-item /el-dropdown-menu /template /el-dropdown/templatescript setup lang=ts// 退出登录const router = useRouter()const route = useRoute()const logout = async () = //第一件事：需要项服务器发请求【退出登录接口】 //第二件事：仓库当中和关于用户的相关的数据清空 await userStore.userLogoutAction() //第三件事：跳转到登陆页面 router.push( path: /login, query: redirect: route.path )/script 注意：需要添加await阻塞退出登录方法 修改permisstion.ts await userStore.userLogoutAction() src\\permisstion.ts //全局前置守卫router.beforeEach(async (to: any, from: any, next: any) = //网页的名字 document.title = `$setting.title-$to.meta.title` //访问某一个路由之前的守卫 nprogress.start() //获取token，去判断用户登录、还是未登录 const token = userStore.token //获取用户名字 const username = userStore.username //用户登录判断 if (token) //登陆成功，访问login。指向首页 if (to.path == /login) next(/home) else //登陆成功访问其余的，放行 //有用户信息 if (username) //放行 next() else //如果没有用户信息，在收尾这里发请求获取到了用户信息再放行 try ... catch (error) //token过期|用户手动处理token //退出登陆-用户相关的数据清空 await userStore.userLogoutAction() next( path: /login, query: redirect: to.path ) else ... )//全局后置守卫// eslint-disable-next-line @typescript-eslint/no-unused-varsrouter.afterEach((to: any, from: any) = // to and from are both route objects. nprogress.done())//第一个问题：任意路由切换实现进度条业务 ----nprogress//第二个问题：路由鉴权//全部路由组件 ：登录|404|任意路由|首页|权限管理（三个子路由）|//用户未登录 ：可以访问login 其余都不行//登陆成功：不可以访问login 其余都可以 8. 品牌管理8.1 品牌数据展示 添加品牌管理界面 https://element-plus.org/zh-CN/component/card.html#%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95 https://element-plus.org/zh-CN/component/table.html https://element-plus.org/zh-CN/component/pagination.html src\\views\\product\\trademark\\index.vue template el-card class=box-card !-- 卡片顶部添加品牌按钮 -- el-button type=primary size=default icon=Plus添加品牌/el-button !-- 表格组件，用于展示已有的数据 -- !-- table ---border:是否有纵向的边框 table-column ---lable：某一个列表 ---width：设置这一列的宽度 ---align：设置这一列对齐方式 -- el-table style=margin: 10px 0px border el-table-column label=序号 width=80px align=center /el-table-column el-table-column label=品牌名称/el-table-column el-table-column label=品牌LOGO/el-table-column el-table-column label=品牌操作/el-table-column /el-table !-- 分页器组件 -- !-- pagination ---v-model:current-page：设置当前分页器页码 ---v-model:page-size:设置每一也展示数据条数 ---page-sizes：每页显示个数选择器的选项设置 ---background:背景颜色 ---layout：分页器6个子组件布局的调整 -把后面的子组件顶到右侧 -- el-pagination v-model:current-page=pageNo v-model:page-size=limit :page-sizes=[3, 5, 7, 9] :background=true layout= prev, pager, next, jumper,-,total, sizes, :total=400 / /el-card/templatescript setup lang=ts//引入组合式API函数import ref from vue//当前页码let pageNo = refnumber(1)//每一页展示的数据let limit = refnumber(3)/scriptstyle lang=scss scoped/style 定义品牌接口数据类型 src\\api\\product\\trademark\\type.ts export interface ResponseData code: number message: string ok: boolean//已有的品牌的ts数据类型export interface TradeMark id?: number tmName: string logoUrl: string//包含全部品牌数据的ts类型export type Records = TradeMark[]//获取的已有全部品牌的数据ts类型export interface TradeMarkResponseData extends ResponseData data: records: Records total: number size: number current: number searchCount: boolean pages: number 定义获取品牌数据接口 src\\api\\product\\trademark\\index.ts //书写品牌管理模块接口import request from @/utils/requestimport type TradeMarkResponseData from ./type//品牌管理模块接口地址enum API //获取已有品牌接口 TRADEMARK_URL = /admin/product/baseTrademark/,//获取已有品牌的接口方法//page:获取第几页 ---默认第一页//limit:获取几个已有品牌的数据export const reqHasTrademark = (page: number, limit: number) = request.getany, TradeMarkResponseData( API.TRADEMARK_URL + `$page/$limit`, ) 渲染展示界面 src\\views\\product\\trademark\\index.vue template el-card class=box-card !-- 卡片顶部添加品牌按钮 -- el-button type=primary size=default icon=Plus添加品牌/el-button !-- 表格组件，用于展示已有的数据 -- !-- table ---border:是否有纵向的边框 table-column ---lable：某一个列表 ---width：设置这一列的宽度 ---align：设置这一列对齐方式 -- el-table style=margin: 10px 0px border :data=trademarkArr el-table-column label=序号 width=80px align=center prop=id /el-table-column el-table-column label=品牌名称 prop=tmName/el-table-column el-table-column label=品牌LOGO !-- https://lianyutian.github.io/posts/dd58b23f.html 10.4作用域插槽 -- template #default= row img :src=row.logoUrl style=width: 100px; height: 100px / /template /el-table-column el-table-column label=品牌操作 template #default= el-button type=primary size=small icon=Edit/el-button el-button type=primary size=small icon=Delete/el-button /template /el-table-column /el-table !-- 分页器组件 -- !-- pagination ---v-model:current-page：设置当前分页器页码 ---v-model:page-size:设置每一也展示数据条数 ---page-sizes：每页显示个数选择器的选项设置 ---background:背景颜色 ---layout：分页器6个子组件布局的调整 -把后面的子组件顶到右侧 -- el-pagination v-model:current-page=pageNo v-model:page-size=limit :page-sizes=[3, 5, 7, 9] :background=true layout= prev, pager, next, jumper,-,total, sizes, :total=total @current-change=getHasTrademark @size-change=sizeChange / /el-card/templatescript setup lang=tsimport reqHasTrademark from @/api/product/trademark// 引入组合式API函数import ref, onMounted from vue// 当前页码let pageNo = refnumber(1)// 每一页展示的数据let limit = refnumber(3)// 存储已有品牌数据总数let total = refnumber(0)// 存储已有品牌的数据let trademarkArr = refany([])// 获取已有品牌的接口封装为一个函数:在任何情况下向获取数据,调用次函数即可// 父子组件通信 https://lianyutian.github.io/posts/dd58b23f.html 8.3子传父const getHasTrademark = async (page = 1) = // 当前页码 pageNo.value = page let result = await reqHasTrademark(pageNo.value, limit.value) if (result.code == 200) //存储已有品牌总个数 total.value = result.data.total trademarkArr.value = result.data.records // 当下拉菜单发生变化的时候触发此方法// 这个自定义事件,分页器组件会将下拉菜单选中数据返回const sizeChange = () = // 当前每一页的数据量发生变化的时候，当前页码归1 getHasTrademark()// 组件挂载完毕钩子---发一次请求,获取第一页、一页三个已有品牌数据onMounted(() = getHasTrademark())/scriptstyle lang=scss scoped/style current-change方法触发时，它会给父组件传递并注入一个参数（点击的页码），相当于把这个参数传递给了getHasTrademark函数，因此能够跳转到正确的页码数 8.2 新增品牌 添加对话框界面 https://element-plus.org/zh-CN/component/dialog.html#dialog-%E5%AF%B9%E8%AF%9D%E6%A1%86 https://element-plus.org/zh-CN/component/upload.html#%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95 src\\views\\product\\trademark\\index.vue template !-- 对话框组件:在添加品牌与修改已有品牌的业务时候使用结构 -- !-- v-model:属性用户控制对话框的显示与隐藏的 true显示 false隐藏 title:设置对话框左上角标题 -- el-dialog v-model=dialogFormVisible title=添加品牌 el-form style=width: 80% el-form-item label=品牌名称 label-width=80px el-input / /el-form-item el-form-item label=品牌LOGO label-width=80px el-upload class=avatar-uploader action=https://run.mocky.io/v3/9d059bf9-4660-45f2-925d-ce80ad6c4d15 :show-file-list=false :on-success=handleAvatarSuccess :before-upload=beforeAvatarUpload img v-if=imageUrl :src=imageUrl class=avatar / el-icon v-else class=avatar-uploader-iconPlus //el-icon /el-upload /el-form-item /el-form !-- https://lianyutian.github.io/posts/dd58b23f.html 10.3具名插槽 -- template #footer span class=dialog-footer el-button @click=dialogFormVisible = false取消/el-button el-button type=primary @click=dialogFormVisible = false 确认 /el-button /span /template /el-dialog/templatescript setup lang=ts// 引入组合式API函数import ref from vue// 对话框是否展示let dialogFormVisible = ref(false)/scriptstyle.avatar-uploader .el-upload border: 1px dashed var(--el-border-color); border-radius: 6px; cursor: pointer; position: relative; overflow: hidden; transition: var(--el-transition-duration-fast);.avatar-uploader .el-upload:hover border-color: var(--el-color-primary);.el-icon.avatar-uploader-icon font-size: 28px; color: #8c939d; width: 178px; height: 178px; text-align: center;/style 添加新增品牌API src\\api\\product\\trademark\\index.ts //书写品牌管理模块接口import request from @/utils/requestimport type TradeMarkResponseData, TradeMark from ./type//品牌管理模块接口地址enum API //添加品牌 ADDTRADEMARK_URL = /admin/product/baseTrademark/save, //修改已有品牌 UPDATETRADEMARK_URL = /admin/product/baseTrademark/update,//添加与修改已有品牌接口方法export const reqAddOrUpdateTrademark = (data: TradeMark) = //修改已有品牌的数据 if (data.id) return request.putany, any(API.UPDATETRADEMARK_URL, data) else //新增品牌 return request.postany, any(API.ADDTRADEMARK_URL, data) 绑定对话框数据 src\\views\\product\\trademark\\index.vue script setup lang=ts// 对话框功能逻辑let dialogFormVisible = ref(false)// 定义收集新增品牌数据let trademarkParams = reactiveTradeMark( tmName: , logoUrl: ,)/script 绑定品牌及图片上传事件 src\\views\\product\\trademark\\index.vue template el-card class=box-card !-- 卡片顶部添加品牌按钮 -- el-button type=primary size=default icon=Plus @click=addTrademark 添加品牌 /el-button /el-card !-- 对话框组件:在添加品牌与修改已有品牌的业务时候使用结构 -- !-- v-model:属性用户控制对话框的显示与隐藏的 true显示 false隐藏 title:设置对话框左上角标题 -- el-dialog v-model=dialogFormVisible title=添加品牌 el-form style=width: 80% el-form-item label=品牌名称 label-width=80px el-input v-model=trademarkParams.tmName / /el-form-item el-form-item label=品牌LOGO label-width=80px !-- class：带的一些样式，需复制到style中 action：图片上传路径需要书写/api,否则代理服务器不发送这次post请求 :show-file-list：是否展示已经上传的文件 :on-success：图片上传成功钩子（收集了上传图片的地址） :before-upload：上传图片之前的钩子函数 -- el-upload class=avatar-uploader action=api/admin/product/fileUpload :show-file-list=false :on-success=handleAvatarSuccess :before-upload=beforeAvatarUpload img v-if=trademarkParams.logoUrl :src=trademarkParams.logoUrl class=avatar / el-icon v-else class=avatar-uploader-iconPlus //el-icon /el-upload /el-form-item /el-form !-- https://lianyutian.github.io/posts/dd58b23f.html 10.3具名插槽 -- template #footer span class=dialog-footer el-button @click=dialogFormVisible = false取消/el-button el-button type=primary @click=confirm确认/el-button /span /template /el-dialog/templatescript setup lang=ts// 对话框功能逻辑let dialogFormVisible = ref(false)// 定义收集新增品牌数据let trademarkParams = reactiveTradeMark( tmName: , logoUrl: ,)//添加品牌按钮的回调const addTrademark = () = //对话框显示 dialogFormVisible.value = true //清空收集数据 trademarkParams.tmName = trademarkParams.logoUrl = //上传图片组件-上传图片之前触发的钩子函数const beforeAvatarUpload: UploadProps[beforeUpload] = (rawFile) = //钩子是在图片上传成功之前触发,上传文件之前可以约束文件类型与大小 //要求:上传文件格式png|jpg|gif 4M if ( rawFile.type == image/png || rawFile.type == image/jpeg || rawFile.type == image/gif ) if (rawFile.size / 1024 / 1024 4) return true else ElMessage( type: error, message: 上传文件大小小于4M, ) return false else ElMessage( type: error, message: 上传文件格式务必PNG|JPG|GIF, ) return false //图片上传成功钩子const handleAvatarSuccess: UploadProps[onSuccess] = (response) = //response:即为当前这次上传图片post请求服务器返回的数据 //收集上传图片的地址,添加一个新的品牌的时候带给服务器 trademarkParams.logoUrl = response.data //图片上传成功,清除掉对应图片校验结果 //formRef.value.clearValidate(logoUrl)//确认添加品牌const confirm = async () = //在你发请求之前,要对于整个表单进行校验 //调用这个方法进行全部表单相校验,如果校验全部通过，在执行后面的语法 // await formRef.value.validate() let result: any = await reqAddOrUpdateTrademark(trademarkParams) //添加|修改已有品牌 if (result.code == 200) //关闭对话框 dialogFormVisible.value = false //弹出提示信息 ElMessage( type: success, message: trademarkParams.id ? 修改品牌成功 : 添加品牌成功, ) //再次发请求获取已有全部的品牌数据 getHasTrademark(trademarkParams.id ? pageNo.value : 1) else //添加品牌失败 ElMessage( type: error, message: trademarkParams.id ? 修改品牌失败 : 添加品牌失败, ) //关闭对话框 dialogFormVisible.value = false /script 8.3 修改品牌 绑定点击事件 template el-table-column label=品牌操作 !-- row 回传编辑数据 -- template #default= row el-button type=primary size=small icon=Edit @click=updateTrademark(row) /el-button el-button type=primary size=small icon=Delete/el-button /template /el-table-column/templatescript setup lang=ts//修改品牌//row:row即为当前已有的品牌const updateTrademark = async (row: TradeMark) = //对话框显示 dialogFormVisible.value = true //ES6语法合并对象 Object.assign(trademarkParams, row)/script 8.4 品牌表单校验 绑定参数 https://element-plus.org/zh-CN/component/form.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99 :model：校验的数据 :rules：校验规则 ref”formRef”：表单实例 prop：表单元素校验的数据，可以直接使用表单绑定的数据 el-form style=width: 80% :model=trademarkParams :rules=rules ref=formRef el-form-item label=品牌名称 label-width=80px prop=tmName el-input placeholder=请输入品牌名称 v-model=trademarkParams.tmName / /el-form-item el-form-item label=品牌LOGO label-width=80px prop=logoUrl ... /el-form-item /el-form 添加自定义规则 //品牌自定义校验规则方法const validatorTmName = (rule: any, value: any, callBack: any) = //是当表单元素触发blur时候,会触发此方法 //自定义校验规则 if (value.trim().length = 2) callBack() else //校验未通过返回的错误的提示信息 callBack(new Error(品牌名称位数大于等于两位)) //品牌LOGO图片的自定义校验规则方法const validatorLogoUrl = (rule: any, value: any, callBack: any) = //如果图片上传 if (value) callBack() else callBack(new Error(LOGO图片务必上传)) 添加rules //表单校验规则对象const rules = tmName: [ //required:这个字段务必校验,表单项前面出来五角星 //trigger:代表触发校验规则时机[blur、change] required: true, trigger: blur, validator: validatorTmName , ], logoUrl: [ required: true, validator: validatorLogoUrl ], 问题1 图片校验时机 因为img是图片，不好判断。因此使用表单的validate属性，全部校验，放在确认按钮的回调函数中 const confirm = async () = //在你发请求之前,要对于整个表单进行校验 //调用这个方法进行全部表单相校验,如果校验全部通过，在执行后面的语法 await formRef.value.validate() ... 问题2 清除校验信息1 当图片没有上传点击确认后会出来校验的提示信息，我们上传图片后校验信息应该消失。使用表单的clearValidate属性 //图片上传成功钩子const handleAvatarSuccess: UploadProps[onSuccess] = ( ...) = ... //图片上传成功,清除掉对应图片校验结果 formRef.value.clearValidate(logoUrl) 清除校验信息2 当我们未填写信息去点击确认按钮时，会弹出2个校验信息。当我们关闭后再打开，校验信息还在。因为，我们需要在添加品牌按钮时清除校验信息。但是因为点击添加品牌，表单还没有加载，所以我们需要换个写法。 //添加品牌按钮的回调const addTrademark = () = //对话框显示 dialogFormVisible.value = true //清空收集数据 trademarkParams.id = 0 trademarkParams.tmName = trademarkParams.logoUrl = //第一种写法:ts的问号语法 formRef.value?.clearValidate(tmName) formRef.value?.clearValidate(logoUrl) /* nextTick(() = formRef.value.clearValidate(tmName) formRef.value.clearValidate(logoUrl) ) */ 同理，修改按钮也需要清除校验信息 //修改已有品牌的按钮的回调//row:row即为当前已有的品牌const updateTrademark = (row: TradeMark) = //清空校验规则错误提示信息 nextTick(() = formRef.value.clearValidate(tmName) formRef.value.clearValidate(logoUrl) ) ... 8.5 删除品牌 添加API src\\api\\product\\trademark\\index.ts //书写品牌管理模块接口import request from @/utils/requestimport type TradeMarkResponseData, TradeMark from ./type//品牌管理模块接口地址enum API //删除已有品牌 DELETE_URL = /admin/product/baseTrademark/remove/,//删除某一个已有品牌的数据export const reqDeleteTrademark = (id: number) = request.deleteany, any(API.DELETE_URL + id) 添加气泡组件 https://element-plus.org/zh-CN/component/popconfirm.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%B9%E5%87%BA%E6%A1%86%E7%9A%84%E5%86%85%E5%AE%B9 src\\views\\product\\trademark\\index.vue template el-card class=box-card el-table el-table-column label=品牌操作 !-- row 回传编辑数据 -- template #default= row el-button type=primary size=small icon=Edit @click=updateTrademark(row) /el-button el-popconfirm :title=`您确定要删除$row.tmName?` width=250px icon=Delete @confirm=removeTradeMark(row.id) template #reference el-button type=primary size=small icon=Delete/el-button /template /el-popconfirm /template /el-table-column /el-table /el-card/template 绑定删除事件 script setup lang=ts// 删除品牌//气泡确认框确定按钮的回调const removeTradeMark = async (id: number) = //点击确定按钮删除已有品牌请求 let result = await reqDeleteTrademark(id) if (result.code == 200) //删除成功提示信息 ElMessage( type: success, message: 删除品牌成功, ) //再次获取已有的品牌数据 getHasTrademark( trademarkArr.value.length 1 ? pageNo.value : pageNo.value - 1, ) else ElMessage( type: error, message: 删除品牌失败, ) /script 9. 属性管理 属性管理分为上面部分的三级分类模块以及下面的添加属性部分。我们将三级分类模块单独提取出来做成全局组件 9.1 三级分类组件 添加静态界面 src\\components\\Category\\index.vue template !-- 三级分类全局组件-- Category/Category el-card style=margin: 10px 0px el-button type=primary size=default icon=Plus添加属性/el-button el-table border style=margin: 10px 0px el-table-column label=序号 type=index align=center width=80px /el-table-column el-table-column label=属性名称 width=120px/el-table-column el-table-column label=属性值名称/el-table-column el-table-column label=操作 width=120px/el-table-column /el-table /el-card/templatescript setup lang=ts/scriptstyle lang=scss scoped/style src\\views\\product\\attr\\index.vue template !-- 三级分类全局组件-- Category/Category el-card style=margin: 10px 0px el-button type=primary size=default icon=Plus添加属性/el-button el-table border style=margin: 10px 0px el-table-column label=序号 type=index align=center width=80px /el-table-column el-table-column label=属性名称 width=120px/el-table-column el-table-column label=属性值名称/el-table-column el-table-column label=操作 width=120px/el-table-column /el-table /el-card/templatescript setup lang=ts/scriptstyle lang=scss scoped/style 全局配置中引入组件 src\\components\\index.ts import SvgIcon from ./SvgIcon/index.vueimport Category from ./Category/index.vueimport type App, Component from vue//引入element-plus提供全部图标组件import * as ElementPlusIconsVue from @element-plus/icons-vueconst components: [name: string]: Component = SvgIcon, Category 添加获取分类接口类型 src\\api\\product\\attr\\type.ts //分类相关的数据ts类型export interface ResponseData code: number message: string ok: boolean//分类ts类型export interface CategoryObj id: number | string name: string category1Id?: number category2Id?: number//相应的分类接口返回数据的类型export interface CategoryResponseData extends ResponseData data: CategoryObj[] 添加获取获取分类接口 src\\api\\product\\attr\\index.ts //这里书写属性相关的API文件import request from @/utils/requestimport CategoryResponseData from ./type//属性管理模块接口地址enum API //获取一级分类接口地址 C1_URL = /admin/product/getCategory1, //获取二级分类接口地址 C2_URL = /admin/product/getCategory2/, //获取三级分类接口地址 C3_URL = /admin/product/getCategory3/,//获取一级分类的接口方法export const reqC1 = () = request.getany, CategoryResponseData(API.C1_URL)//获取二级分类的接口方法export const reqC2 = (category1Id: number | string) = return request.getany, CategoryResponseData(API.C2_URL + category1Id)//获取三级分类的接口方法export const reqC3 = (category2Id: number | string) = return request.getany, CategoryResponseData(API.C3_URL + category2Id) 引入pinia 为什么要使用pinia呢？ 在下面的添加属性那部分，父组件要用到三级分类组件的信息（id），所以将数据放在pinia中是最方便的。 添加CategoryState类型 src\\store\\modules\\type\\type.ts //定义分类仓库state对象的ts类型export interface CategoryState c1Id: string | number c1Arr: CategoryObj[] c2Arr: CategoryObj[] c2Id: string | number c3Arr: CategoryObj[] c3Id: string | number 添加store action src\\store\\modules\\category.ts //商品分类全局组件的小仓库import defineStore from piniaimport reqC1, reqC2, reqC3 from @/api/product/attrimport CategoryResponseData from @/api/product/attr/typeimport CategoryState from ./type/typeconst useCategoryStore = defineStore(Category, state(): CategoryState return //存储一级分类的数据 c1Arr: [], //存储一级分类的ID c1Id: , c2Arr: [], c2Id: , c3Arr: [], c3Id: , , actions: //获取一级分类的方法 async getC1Action() //发请求获取一级分类的数据 const result: CategoryResponseData = await reqC1() if (result.code == 200) this.c1Arr = result.data , //获取二级分类的方法 async getC2Action(category1Id: string | number) //发请求获取一级分类的数据 const result: CategoryResponseData = await reqC2(category1Id) if (result.code == 200) this.c2Arr = result.data , //获取三级分类的方法 async getC3Action(category2Id: string | number) //发请求获取一级分类的数据 const result: CategoryResponseData = await reqC3(category2Id) if (result.code == 200) this.c3Arr = result.data , , getters: ,)export default useCategoryStore 渲染一级分类 src\\components\\Category\\index.vue template el-card el-form inline el-form-item label=一级分类 el-select v-model=categoryStore.c1Id !-- label:即为展示数据 value:即为select下拉菜单收集的数据 -- el-option v-for=c1 in categoryStore.c1Arr :key=c1.id :label=c1.name :value=c1.id /el-option /el-select /el-form-item /el-form /el-card/templatescript setup lang=ts//引入组件挂载完毕方法import onMounted from vue//引入分类相关的仓库import useCategoryStore from @/store/modules/categorylet categoryStore = useCategoryStore()//分类全局组件挂载完毕,通知仓库发请求获取一级分类的数据onMounted(() = getC1())//通知仓库获取一级分类的方法const getC1 = () = //通知分类仓库发请求获取一级分类的数据 categoryStore.getC1Action()/scriptstyle lang=scss scoped/style 渲染二级和三级分类 二级分类需要首先拿到一级分类的id，再根据一级分类id查询二级分类 一级分类选定时会触发change函数（https://element-plus.org/zh-CN/component/select.html#select-events） src\\components\\Category\\index.vue template el-card el-form inline el-form-item label=一级分类 el-select v-model=categoryStore.c1Id @change=handler !-- label:即为展示数据 value:即为select下拉菜单收集的数据 -- el-option v-for=c1 in categoryStore.c1Arr :key=c1.id :label=c1.name :value=c1.id /el-option /el-select /el-form-item el-form-item label=二级分类 el-select v-model=categoryStore.c2Id @change=handler2 !-- label:即为展示数据 value:即为select下拉菜单收集的数据 -- el-option v-for=c2 in categoryStore.c2Arr :key=c2.id :label=c2.name :value=c2.id /el-option /el-select /el-form-item el-form-item label=三级分类 el-select v-model=categoryStore.c3Id !-- label:即为展示数据 value:即为select下拉菜单收集的数据 -- el-option v-for=c3 in categoryStore.c3Arr :key=c3.id :label=c3.name :value=c3.id /el-option /el-select /el-form-item /el-form /el-card/templatescript setup lang=ts//引入组件挂载完毕方法import onMounted from vue//引入分类相关的仓库import useCategoryStore from @/store/modules/categorylet categoryStore = useCategoryStore()//分类全局组件挂载完毕,通知仓库发请求获取一级分类的数据onMounted(() = getC1())//通知仓库获取一级分类的方法const getC1 = () = //通知分类仓库发请求获取一级分类的数据 categoryStore.getC1Action()//二级分类//此方法即为一级分类下拉菜单的change事件(选中值的时候会触发,保证一级分类ID有了)//会将一级分类的id回传const handler = (value: string | number) = //通知仓库获取二级分类的数据 categoryStore.getC2Action(value)//三级分类//此方法即为二级分类下拉菜单的change事件(选中值的时候会触发,保证二级分类ID有了)const handler2 = (value: string | number) = //通知仓库获取三级分类的数据 categoryStore.getC3Action(value)/scriptstyle lang=scss scoped/style 问题 当我们选择好三级菜单后，此时修改一级菜单。二、三级菜单应该清空。修改二级菜单，三级菜单应该清空。 src\\components\\Category\\index.vue script setup lang=ts// 二级分类//此方法即为一级分类下拉菜单的change事件(选中值的时候会触发,保证一级分类ID有了)const handler = (value: string | number) = //需要将二级、三级分类的数据清空 categoryStore.c2Id = categoryStore.c3Arr = [] categoryStore.c3Id = //通知仓库获取二级分类的数据 categoryStore.getC2Action(value)// 三级分类//此方法即为二级分类下拉菜单的change事件(选中值的时候会触发,保证二级分类ID有了)const handler2 = (value: string | number) = //需要将三级分类的数据清空 categoryStore.c3Arr = [] categoryStore.c3Id = //通知仓库获取三级分类的数据 categoryStore.getC3Action(value)/script 没选择好三级菜单之前，添加属性按钮应该处于禁用状态 src\\views\\product\\attr\\index.vue template !-- 三级分类全局组件-- Category/Category el-card style=margin: 10px 0px el-button type=primary size=default icon=Plus :disabled=categoryStore.c3Id ? false : true 添加属性 /el-button /el-card/templatescript setup lang=tsimport useCategoryStore from @/store/modules/categoryconst categoryStore = useCategoryStore()/scriptstyle lang=scss scoped/style 9.2 展示属性 属性类型 src\\api\\product\\attr\\type.ts //属性值对象的ts类型export interface AttrValue id?: number valueName: string attrId?: number flag?: boolean//存储每一个属性值的数组类型export type AttrValueList = AttrValue[]//属性对象export interface Attr id?: number attrName: string categoryId: number | string categoryLevel: number attrValueList: AttrValueList//存储每一个属性对象的数组ts类型export type AttrList = Attr[]//属性接口返回的数据ts类型export interface AttrResponseData extends ResponseData data: Attr[] 添加请求API src\\api\\product\\attr\\index.ts //这里书写属性相关的API文件import request from @/utils/requestimport AttrResponseData, CategoryResponseData from ./type//属性管理模块接口地址enum API //获取分类下已有的属性与属性值 ATTR_URL = /admin/product/attrInfoList/,//获取对应分类下已有的属性与属性值接口export const reqAttr = ( category1Id: string | number, category2Id: string | number, category3Id: string | number,) = return request.getany, AttrResponseData( API.ATTR_URL + `$category1Id/$category2Id/$category3Id`, ) 渲染属性展示界面 src\\views\\product\\attr\\index.vue template !-- 三级分类全局组件-- Category/Category el-card style=margin: 10px 0px el-button type=primary size=default icon=Plus :disabled=categoryStore.c3Id ? false : true 添加属性 /el-button el-table border style=margin: 10px 0px :data=attrArr el-table-column label=序号 type=index align=center width=80px /el-table-column el-table-column label=属性名称 width=120px prop=attrName /el-table-column el-table-column label=属性值名称 !-- row：已有的属性对象 -- template #default= row el-tag style=margin: 5px v-for=item in row.attrValueList :key=item.id item.valueName /el-tag /template /el-table-column el-table-column label=操作 width=120px !-- row：已有的属性对象 -- template #default !-- 修改已有属性的按钮 -- el-button type=primary size=small icon=Edit/el-button el-button type=primary size=small icon=Delete/el-button /template /el-table-column /el-table /el-card/templatescript setup lang=tsimport useCategoryStore from @/store/modules/categoryimport watch, ref from vueimport reqAttr from @/api/product/attrimport AttrResponseData, Attr from @/api/product/attr/typeconst categoryStore = useCategoryStore()// 监听c3Id变化watch( () = categoryStore.c3Id, () = //清空上一次查询的属性与属性值 attrArr.value = [] //保证三级分类得有才能发请求 if (!categoryStore.c3Id) return //获取分类的ID getAttr() ,)//存储已有的属性与属性值let attrArr = refAttr[]([])//获取已有的属性与属性值方法const getAttr = async () = const c1Id, c2Id, c3Id = categoryStore //获取分类下的已有的属性与属性值 let result: AttrResponseData = await reqAttr(c1Id, c2Id, c3Id) if (result.code == 200) attrArr.value = result.data /scriptstyle lang=scss scoped/style 属性展示时机：需要等三级分类确认后才取请求数据，需要监听c3Id c3Id变化时需要清除上次的属性展示 需要保证只有在c3Id数据不为空时才去请求属性数据 9.3 添加属性 添加属性值的总体思路是：收集表单的数据（绑定对应的表单项等）- 发送请求（按钮回调函数，携带的参数）-更新页面 静态页面 src\\views\\product\\attr\\index.vue el-card style=margin: 10px 0px div ... /div div !-- 展示添加属性与修改数据的结构 -- el-form :inline=true el-form-item label=属性名称 el-input placeholder=请你输入属性名称/el-input /el-form-item /el-form el-button type=primary size=default icon=Plus 添加属性值 /el-button el-button type=primary size=default取消/el-button el-table border style=margin: 10px 0px el-table-column label=序号 width=80px type=index align=center /el-table-column el-table-column label=属性值名称 !-- row:即为当前属性值对象 -- template el-input size=small placeholder=请你输入属性值名称/el-input /template /el-table-column el-table-column label=属性值操作 template el-button type=primary size=small icon=Delete/el-button /template /el-table-column /el-table el-button type=primary size=default保存/el-button el-button type=primary size=default取消/el-button /div /el-card 定义变量控制展示属性管理界面还是添加属性界面 src\\views\\product\\attr\\index.vue // 定义变量控制添加属性界面是否展示,定义card组件内容切换变量let scene = refnumber(0) //scene=0,显示table,scene=1,展示添加与修改属性结构 绑定控制属性 template !-- 三级分类全局组件-- Category/Category el-card style=margin: 10px 0px div v-if=scene === 0 !-- 展示属性管理 -- ... /div div v-if=scene === 1 !-- 展示添加属性与修改数据的结构 -- ... /div /el-card/template 进入添加属性界面时，三级分类按钮应该处于禁用状态。将父组件中scene传递给子组件Category template !-- 三级分类全局组件-- Category :scene=scene/Category/template 子组件接收scene，并根据scene值控制选项是否禁用 src\\components\\Category\\index.vue template el-card el-form inline el-form-item label=一级分类 el-select :disabled=scene === 0 ? false : true v-model=categoryStore.c1Id @change=handler ... /el-select /el-form-item el-form-item label=二级分类 el-select :disabled=scene === 0 ? false : true v-model=categoryStore.c2Id @change=handler2 ... /el-select /el-form-item el-form-item label=三级分类 el-select :disabled=scene === 0 ? false : true v-model=categoryStore.c3Id ... /el-select /el-form-item /el-form /el-card/templatescript setup lang=ts//接收父组件传递的是否禁用标识defineProps([scene])/scriptstyle lang=scss scoped/style 添加属性按钮绑定点击事件 src\\views\\product\\attr\\index.vue template !-- 三级分类全局组件-- Category :scene=scene/Category el-card style=margin: 10px 0px div v-if=scene === 0 el-button type=primary size=default icon=Plus :disabled=categoryStore.c3Id ? false : true @click=addAttr 添加属性 /el-button ... /div ... /el-card/templatescript setup lang=ts//定义变量控制添加属性界面是否展示,定义card组件内容切换变量let scene = refnumber(0) //scene=0,显示table,scene=1,展示添加与修改属性结构//添加属性按钮回调const addAttr = () = //切换为添加与修改属性的结构 scene.value = 1/scriptstyle lang=scss scoped/style 点击添加属性值时，列表中添加一条属性 定义变量收集属性值列表数据 //收集新增的属性的数据let attrParams = reactiveAttr( attrName: , //新增的属性的名字 attrValueList: [ //新增的属性值数组 ], categoryId: , //三级分类的ID categoryLevel: 3, //代表的是三级分类) 添加属性值按钮绑定点击事件 每次点击添加属性值按钮时，新增一条空数据 template div v-if=scene === 1 !-- 展示添加属性与修改数据的结构 -- el-form :inline=true el-form-item label=属性名称 el-input placeholder=请你输入属性名称 /el-input /el-form-item /el-form el-button type=primary size=default icon=Plus @click=addAttrValue 添加属性值 /el-button ...\t/div/templatescrpit setup lang=ts //添加属性值 const addAttrValue = () = attrParams.attrValueList.push( valueName: , )/scrpit 渲染属性列表 template !-- 三级分类全局组件-- Category :scene=scene/Category el-card style=margin: 10px 0px div v-if=scene === 0 ... /div div v-if=scene === 1 !-- 展示添加属性与修改数据的结构 -- el-form :inline=true el-form-item label=属性名称 el-input placeholder=请你输入属性名称 v-model=attrParams.attrName /el-input /el-form-item /el-form el-button type=primary size=default icon=Plus @click=addAttrValue 添加属性值 /el-button el-button type=primary size=default取消/el-button el-table border style=margin: 10px 0px :data=attrParams.attrValueList el-table-column label=序号 width=80px type=index align=center /el-table-column el-table-column label=属性值 !-- row:即为当前属性值对象 -- template #default= row el-input size=small placeholder=请你输入属性值 v-model=row.valueName /el-input /template /el-table-column el-table-column label=属性值操作 template #default el-button type=primary size=small icon=Delete /el-button /template /el-table-column /el-table el-button type=primary size=default 保存 /el-button el-button type=primary size=default取消/el-button /div /el-card/template 切换属性值展示形态 属性值输入框失去焦点时将输入框切换成直接展示属性值 添加静态界面 el-table-column label=属性值 !-- row:即为当前属性值对象 -- template #default= row, $index el-input size=small placeholder=请你输入属性值 v-model=row.valueName v-if=row.flag /el-input div v-else row.valueName /div /template/el-table-column flag放在哪？由于每一个属性值对象都需要一个flag属性，因此将flag的添加放在添加属性值的按钮的回调上。（注意修改属性值的type） src\\api\\product\\attr\\type.ts //属性值对象的ts类型export interface AttrValue id?: number valueName: string attrId?: number flag?: boolean src\\views\\product\\attr\\index.vue //添加属性值const addAttrValue = () = attrParams.attrValueList.push( valueName: , flag: true, //控制每一个属性值编辑模式与切换模式的切换 ) 属性输入框失去焦点时需要切换成直接展示，点击属性值时切换成输入框 template el-table-column label=属性值 !-- row:即为当前属性值对象 -- template #default= row, $index el-input size=small placeholder=请你输入属性值 v-model=row.valueName v-if=row.flag @blur=toLook(row, $index) /el-input div v-else @click=toEdit(row, $index) row.valueName /div /template /el-table-column/template scrpit setup lang=ts//属性值表单元素失却焦点事件回调const toLook = (row: AttrValue, $index: number) = //相应的属性值对象flag:变为false,展示div row.flag = false//属性值div点击事件const toEdit = (row: AttrValue, $index: number) = //相应的属性值对象flag:变为true,展示input row.flag = true/scrpit 控制点击属性值时输入框自动聚焦 template el-table-column label=属性值 !-- row:即为当前属性值对象 -- template #default= row, $index el-input size=small placeholder=请你输入属性值 v-model=row.valueName v-if=row.flag @blur=toLook(row, $index) :ref=(inupt: any) = (inputArr[$index] = inupt) /el-input div v-else @click=toEdit(row, $index) row.valueName /div /template /el-table-column/template scrpit setup lang=ts//准备一个数组:将来存储对应的组件实例el-inputlet inputArr = refany([])//属性值div点击事件const toEdit = (row: AttrValue, $index: number) = //相应的属性值对象flag:变为true,展示input row.flag = true //nextTick:响应式数据发生变化,获取更新的DOM(组件实例) nextTick(() = inputArr.value[$index].focus() )/scrpit 属性值操作绑定点击事件 点击时将属性值数组中去除该条数据 el-table-column label=属性值操作 template #default= index el-button type=primary size=small icon=Delete @click=attrParams.attrValueList.splice(index, 1) /el-button /template/el-table-column 绑定保存按钮点击事件 界面 el-button type=primary size=default @click=save(attrParams) 保存/el-button 添加API src\\api\\product\\attr\\index.ts //这里书写属性相关的API文件import request from @/utils/requestimport AttrResponseData, CategoryResponseData from ./type//属性管理模块接口地址enum API //添加或者修改已有的属性的接口 ADDORUPDATEATTR_URL = /admin/product/saveAttrInfo,//新增或者修改已有的属性接口export const reqAddOrUpdateAttr = (data: Attr) = request.postany, any(API.ADDORUPDATEATTR_URL, data) 定义点击事件函数 //保存属性按钮回调const save = async (attrParams: Attr) = //发请求 let result: any = await reqAddOrUpdateAttr(attrParams) //添加属性|修改已有的属性已经成功 if (result.code == 200) //切换场景 scene.value = 0 //提示信息 ElMessage( type: success, message: attrParams.id ? 修改成功 : 添加成功, ) //获取全部已有的属性与属性值（更新页面） getAttr() else ElMessage( type: error, message: attrParams.id ? 修改失败 : 添加失败, ) 9.4 修改属性 绑定修改按钮点击事件 el-table-column label=操作 width=120px !-- row：已有的属性对象 -- template #default= row !-- 修改已有属性的按钮 -- el-button type=primary size=small icon=Edit @click=updateAttr(row) /el-button /template/el-table-column 定义函数 //table表格修改已有属性按钮的回调const updateAttr = (row: Attr) = //切换为添加与修改属性的结构 scene.value = 1 //将已有的属性对象赋值给attrParams对象即为 //ES6-Object.assign进行对象的合并 Object.assign(attrParams, JSON.parse(JSON.stringify(row))) 9.5 删除属性 绑定点击事件 el-table-column label=操作 width=120px el-popconfirm :title=`你确定删除$row.attrName` width=200px @confirm=deleteAttr(row.id) template #reference el-button type=primary size=small icon=Delete /el-button /template /el-popconfirm /template/el-table-column 定义API //这里书写属性相关的API文件import request from @/utils/requestimport AttrResponseData, CategoryResponseData from ./type//属性管理模块接口地址enum API //删除某一个已有的属性 DELETEATTR_URL = /admin/product/deleteAttr/,//删除某一个已有的属性业务export const reqRemoveAttr = (attrId: number) = request.deleteany, any(API.DELETEATTR_URL + attrId) 定义点击函数 //删除某一个已有的属性方法回调const deleteAttr = async (attrId: number) = //发相应的删除已有的属性的请求 let result: any = await reqRemoveAttr(attrId) //删除成功 if (result.code == 200) ElMessage( type: success, message: 删除成功, ) //获取一次已有的属性与属性值 getAttr() else ElMessage( type: error, message: 删除失败, ) 9.6 添加校验 无属性名称时，禁用添加属性值按钮 el-button type=primary size=default icon=Plus @click=addAttrValue :disabled=attrParams.attrName === ? true : false 添加属性值/el-button 添加属性值时，校验属性值是否为空 // 非法校验const check = (len: number) = //非法情况判断1 if (attrParams.attrValueList[len - 1].valueName.trim() == ) //删除调用对应属性值为空的元素 attrParams.attrValueList.splice(len - 1, 1) //提示信息 ElMessage( type: error, message: 属性值不能为空, ) return //添加属性值const addAttrValue = () = // 校验如果是 const len = attrParams.attrValueList.length if (len = 1) //非法情况判断1 check(len) attrParams.attrValueList.push( valueName: , flag: true, //控制每一个属性值编辑模式与切换模式的切换 ) 属性值输入框失去焦点时校验 //属性值表单元素失却焦点事件回调const toLook = (row: AttrValue, $index: number) = //非法情况判断1 if (row.valueName.trim() == ) //删除调用对应属性值为空的元素 attrParams.attrValueList.splice($index, 1) //提示信息 ElMessage( type: error, message: 属性值不能为空, ) return //非法情况2 let repeat = attrParams.attrValueList.find((item) = //切记把当前失却焦点属性值对象从当前数组扣除判断 if (item != row) return item.valueName === row.valueName ) if (repeat) //将重复的属性值从数组当中干掉 attrParams.attrValueList.splice($index, 1) //提示信息 ElMessage( type: error, message: 属性值不能重复, ) return //相应的属性值对象flag:变为false,展示div row.flag = false 9.7 功能完善 添加属性时，自动聚焦到属性值输入框 //添加属性值const addAttrValue = () = // 校验如果是 const len = attrParams.attrValueList.length if (len = 1) //非法情况判断1 check(len) attrParams.attrValueList.push( valueName: , flag: true, //控制每一个属性值编辑模式与切换模式的切换 ) nextTick(() = inputArr.value[len].focus() ) 添加属性按钮增加id属性，清空id否则会出现先点击修改属性，再点击新增属性会变成修改属性 //添加属性按钮回调const addAttr = () = //每一次点击的时候,先清空一下数据再收集数据，主要收集三级分类的ID Object.assign(attrParams, attrName: , //新增的属性的名字 attrValueList: [ //新增的属性值数组 ], categoryId: categoryStore.c3Id, //三级分类的ID categoryLevel: 3, //代表的是三级分类 id: null, ) //切换为添加与修改属性的结构 scene.value = 1 添加取消按钮逻辑 添加属性值的取消 清空属性值列表 el-button type=primary size=default @click=attrParams.attrValueList = [] 取消/el-button 取消返回属性展示界面 el-button type=primary size=default @click=scene = 0 取消/el-button 路由切换时清空分类仓库 //路由组件销毁的时候，把仓库分类相关的数据清空onBeforeUnmount(() = //清空仓库的数据 categoryStore.$reset()) 10. SPU管理10.1 SPU展示 静态页面 src\\views\\product\\spu\\index.vue template div !-- 三级分类 -- Category :scene=scene/Category el-card style=margin: 10px 0px el-button type=primary size=default icon=Plus添加SPU/el-button el-table border style=margin: 10px 0px el-table-column label=序号 type=index align=center width=80px /el-table-column el-table-column label=SPU名称/el-table-column el-table-column label=SPU描述/el-table-column el-table-column label=SPU操作/el-table-column /el-table /el-card !-- 分页器 -- el-pagination v-model:current-page=pageNo v-model:page-size=pageSize :page-sizes=[3, 5, 7, 9] :background=true layout= prev, pager, next, jumper,-, sizes,total :total=400 / /div/templatescript setup lang=tsimport ref from vue//场景的数据let scene = refnumber(0)//分页器默认页码let pageNo = refnumber(1)//每一页展示几条数据let pageSize = refnumber(3)/scriptstyle lang=scss scoped/style SPU数据类型 src\\api\\product\\spu\\type.ts //服务器全部接口返回的数据类型export interface ResponseData code: number message: string ok: boolean//SPU数据的ts类型:需要修改export interface SpuData category3Id: number id?: number spuName: string tmId: number description: string spuImageList: null spuSaleAttrList: null//数组:元素都是已有SPU数据类型export type Records = SpuData[]//定义获取已有的SPU接口返回的数据ts类型export interface HasSpuResponseData extends ResponseData data: records: Records total: number size: number current: number searchCount: boolean pages: number 获取SPU API src\\api\\product\\spu\\index.ts //SPU管理模块的接口import request from @/utils/requestimport type HasSpuResponseData from ./typeenum API //获取已有的SPU的数据 HASSPU_URL = /admin/product/,//获取某一个三级分类下已有的SPU数据export const reqHasSpu = ( page: number, limit: number, category3Id: string | number,) = return request.getany, HasSpuResponseData( API.HASSPU_URL + `$page/$limit?category3Id=$category3Id`, ) 渲染展示界面 src\\views\\product\\spu\\index.vue template div !-- 三级分类 -- Category :scene=scene/Category el-card style=margin: 10px 0px el-button type=primary size=default icon=Plus :disabled=categoryStore.c3Id ? false : true 添加SPU /el-button el-table border style=margin: 10px 0px :data=records el-table-column label=序号 type=index align=center width=80px /el-table-column el-table-column label=SPU名称 prop=spuName/el-table-column el-table-column label=SPU描述 prop=description/el-table-column el-table-column label=SPU操作/el-table-column /el-table /el-card !-- 分页器 -- el-pagination v-model:current-page=pageNo v-model:page-size=pageSize :page-sizes=[3, 5, 7, 9] :background=true layout=prev, pager, next, jumper,-, sizes,total :total=total @current-change=getHasSpu @size-change=changeSize / /div/templatescript setup lang=tsimport ref, watch from vueimport useCategoryStore from @/store/modules/categoryimport reqHasSpu from @/api/product/spuimport HasSpuResponseData from @/api/product/spu/type//分类仓库数据const categoryStore = useCategoryStore()//场景的数据let scene = refnumber(0)//分页器默认页码let pageNo = refnumber(1)//每一页展示几条数据let pageSize = refnumber(3)// 存储已有品牌数据总数let total = refnumber(0)// 存储已有SPU的数据let records = refany([])//此方法执行:可以获取某一个三级分类下全部的已有的SPUconst getHasSpu = async (pager = 1) = console.log(pager) //修改当前页码 pageNo.value = pager let result: HasSpuResponseData = await reqHasSpu( pageNo.value, pageSize.value, categoryStore.c3Id, ) if (result.code == 200) records.value = result.data.records total.value = result.data.total // 监听c3Id变化watch( () = categoryStore.c3Id, () = //清空上一次查询的SPU records.value = [] //保证三级分类得有才能发请求 if (!categoryStore.c3Id) return //获取SPU getHasSpu() ,)//分页器下拉菜单发生变化的时候触发const changeSize = () = getHasSpu()/scriptstyle lang=scss scoped/style 10.2 添加SPU子组件 原因 由于SPU模块需要在三个场景进行切换，全都放在一个组件里面的话会显得很臃肿。因此我们将它放到三个组件当中。 使用v-show来展示页面：v-if是销毁组件，v-show是隐藏组件。在初加载的时候v-if比较快，但是在频繁切换的时候v-if任务重。 静态界面 src\\views\\product\\spu\\spuForm.vue template el-card style=margin: 10px 0px el-form label-width=100px el-form-item label=SPU名称 el-input placeholder=请你输入SPU名称/el-input /el-form-item el-form-item label=SPU品牌 el-select el-option label=华为/el-option el-option label=oppo/el-option el-option label=vivo/el-option /el-select /el-form-item el-form-item label=SPU描述 el-input type=textarea placeholder=请你输入SPU描述/el-input /el-form-item el-form-item label=SPU图片 el-upload action=https://run.mocky.io/v3/9d059bf9-4660-45f2-925d-ce80ad6c4d15 list-type=picture-card el-iconPlus //el-icon /el-upload el-dialog img w-full src= alt=Preview Image / /el-dialog /el-form-item el-form-item label=SPU销售属性 size=normal !-- 展示销售属性的下拉菜单 -- el-select el-option label=华为/el-option el-option label=oppo/el-option el-option label=vivo/el-option /el-select el-button style=margin-left: 10px type=primary size=default icon=Plus 添加属性 /el-button !-- table展示销售属性与属性值的地方 -- el-table border style=margin: 10px 0px el-table-column label=序号 type=index align=center width=80px /el-table-column el-table-column label=销售属性名字 width=120px prop=saleAttrName /el-table-column el-table-column label=销售属性值 !-- row:即为当前SPU已有的销售属性对象 -- /el-table-column el-table-column label=操作 width=120px/el-table-column /el-table /el-form-item el-form-item el-button type=primary size=default保存/el-button el-button type=primary size=default 取消 /el-button /el-form-item /el-form /el-card/templatescript setup lang=ts/script 添加、修改SPU按钮绑定点击事件 src\\views\\product\\spu\\index.vue template div !-- 三级分类 -- Category :scene=scene/Category !-- SPU展示页面 -- div v-show=scene === 0 el-card style=margin: 10px 0px el-button type=primary size=default icon=Plus :disabled=categoryStore.c3Id ? false : true @click=addSpu 添加SPU /el-button el-table border style=margin: 10px 0px :data=records el-table-column label=序号 type=index align=center width=80px /el-table-column el-table-column label=SPU名称 prop=spuName/el-table-column el-table-column label=SPU描述 prop=description/el-table-column el-table-column label=SPU操作 !-- row 回传编辑数据 -- template #default= row el-button type=primary size=small icon=Edit @click=updateSpu /el-button /template /el-table-column /el-table /el-card /div !-- SPU编辑页面 -- SpuForm v-show=scene === 1 @changeScene=changeScene/SpuForm !-- 分页器 -- el-pagination v-model:current-page=pageNo v-model:page-size=pageSize :page-sizes=[3, 5, 7, 9] :background=true layout=prev, pager, next, jumper,-, sizes,total :total=total @current-change=getHasSpu @size-change=changeSize / /div/template script setup lang=ts//添加新的SPU按钮的回调const addSpu = () = //切换为场景1:添加与修改已有SPU结构-SpuForm scene.value = 1//修改已有的SPU的按钮的回调const updateSpu = () = //切换为场景1:添加与修改已有SPU结构-SpuForm scene.value = 1const changeScene = () = scene.value = 0/script 子组件取消按钮回调 src\\views\\product\\spu\\spuForm.vue template el-button size=default @click=cancle 取消 /el-button/template script setup lang=ts//定义子传父const emit = defineEmits([changeScene])//取消按钮的回调const cancle = () = emit(changeScene, 0)/script 10.3 添加SPU模块类型API10.3.1 SPU品牌 类型 src\\api\\product\\spu\\type.ts //品牌数据的TS类型export interface Trademark id: number tmName: string logoUrl: string//品牌接口返回的数据ts类型export interface AllTradeMark extends ResponseData data: Trademark[] API src\\api\\product\\spu\\index.ts enum API //获取已有的SPU的数据 HASSPU_URL = /admin/product/, //获取全部品牌的数据 ALLTRADEMARK_URL = /admin/product/baseTrademark/getTrademarkList,//获取全部的SPU的品牌的数据export const reqAllTradeMark = () = return request.getany, AllTradeMark(API.ALLTRADEMARK_URL) 10.3.2 SPU图片 类型 //商品图片的ts类型export interface SpuImg id?: number imgName?: string imgUrl?: string createTime?: string updateTime?: string spuId?: number//已有的SPU的照片墙数据的类型export interface SpuHasImg extends ResponseData data: SpuImg[] API enum API //获取已有的SPU的数据 HASSPU_URL = /admin/product/, //获取全部品牌的数据 ALLTRADEMARK_URL = /admin/product/baseTrademark/getTrademarkList, //获取某个SPU下的全部的售卖商品的图片数据 IMAGE_URL = /admin/product/spuImageList/,//获取某一个已有的SPU下全部商品的图片地址export const reqSpuImageList = (spuId: number) = return request.getany, SpuHasImg(API.IMAGE_URL + spuId) 10.3.3 全部销售属性 类型 //已有的全部SPU的返回数据ts类型export interface HasSaleAttr id: number name: stringexport interface HasSaleAttrResponseData extends ResponseData data: HasSaleAttr[] API enum API //获取已有的SPU的数据 HASSPU_URL = /admin/product/, //获取全部品牌的数据 ALLTRADEMARK_URL = /admin/product/baseTrademark/getTrademarkList, //获取某个SPU下的全部的售卖商品的图片数据 IMAGE_URL = /admin/product/spuImageList/, //获取整个项目全部的销售属性[颜色、版本、尺码] ALLSALEATTR_URL = /admin/product/baseSaleAttrList,//获取全部的销售属性export const reqAllSaleAttr = () = return request.getany, HasSaleAttrResponseData(API.ALLSALEATTR_URL) 10.3.4 销售属性及其值列表 类型 export interface SpuSaleAttrValue id?: number createTime?: Date updateTime?: Date spuId?: number baseSaleAttrId: number saleAttrValueName: string saleAttrName?: string isChecked?: boolean//销售属性对象ts类型export interface SaleAttr id?: number createTime?: string updateTime?: string spuId?: number baseSaleAttrId: number saleAttrName: string spuSaleAttrValueList: SpuSaleAttrValue[] flag?: boolean//SPU已有的销售属性接口返回数据ts类型export interface SaleAttrResponseData extends ResponseData data: SaleAttr[] API enum API //获取已有的SPU的数据 HASSPU_URL = /admin/product/, //获取全部品牌的数据 ALLTRADEMARK_URL = /admin/product/baseTrademark/getTrademarkList, //获取某个SPU下的全部的售卖商品的图片数据 IMAGE_URL = /admin/product/spuImageList/, //获取整个项目全部的销售属性[颜色、版本、尺码] ALLSALEATTR_URL = /admin/product/baseSaleAttrList, //获取某一个SPU下全部的已有的销售属性接口地址 SPUHASSALEATTR_URL = /admin/product/spuSaleAttrList/,//获取某一个已有的SPU拥有多少个销售属性export const reqSpuHasSaleAttr = (spuId: number) = return request.getany, SaleAttrResponseData(API.SPUHASSALEATTR_URL + spuId) 10.4 获取SPU的数据 说明 SPU的数据应该分为5部分： 第一部分：父组件中的展示的数据，当我们点击编辑SPU按钮时需要从父组件（展示SPU页面）传递到添加SPU页面 其余四部分由10.3中接口获取 问题1：子组件需要用到父组件中的数据，应该怎么办？ 要传递的数据是指定的，也就是我们点击修改时的数据。通过ref的方式，拿到子组件时的实例，再调用子组件暴露的方\t法将数据做为参数传递过去。 问题2：其余4个部分的数据什么时候获取？ 同样的在点击修改按钮时获取，问题一中通过调用子组件的函数传递数据，我们同时也在这个函数中发请求得到数据 数据 父组件传递数据 src\\views\\product\\spu\\index.vue !-- SPU展示页面 --div v-show=scene === 0 el-card style=margin: 10px 0px ... el-table-column label=SPU操作 !-- row 回传编辑数据 -- template #default= row el-button type=primary size=small icon=Edit @click=updateSpu(row) /el-button /template /el-table-column /el-card/div!-- SPU编辑页面 --SpuForm v-show=scene === 1 ref=spu @changeScene=changeScene/SpuForm 子组件对外暴露初始化数据函数 src\\api\\product\\spu\\type.ts //SPU数据的ts类型:需要修改export interface SpuData category3Id: number id?: number spuName: string tmId: number description: string spuImageList: null | SpuImg[] spuSaleAttrList: null | SaleAttr[] src\\views\\product\\spu\\spuForm.vue //存储已有的SPU这些数据let allTradeMark = refTrademark[]([])//商品图片let imgList = refSpuImg[]([])//已有的SPU销售属性let saleAttr = refSaleAttr[]([])//全部销售属性let allSaleAttr = refHasSaleAttr[]([])//存储已有的SPU对象let spuParams = refSpuData( category3Id: 0, //收集三级分类的ID spuName: , //SPU的名字 description: , //SPU的描述 tmId: , //品牌的ID spuImageList: [], spuSaleAttrList: [],)//子组件数据初始化方法const initHasSpuData = async (spu: SpuData) = //存储已有的SPU对象,将来在模板中展示 spuParams.value = spu //spu:即为父组件传递过来的已有的SPU对象[不完整] //获取全部品牌的数据 let result: AllTradeMark = await reqAllTradeMark() //获取某一个品牌旗下全部售卖商品的图片 let result1: SpuHasImg = await reqSpuImageList(spu.id as number) //获取已有的SPU销售属性的数据 let result2: SaleAttrResponseData = await reqSpuHasSaleAttr(spu.id as number) //获取整个项目全部SPU的销售属性 let result3: HasSaleAttrResponseData = await reqAllSaleAttr() //存储全部品牌的数据 allTradeMark.value = result.data //SPU对应商品图片 imgList.value = result1.data.map((item) = return name: item.imgName as string, url: item.imgUrl, ) //存储已有的SPU的销售属性 saleAttr.value = result2.data //存储全部的销售属性 allSaleAttr.value = result3.data//对外暴露defineExpose( initHasSpuData ) 父组件点击编辑时同时调用子组件暴露的方法 //获取子组件实例const spu = refany()//修改已有的SPU的按钮的回调const updateSpu = (row: SpuData) = //切换为场景1:添加与修改已有SPU结构-SpuForm scene.value = 1 //调用子组件实例方法获取完整已有的SPU的数据 spu.value.initHasSpuData(row) 10.5 渲染添加SPU页面10.5.1 渲染品牌、名称、图片墙 渲染页面 src\\views\\product\\spu\\spuForm.vue template el-card style=margin: 10px 0px el-form label-width=100px el-form-item label=SPU名称 el-input placeholder=请你输入SPU名称 v-model=spuParams.spuName /el-input /el-form-item el-form-item label=SPU品牌 el-select v-model=spuParams.tmId el-option v-for=item in allTradeMark :label=item.tmName :key=item.id :value=item.id /el-option /el-select /el-form-item el-form-item label=SPU描述 el-input type=textarea placeholder=请你输入SPU描述 v-model=spuParams.description /el-input /el-form-item el-form-item label=SPU图片 el-upload list-type=picture-card v-model:file-list=imgList action=api/admin/product/fileUpload :on-preview=handlePictureCardPreview :before-upload=handlerUpload el-iconPlus //el-icon /el-upload !-- 预览照片 -- el-dialog v-model=dialogVisible img :src=dialogImageUrl alt=Preview Image style=width: 100%; height: 100% / /el-dialog /el-form-item ... /el-form /el-card/templatescript setup lang=ts//控制对话框的显示与隐藏let dialogVisible = refboolean(false)//存储预览图片地址let dialogImageUrl = refstring()//照片墙点击预览按钮的时候触发的钩子const handlePictureCardPreview = (file: any) = dialogImageUrl.value = file.url //对话框弹出来 dialogVisible.value = true//照片上传成功之前的钩子约束文件的大小与类型const handlerUpload = (file: any) = if ( file.type == image/png || file.type == image/jpeg || file.type == image/gif ) if (file.size / 1024 / 1024 3) return true else ElMessage( type: error, message: 上传文件务必小于3M, ) return false else ElMessage( type: error, message: 上传文件务必PNG|JPG|GIF, ) return false /script 10.5.2 渲染销售属性 已有属性列表 template ... el-form-item label=SPU销售属性 !-- table展示销售属性与属性值的地方 -- el-table border style=margin: 10px 0px :data=saleAttr el-table-column label=序号 type=index align=center width=80px /el-table-column el-table-column label=销售属性名字 width=120px prop=saleAttrName /el-table-column el-table-column label=销售属性值 !-- row:即为当前SPU已有的销售属性对象 -- template #default= row, index el-tag style=margin: 5px v-for=item in row.spuSaleAttrValueList :key=item.id closable @close=row.spuSaleAttrValueList.splice(index, 1) item.saleAttrValueName /el-tag /template /el-table-column el-table-column label=操作 width=120px template #default= index el-button type=danger size=small icon=Delete @click=saleAttr.splice(index, 1) /el-button /template /el-table-column /el-table /el-form-item .../templatescript setup lang=ts/script 销售属性列表中添加按钮与input的切换 script setup lang=ts//获取属性值输入框实例const inputRef = ref()//属性值按钮的点击事件const toEdit = (row: SaleAttr) = //点击按钮的时候,input组件就出来-编辑模式 row.flag = true row.saleAttrValue = //点击按钮后自动聚焦到输入框 nextTick(() = inputRef.value.focus() )//表单元素失却焦点的事件回调const toLook = (row: SaleAttr) = //整理收集的属性的ID与属性值的名字 const baseSaleAttrId, saleAttrValue = row //整理成服务器需要的属性值形式 let newSaleAttrValue: SpuSaleAttrValue = baseSaleAttrId: baseSaleAttrId as number, saleAttrValueName: saleAttrValue as string, //非法情况判断 if ((saleAttrValue as string).trim() == ) ElMessage( type: error, message: 属性值不能为空的, ) return //判断属性值是否在数组当中存在 let repeat = row.spuSaleAttrValueList.find((item) = return item.saleAttrValueName == saleAttrValue ) if (repeat) ElMessage( type: error, message: 属性值重复, ) return //追加新的属性值对象 row.spuSaleAttrValueList.push(newSaleAttrValue) //切换为查看模式 row.flag = false/script 计算出还未拥有的销售属性 //计算出当前SPU还未拥有的销售属性let unSelectSaleAttr = computed(() = //全部销售属性:颜色、版本、尺码 //已有的销售属性:颜色、版本 let unSelectArr = allSaleAttr.value.filter((item) = return saleAttr.value.every((item1) = return item.name != item1.saleAttrName ) ) return unSelectArr) 10.5.3 保存 API src\\api\\product\\spu\\index.ts //SPU管理模块的接口import request from @/utils/requestimport type HasSpuResponseData from ./typeenum API //追加一个新的SPU ADDSPU_URL = /admin/product/saveSpuInfo, //更新已有的SPU UPDATESPU_URL = /admin/product/updateSpuInfo,//添加一个新的SPU的//更新已有的SPU接口//data:即为新增的SPU|或者已有的SPU对象export const reqAddOrUpdateSpu = (data: any) = //如果SPU对象拥有ID,更新已有的SPU if (data.id) return request.postany, any(API.UPDATESPU_URL, data) else return request.postany, any(API.ADDSPU_URL, data) 保整理数据+发送请求+通知父组件更新页面 //保存按钮的回调const save = async () = //整理参数 //发请求:添加SPU|更新已有的SPU //成功 //失败 //1:照片墙的数据 spuParams.value.spuImageList = imgList.value.map((item: any) = return imgName: item.name, //图片的名字 imgUrl: (item.response item.response.data) || item.url, ) //2:整理销售属性的数据 spuParams.value.spuSaleAttrList = saleAttr.value let result = await reqAddOrUpdateSpu(spuParams.value) if (result.code == 200) ElMessage( type: success, message: spuParams.value.id ? 更新成功 : 添加成功, ) //通知父组件切换场景为0 emit(changeScene, flag: 0, ) else ElMessage( type: success, message: spuParams.value.id ? 更新成功 : 添加成功, ) 跳转页面 在添加和修改spu属性后，跳转的页面不一样。修改应该跳转到当前页面，添加应该跳转到第一页。如何区分？spuParams.value.id属性修改按钮的spuParams是自带这个属性的，而添加按钮没有这个属性。因此在保存的时候通过这个属性告知父组件。 src\\views\\product\\spu\\spuForm.vue //保存按钮的回调const save = async () = ... //通知父组件切换场景为0 $emit(changeScene, flag: 0, params: spuParams.value.id ? update : add, ) ... src\\views\\product\\spu\\index.vue //子组件SpuForm绑定自定义事件:目前是让子组件通知父组件切换场景为0const changeScene = (obj: any) = //子组件Spuform点击取消变为场景0:展示已有的SPU scene.value = obj.flag if (obj.params == update) //更新留在当前页 getHasSpu(pageNo.value) else //添加留在第一页 getHasSpu() 10.5.4 添加SPU 绑定按钮点击事件 添加和修改按钮不同的地方在于对于数据的来源不同，修改按钮是一部分（spuParams）来源于父组件传递的数据，将他们与组件绑定，在数据上展示。添加按钮父组件只需要传递category3Id就行，其他的自己收集。 src\\views\\product\\spu\\index.vue //添加新的SPU按钮的回调const addSpu = () = //切换为场景1:添加与修改已有SPU结构-SpuForm scene.value = 1 //点击添加SPU按钮,调用子组件的方法初始化数据 spu.value.initAddSpu(categoryStore.c3Id) 子组件提供添加时数据初始化方法 src\\views\\product\\spu\\spuForm.vue //添加一个新的SPU初始化请求方法const initAddSpu = async (c3Id: number | string) = //清空数据 Object.assign(spuParams.value, category3Id: , //收集三级分类的ID spuName: , //SPU的名字 description: , //SPU的描述 tmId: , //品牌的ID spuImageList: [], spuSaleAttrList: [], ) //清空照片 imgList.value = [] //清空销售属性 saleAttr.value = [] saleAttrIdAndValueName.value = //存储三级分类的ID spuParams.value.category3Id = c3Id as number //获取全部品牌的数据 let result: AllTradeMark = await reqAllTradeMark() let result1: HasSaleAttrResponseData = await reqAllSaleAttr() //存储数据 allTradeMark.value = result.data allSaleAttr.value = result1.data//对外暴露defineExpose( initHasSpuData, initAddSpu ) 10.6 SKU列表10.6.1 添加SKU12. 用户管理12.1 用户管理展示 静态页面 src\\views\\acl\\user\\index.vue template el-card style=height: 80px el-form :inline=true class=form el-form-item label=用户名: el-input placeholder=请你输入搜索用户名/el-input /el-form-item el-form-item el-button type=primary size=default搜索/el-button el-button size=default @click=reset重置/el-button /el-form-item /el-form /el-card el-card style=margin: 10px 0px el-button type=primary size=default添加用户/el-button el-button type=danger size=default批量删除/el-button !-- table展示用户信息 -- el-table style=margin: 10px 0px border el-table-column type=selection align=center/el-table-column el-table-column label=# align=center type=index/el-table-column el-table-column label=ID align=center/el-table-column el-table-column label=用户名字 align=center show-overflow-tooltip /el-table-column el-table-column label=用户名称 align=center show-overflow-tooltip /el-table-column el-table-column label=用户角色 align=center show-overflow-tooltip /el-table-column el-table-column label=创建时间 align=center show-overflow-tooltip /el-table-column el-table-column label=更新时间 align=center show-overflow-tooltip /el-table-column el-table-column label=操作 width=300px align=center /el-table-column /el-table !-- 分页器 -- el-pagination v-model:current-page=pageNo v-model:page-size=pageSize :page-sizes=[5, 7, 9, 11] :background=true layout=prev, pager, next, jumper,-,sizes,total :total=400 / /el-card/template 用户信息API数据类型 src\\api\\acl\\user\\type.ts //账号信息的ts类型export interface ResponseData code: number message: string ok: boolean//代表一个账号信息的ts类型export interface User id?: number createTime?: string updateTime?: string username?: string password?: string name?: string phone?: null roleName?: string//数组包含全部的用户信息export type Records = User[]//获取全部用户信息接口返回的数据ts类型export interface UserResponseData extends ResponseData data: records: Records total: number size: number current: number pages: number 用户信息API src\\api\\acl\\user\\index.ts //用户管理模块的接口import request from @/utils/requestimport type UserResponseData from ./type//枚举地址enum API //获取全部已有用户账号信息 ALLUSER_URL = /admin/acl/user/,//获取用户账号信息的接口export const reqUserInfo = (page: number, limit: number) = return request.getany, UserResponseData( API.ALLUSER_URL + `$page/$limit`, ) 渲染页面 src\\views\\acl\\user\\index.vue template el-card style=height: 80px el-form :inline=true class=form ref=formRef el-form-item label=用户名: el-input placeholder=请你输入搜索用户名/el-input /el-form-item el-form-item el-button type=primary size=default搜索/el-button el-button size=default @click=reset(formRef)重置/el-button /el-form-item /el-form /el-card el-card style=margin: 10px 0px el-button type=primary size=default 添加用户 /el-button el-button type=danger size=default批量删除/el-button !-- table展示用户信息 -- el-table style=margin: 10px 0px border :data=userArr el-table-column type=selection align=center/el-table-column el-table-column label=序号 align=center type=index /el-table-column el-table-column label=ID align=center prop=id/el-table-column el-table-column label=用户名字 align=center show-overflow-tooltip prop=username /el-table-column el-table-column label=用户名称 align=center show-overflow-tooltip prop=name /el-table-column el-table-column label=用户角色 align=center show-overflow-tooltip prop=roleName /el-table-column el-table-column label=创建时间 align=center show-overflow-tooltip prop=createTime /el-table-column el-table-column label=更新时间 align=center show-overflow-tooltip prop=updateTime /el-table-column el-table-column label=操作 width=300px align=center /el-table-column /el-table !-- 分页器 -- el-pagination v-model:current-page=pageNo v-model:page-size=limit :page-sizes=[3, 5, 7, 9] :background=true layout=prev, pager, next, jumper,-,sizes,total :total=total @current-change=getHasUser @size-change=sizeChange / /el-card/templatescript setup lang=tsimport FormInstance from element-plusimport onMounted, ref from vueimport Records, UserResponseData from @/api/acl/user/typeimport reqUserInfo from @/api/acl/userconst formRef = refFormInstance()const reset = (formEl: FormInstance | undefined) = if (!formEl) return formEl.resetFields()//用户总个数let total = refnumber(0)//存储全部用户的数组let userArr = refRecords([])onMounted(() = getHasUser())// 当前页码let pageNo = refnumber(1)// 每一页展示的数据let limit = refnumber(3)// 存储已有品牌数据总数//获取全部已有的用户信息const getHasUser = async (pager = 1) = //收集当前页码 pageNo.value = pager let result: UserResponseData = await reqUserInfo( pageNo.value, limit.value, /* keyword.value, */ ) if (result.code == 200) total.value = result.data.total userArr.value = result.data.records // 当下拉菜单发生变化的时候触发此方法// 这个自定义事件,分页器组件会将下拉菜单选中数据返回const sizeChange = () = // 当前每一页的数据量发生变化的时候，当前页码归1 getHasUser()/script 12.2 添加用户 静态页面 template el-card style=margin: 10px 0px el-button type=primary size=default @click=addUser 添加用户 /el-button ... /el-card !-- 抽屉结构:完成添加新的用户账号|更新已有的账号信息 -- el-drawer v-model=drawer !-- 头部标题:将来文字内容应该动态的 -- template #header h4添加用户/h4 /template !-- 身体部分 -- template #default el-form el-form-item label=用户姓名 el-input placeholder=请您输入用户姓名/el-input /el-form-item el-form-item label=用户昵称 el-input placeholder=请您输入用户昵称/el-input /el-form-item el-form-item label=用户密码 el-input placeholder=请您输入用户密码/el-input /el-form-item /el-form /template template #footer div style=flex: auto el-button取消/el-button el-button type=primary确定/el-button /div /template /el-drawer/templatescript setup lang=ts...//添加用户const drawer = ref(false)const addUser = () = drawer.value = true/script 数据类型 src\\api\\acl\\user\\type.ts //代表一个账号信息的ts类型export interface User id?: number createTime?: string updateTime?: string username?: string password?: string name?: string phone?: null roleName?: string 添加用户API src\\api\\acl\\user\\index.ts //枚举地址enum API //添加一个新的用户账号 ADDUSER_URL = /admin/acl/user/save, //更新已有的用户账号 UPDATEUSER_URL = /admin/acl/user/update,//添加用户与更新已有用户的接口export const reqAddOrUpdateUser = (data: User) = //携带参数有ID更新 if (data.id) return request.putany, any(API.UPDATEUSER_URL, data) else return request.postany, any(API.ADDUSER_URL, data) 渲染页面 src\\views\\acl\\user\\index.vue template el-card style=margin: 10px 0px el-button type=primary size=default @click=addUser 添加用户 /el-button /el-card !-- 抽屉结构:完成添加新的用户账号|更新已有的账号信息 -- el-drawer v-model=drawer !-- 头部标题:将来文字内容应该动态的 -- template #header h4添加用户/h4 /template !-- 身体部分 -- template #default el-form :model=userParams el-form-item label=用户姓名 el-input placeholder=请您输入用户姓名 v-model=userParams.username /el-input /el-form-item el-form-item label=用户昵称 el-input placeholder=请您输入用户昵称 v-model=userParams.name /el-input /el-form-item el-form-item label=用户密码 el-input placeholder=请您输入用户密码 v-model=userParams.password /el-input /el-form-item /el-form /template template #footer div style=flex: auto el-button @click=drawer = false取消/el-button el-button type=primary @click=save确定/el-button /div /template /el-drawer/templatescript setup lang=ts//添加用户const drawer = ref(false)let formRef = refany()const addUser = () = //抽屉显示出来 drawer.value = true //清空数据 Object.assign(userParams, id: 0, username: , name: , password: , ) //清除上一次的错误的提示信息 nextTick(() = formRef.value.clearValidate(username) formRef.value.clearValidate(name) formRef.value.clearValidate(password) )//收集用户信息的响应式数据let userParams = reactiveUser( username: , name: , password: ,)//保存按钮的回调const save = async () = //保存按钮:添加新的用户|更新已有的用户账号信息 let result: any = await reqAddOrUpdateUser(userParams) //添加或者更新成功 if (result.code == 200) //关闭抽屉 drawer.value = false //提示消息 ElMessage( type: success, message: userParams.id ? 更新成功 : 添加成功, ) //获取最新的全部账号的信息 getHasUser(userParams.id ? pageNo.value : 1) else //关闭抽屉 drawer.value = false //提示消息 ElMessage( type: error, message: userParams.id ? 更新失败 : 添加失败, ) /script 参数校验 template el-card style=margin: 10px 0px el-button type=primary size=default @click=addUser 添加用户 /el-button /el-card !-- 抽屉结构:完成添加新的用户账号|更新已有的账号信息 -- el-drawer v-model=drawer !-- 头部标题:将来文字内容应该动态的 -- template #header h4 userParams.id ? 更新用户 : 添加用户 /h4 /template !-- 身体部分 -- template #default el-form :model=userParams :rules=rules ref=formRef el-form-item label=用户姓名 prop=username el-input placeholder=请您输入用户姓名 v-model=userParams.username /el-input /el-form-item el-form-item label=用户昵称 prop=name el-input placeholder=请您输入用户昵称 v-model=userParams.name /el-input /el-form-item el-form-item label=用户密码 prop=password v-if=!userParams.id el-input placeholder=请您输入用户密码 v-model=userParams.password /el-input /el-form-item /el-form /template template #footer div style=flex: auto el-button @click=drawer = false取消/el-button el-button type=primary @click=save确定/el-button /div /template /el-drawer/templatescript setup lang=ts//添加用户const drawer = ref(false)let formRef = refany()const addUser = () = //抽屉显示出来 drawer.value = true //清空数据 Object.assign(userParams, id: 0, username: , name: , password: , ) //清除上一次的错误的提示信息 nextTick(() = formRef.value.clearValidate(username) formRef.value.clearValidate(name) formRef.value.clearValidate(password) )//收集用户信息的响应式数据let userParams = reactiveUser( username: , name: , password: ,)//保存按钮的回调const save = async () = //点击保存按钮的时候,务必需要保证表单全部复合条件在去发请求 await formRef.value.validate() //保存按钮:添加新的用户|更新已有的用户账号信息 let result: any = await reqAddOrUpdateUser(userParams) //添加或者更新成功 if (result.code == 200) //关闭抽屉 drawer.value = false //提示消息 ElMessage( type: success, message: userParams.id ? 更新成功 : 添加成功, ) //获取最新的全部账号的信息 getHasUser(userParams.id ? pageNo.value : 1) else //关闭抽屉 drawer.value = false //提示消息 ElMessage( type: error, message: userParams.id ? 更新失败 : 添加失败, ) //校验用户名字回调函数const validatorUsername = (_rule: any, value: any, callBack: any) = //用户名字|昵称,长度至少五位 if (value.trim().length = 5) callBack() else callBack(new Error(用户名字至少五位)) //校验用户名字回调函数const validatorName = (_rule: any, value: any, callBack: any) = //用户名字|昵称,长度至少五位 if (value.trim().length = 5) callBack() else callBack(new Error(用户昵称至少五位)) const validatorPassword = (_rule: any, value: any, callBack: any) = //用户名字|昵称,长度至少五位 if (value.trim().length = 6) callBack() else callBack(new Error(用户密码至少六位)) //表单校验的规则对象const rules = //用户名字 username: [ required: true, trigger: blur, validator: validatorUsername ], //用户昵称 name: [ required: true, trigger: blur, validator: validatorName ], //用户的密码 password: [ required: true, trigger: blur, validator: validatorPassword ],/script 12.3 更新用户 标题应该该为更新用户，没有输入密码。因为修改业务时我们需要用到用户id，因此再修改按钮存储账号信息赋值了用户的id。 我们根据这个id来决定我们的界面。 初始化用户id：我们再修改的时候将row的值复制给userParams，因此在展示抽屉的时候就会变换 //更新已有的用户按钮的回调//row:即为已有用户的账号信息const updateUser = (row: User) = //抽屉显示出来 drawer.value = true //存储收集已有的账号信息 Object.assign(userParams, row) //清除上一次的错误的提示信息 nextTick(() = formRef.value.clearValidate(username) formRef.value.clearValidate(name) ) 更改当前帐号之后，应该重新登陆 //保存按钮的回调 const save = async () = ... //添加或者更新成功 //获取最新的全部账号的信息 getHasUser(userParams.id ? pageNo.value : 1) //浏览器自动刷新一次 window.location.reload() ### 12.4 分配角色1. 静态页面 `src\\views\\acl\\user\\index.vue` ```html !-- 抽屉结构:完成添加新的用户账号|更新已有的账号信息 -- el-drawer v-model=drawer ... /el-drawer !-- 抽屉结构:用户某一个已有的账号进行职位分配 -- el-drawer v-model=drawer1 template #header h4分配角色(职位)/h4 /template template #default el-form el-form-item label=用户姓名 el-input :disabled=true/el-input /el-form-item el-form-item label=职位列表 el-checkbox @change=handleCheckAllChange v-model=checkAll :indeterminate=isIndeterminate 全选 /el-checkbox !-- 显示职位的的复选框 -- el-checkbox-group @change=handleCheckedCitiesChange el-checkbox /el-checkbox /el-checkbox-group /el-form-item /el-form /template template #footer div style=flex: auto el-button @click=drawer1 = false取消/el-button el-button type=primary @click=confirmClick确定/el-button /div /template /el-drawer 类型 src\\api\\acl\\user\\type.ts //代表一个职位的ts类型export interface RoleData id?: number createTime?: string updateTime?: string roleName: string remark: null//全部职位的列表export type AllRole = RoleData[]//获取全部职位的接口返回的数据ts类型export interface AllRoleResponseData extends ResponseData data: assignRoles: AllRole allRolesList: AllRole //给用户分配职位接口携带参数的ts类型export interface SetRoleData roleIdList: number[] userId: number API src\\api\\acl\\user\\index.ts //枚举地址enum API ALLROLE_URL = /admin/acl/user/toAssign, SETROLE_URL = /admin/acl/user/doAssignRole,//获取全部职位以及包含当前用户的已有的职位export const reqAllRole = (userId: number) = return request.getany, AllRoleResponseData(API.ALLROLE_URL + `/$userId`)//分配职位export const reqSetUserRole = (data: SetRoleData) = return request.postany, any(API.SETROLE_URL, data) 展示页面 templateel-drawer v-model=drawer1 template #header h4分配角色(职位)/h4 /template template #default el-form el-form-item label=用户姓名 el-input v-model=userParams.username :disabled=true/el-input /el-form-item el-form-item label=职位列表 el-checkbox @change=handleCheckAllChange v-model=checkAll :indeterminate=isIndeterminate 全选 /el-checkbox !-- 显示职位的的复选框 -- el-checkbox-group v-model=userRole @change=handleCheckedCitiesChange el-checkbox v-for=(role, index) in allRole :key=index :label=role role.roleName /el-checkbox /el-checkbox-group /el-form-item /el-form /template template #footer div style=flex: auto el-button @click=drawer1 = false取消/el-button el-button type=primary @click=confirmClick确定/el-button /div /template /el-drawer/templatescript setup lang=ts//分配角色let drawer1 = ref(false)//存储全部职位的数据let allRole = refAllRole([])//当前用户已有的职位let userRole = refAllRole([])//分配角色按钮的回调const setRole = async (row: User) = //存储已有的用户信息 Object.assign(userParams, row) //获取全部的职位的数据与当前用户已有的职位的数据 let result: AllRoleResponseData = await reqAllRole(userParams.id as number) if (result.code == 200) //存储全部的职位 allRole.value = result.data.allRolesList //存储当前用户已有的职位 userRole.value = result.data.assignRoles //抽屉显示出来 drawer1.value = true //收集顶部复选框全选数据let checkAll = refboolean(false)//控制顶部全选复选框不确定的样式let isIndeterminate = refboolean(true)//顶部的全部复选框的change事件const handleCheckAllChange = (val: any) = //val:true(全选)|false(没有全选) //将所有角色赋给用户角色 userRole.value = val ? allRole.value : [] //不确定的样式(确定样式)- isIndeterminate.value = false//顶部全部的复选框的change事件const handleCheckedCitiesChange = (value: string | any[]) = //顶部复选框的勾选数据 //代表:勾选上的项目个数与全部的职位个数相等，顶部的复选框勾选上 checkAll.value = value.length === allRole.value.length //不确定的样式 isIndeterminate.value = value.length !== allRole.value.length//确定按钮的回调(分配职位)const confirmClick = async () = //收集参数 let data: SetRoleData = userId: userParams.id as number, roleIdList: userRole.value.map((item) = return item.id as number ), //分配用户的职位 let result: any = await reqSetUserRole(data) if (result.code == 200) //提示信息 ElMessage( type: success, message: 分配职务成功 ) //关闭抽屉 drawer1.value = false //获取更新完毕用户的信息,更新完毕留在当前页 getHasUser(pageNo.value) /script 全选部分： @change：全选框点击时的回调。 v-model：绑定的数据，根据这个值决定是否全选。 :indeterminate：不确定状态，既没有全选也没有全不选（-）。 复选框部分：v-for=(role, index) in allRole：遍历allRole。 :label=role：收集的数据（勾上的数据）。 v-model=userRole：绑定收集的数据，也就是收集的数据存储到userRole中。 @change：勾选变化时的回调。 12.5 删除 绑定点击事件 !-- 批量删除 --el-button type=danger size=default @click=dialogFormVisible = true :disabled=selectIdArr.length === 0 批量删除 /el-button el-dialog v-model=dialogFormVisible title=批量删除 !-- https://lianyutian.github.io/posts/dd58b23f.html 10.3具名插槽 -- template #header span您确定要删除该用户吗？/span /template template #default el-button @click=dialogFormVisible = false取消/el-button el-button type=primary @click=confirm确认/el-button /template/el-dialog...!-- row 单行删除 --el-table-column label=操作 width=300px align=center !-- row 回传编辑数据 -- template #default= row !-- 分配角色 -- el-button size=small icon=User @click=setRole(row) 分配角色 /el-button !-- 编辑 -- el-button type=primary size=small icon=Edit @click=updateUser(row) 编辑 /el-button el-popconfirm :title=`您确定要删除$row.username?` width=250px icon=Delete @confirm=deleteUser(row.id) template #reference el-button type=danger size=small icon=Delete 删除 /el-button /template /el-popconfirm /template /el-table-column API enum API //删除某一个账号 DELETEUSER_URL = /admin/acl/user/remove/, //批量删除的接口 DELETEALLUSER_URL = /admin/acl/user/batchRemove,//删除某一个账号的信息export const reqRemoveUser = (userId: number) = return request.deleteany, any(API.DELETEUSER_URL + userId)//批量删除的接口export const reqSelectUser = (idList: number[]) = return request.delete(API.DELETEALLUSER_URL, data: idList ) 渲染页面 //删除某一个用户const deleteUser = async (userId: number) = let result: any = await reqRemoveUser(userId) if (result.code == 200) ElMessage( type: success, message: 删除成功 ) getHasUser(userArr.value.length 1 ? pageNo.value : pageNo.value - 1) //table复选框勾选的时候会触发的事件let selectIdArr = ref([])console.log(selectIdArr.value.length)const handleSelectionChange = (value: any) = selectIdArr.value = value//批量删除按钮的回调const deleteSelectUser = async () = //整理批量删除的参数 let idsList: any = selectIdArr.value.map((item: id: any ) = return item.id ) //批量删除的请求 let result: any = await reqSelectUser(idsList) if (result.code == 200) ElMessage( type: success, message: 删除成功 ) getHasUser(userArr.value.length 1 ? pageNo.value : pageNo.value - 1) let dialogFormVisible = ref(false)const confirm = () = deleteSelectUser() dialogFormVisible.value = false 12.6 搜索和重置 搜索业务与获取初始数据的请求是同一个，因此我们修改一下获取初始业务的请求。更具是否写道username来判断。 //获取用户账号信息的接口export const reqUserInfo = (page: number, limit: number, username: string) = if (username) return request.getany, UserResponseData( API.ALLUSER_URL + `$page/$limit/?username=$username`, ) else return request.getany, UserResponseData( API.ALLUSER_URL + `$page/$limit`, ) 渲染页面 template el-form :inline=true class=form el-form-item label=用户名: el-input placeholder=请你输入搜索用户名 v-model=keyword/el-input /el-form-item el-form-item el-button type=primary size=default @click=search 搜索 /el-button el-button size=default @click=reset重置/el-button /el-form-item /el-form/templatescript setup lang=tslet keyword = ref()//搜索按钮的回调const search = () = //根据关键字获取相应的用户数据 getHasUser() //清空关键字 keyword.value = //重置import useLayOutSettingStore from @/store/modules/setting//获取模板setting仓库let settingStore = useLayOutSettingStore()//重置按钮const reset = () = settingStore.refresh = !settingStore.refresh/script 13. 角色管理13.1 角色管理展示 静态页面 src\\views\\acl\\role\\index.vue template el-card style=height: 80px el-form :inline=true class=form el-form-item label=职位搜索 el-input placeholder=请你输入搜索职位关键字/el-input /el-form-item el-form-item el-button type=primary size=default搜索/el-button el-button size=default重置/el-button /el-form-item /el-form /el-card el-card style=margin: 10px 0px el-button type=primary size=default添加职位/el-button el-table border style=margin: 10px 0px el-table-column type=index align=center label=#/el-table-column el-table-column label=ID align=center prop=id/el-table-column el-table-column label=职位名称 align=center prop=roleName show-overflow-tooltip /el-table-column el-table-column label=创建时间 align=center show-overflow-tooltip prop=createTime /el-table-column el-table-column label=更新时间 align=center show-overflow-tooltip prop=updateTime /el-table-column el-table-column label=操作 width=280px align=center !-- row:已有的职位对象 -- template #= row, $index el-button size=small icon=User 分配权限 /el-button el-button type=primary size=small icon=Edit编辑/el-button el-popconfirm :title=`你确定要删除$row.roleName?` width=260px template #reference el-button type=danger size=small icon=Delete 删除 /el-button /template /el-popconfirm /template /el-table-column /el-table /el-card el-pagination v-model:current-page=pageNo v-model:page-size=pageSize :page-sizes=[10, 20, 30, 40] :background=true layout=prev, pager, next, jumper,-,sizes,total :total=400 @current-change=getHasRole @size-change=sizeChange //template 数据类型 src\\api\\acl\\role\\type.ts export interface ResponseData code: number message: string ok: boolean//职位数据类型export interface RoleData id?: number createTime?: string updateTime?: string roleName: string remark?: null//全部职位的数组的ts类型export type Records = RoleData[]//全部职位数据的相应的ts类型export interface RoleResponseData extends ResponseData data: records: Records total: number size: number current: number orders: [] optimizeCountSql: boolean hitCount: boolean countId: null maxLimit: null searchCount: boolean pages: number API src\\api\\acl\\role\\index.ts //角色管理模块的的接口import request from @/utils/requestimport type RoleResponseData from ./type//枚举地址enum API //获取全部的职位接口 ALLROLE_URL = /admin/acl/role/,//获取全部的角色export const reqAllRoleList = ( page: number, limit: number, roleName: string,) = return request.getany, RoleResponseData( API.ALLROLE_URL + `$page/$limit/?roleName=$roleName`, ) 渲染页面 template el-card style=height: 80px ... /el-card el-card style=margin: 10px 0px el-button type=primary size=default添加职位/el-button el-table border style=margin: 10px 0px :data=allRole el-table-column type=index align=center label=#/el-table-column el-table-column label=ID align=center prop=id/el-table-column el-table-column label=职位名称 align=center prop=roleName show-overflow-tooltip /el-table-column el-table-column label=创建时间 align=center show-overflow-tooltip prop=createTime /el-table-column el-table-column label=更新时间 align=center show-overflow-tooltip prop=updateTime /el-table-column el-table-column label=操作 width=280px align=center !-- row:已有的职位对象 -- template #default= row el-button size=small icon=User分配权限/el-button el-button type=primary size=small icon=Edit编辑/el-button el-popconfirm :title=`你确定要删除$row.roleName?` width=260px template #reference el-button type=danger size=small icon=Delete 删除 /el-button /template /el-popconfirm /template /el-table-column /el-table /el-card el-pagination v-model:current-page=pageNo v-model:page-size=pageSize :page-sizes=[3, 5, 7, 9] :background=true layout=prev, pager, next, jumper,-,sizes,total :total=total @current-change=getHasRole @size-change=sizeChange //templatescript setup lang=tsimport reqAllRoleList from @/api/acl/role/indeximport Records, RoleResponseData from @/api/acl/role/typeimport ref, onMounted from vue//当前页码let pageNo = refnumber(1)//一页展示几条数据let pageSize = refnumber(10)//搜索职位关键字let keyword = refstring()//总行数let total = refnumber(0)//总角色集合let allRole = refRecords()//组件挂载完毕onMounted(() = //获取职位请求 getHasRole())//获取全部用户信息的方法|分页器当前页码发生变化的回调const getHasRole = async (pager = 1) = //修改当前页码 pageNo.value = pager let result: RoleResponseData = await reqAllRoleList( pageNo.value, pageSize.value, keyword.value, ) if (result.code == 200) total.value = result.data.total allRole.value = result.data.records // 当下拉菜单发生变化的时候触发此方法// 这个自定义事件,分页器组件会将下拉菜单选中数据返回const sizeChange = () = // 当前每一页的数据量发生变化的时候，当前页码归1 getHasRole()/script 13.2 搜索和重置 渲染页面 template el-card style=height: 80px el-form :inline=true class=form el-form-item label=职位搜索 el-input placeholder=请你输入搜索职位关键字 v-model=keyword /el-input /el-form-item el-form-item el-button type=primary size=default @click=search 搜索 /el-button el-button size=default @click=reset重置/el-button /el-form-item /el-form /el-card/templatescript setup lang=ts//搜索const search = () = //再次发请求根据关键字 getHasRole() keyword.value = //重置import useLayOutSettingStore from @/store/modules/setting//获取模板setting仓库let settingStore = useLayOutSettingStore()//重置按钮const reset = () = settingStore.refresh = !settingStore.refresh/script 13.3 添加修改职位 静态页面 !-- 添加职位与更新已有职位的结构:对话框 -- el-dialog v-model=dialogVisite title=添加职位 el-form ref=roleForm :rules=rules :model=roleParams el-form-item label=职位名称 el-input placeholder=请你输入职位名称 v-model=roleParams.roleName /el-input /el-form-item /el-form template #footer el-button type=primary size=default @click=dialogVisite = false 取消 /el-button el-button type=primary size=default @click=save确定/el-button /template /el-dialog API //枚举地址enum API //新增岗位的接口地址 ADDROLE_URL = /admin/acl/role/save, //更新已有的职位 UPDATEROLE_URL = /admin/acl/role/update,//添加职位与更新已有职位接口export const reqAddOrUpdateRole = (data: RoleData) = if (data.id) return request.putany, any(API.UPDATEROLE_URL, data) else return request.postany, any(API.ADDROLE_URL, data) 渲染页面 template !-- 角色界面展示 -- el-card style=margin: 10px 0px el-button type=primary size=default @click=addRole 添加职位 /el-button el-table border style=margin: 10px 0px :data=allRole ... el-table-column label=操作 width=280px align=center !-- row:已有的职位对象 -- template #default= row el-button size=small icon=User分配权限/el-button el-button type=primary size=small icon=Edit @click=updateRole(row) 编辑 /el-button /template /el-table-column /el-table /el-card !-- 添加职位与更新已有职位的结构:对话框 -- el-dialog v-model=dialogVisite title=添加职位 el-form ref=roleForm :rules=rules :model=roleParams el-form-item label=职位名称 el-input placeholder=请你输入职位名称 v-model=roleParams.roleName /el-input /el-form-item /el-form template #footer el-button type=primary size=default @click=dialogVisite = false 取消 /el-button el-button type=primary size=default @click=save确定/el-button /template /el-dialog/templatescript setup lang=ts//添加修改职位let dialogVisite = refboolean(false)//职位参数let roleParams = reactiveRoleData( id: 0, roleName: ,)//添加职位表单实例let roleForm = ref()//添加职位按钮的回调const addRole = () = //对话框显示出来 dialogVisite.value = true //清空数据 Object.assign(roleParams, roleName: , id: 0, ) //清空上一次表单校验错误结果 nextTick(() = roleForm.value.clearValidate(roleName) )//更新已有的职位按钮的回调const updateRole = (row: RoleData) = //显示出对话框 dialogVisite.value = true //存储已有的职位----带有ID的 Object.assign(roleParams, row) //清空上一次表单校验错误结果 nextTick(() = roleForm.value.clearValidate(roleName) )//自定义校验规则的回调const validatorRoleName = (_rule: any, value: any, callBack: any) = if (value.trim().length = 2) callBack() else callBack(new Error(职位名称至少两位)) //职位校验规则const rules = roleName: [ required: true, trigger: blur, validator: validatorRoleName ],//确定按钮的回调const save = async () = //表单校验结果,结果通过在发请求、结果没有通过不应该在发生请求 await roleForm.value.validate() //添加职位|更新职位的请求 let result: any = await reqAddOrUpdateRole(roleParams) if (result.code == 200) //提示文字 ElMessage( type: success, message: roleParams.id ? 更新成功 : 添加成功, ) //对话框显示 dialogVisite.value = false //再次获取全部的已有的职位 getHasRole(roleParams.id ? pageNo.value : 1) /script 13.4 分配角色权限 静态页面 !-- 抽屉组件:分配职位的菜单权限与按钮的权限 --el-drawer v-model=drawer template #header h4分配菜单与按钮的权限/h4 /template template #default !-- 树形控件 -- el-tree ref=tree :data=menuArr show-checkbox node-key=id default-expand-all :default-checked-keys=selectArr :props=defaultProps / /template template #footer div style=flex: auto el-button @click=drawer = false取消/el-button el-button type=primary @click=handler确定/el-button /div /template/el-drawer https://element-plus.org/zh-CN/component/tree.html#%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E9%80%89%E6%8B%A9 树形控件 data：展示的数据 show-checkbox：节点是否可被选择 node-key：每个树节点用来作为唯一标识的属性，整棵树应该是唯一的 default-expand-all：默认展开所有节点 default-checked-keys：默认勾选的节点的 key 的数组 props：属性： label：指定节点标签为节点对象的某个属性值 children:指定子树为节点对象的某个属性值 getHalfCheckedKeys 在 element-plus 中的 getHalfCheckedNodes 涉及到树形控件（Tree Component）的半选状态。在树形控件中，节点可以有三种状态：选中、未选中和半选中。 半选中状态通常表示该节点的子节点中有部分节点被选中，而不是全部。这种状态在树形结构中很有用，因为它允许用户选择一个节点的一部分子节点，而不是强制用户只能全选或全不选。 数据类型 //菜单与按钮数据的ts类型export interface MenuData id: number createTime: string updateTime: string pid: number name: string code: string toCode: string type: number status: null level: number children?: MenuList select: booleanexport type MenuList = MenuData[]export interface MenuResponseData extends ResponseData data: MenuList API //枚举地址enum API //获取全部的菜单与按钮的数据 ALLPERMISSTION = /admin/acl/permission/toAssign/, //给相应的职位分配权限 SETPERMISTION_URL = /admin/acl/permission/doAssign/?,//获取全部菜单与按钮权限数据export const reqAllMenuList = (roleId: number) = return request.getany, MenuResponseData(API.ALLPERMISSTION + roleId)//给相应的职位下发权限export const reqSetPermisstion = (roleId: number, permissionId: number[]) = return request.post( API.SETPERMISTION_URL + `roleId=$roleIdpermissionId=$permissionId`, ) 页面渲染 template ... !-- 抽屉组件:分配职位的菜单权限与按钮的权限 -- el-drawer v-model=drawer template #header h4分配菜单与按钮的权限/h4 /template template #default !-- 树形控件 -- el-tree ref=tree :data=menuArr show-checkbox node-key=id default-expand-all :default-checked-keys=selectArr :props=defaultProps / /template template #footer div style=flex: auto el-button @click=drawer = false取消/el-button el-button type=primary @click=handler确定/el-button /div /template /el-drawer/templatescript setup lang=ts//准备一个数组:数组用于存储勾选的节点的ID(四级的)let selectArr = refnumber[]([])//定义数组存储用户权限的数据let menuArr = refMenuList([])//获取tree组件实例let tree = refany()//控制抽屉显示与隐藏let drawer = refboolean(false)//已有的职位的数据const setPermisstion = async (row: RoleData) = //抽屉显示出来 drawer.value = true //收集当前要分类权限的职位的数据 Object.assign(roleParams, row) //根据职位获取权限的数据 let result: MenuResponseData = await reqAllMenuList(roleParams.id as number) if (result.code === 200) menuArr.value = result.data selectArr.value = filterSelectArr(menuArr.value, []) const defaultProps = children: children, label: name,//过滤出选中的四级id//获取已分配权限的id，这里我们只需要收集最后一层的id即可，因为组件会自动根据最后一层的选择情况决定上层的选择状况。const filterSelectArr = (allData: any, initArr: any) = allData.forEach((item: any) = if (item.select item.level == 4) initArr.push(item.id) if (item.children item.children.length 0) filterSelectArr(item.children, initArr) ) return initArr//抽屉确定按钮的回调const handler = async () = //职位的ID const roleId = roleParams.id as number //选中节点的ID let arr = tree.value.getCheckedKeys() //半选的ID let arr1 = tree.value.getHalfCheckedKeys() let permissionId = arr.concat(arr1) //下发权限 let result: any = await reqSetPermisstion(roleId, permissionId) if (result.code === 200) //抽屉关闭 drawer.value = false ElMessage( type: success, message: 分配权限成功, ) else drawer.value = false ElMessage( type: error, message: result.data.message ) return getHasRole(allRole.value.length 1 ? pageNo.value : pageNo.value - 1)/script 13.5 删除角色 API enum API //删除已有的职位 REMOVEROLE_URL = /admin/acl/role/remove/,//删除已有的职位export const reqRemoveRole = (roleId: number) = return request.deleteany, any(API.REMOVEROLE_URL + roleId) 渲染页面 el-popconfirm :title=`你确定要删除$row.roleName?` width=260px @confirm=removeRole(row.id) template #reference el-button type=danger size=small icon=Delete 删除 /el-button /template/el-popconfirm//删除已有的职位const removeRole = async (id: number) = let result: any = await reqRemoveRole(id) if (result.code === 200) //提示信息 ElMessage( type: success, message: 删除成功 ) getHasRole(allRole.value.length 1 ? pageNo.value : pageNo.value - 1) 14. 菜单管理14.1 菜单展示 静态页面 src\\views\\acl\\permission\\index.vue template div el-table style=width: 100%; margin-bottom: 20px row-key=id border el-table-column label=名称/el-table-column el-table-column label=权限值/el-table-column el-table-column label=修改时间/el-table-column el-table-column label=操作 !-- row:即为已有的菜单对象|按钮的对象的数据 -- template el-button size=small xxxx /el-button el-button type=primary size=small 编辑 /el-button el-button type=danger size=small 删除 /el-button /template /el-table-column /el-table /div/templatescript setup lang=ts/scriptstyle lang=scss scoped/style 数据类型 src\\api\\acl\\permission\\type.ts //数据类型定义export interface ResponseData code: number message: string ok: boolean//菜单数据与按钮数据的ts类型export interface Permisstion id?: number createTime: string updateTime: string pid: number name: string code: null toCode: null type: number status: null level: number children?: PermisstionList select: booleanexport type PermisstionList = Permisstion[]//菜单接口返回的数据类型export interface PermisstionResponseData extends ResponseData data: PermisstionList API src\\api\\acl\\permission\\index.ts import request from @/utils/requestimport type PermisstionResponseData from ./type//枚举地址enum API //获取全部菜单与按钮的标识数据 ALLPERMISSTION_URL = /admin/acl/permission,//获取菜单数据export const reqAllPermisstion = () = return request.getany, PermisstionResponseData(API.ALLPERMISSTION_URL) 渲染页面 src\\views\\acl\\permission\\index.vue template div el-table :data=permisstionArr style=width: 100%; margin-bottom: 20px row-key=id border el-table-column label=名称 prop=name/el-table-column el-table-column label=权限值 prop=code/el-table-column el-table-column label=修改时间 prop=updateTime/el-table-column el-table-column label=操作 !-- row:即为已有的菜单对象|按钮的对象的数据 -- template #default= row el-button size=small :disabled=row.level == 4 ? true : false row.level == 3 ? 添加功能 : 添加菜单 /el-button el-button type=primary size=small :disabled=row.level == 1 ? true : false 编辑 /el-button el-button type=danger size=small :disabled=row.level == 1 ? true : false 删除 /el-button /template /el-table-column /el-table /div/templatescript setup lang=tsimport onMounted, ref from vueimport PermisstionList, PermisstionResponseData, from @/api/acl/permission/typeimport reqAllPermisstion from @/api/acl/permission/index//存储菜单的数据let permisstionArr = refPermisstionList([])//获取菜单数据的方法const getHasPermisstion = async () = let result: PermisstionResponseData = await reqAllPermisstion() if (result.code == 200) permisstionArr.value = result.data //组件挂载完毕onMounted(() = getHasPermisstion())/scriptstyle lang=scss scoped/style 14.2 添加编辑菜单 静态页面 !-- 对话框组件:添加或者更新已有的菜单的数据结构 --el-dialog !-- 表单组件:收集新增与已有的菜单的数据 -- el-form el-form-item label=名称 el-input placeholder=请你输入菜单名称 /el-input /el-form-item el-form-item label=权限 el-input placeholder=请你输入权限数值 /el-input /el-form-item /el-form template #footer span class=dialog-footer el-button取消/el-button el-button type=primary确定/el-button /span /template/el-dialog 数据类型 //添加与修改菜单携带的参数的ts类型export interface MenuParams id?: number //ID code: string //权限数值 level: number //几级菜单 name: string //菜单的名字 pid: number //菜单的ID API //给某一级菜单新增一个子菜单ADDMENU_URL = /admin/acl/permission/save,//更新某一个已有的菜单UPDATE_URL = /admin/acl/permission/update,//添加与更新菜单的方法export const reqAddOrUpdateMenu = (data: MenuParams) = if (data.id) return request.putany, any(API.UPDATE_URL, data) else return request.postany, any(API.ADDMENU_URL, data) 渲染页面 template !-- 对话框组件:添加或者更新已有的菜单的数据结构 -- el-dialog v-model=dialogVisible :title=menuData.id ? 更新菜单 : 添加菜单 !-- 表单组件:收集新增与已有的菜单的数据 -- el-form el-form-item label=名称 el-input placeholder=请你输入菜单名称 v-model=menuData.name /el-input /el-form-item el-form-item label=权限 el-input placeholder=请你输入权限数值 v-model=menuData.code /el-input /el-form-item /el-form template #footer span class=dialog-footer el-button @click=dialogVisible = false取消/el-button el-button type=primary @click=save确定/el-button /span /template /el-dialog /div/templatescript setup lang=ts//携带的参数let menuData = reactiveMenuParams( code: , level: 0, name: , pid: 0,)let dialogVisible = ref(false)//添加菜单按钮的回调const addPermission = (row: Permission) = //清空数据 Object.assign(menuData, id: 0, code: , level: 0, name: , pid: 0, ) //对话框显示出来 dialogVisible.value = true //收集新增的菜单的level数值 menuData.level = row.level + 1 //给谁新增子菜单 menuData.pid = row.id as number//编辑已有的菜单const updatePermisstion = (row: Permission) = dialogVisible.value = true //点击修改按钮:收集已有的菜单的数据进行更新 Object.assign(menuData, row)//确定按钮的回调const save = async () = //发请求:新增子菜单|更新某一个已有的菜单的数据 let result: any = await reqAddOrUpdateMenu(menuData) if (result.code == 200) //对话框隐藏 dialogVisible.value = false //提示信息 ElMessage( type: success, message: menuData.id ? 更新成功 : 添加成功, ) //再次获取全部最新的菜单的数据 getHasPermisstion() /scriptstyle lang=scss scoped/style 14.3 删除 API //删除已有的菜单 DELETEMENU_URL = /admin/acl/permission/remove/,//删除某一个已有的菜单export const reqRemoveMenu = (id: number) = return request.deleteany, any(API.DELETEMENU_URL + id) 渲染页面 template div !-- 菜单展示页面 -- el-table :data=permisstionArr style=width: 100%; margin-bottom: 20px row-key=id border el-table-column label=操作 !-- row:即为已有的菜单对象|按钮的对象的数据 -- template #default= row el-popconfirm :title=`您确定要删除$row.name?` width=260px @confirm=removeMenu(row.id) template #reference el-button type=danger size=small :disabled=row.level == 1 ? true : false 删除 /el-button /template /el-popconfirm /template /el-table-column /el-table /div/templatescript setup lang=ts//删除按钮回调const removeMenu = async (id: number) = let result = await reqRemoveMenu(id) if (result.code === 200) ElMessage( type: success, message: 删除成功 ) else ElMessage( type: error, message: 删除失败 ) getHasPermisstion()/scriptstyle lang=scss scoped/style 15. 首页模块 渲染页面 src\\views\\home\\index.vue template div el-card div class=box img :src=userStore.avatar alt= class=avatar / div class=bottom h3 class=title getTime() 好呀， userStore.username /h3 p class=subtitle硅谷甄选运营平台/p /div /div /el-card div class=bottoms svg-icon name=welcome width=800px height=400px/svg-icon /div /div/templatescript setup lang=tsimport getTime from @/utils/time//引入用户相关的仓库,获取当前用户的头像、昵称import useUserStore from @/store/modules/user//获取存储用户信息的仓库对象let userStore = useUserStore()/scriptstyle lang=scss scoped.box display: flex; .avatar width: 100px; height: 100px; border-radius: 50%; .bottom margin-left: 20px; .title font-size: 30px; font-weight: 900; margin-bottom: 30px; .subtitle font-style: italic; color: skyblue; .bottoms margin-top: 10px; display: flex; justify-content: center;/style 16. setting按钮模块16.1 暗黑模式 静态页面 src\\layout\\tabbar\\setting\\index.vue template el-popover placement=bottom title=主题设置 :width=300 trigger=hover !-- 表单元素 -- el-form el-form-item label=暗黑模式 el-switch @change=changeDark v-model=dark class=mt-2 inline-prompt active-icon=MoonNight inactive-icon=Sunny / /el-form-item /el-form template #reference el-button size=small icon=Setting circle/el-button /template /el-popover/templatescript setup lang=ts/scriptscript lang=tsexport default name: Setting,/scriptstyle lang=scss scoped/style https://element-plus.org/zh-CN/component/popover.html#%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95 https://element-plus.org/zh-CN/component/switch.html#%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95 https://element-plus.org/zh-CN/guide/dark-mode.html#%E6%9A%97%E9%BB%91%E6%A8%A1%E5%BC%8F js src\\main.ts //暗黑模式需要的样式import element-plus/theme-chalk/dark/css-vars.css 切换回调 src\\layout\\tabbar\\setting\\index.vue //收集开关的数据let dark = refboolean(false)//switch开关的chang事件进行暗黑模式的切换const changeDark = () = //获取HTML根节点 let html = document.documentElement //判断HTML标签是否有类名dark dark.value ? (html.className = dark) : (html.className = ) 16.2 主题颜色 静态页面 src\\layout\\tabbar\\setting\\index.vue el-popover placement=bottom title=主题设置 :width=300 trigger=hover !-- 表单元素 -- el-form el-form-item label=主题颜色 el-color-picker @change=setColor v-model=color size=small show-alpha :predefine=predefineColors / /el-form-item /el-form template #reference el-button size=small icon=Setting circle/el-button /template /el-popover https://element-plus.org/zh-CN/component/color-picker.html#%E9%A2%84%E5%AE%9A%E4%B9%89%E9%A2%9C%E8%89%B2 https://element-plus.org/zh-CN/guide/theming.html#%E9%80%9A%E8%BF%87-css-%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE js src\\layout\\tabbar\\setting\\index.vue //自定义主题//颜色组件组件的数据const color = ref(rgba(255, 69, 0, 0.68))const predefineColors = ref([ #ff4500, #ff8c00, #ffd700, #90ee90, #00ced1, #1e90ff, #c71585, rgba(255, 69, 0, 0.68), rgb(255, 120, 0), hsv(51, 100, 98), hsva(120, 40, 94, 0.5), hsl(181, 100%, 37%), hsla(209, 100%, 56%, 0.73), #c7158577,])//主题颜色的设置const setColor = () = //通知js修改根节点的样式对象的属性与属性值 const html = document.documentElement html.style.setProperty(--el-color-primary, color.value) 17. 菜单权限17.1 拆分路由 拆分常量路由和异步路由 src\\router\\router.ts //对外暴露配置路由(常量路由)export const constantRoute = [ //登录路由 path: /login, component: () = import(@/views/login/index.vue), name: login, //命名路由 meta: title: 登录, //菜单标题 hidden: true, //路由的标题在菜单中是否隐藏 , , //登录成功以后展示数据的路由 path: /, component: () = import(@/layout/index.vue), name: layout, meta: hidden: false, , redirect: /home, children: [ path: /home, component: () = import(@/views/home/index.vue), meta: title: 首页, hidden: false, icon: HomeFilled, , , ], , path: /404, component: () = import(@/views/404/index.vue), name: 404, meta: title: 404, hidden: true, , , path: /screen, component: () = import(@/views/screen/index.vue), name: Screen, meta: hidden: false, title: 数据大屏, icon: Platform, , ,]//异步路由export const asnycRoute = [ path: /acl, component: () = import(@/layout/index.vue), name: Acl, meta: hidden: false, title: 权限管理, icon: Lock, , redirect: /acl/user, children: [ path: /acl/user, component: () = import(@/views/acl/user/index.vue), name: User, meta: hidden: false, title: 用户管理, icon: User, , , path: /acl/role, component: () = import(@/views/acl/role/index.vue), name: Role, meta: hidden: false, title: 角色管理, icon: UserFilled, , , path: /acl/permission, component: () = import(@/views/acl/permission/index.vue), name: Permission, meta: hidden: false, title: 菜单管理, icon: Monitor, , , ], , path: /product, component: () = import(@/layout/index.vue), name: Product, meta: hidden: false, title: 商品管理, icon: Goods, , redirect: /product/trademark, children: [ path: /product/trademark, component: () = import(@/views/product/trademark/index.vue), name: Trademark, meta: hidden: false, title: 品牌管理, icon: ShoppingCartFull, , , path: /product/attr, component: () = import(@/views/product/attr/index.vue), name: Attr, meta: hidden: false, title: 属性管理, icon: CollectionTag, , , path: /product/spu, component: () = import(@/views/product/spu/index.vue), name: Spu, meta: hidden: false, title: SPU管理, icon: Calendar, , , path: /product/sku, component: () = import(@/views/product/sku/index.vue), name: Sku, meta: hidden: false, title: SKU管理, icon: Orange, , , ], ,]//任意路由//任意路由export const anyRoute = //任意路由 path: /:pathMatch(.*)*, redirect: /404, name: Any, meta: title: 任意路由, hidden: true, icon: DataLine, , 17.2 动态路由 根据用户返回所拥有的路由权限，过滤出可以展示的路由 src\\store\\modules\\user.ts //引入深拷贝方法//@ts-expect-errorimport cloneDeep from lodash/cloneDeep//用于过滤当前用户需要展示的异步路由function filterAsyncRoute(asnycRoute: any, routes: any) return asnycRoute.filter((item: any) = if (routes.includes(item.name)) if (item.children item.children.length 0) //硅谷333账号:product\\trademark\\attr\\sku item.children = filterAsyncRoute(item.children, routes) return true )// 创建用户小仓库const useUserStore = defineStore(UserStore, // 处理异步|逻辑地方 actions: // 获取用户信息 async userInfoAction() const result: userInfoResponseData = await reqUserInfo() if (result.code === 200) this.username = result.data.name this.avatar = result.data.avatar //计算当前用户需要展示的异步路由 const userAsyncRoute = filterAsyncRoute( cloneDeep(asnycRoute), result.data.routes, ) //菜单需要的数据整理完毕 this.menuRoutes = [...constantRoute, ...userAsyncRoute, anyRoute] //目前路由器管理的只有常量路由:用户计算完毕异步路由、任意路由动态追加 ;[...userAsyncRoute, anyRoute].forEach((route: any) = router.addRoute(route) ) return ok else return Promise.reject(new Error(result.message)) , , getters: ,) 路由加载问题 这样配置路由后，如果你访问的是异步路由，会在刷新的时候出现空白页面。原因是异步路由是异步获取的，加载的时候还没有。因此我们可以在路由守卫文件中改写。next( ...to )这个的意思就是一直加载。 src\\permisstion.ts //全局前置守卫router.beforeEach(async (to: any, from: any, next: any) = ... //用户登录判断 if (token) //登陆成功，访问login。指向首页 if (to.path == /login) next(/home) else //登陆成功访问其余的，放行 //有用户信息 if (username) //放行 next() else //如果没有用户信息，在收尾这里发请求获取到了用户信息再放行 try //获取用户信息 await userStore.userInfoAction() //万一刷新的时候是异步路由，有可能获取到用户信息但是异步路由没有加载完毕，出现空白效果 next( ...to ) catch (error) //token过期|用户手动处理token //退出登陆-用户相关的数据清空 await userStore.userLogoutAction() next( path: /login, query: redirect: to.path ) else ...) 17.3 按钮权限 修改数据类型 src\\store\\modules\\type\\type.ts export interface UserState ... //存储当前用户是否包含某一个按钮 buttons: string[] 自定义指令 src\\directive\\has.ts import pinia from @/storeimport useUserStore from @/store/modules/userconst userStore = useUserStore(pinia)export const isHasButton = (app: any) = //获取对应的用户仓库 //全局自定义指令:实现按钮的权限 app.directive(has, //代表使用这个全局自定义指令的DOM|组件挂载完毕的时候会执行一次 mounted(el: any, options: any) //自定义指令右侧的数值:如果在用户信息buttons数组当中没有 //从DOM树上干掉 //el就是dom元素 //options:传入进来的值 if (!userStore.buttons.includes(options.value)) el.parentNode.removeChild(el) , ) src\\main.ts import isHasButton from ./directive/has// 获取应用实例对象const app = createApp(App)...isHasButton(app)// 将应用挂载到挂载点上app.mount(#app) 使用 el-button size=small :disabled=row.level == 4 ? true : false @click=addPermission(row) v-has=`btn.Permission.add` row.level == 3 ? 添加功能 : 添加菜单 /el-button 在需要控制权限的按钮上添加 v-has=按钮权限名来判断按钮是否有权限 在buttons里包含了用户所拥有的所有按钮权限数据 ​","tags":["Vue3","Pina","前端项目"],"categories":["实战"]},{"title":"vue3基础","path":"/2023/12/22/2023-12-22-vue3基础/","content":"1. Vue3优势 优势 2. 创建项目 create-vue create-vue是Vue官方新的脚手架工具，底层切换到了 vite （下一代前端工具链），为开发提供极速响应 创建项目 前置条件 - 已安装16.0或更高版本的Node.js 执行如下命令，这一指令将会安装并执行 create-vue npm init vue@latest 熟悉关键配置 3. 组合式API3.1 setup 执行时机 在beforeCreate钩子之前执行 基本语法 script export default setup() const message = this is message const logMessage = ()= console.log(message) // 必须return才可以 return message, logMessage /scripttemplate div message /div button @click=logMessage点击/button/template 语法糖 script标签添加 setup标记，不需要再写导出语句，默认会添加导出语句 template div class=person h2姓名：name/h2 h2年龄：age/h2 button @click=changName修改名字/button button @click=changAge年龄+1/button button @click=showTel点我查看联系方式/button /div/templatescript lang=ts export default name:Person, /script!-- 下面的写法是setup语法糖 --script setup lang=ts console.log(this) //undefined // 数据（注意：此时的name、age、tel都不是响应式数据） let name = 张三 let age = 18 let tel = 13888888888 // 方法 function changName() name = 李四//注意：此时这么修改name页面是不变化的 function changAge() console.log(age) age += 1 //注意：此时这么修改age页面是不变化的 function showTel() alert(tel) /script 3.2 reactive和ref函数3.2.1 reactive 作用 接受对象类型数据的参数传入并返回一个响应式的对象 语法 let 响应式对象= reactive(源对象) 返回值 一个Proxy的实例对象，简称：响应式对象 注意点 reactive定义的响应式数据是“深层次”的 示例 template div class=person h2汽车信息：一台 car.brand 汽车，价值 car.price 万/h2 h2游戏列表：/h2 ul li v-for=g in games :key=g.id g.name /li /ul h2测试：obj.a.b.c.d/h2 button @click=changeCarPrice修改汽车价格/button button @click=changeFirstGame修改第一游戏/button button @click=test测试/button /div/templatescript lang=ts setup name=Personimport reactive from vue// 数据let car = reactive( brand: 奔驰, price: 100 )let games = reactive([ id: ahsgdyfa01, name: 英雄联盟 , id: ahsgdyfa02, name: 王者荣耀 , id: ahsgdyfa03, name: 原神 ])let obj = reactive( a: b: c: d:666 )function changeCarPrice() car.price += 10function changeFirstGame() games[0].name = 流星蝴蝶剑function test() obj.a.b.c.d = 999/script 3.2.2 ref 作用 定义响应式变量 语法 let xxx = ref(初始值) 返回值 一个RefImpl的实例对象，简称ref对象或ref，ref对象的value属性是响应式的 注意点 JS中操作数据需要：xxx.value，但模板中不需要.value，直接使用即可 对于let name = ref(张三)来说，name不是响应式的，name.value是响应式的 示例 template div class=person h2姓名：name/h2 h2年龄：age/h2 button @click=changeName修改名字/button button @click=changeAge年龄+1/button button @click=showTel点我查看联系方式/button /div/templatescript setup lang=ts name=Person import ref from vue // name和age是一个RefImpl的实例对象，简称ref对象，它们的value属性是响应式的。 let name = ref(张三) let age = ref(18) // tel就是一个普通的字符串，不是响应式的 let tel = 13888888888 function changeName() // JS中操作ref对象时候需要.value name.value = 李四 console.log(name.value) // 注意：name不是响应式的，name.value是响应式的，所以如下代码并不会引起页面的更新。 // name = ref(zhang-san) function changeAge() // JS中操作ref对象时候需要.value age.value += 1 console.log(age.value) function showTel() alert(tel) /script 3.2.3 对比 都是用来生成响应式数据 不同点 reactive不能处理简单类型的数据 ref参数类型支持更好，但是必须通过.value做访问修改 ref函数内部的实现依赖于reactive函数 reactive重新分配一个新对象，会失去响应式（可以使用Object.assign去整体替换） 使用原则 若需要一个基本类型的响应式数据，必须使用ref 若需要一个响应式对象，层级不深，ref、reactive都可以 若需要一个响应式对象，且层级较深，推荐使用reactive 3.2.4 toRefs 与 toRef 作用 将一个响应式对象中的每一个属性，转换为ref对象 备注 toRefs与toRef功能一致，但toRefs可以批量转换 示例 template div class=person h2姓名：person.name/h2 h2年龄：person.age/h2 h2性别：person.gender/h2 button @click=changeName修改名字/button button @click=changeAge修改年龄/button button @click=changeGender修改性别/button /div/templatescript lang=ts setup name=Person import ref,reactive,toRefs,toRef from vue // 数据 let person = reactive(name:张三, age:18, gender:男) // 通过toRefs将person对象中的n个属性批量取出，且依然保持响应式的能力 let name,gender = toRefs(person) // 通过toRef将person对象中的gender属性取出，且依然保持响应式的能力 let age = toRef(person,age) // 方法 function changeName() name.value += ~ function changeAge() age.value += 1 function changeGender() gender.value = 女 /script 3.3 computed 作用 计算属性基本思想和Vue2保持一致，组合式API下的计算属性只是修改了API写法 示例 template div class=person 姓：input type=text v-model=firstName br 名：input type=text v-model=lastName br 全名：spanfullName/span br button @click=changeFullName全名改为：li-si/button /div/templatescript setup lang=ts name=App import ref,computed from vue let firstName = ref(zhang) let lastName = ref(san) // 计算属性——只读取，不修改 /* let fullName = computed(()= return firstName.value + - + lastName.value ) */ // 计算属性——既读取又修改 let fullName = computed( // 读取 get() return firstName.value + - + lastName.value , // 修改 set(val) console.log(有人修改了fullName,val) firstName.value = val.split(-)[0] lastName.value = val.split(-)[1] ) function changeFullName() fullName.value = li-si /script 3.4 watch 作用 监视数据的变化（和Vue2中的watch作用一致） 特点 Vue3中的watch只能监视以下四种数据 ref定义的数据。 reactive定义的数据。 函数返回一个值（getter函数）。 一个包含上述内容的数组。 3.4.1 侦听ref定义的【基本类型】 监视ref定义的【基本类型】数据：直接写数据名即可，监视的是其value值的改变。 template div class=person h1情况一：监视【ref】定义的【基本类型】数据/h1 h2当前求和为：sum/h2 button @click=changeSum点我sum+1/button /div/templatescript lang=ts setup name=Person import ref,watch from vue // 数据 let sum = ref(0) // 方法 function changeSum() sum.value += 1 // 监视，情况一：监视【ref】定义的【基本类型】数据 const stopWatch = watch(sum,(newValue,oldValue)= console.log(sum变化了,newValue,oldValue) if(newValue = 10) stopWatch() )/script 3.4.2 监视ref定义的【对象类型】 监视ref定义的【对象类型】数据 直接写数据名，监视的是对象的【地址值】，若想监视对象内部的数据，要手动开启深度监视。 注意 若修改的是ref定义的对象中的属性，newValue 和 oldValue 都是新值，因为它们是同一个对象。 若修改整个ref定义的对象，newValue 是新值， oldValue 是旧值，因为不是同一个对象了。 示例 template div class=person h1情况二：监视【ref】定义的【对象类型】数据/h1 h2姓名： person.name /h2 h2年龄： person.age /h2 button @click=changeName修改名字/button button @click=changeAge修改年龄/button button @click=changePerson修改整个人/button /div/templatescript lang=ts setup name=Person import ref,watch from vue // 数据 let person = ref( name:张三, age:18 ) // 方法 function changeName() person.value.name += ~ function changeAge() person.value.age += 1 function changePerson() person.value = name:李四,age:90 /* 监视，情况一：监视【ref】定义的【对象类型】数据，监视的是对象的地址值，若想监视对象内部属性的变化，需要手动开启深度监视 watch的第一个参数是：被监视的数据 watch的第二个参数是：监视的回调 watch的第三个参数是：配置对象（deep、immediate等等.....） */ watch(person,(newValue,oldValue)= console.log(person变化了,newValue,oldValue) ,deep:true) /script 3.4.3 深度监视 监视reactive定义的【对象类型】数据，且默认开启了深度监视。 通过watch监听的ref对象默认是浅层侦听的，直接修改嵌套的对象属性不会触发回调执行，需要开启deep。 template div class=person h1情况三：监视【reactive】定义的【对象类型】数据/h1 h2姓名： person.name /h2 h2年龄： person.age /h2 button @click=changeName修改名字/button button @click=changeAge修改年龄/button button @click=changePerson修改整个人/button hr h2测试：obj.a.b.c/h2 button @click=test修改obj.a.b.c/button /div/templatescript lang=ts setup name=Person import reactive,watch from vue // 数据 let person = reactive( name:张三, age:18 ) let obj = reactive( a: b: c:666 ) // 方法 function changeName() person.name += ~ function changeAge() person.age += 1 function changePerson() Object.assign(person,name:李四,age:80) function test() obj.a.b.c = 888 // 监视，情况三：监视【reactive】定义的【对象类型】数据，且默认是开启深度监视的 watch(person,(newValue,oldValue)= console.log(person变化了,newValue,oldValue) ) watch(obj,(newValue,oldValue)= console.log(Obj变化了,newValue,oldValue) )/script 3.4.4 监视【对象类型】中的属性 监视ref或reactive定义的【对象类型】数据中的某个属性，注意点如下： 若该属性值不是【对象类型】，需要写成函数形式。 若该属性值是依然是【对象类型】，可直接编写，也可写成函数，建议写成函数。 结论：监视的要是对象里的属性，那么最好写函数式，注意点：若是对象监视的是地址值，需要关注对象内部，需要手动开启深度监视。 示例 template div class=person h1情况四：监视【ref】或【reactive】定义的【对象类型】数据中的某个属性/h1 h2姓名： person.name /h2 h2年龄： person.age /h2 h2汽车： person.car.c1 、 person.car.c2 /h2 button @click=changeName修改名字/button button @click=changeAge修改年龄/button button @click=changeC1修改第一台车/button button @click=changeC2修改第二台车/button button @click=changeCar修改整个车/button /div/templatescript lang=ts setup name=Person import reactive,watch from vue // 数据 let person = reactive( name:张三, age:18, car: c1:奔驰, c2:宝马 ) // 方法 function changeName() person.name += ~ function changeAge() person.age += 1 function changeC1() person.car.c1 = 奥迪 function changeC2() person.car.c2 = 大众 function changeCar() person.car = c1:雅迪,c2:爱玛 // 监视，情况四：监视响应式对象中的某个属性，且该属性是基本类型的，要写成函数式 /* watch(()= person.name,(newValue,oldValue)= console.log(person.name变化了,newValue,oldValue) ) */ // 监视，情况四：监视响应式对象中的某个属性，且该属性是对象类型的，可以直接写，也能写函数，更推荐写函数 watch(()=person.car,(newValue,oldValue)= console.log(person.car变化了,newValue,oldValue) ,deep:true)/script 3.4.5 监视的多个数据 监听多个数据 template div class=person h1情况五：监视上述的多个数据/h1 h2姓名： person.name /h2 h2年龄： person.age /h2 h2汽车： person.car.c1 、 person.car.c2 /h2 button @click=changeName修改名字/button button @click=changeAge修改年龄/button button @click=changeC1修改第一台车/button button @click=changeC2修改第二台车/button button @click=changeCar修改整个车/button /div/templatescript lang=ts setup name=Person import reactive,watch from vue // 数据 let person = reactive( name:张三, age:18, car: c1:奔驰, c2:宝马 ) // 方法 function changeName() person.name += ~ function changeAge() person.age += 1 function changeC1() person.car.c1 = 奥迪 function changeC2() person.car.c2 = 大众 function changeCar() person.car = c1:雅迪,c2:爱玛 // 监视，情况五：监视上述的多个数据 watch([()=person.name,person.car],(newValue,oldValue)= console.log(person.car变化了,newValue,oldValue) ,deep:true)/script 3.4.6 immediate 作用 在侦听器创建时立即出发回调，响应式数据变化之后继续执行回调 示例 script setup // 1. 导入watch import ref, watch from vue const count = ref(0) // 2. 调用watch 侦听变化 watch(count, (newValue, oldValue)= console.log(`count发生了变化,老值为$oldValue,新值为$newValue`) , immediate: true )/script 3.5 watchEffect 作用 立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行该函数 watch对比watchEffect 都能监听响应式数据的变化，不同的是监听数据变化的方式不同 watch：要明确指出监视的数据 watchEffect：不用明确指出监视的数据（函数中用到哪些属性，那就监视哪些属性）。 示例 template div class=person h1需求：水温达到50℃，或水位达到20cm，则联系服务器/h1 h2 id=demo水温：temp/h2 h2水位：height/h2 button @click=changePrice水温+1/button button @click=changeSum水位+10/button /div /template script lang=ts setup name=Person import ref,watch,watchEffect from vue // 数据 let temp = ref(0) let height = ref(0) // 方法 function changePrice() temp.value += 10 function changeSum() height.value += 1 // 用watch实现，需要明确的指出要监视：temp、height watch([temp,height],(value)= // 从value中获取最新的temp值、height值 const [newTemp,newHeight] = value // 室温达到50℃，或水位达到20cm，立刻联系服务器 if(newTemp = 50 || newHeight = 20) console.log(联系服务器) ) // 用watchEffect实现，不用 const stopWtach = watchEffect(()= // 室温达到50℃，或水位达到20cm，立刻联系服务器 if(temp.value = 50 || height.value = 20) console.log(document.getElementById(demo)?.innerText) console.log(联系服务器) // 水温达到100，或水位达到50，取消监视 if(temp.value === 100 || height.value === 50) console.log(清理了) stopWtach() ) /script### 3.6 标签的 ref 属性1. 作用 用于注册模板引用 - 用在普通`DOM`标签上，获取的是`DOM`节点。 - 用在组件标签上，获取的是组件实例对象。2. 普通`DOM`标签上 ```html template div class=person h1 ref=title1尚硅谷/h1 h2 ref=title2前端/h2 h3 ref=title3Vue/h3 input type=text ref=inpt brbr button @click=showLog点我打印内容/button /div /template script lang=ts setup name=Person import ref from vue let title1 = ref() let title2 = ref() let title3 = ref() function showLog() // 通过id获取元素 const t1 = document.getElementById(title1) // 打印内容 console.log((t1 as HTMLElement).innerText) console.log((HTMLElementt1).innerText) console.log(t1?.innerText) /************************************/ // 通过ref获取元素 console.log(title1.value) console.log(title2.value) console.log(title3.value) /script 组件标签上 !-- 父组件App.vue --template Person ref=ren/ button @click=test测试/button/templatescript lang=ts setup name=App import Person from ./components/Person.vue import ref from vue let ren = ref() function test() console.log(ren.value.name) console.log(ren.value.age) /script!-- 子组件Person.vue中要使用defineExpose暴露内容 --script lang=ts setup name=Person import ref,defineExpose from vue // 数据 let name = ref(张三) let age = ref(18) /****************************/ /****************************/ // 使用defineExpose将组件中的数据交给外部 defineExpose(name,age)/script 注意 ref绑定的标识名要和定义的ref对象名一致 3.7 生命周期函数 概念 Vue组件实例在创建时要经历一系列的初始化步骤，在此过程中Vue会在合适的时机，调用特定的函数，从而让开发者有机会在特定阶段运行自己的代码，这些特定的函数统称为：生命周期钩子 规律 生命周期整体分为四个阶段，分别是：创建、挂载、更新、销毁，每个阶段都有两个钩子，一前一后。 Vue2的生命周期 创建阶段：beforeCreate、created 挂载阶段：beforeMount、mounted 更新阶段：beforeUpdate、updated 销毁阶段：beforeDestroy、destroyed Vue3的生命周期 创建阶段：setup 挂载阶段：onBeforeMount、onMounted 更新阶段：onBeforeUpdate、onUpdated 卸载阶段：onBeforeUnmount、onUnmounted 常用的钩子 onMounted(挂载完毕)、onUpdated(更新完毕)、onBeforeUnmount(卸载之前) 示例 template div class=person h2当前求和为： sum /h2 button @click=changeSum点我sum+1/button /div/template!-- vue3写法 --script lang=ts setup name=Person import ref, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted from vue // 数据 let sum = ref(0) // 方法 function changeSum() sum.value += 1 console.log(setup) // 生命周期钩子 onBeforeMount(()= console.log(挂载之前) ) onMounted(()= console.log(挂载完毕) ) onBeforeUpdate(()= console.log(更新之前) ) onUpdated(()= console.log(更新完毕) ) onBeforeUnmount(()= console.log(卸载之前) ) onUnmounted(()= console.log(卸载完毕) )/script 3.8 自定义hook 什么是hook？ 本质是一个函数，把setup函数中使用的Composition API进行了封装，类似于vue2.x中的mixin 自定义hook的优势 复用代码, 让setup中的逻辑更清楚易懂 示例 useSum.ts import ref,onMounted from vueexport default function() let sum = ref(0) const increment = ()= sum.value += 1 const decrement = ()= sum.value -= 1 onMounted(()= increment() ) //向外部暴露数据 return sum,increment,decrement useDog.ts import reactive,onMounted from vueimport axios,AxiosError from axiosexport default function() let dogList = reactivestring[]([]) // 方法 async function getDog() try // 发请求 let data = await axios.get(https://dog.ceo/api/breed/pembroke/images/random) // 维护数据 dogList.push(data.message) catch (error) // 处理错误 const err = AxiosErrorerror console.log(err.message) // 挂载钩子 onMounted(()= getDog() ) //向外部暴露数据 return dogList,getDog 组件中具体使用 template h2当前求和为：sum/h2 button @click=increment点我+1/button button @click=decrement点我-1/button hr img v-for=(u,index) in dogList.urlList :key=index :src=(u as string) span v-show=dogList.isLoading加载中....../spanbr button @click=getDog再来一只狗/button/templatescript lang=ts import defineComponent from vue export default defineComponent( name:App, )/scriptscript setup lang=ts import useSum from ./hooks/useSum import useDog from ./hooks/useDog let sum,increment,decrement = useSum() let dogList,getDog = useDog()/script 4. 组件通信4.1 父传子 父传子 父组件中给子组件绑定属性 子组件内部通过props选项接收数据 示例 4.2 子传父 子传父 父组件中给子组件标签通过@绑定事件 子组件内部通过 emit 方法触发事件 示例 4.3 defineExpose defineExpose 默认情况下在 script setup语法糖下组件内部的属性和方法是不开放给父组件访问的，可以通过defineExpose编译宏指定哪些属性和方法容许访问说明：指定testMessage属性可以被访问到 4.4 provide和inject 作用和场景 顶层组件向任意的底层组件传递数据和方法，实现跨层组件通信 跨层传递普通数据 实现步骤 顶层组件通过 provide 函数提供数据 底层组件通过 inject 函数提供数据 跨层传递响应式数据 在调用provide函数时，第二个参数设置为ref对象 跨层传递方法 顶层组件可以向底层组件传递方法，底层组件调用方法修改顶层组件的数据 5. defineOptions 背景说明 有 script setup 之前，如果要定义 props, emits 可以轻而易举地添加一个与 setup 平级的属性。 但是用了 script setup 后，就没法这么干了 setup 属性已经没有了，自然无法添加与其平级的属性。 为了解决这一问题，引入了 defineProps 与 defineEmits 这两个宏。但这只解决了 props 与 emits 这两个属性。 如果我们要定义组件的 name 或其他自定义的属性，还是得回到最原始的用法——再添加一个普通的 script 标签。 这样就会存在两个 script 标签。让人无法接受。 所以在 Vue 3.3 中新引入了 defineOptions 宏。顾名思义，主要是用来定义 Options API 的选项。可以用 defineOptions 定义任意的选项， props, emits, expose, slots 除外（因为这些可以使用 defineXXX 来做到） 示例 6. pina6.1 搭建 pinia 环境 第一步 npm install pinia 第二步 操作src/main.ts import createApp from vueimport App from ./App.vue/* 引入createPinia，用于创建pinia */import createPinia from pinia/* 创建pinia */const pinia = createPinia()const app = createApp(App)/* 使用插件 */app.use(pinia)app.mount(#app) 6.2 存储+读取数据 Store是一个保存：状态、业务逻辑 的实体，每个组件都可以读取、写入它。 它有三个概念：state、getter、action，相当于组件中的： data、 computed 和 methods。 具体编码：src/store/count.ts // 引入defineStore用于创建storeimport defineStore from pinia// 定义并暴露一个storeexport const useCountStore = defineStore(count, // 动作 actions:, // 状态 state() return sum:6 , // 计算 getters:) 具体编码：src/store/talk.ts // 引入defineStore用于创建storeimport defineStore from pinia// 定义并暴露一个storeexport const useTalkStore = defineStore(talk, // 动作 actions:, // 状态 state() return talkList:[ id:yuysada01,content:你今天有点怪，哪里怪？怪好看的！, id:yuysada02,content:草莓、蓝莓、蔓越莓，你想我了没？, id:yuysada03,content:心里给你留了一块地，我的死心塌地 ] , // 计算 getters:) 组件中使用state中的数据 template h2当前求和为： sumStore.sum /h2/templatescript setup lang=ts name=Count // 引入对应的useXxxxxStore import useSumStore from @/store/sum // 调用useXxxxxStore得到对应的store const sumStore = useSumStore()/script template ul li v-for=talk in talkStore.talkList :key=talk.id talk.content /li /ul/templatescript setup lang=ts name=Count import axios from axios import useTalkStore from @/store/talk const talkStore = useTalkStore()/script 6.3 修改数据 第一种修改方式，直接修改 countStore.sum = 666 第二种修改方式：批量修改 countStore.$patch( sum:999, school:atguigu) 第三种修改方式：借助action修改（action中可以编写一些业务逻辑） import defineStore from piniaexport const useCountStore = defineStore(count, /*************/ actions: //加 increment(value:number) if (this.sum 10) //操作countStore中的sum this.sum += value , //减 decrement(value:number) if(this.sum 1) this.sum -= value , /*************/) 组件中调用action即可 // 使用countStoreconst countStore = useCountStore()// 调用对应actioncountStore.incrementOdd(n.value) 6.4 storeToRefs 借助storeToRefs将store中的数据转为ref对象，方便在模板中使用。 注意：pinia提供的storeToRefs只会将数据做转换，而Vue的toRefs会转换store中数据。 template div class=count h2当前求和为：sum/h2 /div/templatescript setup lang=ts name=Count import useCountStore from @/store/count /* 引入storeToRefs */ import storeToRefs from pinia /* 得到countStore */ const countStore = useCountStore() /* 使用storeToRefs转换countStore，随后解构 */ const sum = storeToRefs(countStore)/script 6.5 getters 概念：当state中的数据，需要经过处理后再使用时，可以使用getters配置。 追加getters配置。 // 引入defineStore用于创建storeimport defineStore from pinia// 定义并暴露一个storeexport const useCountStore = defineStore(count, // 动作 actions: /************/ , // 状态 state() return sum:1, school:atguigu , // 计算 getters: bigSum:(state):number = state.sum *10, upperSchool():string return this. school.toUpperCase() ) 组件中读取数据： const increment,decrement = countStorelet sum,school,bigSum,upperSchool = storeToRefs(countStore) 6.6 $subscribe 通过 store 的 $subscribe() 方法侦听 state 及其变化 talkStore.$subscribe((mutate,state)= console.log(LoveTalk,mutate,state) localStorage.setItem(talk,JSON.stringify(talkList.value))) 6.7 store组合式写法 示例 import defineStore from piniaimport axios from axiosimport nanoid from nanoidimport reactive from vueexport const useTalkStore = defineStore(talk,()= // talkList就是state const talkList = reactive( JSON.parse(localStorage.getItem(talkList) as string) || [] ) // getATalk函数相当于action async function getATalk() // 发请求，下面这行的写法是：连续解构赋值+重命名 let data:content:title = await axios.get(https://api.uomg.com/api/rand.qinghua?format=json) // 把请求回来的字符串，包装成一个对象 let obj = id:nanoid(),title // 放到数组中 talkList.unshift(obj) return talkList,getATalk)","tags":["Vue3","Pina"],"categories":["前端"]},{"title":"typescript基础","path":"/2023/12/20/2023-12-20-TypeScript基础/","content":"1. 安装TS工具包 npm i -g typescript typescript 包：用来编译 TS 代码的包，提供了 tsc 命令，实现了 TS - JS 的转化 创建基于TS的vue项目 npm create vite vite-ts-demo --template vue-ts 2. TypeScrpit基础2.1 类型注解 作用 TypeScript 是 JS 的超集，TS 提供了 JS 的所有功能，并且额外的增加了：类型系统 所有的 JS 代码都是 TS 代码 JS 有类型（比如，numberstring 等），但是 JS 不会检查变量的类型是否发生变化，而 TS 会检查 TypeScript 类型系统的主要优势：可以显示标记出代码中的意外行为，从而降低了发生错误的可能性 示例 let age = 18let age: number = 18说明：代码中的 : number 就是类型注解作用：为变量添加类型约束。比如，上述代码中，约定变量 age 的类型为 number 类型解释：约定了什么类型，就只能给变量赋值该类型的值，否则，就会报错约定了类型之后，代码的提示就会非常的清晰 错误演示 // 错误代码：// 错误原因：将 string 类型的值赋值给了 number 类型的变量，类型不一致let age: number = 18 2.2 TypeScript类型概述 分类 可以将 TS 中的常用基础类型细分为两类 js已有类型 原始类型，简单类型（ numberstringbooleannullundefined ） 复杂数据类型（数组，对象，函数等） TS新增类型 联合类型 自定义类型（类型别名） 接口 元组 字面量类型 枚举 void 2.3 基本数据类型 特点 简单，这些类型，完全按照 JS 中类型的名称来书写 示例 // 供我们学习 TS 的运行环境// console.log(123)// 相当于省略了 :number, 会自动进行类型推论, 根据初始值来推论// let age = 18let age: number = 18age = 20age = 30// age = 40console.log(age)// string 基本数据类型let username: string = 刘狄威username.slice// props: // msg: // type: String // 包装类// // // 类型注解总结: // 1. 将来不能将其他类型的值赋予这个变量// 2. 代码有提示, 在变量后面 . 可以直接看到当前类型所支持的所有属性和方法let bool: boolean = falsebool = truelet gender: undefined = undefined// gender = 男let hobby: null = null// hobby = xx 2.4 数组类型 示例 // 数组类型 // 声明数组的方式1 (推荐用法) // let arr = [123, abc, true] // let arr1 = [123, 456, 789] let arr: number[] = [1, 2, 3, 4, 5] let arr2: string[] = [abc, def, ghi] // arr2.forEach(item = item.indexOf()) // 声明数组的方式2 let arr3: Arraynumber = [1, 2, 3, 4, 5] 2.5 联合类型 作用 通过联合类型将多个类型组合成一个类型 需求 数组中既有 number 类型，又有 string 类型，这个数组的类型应该如何写? 语法 let arr: (number | string)[] = [1, a, 3, b]解释： | （竖线）在 TS 中叫做联合类型，即：由两个或多个其他类型组成的类型，表示可以是这些类型中的任意一种注意：这是 TS 中联合类型的语法，只有一根竖线，不要与 JS 中的或（|| 或）混淆了 示例 // 需求: 希望数组里面可以存数字或字符串 // 联合类型: | let arr: (number | string)[] = [1, 2, 3, abc] // 注意事项: | 的优先级较低, 需要用 () 包裹提升优先级 // 一旦使用联合类型, 说明 arr 中存储的既可能是 number 也可能是 string, 所以会丢失一部分提示信息 (只能提示共有的方法和属性) let timerId: number | null = null timerId = setTimeout(() = , 1000) 2.6 类型别名 作用 能够使用类型别名给类型起别名 语法 类型别名（自定义类型） ：为任意类型起别名 type 别名 = 类型 使用场景 当同一类型（复杂）被多次使用时，可以通过类型别名，简化该类型的使用 示例 // 需求: 希望 N 个数组里面可以存数字或字符串 // 类型别名 type ArrType = (number | string)[] let arr1: ArrType = [1, 2, 3, abc] let arr2: ArrType = [1, 2, 3, abc] let arr3: ArrType = [1, 2, 3, abc] let arr4: ArrType = [1, abc, 3, aaa] // 灵活度很高, 可以随意搭配组合使用 type ItemType = number | string let arr5: ItemType[] = [1, 2, 3, abc] let str1: ItemType = 123 str1 = 123 // 总结: 将一组类型存储到「变量」里, 用 type 来声明这个特殊的「变量」 2.7 函数类型2.7.1 基本使用 作用 能够给函数指定类型，实际上指的是：指定 函数参数 和 返回值 的类型 语法 为函数指定类型的两种方式 单独指定参数、返回值的类型 同时指定参数、返回值的类型 单独指定 // 普通函数function 函数名(参数1: 参数1类型, 参数2: 参数2类型): 返回值类型 函数体 function add(a: number, b: number): number return a + b// 函数表达式const fn = function(a: number, b: number): number return a + b// 箭头函数const add = (num1: number, num2: number): number = return num1 + num2 同时指定 type AddFn = (num1: number, num2: number) = numberconst add: AddFn = (num1, num2) = return num1 + num2 当函数作为表达式时，可以通过类似箭头函数形式的语法来为函数添加类型 这种形式只适用于函数表达式 2.7.2 void类型 概念 如果函数没有返回值，那么，函数返回值类型为： void 示例 // 如果什么都不写，此时，add 函数的返回值类型为： voidconst add = () = // 这种写法是明确指定函数返回值类型为 void，与上面不指定返回值类型相同const add = (): void = // 但，如果指定 返回值类型为 undefined，此时，函数体中必须显示的 return undefined 才可以const add = (): undefined = // 此处，返回的 undefined 是 JS 中的一个值 return undefined // 需求: 定义一个打印文本的函数, 不需要返回值 // 如果不写 return 我们知道默认返回的是 undefined, 但是 ts 给我们类型推断为 void // 在 ts 中写 : undefined 设置返回值类型的意思是: 必须返回一个 undefined // ts 给我们提供了一个返回值类型: void 意思就是没有返回值 const sayHi = (content: string): void = console.log(content) sayHi(你好世界) 2.7.3 可选参数 作用 使用函数实现某个功能时，参数可以传也可以不传。这种情况下，在给函数参数指定类型时，就用到可选参数了 比如，数组的 slice 方法，可以 slice() 也可以 slice(1) 还可以 slice(1, 3) 示例 function mySlice(start?: number, end?: number): void console.log(起始索引：, start, 结束索引：, end) 可选参数：在可传可不传的参数名称后面添加 ? （问号） 可选参数只能出现在参数列表的最后，也就是说可选参数后面不能再出现必选参数 2.8 对象类型2.8.1 基本使用 作用 JS 中的对象是由属性和方法构成的，而 TS 对象的类型就是在描述对象的结构（有什么类型的属性 和方法） 语法 使用 {} 来描述对象结构 属性采用 属性名: 类型 的形式 方法采用 方法名(): 返回值类型 的形式 示例 // 空对象let person: = // 有属性的对象let person: name: string = name: 同学// 既有属性又有方法的对象// 在一行代码中指定对象的多个属性类型时，使用 `;`（分号）来分隔let person: name: string; sayHi(): void = name: jack, sayHi() // 对象中如果有多个类型，可以换行写：// 通过换行来分隔多个属性类型，可以去掉 `;`let person: name: string sayHi(): void = name: jack, sayHi() 2.8.2 使用类型别名 问题 直接使用 {} 形式为对象添加类型，会降低代码的可读性（不好辨识类型和值） 推荐：使用类型别名为对象添加类型 示例 // 对象类型 type Person = name: string, age: number, gender: string, hobby: string, girlFriend?: string, // ? 表示可选属性 // sayHi: (content: string) = void sayHi(content: string): void // ts 就像在写注释, 以前写的注释是给程序员看的, ts 写的类型是给编辑器看的, 程序员也可以看 let obj1: Person = name: 刘狄威, age: 38, gender: 未知, hobby: 圣杯布局, girlFriend: 乔碧萝, sayHi(content) console.log(八嘎: + content) let obj2: Person = name: 某一帆, age: 66, gender: 未知, hobby: 黑卅导, sayHi(content) console.log(你真别学了: + content) obj1.sayHi(庆友) obj2.sayHi(李伟兴) // 传统 if (obj1.girlFriend) obj1.girlFriend.concat() // 优雅 obj1.girlFriend obj1.girlFriend.concat() // 最新: 可选链操作符, 前面有才会执行后面的函数 obj1.girlFriend?.concat() 2.8.3 箭头函数形式的方法类型 示例 greet(name: string):string, greet: (name: string) = stringtype Person = greet: (name: string) = void greet(name: string): voidlet person: Person = greet(name) console.log(name) 2.8.4 对象可选属性 作用 对象的属性或方法，也可以是可选的，此时就用到可选属性了 比如，我们在使用 axios({ … }) 时，如果发送 GET 请求，method 属性就可以省略 可选属性的语法与函数可选参数的语法一致，都使用 ? 来表示 示例 type Config = url: string method?: stringfunction myAxios(config: Config) console.log(config) 2.9 接口类型2.9.1 基本使用 作用 当一个对象类型被多次使用时，一般会使用接口（ interface ）来描述对象的类型，达到复用的目的 使用 interface 关键字来声明接口 接口名称(比如，IPerson)，可以是任意合法的变量名称，推荐以 I 开头 声明接口后，直接使用接口名称作为变量的类型 因为每一行只有一个属性类型，因此，属性类型后没有 ;(分号) 示例 // 作用: 给对象约束属性和方法// 基础语法:interface 接口名 属性名: 类型 interface IPerson username: string age: number gender: string sayHi: () = voidconst p1: IPerson = username: 刘狄威, age: 38, gender: 未知, sayHi() console.log(我是榜一刘狄威, i\\m rich) 2.9.2 interface vs type 相同 都可以给对象指定类型 不同 接口，只能为对象指定类型 类型别名，不仅可以为对象指定类型，实际上可以为任意类型指定别名 推荐：能使用 type 就是用 type 示例 interface IPerson name: string age: number sayHi(): void // 为对象类型创建类型别名type IPerson = name: string age: number sayHi(): void // 为联合类型创建类型别名type NumStr = number | string 2.9.3 接口继承 作用 如果两个接口之间有相同的属性或方法，可以将公共的属性或方法抽离出来，通过继承来实现复用 示例 interface IPerson username: string age: number gender: string sayHi: () = void const p1: IPerson = username: 刘狄威, age: 38, gender: 未知, sayHi() console.log(我是榜一刘狄威, i\\m rich) p1.sayHi() // 接口继承: IStudent 具备 IPerson 的所有约束规则 interface IStudent extends IPerson score: number sleep: () = void const s1: IStudent = username: 刘狄威, age: 18, gender: 男, sayHi() console.log(我是榜一刘狄威, i\\m rich) , score: 59, sleep() console.log(刘狄威正在睡觉...) , s1.sayHi() s1.sleep() // 使用 type 实现和 interface 类似继承的效果 type Person = username: string age: number gender: string sayHi: () = void // 与连接符: 既要满足前面的也要满足后面的 // | 或连接符: 满足其中一个即可 type Student = score: number sleep: () = void Person const s2: Student = username: 刘狄威, age: 28, gender: 未知, sayHi() console.log(大嘎好!) , score: 80, sleep() console.log(我在睡觉) , // type ItemType = string | number // type ArrType = string[] // interface IStudent // // 总结: interface 和 type 的区别, interface 只能约束对象, 而 type 可以更灵活的使用 // 能用 type 就用 type 更灵活, 更简单 // 接口继承: 可以实现让一个接口使用另一个接口的类型约束, 实现接口的复用 2.10 元组类型 概念 元组类型是另一种类型的数组，它确切地知道包含多少个元素，以及特定索引对应的类型 场景 在地图中，使用经纬度坐标来标记位置信息 说明 元组类型可以确切地标记出有多少个元素，以及每个元素的类型 该示例中，元素有两个元素，每个元素的类型都是 number let position: [number, number] = [39.5427, 116.2317] 2.11 类型推论 作用 在 TS 中，某些没有明确指出类型的地方，TS 的类型推论机制会帮助提供类型 常见场景 声明变量并初始化时 决定函数返回值时 示例 // 变量 age 的类型被自动推断为：numberlet age = 18// 函数返回值的类型被自动推断为：numberfunction add(num1: number, num2: number) return num1 + num2 2.12 字面量类型2.12.1 基本使用 思考 思考以下代码，两个变量的类型分别是什么? let str1 = Hello TSconst str2 = Hello TS 通过 TS 类型推论机制，可以得到答案 变量 str1 的类型为：string 变量 str2 的类型为：’Hello TS’ 解释 str1 是一个变量(let)，它的值可以是任意字符串，所以类型为:string str2 是一个常量(const)，它的值不能变化只能是 ‘Hello TS’，所以，它的类型为:’Hello TS’ 声明的变量是不可修改的, 意味着从始至终都必须是 ‘Hello TS’, 所以 TS 将其当做一个类型来看, 这种类型就被称为「字面量」类型 注意 此处的 ‘Hello TS’，就是一个字面量类型，也就是说某个特定的字符串也可以作为 TS 中的类型 任意的 JS 字面量（比如，对象、数字等）都可以作为类型使用 字面量： name: jack [] 18 20 abc false function() 2.12.2 使用模式和场景 使用模式 字面量类型配合联合类型一起使用 场景 用来表示一组明确的可选值列表 示例 比如，在贪吃蛇游戏中，游戏的方向的可选值只能是上、下、左、右中的任意一个 // 使用自定义类型:type Direction = up | down | left | rightfunction changeDirection(direction: Direction) console.log(direction)// 调用函数时，会有类型提示：changeDirection(up) 参数 direction 的值只能是 updownleftright 中的任意一个 相比于 string 类型，使用字面量类型更加精确、严谨 2.13 枚举类型2.13.1 基本使用 作用 枚举的功能类似于字面量类型+联合类型组合的功能，也可以表示一组明确的可选值 定义一组命名常量。它描述一个值，该值可以是这些命名常量中的一个 示例 // 创建枚举enum Direction Up, Down, Left, Right // 使用枚举类型function changeDirection(direction: Direction) console.log(direction)// 调用函数时，需要应该传入：枚举 Direction 成员的任意一个// 类似于 JS 中的对象，直接通过 点（.）语法 访问枚举的成员changeDirection(Direction.Up) 使用 enum 关键字定义枚举 约定枚举名称以大写字母开头 枚举中的多个值之间通过 , （逗号）分隔 定义好枚举后，直接使用枚举名称作为类型注解 2.13.2 数字枚举 问题 我们把枚举成员作为了函数的实参，它的值是什么呢? 通过将鼠标移入 Direction.Up，可以看到枚举成员 Up 的值为 0 注意 枚举成员是有值的，默认为：从 0 开始自增的数值 概念 我们把，枚举成员的值为数字的枚举，称为： 数字枚举 示例 也可以给枚举中的成员初始化值 // Down - 11、Left - 12、Right - 13enum Direction Up = 10, Down, Left, Right enum Direction Up = 2, Down = 4, Left = 8, Right = 16 2.13.3 字符串枚举 概念 枚举成员的值是字符串，称为： 字符串枚举 注意 字符串枚举没有自增长行为，因此，字符串枚举的每个成员必须有初始值 示例 enum Direction Up = UP, Down = DOWN, Left = LEFT, Right = RIGHT 2.13.4 枚举原理 说明 枚举是 TS 为数不多的非 JavaScript 类型级扩展(不仅仅是类型)的特性之一 因为：其他类型仅仅被当做类型，而枚举不仅用作类型，还提供值(枚举成员都是有值的) 也就是说，其他的类型会在编译为 JS 代码时自动移除。但是，枚举类型会被编译为 JS 代码 解析 enum Direction Up = UP, Down = DOWN, Left = LEFT, Right = RIGHT// 会被编译为以下 JS 代码：var Direction;(function (Direction) Direction[Up] = UPDirection[Down] = DOWNDirection[Left] = LEFTDirection[Right] = RIGHT)(Direction || Direction = ) 枚举与前面讲到的字面量类型+联合类型组合的功能类似，都用来表示一组明确的可选值列表 一般情况下，推荐使用字面量类型+联合类型组合的方式，因为相比枚举，这种方式更加直观、简洁、高效 2.14 any类型 注意 不推荐使用 any!这会让 TypeScript 变为 “AnyScript”(失去 TS 类型保护的优势) 因为当值的类型为 any 时，可以对该值进行任意操作，并且不会有代码提示 示例 let obj: any = x: 0 obj.bar = 100obj()const n: number = obj 以上操作都不会有任何类型错误提示，即使可能存在错误 尽可能的避免使用 any 类型，除非临时使用 any 来“避免”书写很长、很复杂的类型 隐式转换 声明变量不提供类型也不提供默认值 函数参数不加类型 2.15 类型断言 作用 有时候你会比 TS 更加明确一个值的类型，此时，可以使用类型断言来指定更具体的类型。 const aLink = document.getElementById(link) 注意 该方法返回值的类型是 HTMLElement，该类型只包含所有标签公共的属性或方法，不包含 a标签特有的 href 等属性 因此，这个**类型太宽泛(不具体)**，无法操作 href 等 a 标签特有的属性或方法 解决方式 这种情况下就需要使用类型断言指定更加具体的类型 示例 // 页面上有一个 id 为 link 的 a 标签 // 我们知道它是 a 标签 // 但是 TS 不知道 // document.getElementById 的返回值是 HTMLElement // 而 HTMLElement 身上没有 href // 类型断言: 强行指定获取到的结果类型 const a = document.getElementById(link) as HTMLAnchorElement const box = document.getElementById(box) as HTMLDivElement const pp = document.getElementById(pp) as HTMLParagraphElement const img = document.getElementById(avatar) as HTMLImageElement img.src const result = document.createElement(img) console.log(a.href) if (a) console.log(a.href) a a.href // 总结: 当函数获取到的结果类型较为宽泛时, 我们又知道具体类型, 就可以使用断言强行指定类型 使用 as 关键字实现类型断言 关键字 as 后面的类型是一个更加具体的类型（HTMLAnchorElement 是 HTMLElement 的子类型） 通过类型断言，aLink 的类型变得更加具体，这样就可以访问 a 标签特有的属性或方法了 3. TypeScrpit泛型3.1 基本介绍 作用 泛型是可以在保证类型安全前提下，让函数等与多种类型一起工作，从而实现复用。常用于：函 数、接口、class 中。 需求 创建一个 id 函数，传入什么数据就返回该数据本身(也就是说，参数和返回值类型相同) 问题 function id(value: number): number return value 比如，id(10) 调用以上函数就会直接返回 10 本身。但是，该函数只接收数值类型，无法用于其他类型 function id(value: any): any return value 为了能让函数能够接受任意类型，可以将参数类型修改为 any。但是，这样就失去了 TS 的类型保护，类型不安全 3.2 泛型函数 语法 function idType(value: Type): Type return value function idT(value: T): T return value 在函数名称的后面添加 (尖括号)，尖括号中添加类型变量，比如此处的 Type 类型变量 Type，是一种特殊类型的变量，它处理类型而不是值 该类型变量相当于一个类型容器，能够捕获用户提供的类型(具体是什么类型由用户调用该函数时指定) 因为 Type 是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型 类型变量 Type，可以是任意合法的变量名称 调用 const num = idnumber(10)const str = idstring(a) 说明 （1）在函数名称的后面添加 (尖括号)，尖括号中指定具体的类型，比如，此处的number （2）当传入类型 number 后，这个类型就会被函数声明时指定的类型变量 Type 捕获到 （3）此时，Type 的类型就是 number，所以，函数 id 参数和返回值的类型也都是 number 同样，如果传入类型 string，函数 id 参数和返回值的类型就都是 string 这样，通过泛型就做到了让 id 函数与多种不同的类型一起工作，实现了复用的同时保证了类型安全 3.3 简化泛型函数调用 简化 // 省略 number 调用函数let num = id(10)let str = id(a) 在调用泛型函数时，可以省略 类型 来简化泛型函数的调用 此时，TS 内部会采用一种叫做类型参数推断的机制，来根据传入的实参自动推断出类型变量Type 的类型 比如，传入实参 10，TS 会自动推断出变量 num 的类型 number，并作为 Type 的类型 推荐使用这种简化的方式调用泛型函数，使代码更短，更易于阅读 说明 当编译器无法推断类型或者推断的类型不准确时，就需要显式地传入类型参数 3.4 泛型约束 示例 // 创建一个接口interface ILength length: number // Type extends ILength 添加泛型约束// 解释：表示传入的 类型 必须满足 ILength 接口的要求才行，也就是得有一个 number 类型的 length 属性function idType extends ILength(value: Type): Type console.log(value.length) return value 说明 创建描述约束的接口 ILength，该接口要求提供 length 属性 过 extends 关键字使用该接口，为泛型(类型变量)添加约束 该约束表示：传入的类型必须具有 length 属性 注意 传入的实参(比如，数组)只要有 length 属性即可（类型兼容性) 3.5 多个类型变量 场景 泛型的类型变量可以有多个，并且类型变量之间还可以约束(比如，第二个类型变量受第一个类型变量约束) 示例 创建一个函数来获取对象中属性的值 function getPropType, Key extends keyof Type(obj: Type, key: Key) return obj[key]let person = name: jack, age: 18 getProp(person, name) 说明 添加了第二个类型变量 Key，两个类型变量之间使用 , 逗号分隔。 keyof 关键字接收一个对象类型，生成其键名称(可能是字符串或数字)的联合类型。 本示例中 keyof Type 实际上获取的是 person 对象所有键的联合类型，也就是：name| age 类型变量 Key 受 Type 约束，可以理解为：Key 只能是 Type 所有键中的任意一个，或者说只能访问对象中存在的属性 示例 // 多个泛型 // 需求: 定义一个函数, 传入一个对象, 再传入一个字符串属性名, 返回属性值 // 新语法: keyof O 意思就是 O 的所有属性 function getPropO, K extends keyof O(obj: O, key: K) return obj[key] const p1 = name: 刘狄威, gender: 男 const p2 = score: 59, hobby: 抽烟喝酒烫头 const result1 = getProp(p1, name) // 报错：类型“age”的参数不能赋给类型“name | gender”的参数 // const result2 = getProp(p1, age) const result3 = getProp(p1, gender) console.log(result1) 3.6 泛型接口 作用 接口也可以配合泛型来使用，以增加其灵活性，增强其复用 示例 // 泛型接口 interface StudentT id: number name: T hobby: T[] let s1: Studentstring = id: 123, name: 刘狄威, hobby: [抽烟, 喝酒, 写圣杯布局] const s2: Studentnumber = id: 123, name: 0, hobby: [1, 2, 3, 4] const arr1: number[] = [1, 2, 3] const arr2: Arraynumber = [1, 2, 3] const arr3: Arraystring = [1, a, c] 说明 在接口名称的后面添加 类型变量 ，那么，这个接口就变成了泛型接口。 接口的类型变量，对接口中所有其他成员可见，也就是接口中所有成员都可以使用类型变量。 使用泛型接口时，需要显式指定具体的类型(比如，此处的 Student)。 此时，name属性的参数类型是 number;hobby方法的参数类型是 number[]。 4. TypeScript与Vue4.1 defineProps与Typescript defineProps配合vue默认语法进行类型校验（运行时声明） defineProps配合ts的泛型定义props类型校验，这样更直接 props可以通过解构来指定默认值 5. TypeScript类型声明文件5.1 基本介绍 作用 用来为已存在的JS库提供类型信息 分类 TS 中有两种文件类型：.ts 文件 .d.ts 文件 .ts 既包含类型信息又可执行代码 可以被编译为 .js 文件，然后，执行代码 用途：编写程序代码的地方 .d.ts 只包含类型信息 的类型声明文件 不会生成 .js 文件，仅用于提供类型信息,在**.d.ts**文件中不允许出现可执行的代码，只用于提供类型 用途：为 JS 提供类型信息 5.2 自定义类型声明文件 项目内共享类型 如果多个 .ts 文件中都用到同一个类型，此时可以创建 .d.ts 文件提供该类型，实现类型共享。 操作步骤: 创建 index.d.ts 类型声明文件。 创建需要共享的类型，并使用 export 导出(TS 中的类型也可以使用 importexport 实现模块化功能)。 在需要使用共享类型的 .ts 文件中，通过 import 导入即可(.d.ts 后缀导入时，直接省略)。 自定义类型声明文件-为js提供声明 为已有 JS 文件提供类型声明 在将 JS 项目迁移到 TS 项目时，为了让已有的 .js 文件有类型声明。 成为库作者，创建库给其他人使用。 演示:基于最新的 ESModule(importexport)来为已有 .js 文件，创建类型声明文件。 类型声明文件的使用说明 TS 项目中也可以使用 .js 文件。 在导入 .js 文件时，TS 会自动加载与 .js 同名的 .d.ts 文件，以提供类型声明。 declare 关键字:用于类型声明，为其他地方(比如，.js 文件)已存在的变量声明类型，而不是创建一个新的变量。 对于 type、interface 等这些明确就是 TS 类型的(只能在 TS 中使用的)，可以省略 declare 关键字。 对于 let、function 等具有双重含义(在 JS、TS 中都能用)，应该使用 declare 关键字，明确指定此处用于类型声明。 示例 let songName = 痴心绝对let position = x: 0, y: 0function add(x, y) return x + yfunction changeDirection(direction) console.log(direction)const fomartPoint = point = console.log(当前坐标：, point)export count, songName, position, add, changeDirection, fomartPoint 定义类型声明文件 declare let count:numberdeclare let songName: stringinterface Position x: number, y: numberdeclare let position: Positiondeclare function add (x :number, y: number) : numbertype Direction = left | right | top | bottomdeclare function changeDirection (direction: Direction): voidtype FomartPoint = (point: Position) = voiddeclare const fomartPoint: FomartPointexport count, songName, position, add, changeDirection, FomartPoint, fomartPoint \\1. 对于 type、interface 等这些明确就是 TS 类型的(只能在 TS 中使用的)，可以省略 declare 关键字。 \\2. 对于 let、function 等具有双重含义(在 JS、TS 中都能用)，应该使用 declare 关键字，明确指 定此处用于类型声明。 import _ from ‘lodash’ 在 VSCode 中，查看 ‘lodash’ 前面的提示 let count 10定义类型声明文件 综合练习","tags":["typescript"],"categories":["前端"]},{"title":"vue3后台管理模板","path":"/2023/12/15/2023-12-15-Vue后台管理项目模板/","content":"1. 项目初始化1.1 环境准备 node v16.19.1 pnpm 8.12.1 npm i -g pnpm 1.2 初始化项目 pnpm create vite 选择vue、TypeScript 进入项目 // 安装依赖pnpm i// 安装完依赖运行程序pnpm run dev 2. 项目配置2.1 eslint配置 作用 eslint中文官网:http://eslint.cn/ ESLint最初是由Nicholas C. Zakas 于2013年6月创建的开源项目。它的目标是提供一个插件化的javascript代码检测工具 步骤 首先安装eslint pnpm i eslint -D 生成配置文件:.eslint.cjs npx eslint --init .eslint.cjs配置文件解析 module.exports = //运行环境 env: browser: true,//浏览器端 es2021: true,//es2021 , //规则继承 extends: [ //全部规则默认是关闭的,这个配置项开启推荐规则,推荐规则参照文档 //比如:函数不能重名、对象不能出现重复key eslint:recommended, //vue3语法规则 plugin:vue/vue3-essential, //ts语法规则 plugin:@typescript-eslint/recommended ], //要为特定类型的文件指定处理器 overrides: [ ], //指定解析器:解析器 //Esprima 默认解析器 //Babel-ESLint babel解析器 //@typescript-eslint/parser ts解析器 parser: @typescript-eslint/parser, //指定解析器选项 parserOptions: ecmaVersion: latest,//校验ECMA最新版本 sourceType: module//设置为script（默认），或者module代码在ECMAScript模块中 , //ESLint支持使用第三方插件。在使用插件之前，您必须使用npm安装它 //该eslint-plugin-前缀可以从插件名称被省略 plugins: [ vue, @typescript-eslint ], //eslint规则 rules: 安装vue3环境代码校验插件 插件作用 # 让所有与prettier规则存在冲突的Eslint rules失效，并使用prettier进行代码检查eslint-config-prettier,eslint-plugin-import,eslint-plugin-node,# 运行更漂亮的Eslint，使prettier规则优先级更高，Eslint优先级低eslint-plugin-prettier,# vue.js的Eslint插件（查找vue语法错误，发现错误指令，查找违规风格指南eslint-plugin-vue,# 该解析器允许使用Eslint校验所有babel code@babel/eslint-parser, 安装指令 pnpm install -D eslint-plugin-import eslint-plugin-vue eslint-plugin-node eslint-plugin-prettier eslint-config-prettier eslint-plugin-node @babel/eslint-parser 修改.eslintrc.cjs配置文件 // @see https://eslint.bootcss.com/docs/rules/module.exports = env: browser: true, es2021: true, node: true, jest: true, , /* 指定如何解析语法 */ parser: vue-eslint-parser, /** 优先级低于 parse 的语法解析配置 */ parserOptions: ecmaVersion: latest, sourceType: module, parser: @typescript-eslint/parser, jsxPragma: React, ecmaFeatures: jsx: true, , , /* 继承已有的规则 */ extends: [ eslint:recommended, plugin:vue/vue3-essential, plugin:@typescript-eslint/recommended, plugin:prettier/recommended, ], plugins: [vue, @typescript-eslint], /* * off 或 0 == 关闭规则 * warn 或 1 == 打开的规则作为警告（不影响代码执行） * error 或 2 == 规则作为一个错误（代码不能执行，界面报错） */ rules: // eslint（https://eslint.bootcss.com/docs/rules/） no-var: error, // 要求使用 let 或 const 而不是 var no-multiple-empty-lines: [warn, max: 1 ], // 不允许多个空行 no-console: process.env.NODE_ENV === production ? error : off, no-debugger: process.env.NODE_ENV === production ? error : off, no-unexpected-multiline: error, // 禁止空余的多行 no-useless-escape: off, // 禁止不必要的转义字符 // typeScript (https://typescript-eslint.io/rules) @typescript-eslint/no-unused-vars: error, // 禁止定义未使用的变量 @typescript-eslint/prefer-ts-expect-error: error, // 禁止使用 @ts-ignore @typescript-eslint/no-explicit-any: off, // 禁止使用 any 类型 @typescript-eslint/no-non-null-assertion: off, @typescript-eslint/no-namespace: off, // 禁止使用自定义 TypeScript 模块和命名空间。 @typescript-eslint/semi: off, // eslint-plugin-vue (https://eslint.vuejs.org/rules/) vue/multi-word-component-names: off, // 要求组件名称始终为 “-” 链接的单词 vue/script-setup-uses-vars: error, // 防止script setup使用的变量template被标记为未使用 vue/no-mutating-props: off, // 不允许组件 prop的改变 vue/attribute-hyphenation: off, // 对模板中的自定义组件强制执行属性命名样式 , 配置忽略文件 新建.eslintignore忽略文件添加忽略 distnode_modules 修改运行脚本 scripts: // 执行`pnpm run dev`直接打开浏览器 dev: vite --open, ... // eslint检查src目录下源码 lint: eslint src, // eslint修复src目录下源码 fix: eslint src --fix 2.2 prettier配置 作用 有了eslint，为什么还要有prettier？eslint针对的是javascript，他是一个检测工具，包含js语法以及少部分格式问题，在eslint看来，语法对了就能保证代码正常运行，格式问题属于其次； 而prettier属于格式化工具，它看不惯格式不统一，所以它就把eslint没干好的事接着干，另外，prettier支持包含js在内的多种语言。 总结起来，eslint和prettier这俩兄弟一个保证js代码质量，一个保证代码美观。 安装依赖 pnpm install -D eslint-plugin-prettier prettier eslint-config-prettier 添加规则 新建.prettierrc.json文件添加规则 singleQuote: true, semi: false, bracketSpacing: true, htmlWhitespaceSensitivity: ignore, endOfLine: auto, trailingComma: all, tabWidth: 2 添加忽略 新建.prettierignore文件添加忽略文件 /dist/*/html/*.local/node_modules/****/*.svg**/*.sh/public/* 修复代码 通过pnpm run lint去检测语法，如果出现不规范格式,通过pnpm run fix修改 2.3 stylelint配置 作用 stylelint为css的lint工具。可格式化css代码，检查css语法错误与不合理的写法，指定css书写顺序等。 安装依赖 本项目中使用scss作为预处理器，安装以下依赖 pnpm add sass sass-loader stylelint postcss postcss-scss postcss-html stylelint-config-prettier stylelint-config-recess-order stylelint-config-recommended-scss stylelint-config-standard stylelint-config-standard-vue stylelint-scss stylelint-order stylelint-config-standard-scss -D 配置文件 新建.stylelintrc.cjs配置文件 官网:https://stylelint.bootcss.com/ // @see https://stylelint.bootcss.com/module.exports = extends: [ stylelint-config-standard, // 配置stylelint拓展插件 stylelint-config-html/vue, // 配置 vue 中 template 样式格式化 stylelint-config-standard-scss, // 配置stylelint scss插件 stylelint-config-recommended-vue/scss, // 配置 vue 中 scss 样式格式化 stylelint-config-recess-order, // 配置stylelint css属性书写顺序插件, stylelint-config-prettier, // 配置stylelint和prettier兼容 ], overrides: [ files: [**/*.(scss|css|vue|html)], customSyntax: postcss-scss, , files: [**/*.(html|vue)], customSyntax: postcss-html, , ], ignoreFiles: [ **/*.js, **/*.jsx, **/*.tsx, **/*.ts, **/*.json, **/*.md, **/*.yaml, ], /** * null = 关闭该规则 * always = 必须 */ rules: value-keyword-case: null, // 在 css 中使用 v-bind，不报错 no-descending-specificity: null, // 禁止在具有较高优先级的选择器后出现被其覆盖的较低优先级的选择器 function-url-quotes: always, // 要求或禁止 URL 的引号 always(必须加上引号)|never(没有引号) no-empty-source: null, // 关闭禁止空源码 selector-class-pattern: null, // 关闭强制选择器类名的格式 property-no-unknown: null, // 禁止未知的属性(true 为不允许) block-opening-brace-space-before: always, //大括号之前必须有一个空格或不能有空白符 value-no-vendor-prefix: null, // 关闭 属性值前缀 --webkit-box property-no-vendor-prefix: null, // 关闭 属性前缀 -webkit-mask selector-pseudo-class-no-unknown: [ // 不允许未知的选择器 true, ignorePseudoClasses: [global, v-deep, deep], // 忽略属性，修改element默认样式的时候能使用到 , ], , 配置忽略 新建.stylelintignore忽略文件 /node_modules/*/dist/*/html/*/public/* 新增运行脚本 scripts: lint:style: stylelint src/**/*.css,scss,vue --cache --fix 同一配置 最后配置统一的prettier来格式化我们的js和css，html代码 scripts: dev: vite --open, build: vue-tsc vite build, preview: vite preview, lint: eslint src, fix: eslint src --fix, format: prettier --write \\./**/*.html,vue,ts,js,json,md\\, lint:eslint: eslint src/**/*.ts,vue --cache --fix, lint:style: stylelint src/**/*.css,scss,vue --cache --fix, 当我们运行pnpm run format的时候，会把代码直接格式化 2.4 husky配置 作用 在上面我们已经集成好了我们代码校验工具，但是需要每次手动的去执行命令才会格式化我们的代码。如果有人没有格式化就提交了远程仓库中，那这个规范就没什么用。所以我们需要强制让开发人员按照代码规范来提交。 要做到这件事情，就需要利用husky在代码提交之前触发git hook(git在客户端的钩子)，然后执行pnpm run format来自动的格式化我们的代码。 安装 husky pnpm install -D husky 初始化 npx husky-init 会在根目录下生成个一个.husky目录，在这个目录下面会有一个pre-commit文件，这个文件里面的命令在我们执行commit的时候就会执行 在.husky/pre-commit文件添加如下命令 #!/usr/bin/env sh. $(dirname -- $0)/_/husky.shpnpm run format 当我们对代码进行commit操作的时候，就会执行命令，对代码进行格式化，然后再提交。 2.5 commitlint配置 作用 对于我们的commit信息，也是有统一规范的，不能随便写,要让每个人都按照统一的标准来执行，我们可以利用commitlint来实现。 安装依赖 pnpm add @commitlint/config-conventional @commitlint/cli -D 添加配置 新建commitlint.config.cjs(注意是cjs) module.exports = extends: [@commitlint/config-conventional], // 校验规则 rules: type-enum: [ 2, always, [ feat, fix, docs, style, refactor, perf, test, chore, revert, build, ], ], type-case: [0], type-empty: [0], scope-empty: [0], scope-case: [0], subject-full-stop: [0, never], subject-case: [0, never], header-max-length: [0, always, 72], , 在package.json中配置scripts命令 # 在scrips中添加下面的代码scripts: commitlint: commitlint --config commitlint.config.cjs -e -V , 配置结束，现在当我们填写commit信息的时候，前面就需要带着下面的subject feat,//新特性、新功能fix,//修改bugdocs,//文档修改style,//代码格式修改, 注意不是 css 修改refactor,//代码重构perf,//优化相关，比如提升性能、体验test,//测试用例修改chore,//其他修改, 比如改变构建流程、或者增加依赖库、工具等revert,//回滚到上一个版本build,//编译相关的修改，例如发布版本、对项目构建或者依赖的改动 配置husky npx husky add .husky/commit-msg 在生成的commit-msg文件中添加下面的命令 #!/usr/bin/env sh. $(dirname -- $0)/_/husky.shpnpm commitlint 当我们 commit 提交信息时，就不能再随意写了，必须是 git commit -m ‘fix: xxx’ 符合类型的才可以 需要注意的是类型的后面需要用英文的 :，并且冒号后面是需要空一格的，这个是不能省略的 2.6 强制使用pnpm包管理器工具 作用 团队开发项目的时候，需要统一包管理器工具,因为不同包管理器工具下载同一个依赖,可能版本不一样,导致项目出现bug问题,因此包管理器工具需要统一管理！！！ 创建配置 在根目录创建scritps/preinstall.js文件，添加下面的内容 if (!/pnpm/.test(process.env.npm_execpath || )) console.warn( `\\u001b[33mThis repository must using pnpm as the package manager ` + ` for scripts to work properly.\\u001b[39m `, ) process.exit(1) 配置命令 scripts: preinstall: node ./scripts/preinstall.js 当我们使用npm或者yarn来安装包的时候，就会报错了。原理就是在install的时候会触发preinstall（npm提供的生命周期钩子）这个文件里面的代码。 3. 项目集成3.1 集成element-plus 官网 官网地址:https://element-plus.gitee.io/zh-CN/ 安装依赖 pnpm install element-plus @element-plus/icons-vue 配置 入口文件main.ts全局安装element-plus,element-plus默认支持语言英语设置为中文 import createApp from vueimport App from ./App.vueimport ElementPlus from element-plusimport element-plus/dist/index.css//@ts-expect-error忽略当前文件ts类型的检测否则有红色提示(打包会失败)import zhCn from element-plus/dist/locale/zh-cn.mjsconst app = createApp(App)app .use(ElementPlus, locale: zhCn, ) .mount(#app) 指定全局组件类型 在 tsconfig.json 中通过 compilerOptions.type 指定全局组件类型 // tsconfig.json compilerOptions: // ... types: [element-plus/global] 3.2 src别名的配置 配置vite.config.ts 在开发项目的时候文件与文件关系可能很复杂，因此我们需要给src文件夹配置一个别名！！！ // vite.config.tsimport defineConfig from viteimport vue from @vitejs/plugin-vueimport path from pathexport default defineConfig( plugins: [vue()], resolve: alias: @: path.resolve(./src) // 相对路径别名配置，使用 @ 代替 src ) tsconfig.json配置 // tsconfig.json compilerOptions: baseUrl: ./, // 解析非相对模块的基地址，默认是当前目录 paths: //路径映射，相对于baseUrl @/*: [src/*] 3.3 环境变量配置 作用 项目开发过程中，至少会经历开发环境、测试环境和生产环境(即正式环境)三个阶段。不同阶段请求的状态(如接口地址等)不尽相同，若手动切换接口地址是相当繁琐且易出错的。于是环境变量配置的需求就应运而生，我们只需做简单的配置，把环境状态切换的工作交给代码。 环境 开发环境（development） 顾名思义，开发使用的环境，每位开发人员在自己的dev分支上干活，开发到一定程度，同事会合并代码，进行联调。 测试环境（testing） 测试同事干活的环境啦，一般会由测试同事自己来部署，然后在此环境进行测试 生产环境（production） 生产环境是指正式提供对外服务的，一般会关掉错误报告，打开错误日志。(正式提供给客户使用的环境) 配置 项目根目录分别添加 开发、生产和测试环境的文件! .env.development.env.production.env.test 添加配置 .env.development # 变量必须以 VITE_ 为前缀才能暴露给外部读取NODE_ENV = developmentVITE_APP_TITLE = 后台开发模板VITE_APP_BASE_API = /dev-api .env.production NODE_ENV = productionVITE_APP_TITLE = 后台开发模板VITE_APP_BASE_API = /prod-api .env.test # 变量必须以 VITE_ 为前缀才能暴露给外部读取NODE_ENV = testVITE_APP_TITLE = 后台开发模板VITE_APP_BASE_API = /test-api 配置运行命令：package.json scripts: build:test: vue-tsc vite build --mode test, build:pro: vue-tsc vite build --mode production , 通过import.meta.env获取环境变量 template divHello/div/templatescript lang=tsconsole.log(import.meta.env)export default /scriptstyle/style 3.4 SVG图标配置3.4.1 图标配置 作用 在开发项目的时候经常会用到svg矢量图,而且我们使用SVG以后，页面上加载的不再是图片资源。 这对页面性能来说是个很大的提升，而且我们SVG文件比img要小的很多，放在项目中几乎不占用资源。 安装依赖 pnpm install vite-plugin-svg-icons -D 配置 在vite.config.ts中配置插件 import createSvgIconsPlugin from vite-plugin-svg-iconsimport path from pathexport default () = return plugins: [ createSvgIconsPlugin( // Specify the icon folder to be cached iconDirs: [path.resolve(process.cwd(), src/assets/icons)], // Specify symbolId format symbolId: icon-[dir]-[name], ), ], 入口文件导入 // main.tsimport virtual:svg-icons-register 3.4.2 封装为全局组件 作用 因为项目很多模块需要使用图标,因此把它封装为全局组件！！！ 示例 在srccomponents目录下创建一个SvgIcon组件 template div svg :style= width: width, height: height use :xlink:href=prefix + name :fill=color/use /svg /div/templatescript setup lang=tsdefineProps( //xlink:href属性值的前缀 prefix: type: String, default: #icon-, , //svg矢量图的名字 name: String, //svg图标的颜色 color: type: String, default: , , //svg宽度 width: type: String, default: 16px, , //svg高度 height: type: String, default: 16px, ,)/scriptstyle scoped/style 注册全局组件 在srccomponents文件夹目录下创建一个index.ts文件：用于注册components文件夹内部全部全局组件！！！ // index.tsimport SvgIcon from ./SvgIcon/index.vue;import type App, Component from vue;const components: [name: string]: Component = SvgIcon ;export default install(app: App) Object.keys(components).forEach((key: string) = app.component(key, components[key]); ) 入口文件使用自定义插件 import gloablComponent from ./components/index;app.use(gloablComponent); 3.5 集成sass 作用 我们目前在组件内部已经可以使用scss样式,因为在配置styleLint工具的时候，项目当中已经安装过sass sass-loader,因此我们再组件内可以使用scss语法！！！需要加上lang”scss” style scoped lang=scss/style 全局样式 在srcstyles目录下创建一个index.scss文件，当然项目中需要用到清除默认样式，因此在index.scss引入reset.scss reset.scss *,*:after,*:before box-sizing: border-box; outline: none;html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video font: inherit; font-size: 100%; margin: 0; padding: 0; vertical-align: baseline; border: 0;article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section display: block;body line-height: 1;ol,ul list-style: none;blockquote,q quotes: none; :before, :after content: ; content: none; sub,sup font-size: 75%; line-height: 0; position: relative; vertical-align: baseline;sup top: -.5em;sub bottom: -.25em;table border-spacing: 0; border-collapse: collapse;input,textarea,button font-family: inhert; font-size: inherit; color: inherit;select text-indent: .01px; text-overflow: ; border: 0; border-radius: 0; -webkit-appearance: none; -moz-appearance: none;select::-ms-expand display: none;code,pre font-family: monospace, monospace; font-size: 1em; index.scss //引入清除默认样式@import ./reset.scss;//滚动条外观设置::-webkit-scrollbar width: 10px;::-webkit-scrollbar-track background: $base-menu-background;::-webkit-scrollbar-thumb width: 10px; background-color: yellowgreen; border-radius: 10px; 入口文件引入 // main.tsimport @/styles 但是你会发现在srcstylesindex.scss全局样式文件中没有办法使用$变量.因此需要给项目中引入全局变量$. 在stylevariable.scss创建一个variable.scss文件！ 在vite.config.ts文件配置如下: export default defineConfig((config) = css: preprocessorOptions: scss: javascriptEnabled: true, additionalData: @import ./src/styles/variable.scss;, , , , @import ./src/styles/variable.less;后面的;不要忘记，不然会报错! 配置完毕你会发现scss提供这些全局变量可以在组件样式中使用了！！！ 3.6 mock数据 安装依赖 https://www.npmjs.com/package/vite-plugin-mock pnpm install vite-plugin-mock@2.9.6 -D 配置启用插件 // vite.config.js//mock插件提供方法import viteMockServe from vite-plugin-mockexport default defineConfig(( command ) = return plugins: [ viteMockServe( localEnabled: command === serve, //保证开发阶段可以使用mock接口 ), ], ) 测试 在根目录创建mock文件夹:去创建我们需要mock数据与接口！！！ 在mock文件夹内部创建一个user.ts文件 //createUserList:次函数执行会返回一个数组,数组里面包含两个用户信息function createUserList() return [ userId: 1, avatar: https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif, username: admin, password: 111111, desc: 平台管理员, roles: [平台管理员], buttons: [cuser.detail], routes: [home], token: Admin Token, , userId: 2, avatar: https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif, username: system, password: 111111, desc: 系统管理员, roles: [系统管理员], buttons: [cuser.detail, cuser.user], routes: [home], token: System Token, , ]//对外暴露一个数组:数组里面包含两个接口//登录假的接口//获取用户信息的假的接口export default [ // 用户登录接口 url: /api/user/login, //请求地址 method: post, //请求方式 response: ( body ) = //获取请求体携带过来的用户名与密码 const username, password = body //调用获取用户信息函数,用于判断是否有此用户 const checkUser = createUserList().find( (item) = item.username === username item.password === password, ) //没有用户返回失败信息 if (!checkUser) return code: 201, data: message: 账号或者密码不正确 //如果有返回成功信息 const token = checkUser return code: 200, data: token , , // 获取用户信息 url: /api/user/info, method: get, response: (request) = //获取请求头携带token const token = request.headers.token //查看用户信息是否包含有次token用户 const checkUser = createUserList().find((item) = item.token === token) //没有返回失败的信息 if (!checkUser) return code: 201, data: message: 获取用户信息失败 //如果有返回成功信息 return code: 200, data: checkUser , ,] 安装axios pnpm install axios 测试 // main.tsimport axios from axiosaxios( url: /api/user/login, method: post, data: username: admin, password: 111111, ,) 3.7 axios二次封装 作用 使用请求拦截器，可以在请求拦截器中处理一些业务(开始进度条、请求头携带公共参数) 使用响应拦截器，可以在响应拦截器中处理一些业务(进度条结束、简化服务器返回的数据、处理http网络错误) 示例 在根目录下创建utilsrequest.ts import axios from axiosimport ElMessage from element-plus//创建axios实例const request = axios.create( baseURL: import.meta.env.VITE_APP_BASE_API, timeout: 5000,)//请求拦截器request.interceptors.request.use((config) = return config)//响应拦截器request.interceptors.response.use( (response) = return response.data , (error) = //处理网络错误 let msg = const status = error.response.status switch (status) case 401: msg = token过期 break case 403: msg = 无权访问 break case 404: msg = 请求地址错误 break case 500: msg = 服务器出现问题 break default: msg = 无网络 ElMessage( type: error, message: msg, ) return Promise.reject(error) ,)export default request 4. 路由配置 安装依赖 pnpm i vue-router 路由雏形 以src\\views\\login\\index.vue为例，创建路由界面 template div一级路由login/div/templatescript setup lang=ts/scriptstyle lang=scss/style 创建路由src\\router\\router.ts文件，定义路由 // 对外暴露配置路由(常量路由)export const constantRoute = [ //登录路由 path: /login, component: () = import(@/views/login/index.vue), name: login, //命名路由 , // 登录成功以后展示数据的路由 path: /, component: () = import(@/views/home/index.vue), name: layout, , path: /404, component: () = import(@/views/404/index.vue), name: 404, , // 重定向 path: /:pathMatch(.*)*, redirect: /404, name: Any, ,] 创建src\\router\\index.ts路由 // 通过vue-router插件实现模板路由配置import createRouter, createWebHashHistory from vue-routerimport constantRoute from ./router// 创建路由器const router = createRouter( // 路由模式hash history: createWebHashHistory(), routes: constantRoute, // 滚动行为 scrollBehavior() return left: 0, top: 0, ,)export default router 在main.ts中挂载路由 // 导入路由组件import router from ./router// 获取应用实例对象const app = createApp(App)// 使用路由组件app.use(router) 指定路由出口 !-- App.vue --template divrouter-view/router-view/div/templatescript setup lang=ts/scriptstyle/style 5. 登录模块5.1 登录界面 编写登录界面 !-- src/views/login/index.vue --template div class=login_container el-row el-col :span=12 :xs=0/el-col el-col :span=12 :xs=24 el-form class=login_form h1Hello/h1 h2欢迎来到XXX/h2 el-form-item el-input :prefix-icon=User v-model=loginForm.username /el-input /el-form-item el-form-item el-input type=password :prefix-icon=Lock v-model=loginForm.password show-password /el-input /el-form-item el-form-item el-button :loading=loadType class=login_btn type=primary size=default @click=login 登录 /el-button /el-form-item /el-form /el-col /el-row /div/templatescript setup lang=tsimport User, Lock from @element-plus/icons-vueimport reactive from vue// 登录效果let loadType = ref(false)//收集账号与密码数据let loginForm = reactive( username: admin, password: 111111 )/scriptstyle lang=scss scoped.login_container width: 100%; height: 100vh; background: url(@/assets/images/background.jpg) no-repeat; background-size: cover; .login_form position: relative; width: 80%; top: 30vh; background: url(@/assets/images/login_form.png) no-repeat; background-size: cover; padding: 40px; h1 color: white; font-size: 40px; h2 color: white; font-size: 20px; margin: 20px 0px; .login_btn width: 100%; /style 5.2 编写请求登录API 接口请求参数及返回类型 // 用户登录接口 url: /dev-api/user/login, //请求地址 method: post, //请求方式 response: ( body ) = //获取请求体携带过来的用户名与密码 const username, password = body //调用获取用户信息函数,用于判断是否有此用户 const checkUser = createUserList().find( (item) = item.username === username item.password === password, ) //没有用户返回失败信息 if (!checkUser) return code: 201, data: message: 账号或者密码不正确 //如果有返回成功信息 const token = checkUser return code: 200, data: token ,, // 登录接口返回数据类型 userId: 1, avatar: https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif, username: admin, password: 111111, desc: 平台管理员, roles: [平台管理员], buttons: [cuser.detail], routes: [home], token: Admin Token,, 根据登录接口编写数据类型type // src/api/user/type.ts// 登录接口需要携带参数ts类型export interface loginForm username: string password: string// ? 可选参数export interface dataType token?: string message?: string// 登录接口返回数据类型export interface loginResponseData code: number data: dataType 编写登录接口 // src/api/user/index.ts// 同一管理用户相关的接口import request from @/utils/requestimport loginForm, loginResponseData from ./type// 统一管理APIenum API LOGIN_URL = /user/login,// 暴露请求函数// 登录接口export const reqLogin = (data: loginForm) = request.postany, loginResponseData(API.LOGIN_URL, data) 5.3 用户数据存储pinia 安装依赖 pnpm i pinia@2.0.34 创建pinia仓库 // src/store/index.ts//仓库大仓库import createPinia from pinia//创建大仓库const pinia = createPinia()//对外暴露：入口文件需要安装仓库export default pinia 挂载pinia // main.ts// 导入piniaimport pinia from ./storeapp.use(pinia) 创建UserState数据类型 // src/store/modules/type/type.tsexport interface UserState token: string | null token相关工具方法 // src/utils/token.ts// 封装本地存储和读取数据的方法export const SET_TOKEN = (token: string) = localStorage.setItem(TOKEN, token)export const GET_TOKEN = (): string | null = return localStorage.getItem(TOKEN) 创建用户相关仓库 // src/store/modules/user.ts// 创建用户相关的小仓库import defineStore from piniaimport loginForm, loginResponseData from @/api/user/typeimport reqLogin from @/api/userimport GET_TOKEN, SET_TOKEN from @/utils/tokenimport UserState from ./type/type// 创建用户小仓库const useUserStore = defineStore(User, // 用户仓库存储数据地方 state(): UserState return token: GET_TOKEN(), , // 处理异步|逻辑地方 actions: async userLogin(data: loginForm) const result: loginResponseData = await reqLogin(data) console.log(result) if (result.code === 200) this.token = result.data.token as string //localStorage.setItem(TOKEN, this.token) SET_TOKEN(this.token) return OK else return Promise.reject(new Error(result.data.message)) , , getters: ,)// 对外暴露小仓库export default useUserStore 5.4 登录按钮点击事件 登录 !-- src/views/login/index.vue --script setup lang=tsimport User, Lock from @element-plus/icons-vueimport reactive, ref from vueimport useUserStore from @/store/modules/userimport useRouter from vue-routerimport ElNotification from element-plus// 登录效果let loadType = ref(false)//收集账号与密码数据let loginForm = reactive( username: admin, password: 111111 )const router = useRouter()let userStore = useUserStore()// 登录const login = async () = loadType.value = true try await userStore.userLogin(loginForm) router.push(/) ElNotification( type: success, message: 登录成功, ) loadType.value = false catch (error) loadType.value = false ElNotification( type: error, message: (error as Error).message, ) /script 5.5 登录提示 需求 修改登录提示 提供时间函数 // src/utils/time.tsexport const getTime = () = let message = const hours = new Date().getHours() if (hours = 9) message = 早上 else if (hours = 12) message = 上午 else if (hours = 18) message = 下午 else message = 晚上 return message 修改提示 // 登录const login = async () = loadType.value = true try await userStore.userLogin(loginForm) router.push(/) ElNotification( type: success, message: 欢迎回来, // 修改提示 title: `HI,$getTime()好`, ) loadType.value = false catch (error) loadType.value = false ElNotification( type: error, message: (error as Error).message, ) 5.6 登录表单校验 绑定表单 https://element-plus.org/zh-CN/component/form.html#%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C el-form class=login_form !-- 表单规则 -- :rules=rules !-- 表单数据 -- :model=loginForm !-- 通过ref获取表单组件 -- ref=loginFormRef 定义规则 //定义表单校验需要的配置对象const rules = username: [ //规则对象属性: required: true, // required,代表这个字段务必要校验的 min: 5, //min:文本长度至少多少位 max: 10, // max:文本长度最多多少位 message: 长度应为6-10位, // message:错误的提示信息 trigger: change, //trigger:触发校验表单的时机 change-文本发生变化触发校验, blur:失去焦点的时候触发校验规则 , ], password: [ required: true, min: 6, max: 10, message: 长度应为6-15位, trigger: change, , ],// 获取表单组件const loginFormRef = ref() 执行校验 // 登录const login = async () = //保证全部表单项校验通过 await loginFormRef.value.validate() ... 5.7 自定义校验 自定义规则 有时候默认的校验规则不满足校验要求，这个时候可以自定义校验规则函数 //自定义校验规则函数const validatorUserName = (_rule: any, value: any, callback: any) = //rule：校验规则对象 //value:表单元素文本内容 //callback:符合条件，callback放行通过，不符合：注入错误提示信息 if (value.length = 5) callback() else callback(new Error(账号长度至少5位)) const validatorPassword = (_rule: any, value: any, callback: any) = if (value.length = 6) callback() else callback(new Error(密码长度至少6位)) 添加规则 //定义表单校验需要的配置对象const rules = username: [ validator: validatorUserName, trigger: change , ], password: [ validator: validatorPassword, trigger: change , ], 6. Layout模块6.1 主界面 主界面 !-- src/layout/index.vue --template div class=layout_container !-- 左侧菜单 -- div class=layout_slider/div !-- 顶部导航 -- div class=layout_tabbar/div !-- 内容展示区域 -- div class=layout_main p style=height: 1000000px/p /div /div/templatescript setup lang=ts/scriptstyle lang=scss scoped.layout_container width: 100%; height: 100vh; .layout_slider width: $base-menu-width; height: 100vh; background: $base-menu-background; .layout_tabbar position: fixed; width: calc(100% - $base-menu-width); height: $base-tabbar-height; background: cyan; top: 0; left: $base-menu-width; .layout_main position: absolute; width: calc(100% - $base-menu-width); height: calc(100vh - $base-tabbar-height); background-color: yellowgreen; left: $base-menu-width; top: $base-tabbar-height; padding: 20px; overflow: auto; /style 定义全局变量 // scr/styles/variable.scss// 项目提供scss全局变量//左侧的菜单的宽度$base-menu-width:260px;//左侧菜单的背景颜色$base-menu-background:#001529;$base-menu-min-width:50px;// 顶部导航的高度$base-tabbar-height:50px; 定义滚动条样式 // scr/styles/index.scss//引入清除默认样式@import ./reset.scss;//滚动条外观设置::-webkit-scrollbar width: 10px;::-webkit-scrollbar-thumb width: 10px; background-color: yellowgreen; border-radius: 10px; 6.2 封装LOGO 创建logo组件 !-- src/layout/logo/index.vue --template div class=logo img src=../../../../public/logo.png alt= / pxxx后台管理/p /div/templatescript setup lang=ts/scriptstyle lang=scss scoped.logo width: 100%; height: $base-menu-logo-height; color: white; display: flex; align-items: center; padding: 20px; img width: 40px; height: 40px; p font-size: $base-logo-title-fontSize; margin-left: 10px; /style 添加logo全局变量 // scr/styles/variable.scss//左侧菜单logo高度设置$base-menu-logo-height:50px;//左侧菜单logo右侧文字大小$base-logo-title-fontSize:20px; 引入logo组件 template div class=layout_container !-- 左侧菜单 -- div class=layout_slider !-- 引入logo -- Logo/Logo /div !-- 顶部导航 -- div class=layout_tabbar/div !-- 内容展示区域 -- div class=layout_main p style=height: 1000000px/p /div /div/templatescript setup lang=tsimport Logo from @/views/layout/logo/index.vue/script 抽取配置 为了方便以后对logo以及标题的修改，可以将logo内容抽取到配置文件中 // src/setting.ts//用于项目logo|标题配置export default title: 硅谷甄选运营平台, //项目的标题 logo: /public/logo.png, //项目logo设置 logoHidden: true, //logo组件是否隐藏 修改logo组件 template div class=logo v-if=!setting.logoHidden img :src=setting.logo alt= / p setting.title /p /div/templatescript setup lang=tsimport setting from @/setting/script 6.3 左侧静态菜单组件 左侧滚动条 https://element-plus.org/zh-CN/component/scrollbar.html template div class=layout_container !-- 左侧菜单 -- div class=layout_slider !-- logo -- Logo/Logo !-- 滚动组件 -- el-scrollbar class=scrollbar p v-for=item in 2000 :key=item class=scrollbar-demo-item item /p /el-scrollbar /div !-- 顶部导航 -- div class=layout_tabbar/div !-- 内容展示区域 -- div class=layout_main p style=height: 1000000px/p /div /div/templatestyle lang=scss scoped.layout_container width: 100%; height: 100vh; // 设置字体颜色 color: white; .layout_slider width: $base-menu-width; height: 100vh; background: $base-menu-background; // 设置滚动条样式 .scrollbar width: 100%; height: calc(100vh - $base-menu-logo-height); // 消除滚动border .el-menu border-right: 0; .layout_tabbar position: fixed; width: calc(100% - $base-menu-width); height: $base-tabbar-height; background: cyan; top: 0; left: $base-menu-width; .layout_main position: absolute; width: calc(100% - $base-menu-width); height: calc(100vh - $base-tabbar-height); background-color: yellowgreen; left: $base-menu-width; top: $base-tabbar-height; padding: 20px; overflow: auto; /style 菜单组件 https://element-plus.org/zh-CN/component/menu.html template div class=layout_container !-- 左侧菜单 -- div class=layout_slider !-- logo -- Logo/Logo !-- 滚动组件 -- el-scrollbar !-- 菜单组件 -- el-menu background-color=#001529 text-color=white el-menu-item index=1首页/el-menu-item el-menu-item index=2数据大屏/el-menu-item !-- 折叠菜单 -- el-sub-menu index=3 template #title span权限管理/span /template el-menu-item index=3-1用户管理/el-menu-item el-menu-item index=3-2角色管理/el-menu-item el-menu-item index=3-3菜单管理/el-menu-item /el-sub-menu /el-menu /el-scrollbar /div !-- 顶部导航 -- div class=layout_tabbar/div !-- 内容展示区域 -- div class=layout_main p style=height: 1000000px/p /div /div/template 6.4 动态菜单组件 封装组件 src\\layout\\menu\\index.vue template !-- 菜单组件 -- el-menu background-color=#001529 text-color=white el-menu-item index=1首页/el-menu-item el-menu-item index=2数据大屏/el-menu-item !-- 折叠菜单 -- el-sub-menu index=3 template #title span权限管理/span /template el-menu-item index=3-1用户管理/el-menu-item el-menu-item index=3-2角色管理/el-menu-item el-menu-item index=3-3菜单管理/el-menu-item /el-sub-menu /el-menu/templatescript setup lang=ts/scriptstyle lang=scss scoped/style src\\layout\\index.vue template div class=layout_container !-- 左侧菜单 -- div class=layout_slider !-- logo -- Logo/Logo !-- 滚动组件 -- el-scrollbar class=scrollbar Menu/Menu /el-scrollbar /div !-- 顶部导航 -- div class=layout_tabbar/div !-- 内容展示区域 -- div class=layout_main p style=height: 1000000px/p /div /div/templatescript setup lang=tsimport Logo from ./logo/index.vueimport Menu from ./menu/index.vue/script 路由信息存入pinia 定义路由类型 src\\store\\modules\\type\\type.ts import RouteRecordRaw from vue-routerexport interface UserState token: string | null menuRoutes: RouteRecordRaw[] // 路由类型 路由信息存入state import constantRoute from @/router/router// 创建用户仓库const useUserStore = defineStore(User, // 用户仓库存储数据地方 state(): UserState return token: GET_TOKEN(), menuRoutes: constantRoute, , ...) 路由添加meta信息 src\\router\\router.ts // 对外暴露配置路由(常量路由)export const constantRoute = [ //登录 path: /login, component: () = import(@/views/login/index.vue), name: login, meta: title: 登录, //菜单标题 , , //登录成功以后展示数据的路由 path: /, component: () = import(@/layout/index.vue), name: layout, meta: title: layout, , redirect: /home, children: [ path: /home, component: () = import(@/views/home/index.vue), meta: title: 首页, , , path: /home2, component: () = import(@/views/home/index.vue), meta: title: 首页2, , , ], , //404 path: /404, component: () = import(@/views/404/index.vue), name: 404, meta: title: 404, , ,] 父组件获取路由信息并传递给子组件 src\\layout\\index.vue template div class=layout_container !-- 左侧菜单 -- div class=layout_slider !-- logo -- Logo/Logo !-- 滚动组件 -- el-scrollbar class=scrollbar el-menu background-color=#001529 text-color=white // 传递路由数据 Menu :menuList=userStore.menuRoutes/Menu /el-menu /el-scrollbar /div !-- 顶部导航 -- div class=layout_tabbar/div !-- 内容展示区域 -- div class=layout_main p style=height: 1000000px/p /div /div/templatescript setup lang=tsimport Logo from ./logo/index.vueimport Menu from ./menu/index.vueimport useUserStore from @/store/modules/user// 获取用户仓库const userStore = useUserStore()/script 子组件根据路由数据动态创建菜单 src\\layout\\menu\\index.vue template template v-for=item in menuList :key=item.path !-- 没有子路由 -- el-menu-item v-if=!item.children :index=item.path template #title span标/span span item.meta.title /span /template /el-menu-item !-- 有子路由但只有一个子路由 -- el-menu-item v-if=item.children item.children.length === 1 :index=item.children[0].path template #title span标/span span item.children[0].meta.title /span /template /el-menu-item !-- 有子路由且个数大于一个 -- el-sub-menu :index=item.path v-if=item.children item.children.length = 2 template #title span item.meta.title /span /template !-- 递归创建菜单 -- Menu :menuList=item.children/Menu /el-sub-menu /template/templatescript setup lang=ts//获取父组件传递过来的全部路由数组defineProps([menuList])/scriptscript lang=tsexport default // eslint-disable-next-line vue/no-reserved-component-names name: Menu,/scriptstyle lang=scss scoped/style 注意：当子路由个数大于等于一个时，并且或许子路由还有后代路由时。这里我们使用了递归组件。递归组件需要命名（另外使用一个script标签，vue2格式）。 菜单隐藏 添加meta信息 src\\router\\router.ts // 对外暴露配置路由(常量路由)export const constantRoute = [ //登录 path: /login, component: () = import(@/views/login/index.vue), name: login, meta: title: 登录, //菜单标题 hidden: true, //代表路由标题在菜单中是否隐藏 true:隐藏 false:不隐藏 , , //登录成功以后展示数据的路由 path: /, component: () = import(@/layout/index.vue), name: layout, meta: title: layout, hidden: false, , redirect: /home, children: [ path: /home, component: () = import(@/views/home/index.vue), meta: title: 首页, hidden: false, , , path: /home2, component: () = import(@/views/home/index.vue), meta: title: 首页2, hidden: false, icon: HomeFilled, , , ], , //404 path: /404, component: () = import(@/views/404/index.vue), name: 404, meta: title: 404, hidden: true, , ,] 为方便判断修改menu组件 src\\layout\\menu\\index.vue template template v-for=item in menuList :key=item.path !-- 没有子路由 -- template v-if=!item.children el-menu-item v-if=!item.meta.hidden :index=item.path template #title span标/span span item.meta.title /span /template /el-menu-item /template !-- 有子路由但只有一个子路由 -- template v-if=item.children item.children.length === 1 el-menu-item v-if=!item.children[0].meta.hidden :index=item.children[0].path template #title span标/span span item.children[0].meta.title /span /template /el-menu-item /template !-- 有子路由且个数大于一个 -- el-sub-menu v-if=item.children item.children.length = 2 :index=item.path template #title span item.meta.title /span /template !-- 递归创建菜单 -- Menu :menuList=item.children/Menu /el-sub-menu /template/templatescript setup lang=ts//获取父组件传递过来的全部路由数组defineProps([menuList])/scriptscript lang=tsexport default // eslint-disable-next-line vue/no-reserved-component-names name: Menu,/scriptstyle lang=scss scoped/style 添加菜单图标 注册图标组件 src\\components\\index.ts import SvgIcon from ./SvgIcon/index.vueimport type App, Component from vue//引入element-plus提供全部图标组件import * as ElementPlusIconsVue from @element-plus/icons-vueconst components: [name: string]: Component = SvgIcon //对外暴露插件对象export default //务必叫做install方法 install(app: App) //注册项目全部的全局组件 Object.keys(components).forEach((key) = //注册为全局组件 app.component(key, components[key]) ) //将element-plus提供全部图标注册为全局组件 for (const [key, component] of Object.entries(ElementPlusIconsVue)) app.component(key, component) , 添加meta信息 https://element-plus.org/zh-CN/component/icon.html src\\router\\router.ts // 对外暴露配置路由(常量路由)export const constantRoute = [ //登录 path: /login, component: () = import(@/views/login/index.vue), name: login, meta: title: 登录, //菜单标题 hidden: false, //代表路由标题在菜单中是否隐藏 true:隐藏 false:不隐藏 icon: Promotion, //菜单文字左侧的图标,支持element-plus全部图标 , , //登录成功以后展示数据的路由 path: /, component: () = import(@/layout/index.vue), name: layout, meta: title: , hidden: false, icon: , , redirect: /home, children: [ path: /home, component: () = import(@/views/home/index.vue), meta: title: 首页, hidden: false, icon: HomeFilled, , , ], , //404 path: /404, component: () = import(@/views/404/index.vue), name: 404, meta: title: 404, hidden: false, icon: DocumentDelete, , ,] 修改menu组件 src\\layout\\menu\\index.vue template template v-for=item in menuList :key=item.path !--没有子路由-- template v-if=!item.children el-menu-item :index=item.path v-if=!item.meta.hidden !-- 图标 -- el-icon component :is=item.meta.icon/component /el-icon template #title span item.meta.title /span /template /el-menu-item /template !-- 有子路由但是只有一个子路由 -- template v-if=item.children item.children.length == 1 el-menu-item :index=item.children[0].path v-if=!item.children[0].meta.hidden !-- 图标 -- el-icon component :is=item.children[0].meta.icon/component /el-icon template #title span item.children[0].meta.title /span /template /el-menu-item /template !-- 有子路由且个数大于一个1 -- el-sub-menu :index=item.path v-if=item.children item.children.length 1 template #title !-- 图标 -- el-icon component :is=item.meta.icon/component /el-icon span item.meta.title /span /template Menu :menuList=item.children/Menu /el-sub-menu /template/templatescript setup lang=ts//获取父组件传递过来的全部路由数组defineProps([menuList])/scriptscript lang=tsexport default // eslint-disable-next-line vue/no-reserved-component-names name: Menu,/scriptstyle lang=scss scoped/style 路由跳转 点击菜单时需要跳转至对应路由界面，@click=goRoute(item.path) template template v-for=item in menuList :key=item.path !--没有子路由-- template v-if=!item.children el-menu-item :index=item.path v-if=!item.meta.hidden @click=goRoute(item.path) el-icon !-- 图标 -- component :is=item.meta.icon/component /el-icon template #title span item.meta.title /span /template /el-menu-item /template !-- 有子路由但是只有一个子路由 -- template v-if=item.children item.children.length == 1 el-menu-item :index=item.children[0].path v-if=!item.children[0].meta.hidden @click=goRoute(item.children[0].path) el-icon component :is=item.children[0].meta.icon/component /el-icon template #title span item.children[0].meta.title /span /template /el-menu-item /template !-- 有子路由且个数大于一个1 -- el-sub-menu :index=item.path v-if=item.children item.children.length 1 template #title el-icon component :is=item.meta.icon/component /el-icon span item.meta.title /span /template Menu :menuList=item.children/Menu /el-sub-menu /template/templatescript setup lang=tsimport useRouter from vue-router// 获取父组件传递过来的全部路由数组defineProps([menuList])const route = useRouter()// 根据路由路径跳转const goRoute = (path: string) = route.push(path)/scriptscript lang=tsexport default // eslint-disable-next-line vue/no-reserved-component-names name: Menu,/scriptstyle lang=scss scoped/style 6.5 封装Main组件 封装内容展示区域组件，添加路由跳转动画 https://router.vuejs.org/zh/guide/advanced/transitions.html src\\layout\\main\\index.vue template !-- 路由组件出口的位置 -- router-view v-slot= Component transition name=fade !-- 渲染layout一级路由的子路由 -- component :is=Component / /transition /router-view/templatescript setup lang=ts/scriptstyle lang=scss scoped.fade-enter-from opacity: 0;.fade-enter-active transition: all 0.3s;.fade-enter-to opacity: 1;/style 修改layout src\\layout\\index.vue template div class=layout_container !-- 左侧菜单 -- div class=layout_slider !-- logo -- Logo/Logo !-- 滚动组件 -- el-scrollbar class=scrollbar el-menu background-color=#001529 text-color=white Menu :menuList=userStore.menuRoutes/Menu /el-menu /el-scrollbar /div !-- 顶部导航 -- div class=layout_tabbar/div !-- 内容展示区域 -- div class=layout_main Main/Main /div /div/template 6.6 配置全路由 配置路由 src\\router\\router.ts // 对外暴露配置路由(常量路由)export const constantRoute = [ //登录 path: /login, component: () = import(@/views/login/index.vue), name: login, meta: title: 登录, //菜单标题 hidden: true, //代表路由标题在菜单中是否隐藏 true:隐藏 false:不隐藏 icon: Promotion, //菜单文字左侧的图标,支持element-plus全部图标 , , //登录成功以后展示数据的路由 path: /, component: () = import(@/layout/index.vue), name: layout, meta: title: , hidden: false, icon: , , redirect: /home, children: [ path: /home, component: () = import(@/views/home/index.vue), meta: title: 首页, hidden: false, icon: HomeFilled, , , ], , //404 path: /404, component: () = import(@/views/404/index.vue), name: 404, meta: title: 404, hidden: true, icon: DocumentDelete, , , path: /acl, component: () = import(@/layout/index.vue), name: Acl, meta: hidden: false, title: 权限管理, icon: Lock, , children: [ path: /acl/user, component: () = import(@/views/acl/user/index.vue), name: User, meta: hidden: false, title: 用户管理, icon: User, , , path: /acl/role, component: () = import(@/views/acl/role/index.vue), name: Role, meta: hidden: false, title: 角色管理, icon: UserFilled, , , path: /acl/permission, component: () = import(@/views/acl/permission/index.vue), name: Permission, meta: hidden: false, title: 菜单管理, icon: Monitor, , , ], ,] 创建相应组件 6.7 菜单刷新展示 问题 当页面刷新时，菜单会自动收起。使用element-plus的default-active 处理 处理 https://element-plus.org/zh-CN/component/menu.html#menu-attributes template div class=layout_container !-- 左侧菜单 -- div class=layout_slider !-- logo -- Logo/Logo !-- 滚动组件 -- el-scrollbar class=scrollbar el-menu background-color=#001529 text-color=white :default-active=route.path Menu :menuList=userStore.menuRoutes/Menu /el-menu /el-scrollbar /div !-- 顶部导航 -- div class=layout_tabbar/div !-- 内容展示区域 -- div class=layout_main Main/Main /div /div/templatescript setup lang=tsimport Logo from ./logo/index.vueimport Menu from ./menu/index.vueimport useUserStore from @/store/modules/userimport Main from ./main/index.vueimport useRoute from vue-routerconst userStore = useUserStore()// 获取路由const route = useRoute()/script 6.8 顶部tabbar组件 添加静态界面 https://element-plus.org/zh-CN/component/breadcrumb.html https://element-plus.org/zh-CN/component/dropdown.html src\\layout\\tabbar\\index.vue template div class=tabbar div class=tabbar_left !-- 顶部左侧的图标 -- el-icon style=margin-right: 10px Expand/Expand /el-icon !-- 左侧的面包屑 -- el-breadcrumb separator-icon=ArrowRight el-breadcrumb-item权限管理/el-breadcrumb-item el-breadcrumb-item用户管理/el-breadcrumb-item /el-breadcrumb /div div class=tabbar_right el-button size=small icon=Refresh circle/el-button el-button size=small icon=FullScreen circle/el-button el-button size=small icon=Setting circle/el-button img src=../../../public/logo.png style=width: 24px; height: 24px; margin: 0px 10px / !-- 下拉菜单 -- el-dropdown span class=el-dropdown-link admin el-icon class=el-icon--right arrow-down / /el-icon /span template #dropdown el-dropdown-menu el-dropdown-item退出登陆/el-dropdown-item /el-dropdown-menu /template /el-dropdown /div /div/templatescript setup lang=ts/scriptstyle lang=scss scoped.tabbar width: 100%; height: 100%; display: flex; justify-content: space-between; background-image: linear-gradient( to right, rgb(236, 229, 229), rgb(151, 136, 136), rgb(240, 234, 234) ); .tabbar_left display: flex; align-items: center; margin-left: 20px; .tabbar_right display: flex; align-items: center; /style 拆分组件 src\\layout\\tabbar\\breadcrumb\\index.vue template !-- 顶部左侧的图标 -- el-icon style=margin-right: 10px Expand/Expand /el-icon !-- 左侧的面包屑 -- el-breadcrumb separator-icon=ArrowRight el-breadcrumb-item权限挂历/el-breadcrumb-item el-breadcrumb-item用户管理/el-breadcrumb-item /el-breadcrumb/templatescript setup lang=ts/scriptstyle lang=scss scoped/style src\\layout\\tabbar\\setting\\index.vue template el-button size=small icon=Refresh circle/el-button el-button size=small icon=FullScreen circle/el-button el-button size=small icon=Setting circle/el-button img src=../../../../public/logo.png style=width: 24px; height: 24px; margin: 0px 10px / !-- 下拉菜单 -- el-dropdown span class=el-dropdown-link admin el-icon class=el-icon--right arrow-down / /el-icon /span template #dropdown el-dropdown-menu el-dropdown-item退出登陆/el-dropdown-item /el-dropdown-menu /template /el-dropdown/templatescript setup lang=ts/scriptstyle lang=scss scoped/style src\\layout\\tabbar\\index.vue template div class=tabbar div class=tabbar_left Breadcrumb/Breadcrumb /div div class=tabbar_right Setting/Setting /div /div /template script setup lang=ts import Breadcrumb from ./breadcrumb/index.vue import Setting from ./setting/index.vue /script### 6.9 菜单折叠1. 修改折叠图标 添加点击事件根据折叠状态判断，展示不同图标 https://cn.vuejs.org/guide/essentials/component-basics.html#dynamic-components `src\\layout\\tabbar\\breadcrumb\\index.vue` ```html template !-- 顶部左侧的图标 -- el-icon style=margin-right: 10px @click=changeIcon !-- 动态切换图标 -- component :is=settingStore.fold ? Fold : Expand/component /el-icon !-- 左侧的面包屑 -- el-breadcrumb separator-icon=ArrowRight el-breadcrumb-item权限管理/el-breadcrumb-item el-breadcrumb-item用户管理/el-breadcrumb-item /el-breadcrumb /template script setup lang=ts import useSettingStore from @/store/modules/setting //获取layout配置相关的仓库 let settingStore = useSettingStore() const changeIcon = () = console.log(settingStore.fold) settingStore.fold = !settingStore.fold /script style lang=scss scoped/style 因为整个左侧栏、顶部tabbar栏和main界面都受到折叠效果影响，所以将折叠状态存入pinia 新建setting仓库 src\\store\\modules\\setting.ts //小仓库：layout组件相关配置仓库import defineStore from piniaconst useSettingStore = defineStore(SettingStore, state: () = return fold: false, //用户控制菜单折叠还是收起的控制 ,)export default useSettingStore 联动更新左侧菜单栏 点击折叠时，动态修改左侧菜单栏宽度。 添加全局属性 src\\styles\\variable.scss //左侧菜单最小宽度$base-menu-min-width:50px; 绑定动态属性 src\\layout\\index.vue template div class=layout_container !-- 左侧菜单 -- div class=layout_slider :class= fold: settingStore.fold ? true : false /div /div/templatescript setup lang=tsimport useSettingStore from @/store/modules/settingconst settingStore = useSettingStore()/scriptstyle lang=scss scoped.layout_container width: 100%; height: 100vh; color: white; .layout_slider width: $base-menu-width; height: 100vh; background: $base-menu-background; transition: all 0.1s; // 添加左侧菜单最小宽度 .fold width: $base-menu-min-width; .scrollbar width: 100%; height: calc(100vh - $base-menu-logo-height); .el-menu border-right: 0; /style 左侧菜单栏修改折叠状态：collapse https://element-plus.org/zh-CN/component/menu.html#menu-attributes src\\layout\\index.vue template div class=layout_container !-- 左侧菜单 -- div class=layout_slider :class= fold: settingStore.fold ? true : false !-- logo -- Logo/Logo !-- 滚动组件 -- el-scrollbar class=scrollbar el-menu background-color=#001529 text-color=white :default-active=route.path :collapse=settingStore.fold Menu :menuList=userStore.menuRoutes/Menu /el-menu /el-scrollbar /div /div/template 联动更新tabbar template div class=layout_container !-- 顶部导航 -- div class=layout_tabbar :class= fold: settingStore.fold ? true : false Tabbar/Tabbar /div /div/templatescript setup lang=tsimport useSettingStore from @/store/modules/setting const settingStore = useSettingStore()/scriptstyle lang=scss scoped .layout_tabbar position: fixed; width: calc(100% - $base-menu-width); height: $base-tabbar-height; background: cyan; top: 0; left: $base-menu-width; transition: all 0.1s; .fold // 宽度 = 界面宽度 - 折叠后菜单栏所占宽度 width: calc(100vw - $base-menu-min-width); // 距离折叠后菜单栏宽度 left: $base-menu-min-width; /style 联动更新main template div class=layout_container !-- 内容展示区域 -- div class=layout_main :class= fold: settingStore.fold ? true : false Main/Main /div /div/templatescript setup lang=tsimport useSettingStore from @/store/modules/settingconst settingStore = useSettingStore()/scriptstyle lang=scss scoped .layout_main position: absolute; width: calc(100% - $base-menu-width); height: calc(100vh - $base-tabbar-height); background-color: yellowgreen; left: $base-menu-width; top: $base-tabbar-height; padding: 20px; overflow: auto; transition: all 0.1s; .fold width: calc(100vw - $base-menu-min-width); left: $base-menu-min-width; /style 6.10 动态更新面包屑 获取路由 使用route.matched函数，此函数能得到当前路由的信息 修改界面 src\\layout\\tabbar\\breadcrumb\\index.vue template !-- 左侧的面包屑 -- el-breadcrumb separator-icon=ArrowRight el-breadcrumb-item v-for=(item, index) in route.matched :key=index v-show=item.meta.title :to=item.path item.meta.title /el-breadcrumb-item /el-breadcrumb/templatescript setup lang=tsimport useSettingStore from @/store/modules/settingimport useRoute from vue-router// 获取layout配置相关的仓库let settingStore = useSettingStore()// 路由const route = useRoute()const changeIcon = () = console.log(settingStore.fold) settingStore.fold = !settingStore.fold/scriptstyle lang=scss scoped/style v-show控制无标题时不显示 设置点击权限管理时自动跳转到用户管理 src\\router\\router.ts path: /acl, component: () = import(@/layout/index.vue), name: Acl, meta: hidden: false, title: 权限管理, icon: Lock, , redirect: /acl/user, 6.11 刷新功能实现 在setting仓库添加refresh属性 src\\store\\modules\\setting.ts //小仓库：layout组件相关配置仓库import defineStore from piniaconst useSettingStore = defineStore(SettingStore, state: () = return fold: false, //用户控制菜单折叠还是收起的控制 refresh: false, //用于控制刷新效果 ,)export default useSettingStore 在setting.vue组件中配置刷新按钮点击事件 src\\layout\\tabbar\\setting\\index.vue template el-button size=small icon=Refresh circle @click=updateRefresh /el-button/templatescript setup lang=tsimport useSettingStore from @/store/modules/settingconst settingStore = useSettingStore()const updateRefresh = () = settingStore.refresh = !settingStore.refresh/scriptstyle lang=scss scoped/style 在main组件中监听按钮状态值，状态值变化就重建路由组件 src\\layout\\main\\index.vue template !-- 路由组件出口的位置 -- router-view v-slot= Component transition name=fade div v-if=flag !-- 渲染layout一级路由的子路由 -- component :is=Component / /div /transition /router-view/templatescript setup lang=tsimport ref, watch, nextTick from vueimport useSettingStore from @/store/modules/settingconst settingStore = useSettingStore()//控制当前组件是否销毁重建let flag = ref(true)//监听仓库内部的数据是否发生变化，如果发生变化，说明用户点击过刷新按钮watch( () = settingStore.refresh, () = //点击刷新按钮：路由组件销毁 flag.value = false // 异步刷新，vue重建DOM后会调用该方法 // https://lianyutian.github.io/posts/dd58b23f.html 9.5章节 nextTick(() = flag.value = true ) ,)/script 6.12 全屏功能实现 绑定全屏按钮点击事件 src\\layout\\tabbar\\setting\\index.vue template el-button size=small icon=FullScreen circle @click=fullScreen /el-buttonscript setup lang=ts// 全屏功能const fullScreen = () = // DOM对象的一个属性：可以用来判断当前是不是全屏的模式【全屏：true，不是全屏：false】 let full = document.fullscreenElement // 切换成全屏 if (!full) // 文档根节点的方法requestFullscreen实现全屏 document.documentElement.requestFullscreen() else // 退出全屏 document.exitFullscreen() /scriptstyle lang=scss scoped/style 7. 登录业务完善7.1 获取用户信息 添加用户state存储类型和属性 src\\store\\modules\\type\\type.ts import RouteRecordRaw from vue-routerexport interface UserState token: string | null menuRoutes: RouteRecordRaw[] username: string avatar: string src\\store\\modules\\user.ts // 创建用户小仓库const useUserStore = defineStore(UserStore, // 用户仓库存储数据地方 state(): UserState return token: GET_TOKEN(), menuRoutes: constantRoute, username: , avatar: , // 用户头像 , 添加获取信息方法 userInfoAction src\\store\\modules\\user.ts // src/store/modules/user.ts// 创建用户相关的仓库import defineStore from piniaimport loginForm, loginResponseData from @/api/user/typeimport reqLogin, reqUserInfo from @/api/userimport GET_TOKEN, SET_TOKEN from @/utils/tokenimport UserState from ./type/typeimport constantRoute from @/router/router// 创建用户小仓库const useUserStore = defineStore(UserStore, // 用户仓库存储数据地方 state(): UserState return token: GET_TOKEN(), menuRoutes: constantRoute, username: , avatar: , , // 处理异步|逻辑地方 actions: // 获取用户信息 async userInfoAction() const result = await reqUserInfo() if (result.code === 200) this.username = result.data.checkUser.username this.avatar = result.data.checkUser.avatar console.log(result) , , getters: ,)// 对外暴露小仓库export default useUserStore 修改请求携带token信息 此前获取用户信息，未携带token会获取不到用户信息 src\\utils\\request.ts import axios from axiosimport ElMessage from element-plusimport useUserStore from @/store/modules/user//创建axios实例const request = axios.create( baseURL: import.meta.env.VITE_APP_BASE_API, timeout: 5000,)//请求拦截器request.interceptors.request.use((config) = //获取用户相关的小仓库，获取token，登录成功以后携带个i服务器 const userStore = useUserStore() if (userStore.token) config.headers.token = userStore.token //config配置对象，headers请求头，经常给服务器端携带公共参数 //返回配置对象 return config) home组件挂载获取用户信息 登录之后页面（home）上来就要获取用户信息。并且将它使用到页面中 src\\views\\home\\index.vue template div一级路由home/div/templatescript setup lang=tsimport onMounted from vueimport useUserStore from @/store/modules/userconst userStore = useUserStore()onMounted(() = userStore.userInfoAction())/script 修改设置组件中的用户信息 src\\layout\\tabbar\\setting\\index.vue template img :src=userStore.avatar style=width: 24px; height: 24px; margin: 0px 10px / !-- 下拉菜单 -- el-dropdown span class=el-dropdown-link userStore.username el-icon class=el-icon--right arrow-down / /el-icon /span template #dropdown el-dropdown-menu el-dropdown-item退出登陆/el-dropdown-item /el-dropdown-menu /template /el-dropdown/templatescript setup lang=tsimport useSettingStore from @/store/modules/settingimport useUserStore from @/store/modules/userimport useStore from element-plus/es/components/table/src/store/index.mjsconst userStore = useUserStore()/script 7.2 退出登录 绑定退出登录按钮点击事件 src\\layout\\tabbar\\setting\\index.vue template !-- 下拉菜单 -- el-dropdown template #dropdown el-dropdown-menu el-dropdown-item @click=logout退出登陆/el-dropdown-item /el-dropdown-menu /template /el-dropdown/templatescript setup lang=tsimport useSettingStore from @/store/modules/settingimport useUserStore from @/store/modules/userimport useRouter, useRoute from vue-routerconst userStore = useUserStore()// 退出登录const router = useRouter()const route = useRoute()const logout = () = //第一件事：需要项服务器发请求【退出登录接口】（我们这里没有） //第二件事：仓库当中和关于用户的相关的数据清空 userStore.userLogoutAction() //第三件事：跳转到登陆页面 router.push( path: /login, query: redirect: route.path )/script 携带的query参数方便下次登陆时直接跳转到当时推出的界面 清空用户信息 src\\store\\modules\\user.ts // src/store/modules/user.ts// 创建用户相关的仓库import defineStore from piniaimport loginForm, loginResponseData from @/api/user/typeimport reqLogin, reqUserInfo from @/api/userimport GET_TOKEN, SET_TOKEN, REMOVE_TOKEN from @/utils/tokenimport UserState from ./type/typeimport constantRoute from @/router/router// 创建用户小仓库const useUserStore = defineStore(UserStore, // 用户仓库存储数据地方 state(): UserState return token: GET_TOKEN(), menuRoutes: constantRoute, username: , avatar: , // 用户头像 , // 处理异步|逻辑地方 actions: // 退出登录 userLogoutAction() //当前没有mock接口（不做）：服务器数据token失效 //本地数据清空 this.token = this.username = this.avatar = REMOVE_TOKEN() , , getters: ,)// 对外暴露小仓库export default useUserStore 添加清除token方法 src\\utils\\token.ts export const REMOVE_TOKEN = () = localStorage.removeItem(TOKEN) 登录时判断是否有query参数 src\\views\\login\\index.vue script setup lang=tsconst router = useRouter()const route = useRoute()let userStore = useUserStore()// 登录const login = async () = //保证全部表单项校验通过 await loginFormRef.value.validate() loadType.value = true try await userStore.userLoginAction(loginForm) //编程式导航跳转到展示数据首页 //判断登录的时候,路由路径当中是否有query参数，如果有就往query参数挑战，没有跳转到首页 let redirect: any = route.query.redirect router.push( path: redirect || / ) ElNotification( type: success, message: 欢迎回来, title: `HI,$getTime()好`, ) loadType.value = false catch (error) loadType.value = false ElNotification( type: error, message: (error as Error).message, ) /script 此时不在首页界面退出登录会有登录后再登录获取不到用户信息的bug，后面修复 7.4 路由鉴权 安装进度条组件 pnpm i nprogress 新建permisstion.ts src\\permisstion.ts //路由鉴权：鉴权：项目当中路由能不能被访问的权限import router from @/routerimport setting from ./settingimport nprogress from nprogress//引入进度条样式import nprogress/nprogress.css//进度条的加载圆圈不要nprogress.configure( showSpinner: false )//获取用户相关的小仓库内部token数据，去判断用户是否登陆成功import useUserStore from @/store/modules/user//为什么要引piniaimport pinia from ./storeconst userStore = useUserStore(pinia)//全局前置守卫router.beforeEach(async (to: any, from: any, next: any) = //网页的名字 document.title = `$setting.title-$to.meta.title` //访问某一个路由之前的守卫 nprogress.start() //获取token，去判断用户登录、还是未登录 const token = userStore.token //获取用户名字 const username = userStore.username //用户登录判断 if (token) //登陆成功，访问login。指向首页 if (to.path == /login) next(/home) else //登陆成功访问其余的，放行 //有用户信息 if (username) //放行 next() else //如果没有用户信息，在收尾这里发请求获取到了用户信息再放行 try //获取用户信息 await userStore.userInfoAction() next() catch (error) //token过期|用户手动处理token //退出登陆-用户相关的数据清空 userStore.userLogoutAction() next( path: /login, query: redirect: to.path ) else //用户未登录 if (to.path == /login) next() else next( path: /login, query: redirect: to.path ) next())//全局后置守卫router.afterEach((to: any, from: any) = // to and from are both route objects. nprogress.done())//第一个问题：任意路由切换实现进度条业务 ----nprogress//第二个问题：路由鉴权//全部路由组件 ：登录|404|任意路由|首页|权限管理（三个子路由）|//用户未登录 ：可以访问login 其余都不行//登陆成功：不可以访问login 其余都可以 问题？ 不引入pinia时 全局路由守卫将获取用户信息的请求放在了跳转之前。实现了刷新后用户信息丢失的功能","tags":["Vue3","Pinia","后台管理"],"categories":["前端"]},{"title":"vue2基础","path":"/2023/12/14/2023-12-14-vue2-基础/","content":"1. Vue快速上手 Vue (读音 vjuː，类似于 view) 是一套 **构建用户界面 ** 的 渐进式 框架 Vue2官网：https://v2.cn.vuejs.org/ 1.1 什么是构建用户界面 基于数据渲染出用户可以看到的界面 1.2 创建Vue实例 准备容器 引包（官网） — 开发版本生产版本 创建Vue实例 new Vue() 指定配置项，渲染数据 el:指定挂载点 data提供数据 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody!-- 创建Vue实例，初始化渲染 1. 准备容器 (Vue所管理的范围) 2. 引包 (开发版本包 / 生产版本包) 官网 3. 创建实例 4. 添加配置项 = 完成渲染--!-- 不是Vue管理的范围 --div class=box2 box2 -- count /divdiv class=box box -- msg /div-----------------------------------------------------!-- Vue所管理的范围 --div id=app !-- 这里将来会编写一些用于渲染的代码逻辑 -- h1 msg /h1 a href=# count /a/div!-- 引入的是开发版本包 - 包含完整的注释和警告 --script src=https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js/scriptscript // 一旦引入 VueJS核心包，在全局环境，就有了 Vue 构造函数 const app = new Vue( // 通过 el 配置选择器，指定 Vue 管理的是哪个盒子 el: #app, // 通过 data 提供数据 data: msg: Hello 传智播客, count: 666 )/script/body/html 1.3 插值表达式 利用表达式进行插值，渲染到页面中 表达式：是可以被求值的代码，JS引擎会讲其计算出一个结果 以下的情况都是表达式： money + 100money - 100money * 10money / 10 price = 100 ? 真贵:还行obj.namearr[0]fn()obj.fn() 语法 插值表达式语法： h3titleh3pnickName.toUpperCase()/ppage = 18 ? 成年:未成年/ppobj.name/ppfn()/p 错误用法 1.在插值表达式中使用的数据 必须在data中进行了提供phobby/p //如果在data中不存在 则会报错2.支持的是表达式，而非语句，比如：if for ...pif/p3.不能在标签属性中使用 插值 (插值表达式只能标签中间使用)p title=username我是P标签/p 1.4 响应式特性 简单理解就是数据变，视图对应变。 如何访问 和 修改 data中的数据（响应式演示） data中的数据, 最终会被添加到实例上 ① 访问数据： “实例.属性名” ② 修改数据： “实例.属性名” “值” 1.5 开发者工具 通过谷歌应用商店安装（国外网站） 极简插件下载（推荐） https://chrome.zzzmh.cn/index 安装步骤 安装之后可以F12后看到多一个Vue的调试面板 2. Vue指令 概念 指令（Directives）是 Vue 提供的带有 v- 前缀 的 特殊 标签属性。 分类 vue 中的指令按照不同的用途可以分为如下 6 大类： 内容渲染指令（v-html、v-text） 条件渲染指令（v-show、v-if、v-else、v-else-if） 事件绑定指令（v-on） 属性绑定指令 （v-bind） 双向绑定指令（v-model） 列表渲染指令（v-for） 指令是 vue 开发中最基础、最常用、最简单的知识点。 2.1 内容渲染指令 v-text（类似innerText） 使用语法：p v-text=unamehello/p，意思是将 uame 值渲染到 p 标签中 类似 innerText，使用该语法，会覆盖 p 标签原有内容 v-html（类似 innerHTML） 使用语法：p v-html=introhello/p，意思是将 intro 值渲染到 p 标签中 类似 innerHTML，使用该语法，会覆盖 p 标签原有内容，能够将HTML标签的样式呈现出来。 示例 div id=app h2个人信息/h2 // 既然指令是vue提供的特殊的html属性，所以咱们写的时候就当成属性来用即可 p v-text=uname姓名：/p p v-html=intro简介：/p/div script const app = new Vue( el:#app, data: uname:张三, intro:h2这是一个strong非常优秀/strong的boyh2 )/script 2.2 条件渲染指令 v-show 作用： 控制元素显示隐藏 语法： v-show “表达式” 表达式值为 true 显示， false 隐藏 原理： 切换 display:none 控制显示隐藏 场景：频繁切换显示隐藏的场景 v-if 作用： 控制元素显示隐藏（条件渲染） 语法： v-if “表达式” 表达式值 true显示， false 隐藏 原理： 基于条件判断，是否创建 或 移除元素节点 场景： 要么显示，要么隐藏，不频繁切换的场景 示例 body !-- v-show底层原理：切换 css 的 display: none 来控制显示隐藏 v-if 底层原理：根据 判断条件 控制元素的 创建 和 移除（条件渲染） -- div id=app div v-show=flag class=box我是v-show控制的盒子/div div v-if=flag class=box我是v-if控制的盒子/div /div script src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/script script const app = new Vue( el: #app, data: flag: false ) /script/body v-else 和 v-else-if 作用：辅助v-if进行判断渲染 语法：v-else v-else-if”表达式” 需要紧接着v-if使用 示例 htmlbody div id=app p v-if=gender === 1性别：♂ 男/p p v-else性别：♀ 女/p hr p v-if=score = 90成绩评定A：奖励电脑一台/p p v-else-if=score = 70成绩评定B：奖励周末郊游/p p v-else-if=score = 60成绩评定C：奖励零食礼包/p p v-else成绩评定D：惩罚一周不能玩手机/p /div script src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/script script const app = new Vue( el: #app, data: gender: 2, score: 95 ) /script/body/html 2.3 事件绑定指令 使用Vue时，如需为DOM注册事件，及其的简单，语法如下： button v-on:事件名”内联语句”按钮 button v-on:事件名”处理函数”按钮 button v-on:事件名”处理函数(实参)”按钮 v-on: 简写为 @ 内联语句 div id=app button @click=count---/button span count /span button v-on:click=count+++/button /div script src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/script script const app = new Vue( el: #app, data: count: 100 ) /script 事件处理函数 事件处理函数应该写到一个跟data同级的配置项（methods）中 methods中的函数内部的this都指向Vue实例 示例 body div id=app button @click=fn切换显示隐藏/button h1 v-show=isShow黑马程序员/h1 /div script src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/script script const app4 = new Vue( el: #app, data: isShow: true , methods: fn () // 让提供的所有methods中的函数，this都指向当前实例 // console.log(执行了fn, app.isShow) // console.log(app3 === this) this.isShow = !this.isShow ) /script/body 给事件处理函数传参 如果不传递任何参数，则方法无需加小括号；methods方法中可以直接使用 e 当做事件对象 如果传递了参数，则实参 $event 表示事件对象，固定用法。 示例 body div id=app div class=box h3小黑自动售货机/h3 button @click=buy(5)可乐5元/button button @click=buy(10)咖啡10元/button button @click=buy(8)牛奶8元/button /div p银行卡余额： money 元/p /div script src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/script script const app = new Vue( el: #app, data: money: 100 , methods: buy (price) this.money -= price ) /script/body 2.4 属性绑定指令 作用 动态设置html的标签属性 比如：src、url、title 语法 v-bind:属性名”表达式” v-bind：可以简写成 : 比如，有一个图片，它的 src 属性值，是一个图片地址。这个地址在数据 data 中存储。 则可以这样设置属性值： img v-bind:src=url / img :src=url / （v-bind可以省略） 示例 div id=app img v-bind:src=imgUrl v-bind:title=msg alt= img :src=imgUrl :title=msg alt=/divscript src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/scriptscript const app = new Vue( el: #app, data: imgUrl: ./imgs/10-02.png, msg: hello 波仔 )/script 2.4.1 v-bind操作class 语法：div :class = 对象/数组这是一个div/div 对象语法 当class动态绑定的是对象时，键就是类名，值就是布尔值，如果值是true，就有这个类，否则没有这个类 div class=box :class= 类名1: 布尔值, 类名2: 布尔值 /div 适用场景：一个类名，来回切换 数组语法 当class动态绑定的是数组时 → 数组中所有的类，都会添加到盒子上，本质就是一个 class 列表 div class=box :class=[ 类名1, 类名2, 类名3 ]/div 适用场景:批量添加或删除类 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style .box width: 200px; height: 200px; border: 3px solid #000; font-size: 30px; margin-top: 10px; .pink background-color: pink; .big width: 300px; height: 300px; /style/headbody div id=app div class=box :class= pink: true, big: true 黑马程序员/div div class=box :class=[pink, big]黑马程序员/div /div script src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/script script const app = new Vue( el: #app, data: ) /script/body/html 京东秒杀-tab栏切换导航高亮 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style * margin: 0; padding: 0; ul display: flex; border-bottom: 2px solid #e01222; padding: 0 10px; li width: 100px; height: 50px; line-height: 50px; list-style: none; text-align: center; li a display: block; text-decoration: none; font-weight: bold; color: #333333; li a.active background-color: #e01222; color: #fff; /style/headbody div id=app ul li v-for=(item, index) in list :key=item.id @click=activeIndex = index !-- 对象语法 -- a :class= active: index === activeIndex href=# item.name /a /li /ul /div script src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/script script const app = new Vue( el: #app, data: activeIndex: 2, // 记录高亮 list: [ id: 1, name: 京东秒杀 , id: 2, name: 每日特价 , id: 3, name: 品类秒杀 ] ) /script/body/html 2.4.2 v-bind操作style 语法 div class=box :style= CSS属性名1: CSS属性值, CSS属性名2: CSS属性值 /div 练习 head style .box width: 200px; height: 200px; background-color: rgb(187, 150, 156); /style/headbody div id=app div class=box :style= width: 400px, height: 400px, backgroundColor: green /div /div script src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/script script const app = new Vue( el: #app, data: ) /script/body/html 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style .progress height: 25px; width: 400px; border-radius: 15px; background-color: #272425; border: 3px solid #272425; box-sizing: border-box; margin-bottom: 30px; .inner width: 50%; height: 20px; border-radius: 10px; text-align: right; position: relative; background-color: #409eff; background-size: 20px 20px; box-sizing: border-box; transition: all 1s; .inner span position: absolute; right: -20px; bottom: -25px; /style/headbody div id=app !-- 外层盒子底色 （黑色） -- div class=progress !-- 内层盒子 - 进度（蓝色） -- div class=inner :style= width: percent + % span percent %/span /div /div button @click=percent = 25设置25%/button button @click=percent = 50设置50%/button button @click=percent = 75设置75%/button button @click=percent = 100设置100%/button /div script src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/script script const app = new Vue( el: #app, data: percent: 30 ) /script/body/html 2.5 列表渲染指令 v-for 指令需要使用 (item, index) in arr 形式的特殊语法，其中： item 是数组中的每一项 index 是每一项的索引，不需要可以省略 arr 是被遍历的数组 此语法也可以遍历对象和数字 // 遍历对象// div v-for=(value, key, index) in objectvalue/div// value:对象中的值// key:对象中的键// index:遍历索引从0开始// 遍历数字// p v-for=item in 10item/p// item从1 开始htmlbody div id=app h3小黑水果店/h3 ul li v-for=(item, index) in list item - index /li /ul ul li v-for=item in list item /li /ul /div script src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/script script const app = new Vue( el: #app, data: list: [西瓜, 苹果, 鸭梨, 榴莲] ) /script/body/html v-for中的key 语法： key”唯一值” 作用：给列表项添加的唯一标识。便于Vue进行列表项的正确排序复用。 为什么加key：Vue 的默认行为会尝试原地修改元素（就地复用） 示例 ul li v-for=(item, index) in booksList :key=item.id span item.name /span span item.author /span button @click=del(item.id)删除/button /li/ul 注意： key 的值只能是字符串 或 数字类型 key 的值必须具有唯一性 推荐使用 id 作为 key（唯一），不推荐使用 index 作为 key（会变化，不对应） 2.6 双向绑定指令2.6.1 一般元素 数据改变后，呈现的页面结果会更新 页面结果更新后，数据也会随之而变 作用 给表单元素（input、radio、select）使用，双向绑定数据，可以快速 获取 或 设置 表单元素内容 语法 v-model=变量 示例 点击登录按钮获取表单中的内容 点击重置按钮清空表单中的内容 htmlbody div id=app !-- v-model 可以让数据和视图，形成双向数据绑定 (1) 数据变化，视图自动更新 (2) 视图变化，数据自动更新 可以快速[获取]或[设置]表单元素的内容 -- 账户：input type=text v-model=username brbr 密码：input type=password v-model=password brbr button @click=login登录/button button @click=reset重置/button /div script src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/script script const app = new Vue( el: #app, data: username: , password: , methods: login () console.log(this.username, this.password) , reset () this.username = this.password = ) /script/body/html 2.6.2 v-model在其他表单元素的使用 常见的表单元素都可以用 v-model 绑定关联 → 快速 获取 或 设置 表单元素的值 它会根据 控件类型 自动选取 正确的方法 来更新元素 输入框 input:text —— value 文本域 textarea —— value 复选框 input:checkbox —— checked 单选框 input:radio —— checked 下拉菜单 select —— value 示例 htmlhead style textarea display: block; width: 240px; height: 100px; margin: 10px 0; /style/headbody div id=app h3小黑学习网/h3 姓名： input type=text v-model=username brbr 是否单身： input type=checkbox v-model=isSingle brbr !-- 前置理解： 1. name: 给单选框加上 name 属性 可以分组 → 同一组互相会互斥 2. value: 给单选框加上 value 属性，用于提交给后台的数据 结合 Vue 使用 → v-model -- 性别: input v-model=gender type=radio name=gender value=1男 input v-model=gender type=radio name=gender value=2女 brbr !-- 前置理解： 1. option 需要设置 value 值，提交给后台 2. select 的 value 值，关联了选中的 option 的 value 值 结合 Vue 使用 → v-model -- 所在城市: select v-model=cityId option value=101北京/option option value=102上海/option option value=103成都/option option value=104南京/option /select brbr 自我描述： textarea v-model=desc/textarea button立即注册/button /div script src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/script script const app = new Vue( el: #app, data: username: , isSingle: false, gender: 2, cityId: 102, desc: ) /script/body/html 2.7 指令修饰符 所谓指令修饰符就是通过“.”指明一些指令后缀 不同的后缀封装了不同的处理操作 — 简化代码。 2.7.1 按键修饰符 @keyup.enter —当点击enter键的时候才触发 body div id=app h3@keyup.enter → 监听键盘回车事件/h3 input @keyup.enter=fn v-model=username type=text /div script src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/script script const app = new Vue( el: #app, data: username: , methods: fn (e) // 自己写监听回车触发事件 // if (e.key === Enter) // console.log(键盘回车的时候触发, this.username) // console.log(键盘回车的时候触发, this.username) ) /script/body/html 2.7.2 v-model修饰符 v-model.trim —去除首位空格 v-model.number —转数字 htmlbody div id=app h3v-model修饰符 .trim .number/h3 姓名：input v-model.trim=username type=textbr 年纪：input v-model.number=age type=textbr /div script src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/script script const app = new Vue( el: #app, data: username: , age: , ) /script/body/html 2.7.3 事件修饰符 @事件名.stop — 阻止冒泡 @事件名.prevent —阻止默认行为 @事件名.stop.prevent —可以连用 即阻止事件冒泡也阻止默认行为 style .father width: 200px; height: 200px; background-color: pink; margin-top: 20px; .son width: 100px; height: 100px; background-color: skyblue; /style div id=app h3@事件名.stop → 阻止冒泡/h3 div @click=fatherFn class=father div @click=sonFn class=son儿子/div /div h3@事件名.prevent → 阻止默认行为/h3 a @click href=http://www.baidu.com阻止默认行为/a /div script src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/script script const app = new Vue( el: #app, methods: fatherFn () alert(老父亲被点击了) , sonFn (e) // e.stopPropagation() alert(儿子被点击了) ) /script 2.8 自定义指令2.8.1 基本语法 指令介绍 内置指令：v-html、v-if、v-bind、v-on… 这都是Vue给咱们内置的一些指令，可以直接使用 自定义指令：同时Vue也支持让开发者，自己注册一些指令。这些指令被称为自定义指令 每个指令都有自己各自独立的功能 概念 自己定义的指令，可以封装一些DOM操作，扩展额外的功能 语法 全局注册 // 在main.js中Vue.directive(指令名, inserted (el) // 可以对 el 标签，扩展额外功能 el.focus() ) 局部注册 // 在Vue组件的配置项中directives: 指令名: inserted () // 可以对 el 标签，扩展额外功能 el.focus() 使用指令 注意：在使用指令的时候，一定要先注册，再使用，否则会报错使用指令语法： v-指令名。如：input type=text v-focus/ 注册指令时不用加v-前缀，但使用时一定要加v-前缀 配置项介绍 inserted:被绑定元素插入父节点时调用的钩子函数 el：使用指令的那个DOM元素 示例 需求：当页面加载时，让元素获取焦点（autofocus在safari浏览器有兼容性） App.vue template div h1自定义指令/h1 input v-focus ref=inp type=text /div/templatescriptexport default // mounted () // this.$refs.inp.focus() // // 局部注册指令 directives: // 指令名：指令的配置项 focus: inserted (el) el.focus() /scriptstyle/style 2.8.2 指令的值 需求 实现一个 color 指令 - 传入不同的颜色, 给标签设置文字颜色 语法 在绑定指令时，可以通过“等号”的形式为指令 绑定 具体的参数值 div v-color=color我是内容/div 通过 binding.value 可以拿到指令值，指令值修改会 触发 update 函数 directives: color: inserted (el, binding) el.style.color = binding.value , update (el, binding) el.style.color = binding.value 示例 App.vue template div h1 v-color=color1指令的值1测试/h1 h1 v-color=color2指令的值2测试/h1 button @click=changeColor 改变第一个h1的颜色 /button /div/templatescriptexport default data () return color1: red, color2: orange , directives: color: // 1. inserted 提供的是元素被添加到页面中时的逻辑 inserted (el, binding) // console.log(el, binding.value); // binding.value 就是指令的值 el.style.color = binding.value , // 2. update 指令的值修改的时候触发，提供值变化后，dom更新的逻辑 update (el, binding) console.log(指令的值修改了); el.style.color = binding.value , methods: changeColor() this.color1 = blue; /scriptstyle/style 2.8.3 v-loading的指令封装 场景 实际开发过程中，发送请求需要时间，在请求的数据未回来时，页面会处于空白状态 用户体验不好 需求 封装一个 v-loading 指令，实现加载中的效果 分析 本质 loading效果就是一个蒙层，盖在了盒子上 数据请求中，开启loading状态，添加蒙层 数据请求完毕，关闭loading状态，移除蒙层 实现 准备一个 loading类，通过伪元素定位，设置宽高，实现蒙层 开启关闭 loading状态（添加移除蒙层），本质只需要添加移除类即可 结合自定义指令的语法进行封装复用 .loading:before content: ; position: absolute; left: 0; top: 0; width: 100%; height: 100%; background: #fff url(./loading.gif) no-repeat center; 示例 template div class=main div class=box v-loading=isLoading ul li v-for=item in list :key=item.id class=news div class=left div class=title item.title /div div class=info span item.source /span span item.time /span /div /div div class=right img :src=item.img alt= /div /li /ul /div div class=box2 v-loading=isLoading2/div /div/templatescript// 安装axios = yarn add axiosimport axios from axios// 接口地址：http://hmajax.itheima.net/api/news// 请求方式：getexport default data () return list: [], isLoading: true, isLoading2: true , async created () // 1. 发送请求获取数据 const res = await axios.get(http://hmajax.itheima.net/api/news) setTimeout(() = // 2. 更新到 list 中，用于页面渲染 v-for this.list = res.data.data this.isLoading = false , 2000) , directives: loading: inserted (el, binding) binding.value ? el.classList.add(loading) : el.classList.remove(loading) , update (el, binding) binding.value ? el.classList.add(loading) : el.classList.remove(loading) /scriptstyle.loading:before content: ; position: absolute; left: 0; top: 0; width: 100%; height: 100%; background: #fff url(./loading.gif) no-repeat center;.box2 width: 400px; height: 400px; border: 2px solid #000; position: relative;.box width: 800px; min-height: 500px; border: 3px solid orange; border-radius: 5px; position: relative;.news display: flex; height: 120px; width: 600px; margin: 0 auto; padding: 20px 0; cursor: pointer;.news .left flex: 1; display: flex; flex-direction: column; justify-content: space-between; padding-right: 10px;.news .left .title font-size: 20px;.news .left .info color: #999999;.news .left .info span margin-right: 20px;.news .right width: 160px; height: 120px;.news .right img width: 100%; height: 100%; object-fit: cover;/style 3. computed计算属性3.1 基本操作 概念 基于现有的数据，计算出来的新属性。 依赖的数据变化，自动重新计算。 语法 声明在 computed 配置项中，一个计算属性对应一个函数 使用起来和普通属性一样使用 注意 computed配置项和data配置项是同级的 computed中的计算属性虽然是函数的写法，但他依然是个属性 computed中的计算属性不能和data中的属性同名 使用computed中的计算属性和使用data中的属性是一样的用法 computed中计算属性内部的this依然指向的是Vue实例 案例 比如我们可以使用计算属性实现下面这个业务场景 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style table border: 1px solid #000; text-align: center; width: 240px; th,td border: 1px solid #000; h3 position: relative; /style/headbody div id=app h3小黑的礼物清单/h3 table tr th名字/th th数量/th /tr tr v-for=(item, index) in list :key=item.id td item.name /td td item.num 个/td /tr /table !-- 目标：统计求和，求得礼物总数 -- p礼物总数： totalCount 个/p /div script src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/script script const app = new Vue( el: #app, data: // 现有的数据 list: [ id: 1, name: 篮球, num: 1 , id: 2, name: 玩具, num: 2 , id: 3, name: 铅笔, num: 5 , ] , computed: totalCount () // 基于现有的数据，编写求值逻辑 // 计算属性函数内部，可以直接通过 this 访问到 app 实例 // console.log(this.list) // 需求：对 this.list 数组里面的 num 进行求和 → reduce let total = this.list.reduce((sum, item) = sum + item.num, 0) return total ) /script/body/html 3.2 computed计算属性 VS methods方法3.2.1 computed计算属性 作用 封装了一段对于数据的处理，求得一个结果 语法 写在computed配置项中 作为属性，直接使用 js中使用计算属性： this.计算属性 模板中使用计算属性： 3.2.2 methods计算属性 作用 给Vue实例提供一个方法，调用以处理业务逻辑。 语法： 写在methods配置项中 作为方法调用 js中调用：`this.方法名()`模板中调用 方法名() 或者 @事件名=方法名 3.2.3 计算属性的优势 缓存特性（提升性能） 计算属性会对计算出来的结果缓存，再次使用直接读取缓存 依赖项变化了，会自动重新计算 → 并再次缓存 methods没有缓存特性 3.2.4 总结 computed有缓存特性，methods没有缓存 当一个结果依赖其他多个值时，推荐使用计算属性 当处理业务逻辑时，推荐使用methods方法，比如事件的处理函数 3.3 计算属性的完整写法 既然计算属性也是属性，能访问，应该也能修改了？ 计算属性默认的简写，只能读取访问，不能 “修改” 如果要 “修改” → 需要写计算属性的完整写法 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style input width: 30px; /style/headbody div id=app 姓：input type=text v-model=firstName + 名：input type=text v-model=lastName = span fullName /spanbrbr button @click=changeName改名卡/button /div script src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/script script const app = new Vue( el: #app, data: firstName: 刘, lastName: 备, , methods: changeName () this.fullName = 黄忠 , computed: // 简写 → 获取，没有配置设置的逻辑 // fullName () // return this.firstName + this.lastName // // 完整写法 → 获取 + 设置 fullName: // (1) 当fullName计算属性，被获取求值时，执行get（有缓存，优先读缓存） // 会将返回值作为，求值的结果 get () return this.firstName + this.lastName , // (2) 当fullName计算属性，被修改赋值时，执行set // 修改的值，传递给set方法的形参 set (value) // console.log(value.slice(0, 1)) // console.log(value.slice(1)) this.firstName = value.slice(0, 1) this.lastName = value.slice(1) ) /script/body/html 4. watch侦听器（监视器）4.1 基础写法 作用 监视数据变化，执行一些业务逻辑或异步操作 语法 watch同样声明在跟data同级的配置项中 简单写法： 简单类型数据直接监视 完整写法：添加额外配置项 data: words: 苹果, obj: words: 苹果 ,watch: // 该方法会在数据变化时，触发执行 数据属性名 (newValue, oldValue) 一些业务逻辑 或 异步操作。 , 对象.属性名 (newValue, oldValue) 一些业务逻辑 或 异步操作。 案例 !DOCTYPE htmlhtml lang=en head meta charset=UTF-8 / meta http-equiv=X-UA-Compatible content=IE=edge / meta name=viewport content=width=device-width, initial-scale=1.0 / titleDocument/title style * margin: 0; padding: 0; box-sizing: border-box; font-size: 18px; #app padding: 10px 20px; .query margin: 10px 0; .box display: flex; textarea width: 300px; height: 160px; font-size: 18px; border: 1px solid #dedede; outline: none; resize: none; padding: 10px; textarea:hover border: 1px solid #1589f5; .transbox width: 300px; height: 160px; background-color: #f0f0f0; padding: 10px; border: none; .tip-box width: 300px; height: 25px; line-height: 25px; display: flex; .tip-box span flex: 1; text-align: center; .query span font-size: 18px; .input-wrap position: relative; .input-wrap span position: absolute; right: 15px; bottom: 15px; font-size: 12px; .input-wrap i font-size: 20px; font-style: normal; /style /head body div id=app !-- 条件选择框 -- div class=query span翻译成的语言：/span select option value=italy意大利/option option value=english英语/option option value=german德语/option /select /div !-- 翻译框 -- div class=box div class=input-wrap textarea v-model=obj.words/textarea spani⌨️/i文档翻译/span /div div class=output-wrap div class=transbox result /div /div /div /div script src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/script script src=https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js/script script // 接口地址：https://applet-base-api-t.itheima.net/api/translate // 请求方式：get // 请求参数： // （1）words：需要被翻译的文本（必传） // （2）lang： 需要被翻译成的语言（可选）默认值-意大利 // ----------------------------------------------- const app = new Vue( el: #app, data: // words: obj: words: , result: , // 翻译结果 // timer: null // 延时器id , // 具体讲解：(1) watch语法 (2) 具体业务实现 watch: // 该方法会在数据变化时调用执行 // newValue新值, oldValue老值（一般不用） // words (newValue) // console.log(变化了, newValue) // obj.words (newValue) // console.log(变化了, newValue) // 防抖: 延迟执行 → 干啥事先等一等，延迟一会，一段时间内没有再次触发，才执行 clearTimeout(this.timer) this.timer = setTimeout(async () = const res = await axios( url: https://applet-base-api-t.itheima.net/api/translate, params: words: newValue ) this.result = res.data.data console.log(res.data.data) , 300) ) /script /body/html 4.2 完整写法 语法 完整写法 —添加额外的配置项 deep:true 对复杂类型进行深度监听 immdiate:true 初始化 立刻执行一次 data: obj: words: 苹果, lang: italy ,,watch: // watch 完整写法 对象: deep: true, // 深度监视 immdiate:true,//立即执行handler函数 handler (newValue) console.log(newValue) 案例 当文本框输入的时候 右侧翻译内容要时时变化 当下拉框中的语言发生变化的时候 右侧翻译的内容依然要时时变化 如果文本框中有默认值的话要立即翻译 script const app = new Vue( el: #app, data: obj: words: 小黑, lang: italy , result: , // 翻译结果 , watch: obj: deep: true, // 深度监视 immediate: true, // 立刻执行，一进入页面handler就立刻执行一次 handler (newValue) clearTimeout(this.timer) this.timer = setTimeout(async () = const res = await axios( url: https://applet-base-api-t.itheima.net/api/translate, params: newValue ) this.result = res.data.data console.log(res.data.data) , 300) )/script 5. Vue生命周期5.1 四个阶段 思考 什么时候可以发送初始化渲染请求？（越早越好）什么时候可以开始操作dom？（至少dom得渲染出来） Vue生命周期 就是一个Vue实例从创建 到 销毁 的整个过程。 四个阶段 生命周期四个阶段：① 创建 ② 挂载 ③ 更新 ④ 销毁 1.创建阶段：创建响应式数据 2.挂载阶段：渲染模板 3.更新阶段：修改数据，更新视图 4.销毁阶段：销毁Vue实例 5.2 Vue生命周期钩子 概念 Vue生命周期过程中，会自动运行一些函数，被称为【生命周期钩子】→ 让开发者可以在【特定阶段】运行自己的代码 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody div id=app h3 title /h3 div button @click=count---/button span count /span button @click=count+++/button /div /div script src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/script script const app = new Vue( el: #app, data: count: 100, title: 计数器 , // 1. 创建阶段（准备数据） beforeCreate () console.log(beforeCreate 响应式数据准备好之前, this.count) , created () console.log(created 响应式数据准备好之后, this.count) // this.数据名 = 请求回来的数据 // 可以开始发送初始化渲染的请求了 , // 2. 挂载阶段（渲染模板） beforeMount () console.log(beforeMount 模板渲染之前, document.querySelector(h3).innerHTML) , mounted () console.log(mounted 模板渲染之后, document.querySelector(h3).innerHTML) // 可以开始操作dom了 , // 3. 更新阶段(修改数据 → 更新视图) beforeUpdate () console.log(beforeUpdate 数据修改了，视图还没更新, document.querySelector(span).innerHTML) , updated () console.log(updated 数据修改了，视图已经更新, document.querySelector(span).innerHTML) , // 4. 卸载阶段 beforeDestroy () console.log(beforeDestroy, 卸载前) console.log(清除掉一些Vue以外的资源占用，定时器，延时器...) , destroyed () console.log(destroyed，卸载后) ) /script/body/html 5.3 案例 在created中发送数据 htmlbody div id=app ul li v-for=(item, index) in list :key=item.id class=news div class=left div class=title item.title /div div class=info span item.source /span span item.time /span /div /div div class=right img :src=item.img alt= /div /li /ul /div script src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/script script src=https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js/script script // 接口地址：http://hmajax.itheima.net/api/news // 请求方式：get const app = new Vue( el: #app, data: list: [] , async created () // 1. 发送请求获取数据 const res = await axios.get(http://hmajax.itheima.net/api/news) // 2. 更新到 list 中，用于页面渲染 v-for this.list = res.data.data ) /script/body/html 在mounted中获取焦点 htmlbodydiv class=container id=app div class=search-container img src=https://www.itheima.com/images/logo.png alt= div class=search-box input type=text v-model=words id=inp button搜索一下/button /div /div/divscript src=https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js/scriptscript const app = new Vue( el: #app, data: words: , // 核心思路： // 1. 等input框渲染出来 mounted 钩子 // 2. 让input框获取焦点 inp.focus() mounted () document.querySelector(#inp).focus() )/script/body/html 6. 工程化开发和脚手架6.1 开发Vue的两种方式 核心包传统开发模式 基于html css js 文件，直接引入核心包，开发 Vue。 工程化开发模式 基于构建工具（例如：webpack）的环境中开发Vue。 工程化开发模式优点 提高编码效率，比如使用JS新语法、LessSass、Typescript等通过webpack都可以编译成浏览器识别的ES3ES5CSS等 工程化开发模式问题 webpack配置不简单 雷同的基础配置 缺乏统一的标准 为了解决以上问题，所以我们需要一个工具，生成标准化的配置 6.2 脚手架Vue CLI 作用 Vue CLI 是Vue官方提供的一个全局命令工具 可以帮助我们快速创建一个开发Vue项目的标准化基础架子。【集成了webpack配置】 好处 开箱即用，零配置 内置babel等工具 标准化的webpack配置 使用步骤 全局安装（只需安装一次即可） yarn global add @vuecli 或者 npm i @vuecli -g 查看vuecli版本： vue –version 创建项目架子：vue create project-name(项目名不能使用中文) 启动项目：yarn serve 或者 npm run serve(命令不固定，找package.json) 项目目录介绍 main.js 入口文件 App.vue App根组件 index.html 模板文件 运行流程 7. 组件化开发7.1 概念 组件化 一个页面可以拆分成一个个组件，每个组件有着自己独立的结构、样式、行为。 好处 便于维护，利于复用 → 提升开发效率。 组件分类 普通组件、根组件。 示例 比如：下面这个页面，可以把所有的代码都写在一个页面中，但是这样显得代码比较混乱，难易维护。咱们可以按模块进行组件划分。 7.2 根组件 概念 整个应用最上层的组件，包裹所有普通小组件 示例 7.3 组件的构成7.3.1 基本构成 语法高亮插件 三部分构成 template：结构 （有且只能一个根元素） script: js逻辑 style： 样式 (可支持less，需要装包) 让组件支持less 装包: yarn add less less-loader -D 或者npm i less less-loader -D style标签，lang”less” 开启less功能 7.3.2 scoped解决样式冲突 默认情况 写在组件中的样式会 全局生效 → 因此很容易造成多个组件之间的样式冲突问题。 全局样式 默认组件中的样式会作用到全局，任何一个组件中都会受到此样式的影响 局部样式 可以给组件加上scoped 属性,可以让样式只作用于当前组件 示例 BaseOne.vue template div class=base-one BaseOne /div/templatescriptexport default /scriptstyle scoped/style BaseTwo.vue template div class=base-one BaseTwo /div/templatescriptexport default /scriptstyle scoped/style App.vue template div id=app BaseOne/BaseOne BaseTwo/BaseTwo /div/templatescriptimport BaseOne from ./components/BaseOneimport BaseTwo from ./components/BaseTwoexport default name: App, components: BaseOne, BaseTwo /script scoped原理 当前组件内标签都被添加data-v-hash值 的属性 css选择器都被添加 [data-v-hash值] 的属性选择器 最终效果: 必须是当前组件的元素, 才会有这个自定义属性, 才会被这个样式作用到 7.3.3 data必须是一个函数 data为什么要写成函数 一个组件的 data 选项必须是一个函数。目的是为了：保证每个组件实例，维护**独立**的一份**数据**对象。 每次创建新的组件实例，都会新执行一次data 函数，得到一个新对象。 案例 BaseCount.vue template div class=base-count button @click=count---/button span count /span button @click=count+++/button /div/templatescriptexport default // 要写成一个函数 data: function () return count: 100, ,/scriptstyle.base-count margin: 20px;/style App.vue template div class=app BaseCount/BaseCount /div/templatescriptimport BaseCount from ./components/BaseCountexport default components: BaseCount, ,/scriptstyle/style 7.4 局部注册 特点 只能在注册的组件内使用 步骤 创建.vue文件（三个组成部分） 在使用的组件内先导入再注册，最后使用 使用方式 当成html标签使用即可 组件名组件名 注意 组件名规范 — 大驼峰命名法， 如 HmHeader 语法 // 导入需要注册的组件import 组件对象 from .vue文件路径import HmHeader from ./components/HmHeaderexport default // 局部注册 components: 组件名: 组件对象, HmHeader:HmHeaer, // 缩写方式 // HmHeader 7.5 全局注册 特点 全局注册的组件，在项目的任何组件中都能使用 步骤 创建.vue组件（三个组成部分） main.js中进行全局注册 使用方式 当成HTML标签直接使用 组件名组件名 注意 组件名规范 — 大驼峰命名法， 如 HmHeader 语法 Vue.component(‘组件名’, 组件对象) // 导入需要全局注册的组件import HmButton from ./components/HmButtonVue.component(HmButton, HmButton) 8. 组件通信8.1 概念 什么是组件通信 组件通信，就是指组件与组件之间的数据传递 组件的数据是独立的，无法直接访问其他组件的数据。 想使用其他组件的数据，就需要组件通信 组件之间如何通信 组件关系分类 父子关系 非父子关系 通信解决方案 8.2 父传子 父组件通过 props 将数据传递给子组件 子组件利用 $emit 通知父组件修改更新 案例 父组件通过props将 myTitle 传递给子组件 父组件App.vue template div class=app style=border: 3px solid #000; margin: 10px 我是APP组件 !-- 1.给组件标签，添加属性方式 赋值 -- Son :title=myTitle/Son /div/templatescriptimport Son from ./components/Son.vueexport default name: App, data() return myTitle: 学前端，就来黑马程序员, , components: Son, ,/scriptstyle/style 子组件Son.vue template div class=son style=border:3px solid #000;margin:10px !-- 3.直接使用props的值 -- 我是Son组件 title /div/templatescriptexport default name: Son-Child, // 2.通过props来接受 props:[title]/scriptstyle/style 父向子传值步骤 （1）给子组件以添加属性的方式传值 （2）子组件内部通过props接收 （3）模板中直接使用 props接收的值 8.3 子传父 子组件利用 $emit 通知父组件，进行修改更新 子向父传值步骤 $emit触发事件，给父组件发送消息通知 父组件监听$emit触发的事件 提供处理函数，在函数的性参中获取传过来的参数 8.4 props 定义 组件上 注册的一些 自定义属性 作用 向子组件传递数据 特点 可以 传递 任意数量 的prop 可以 传递 任意类型 的prop 案例 父组件App.vue template div class=app UserInfo :username=username :age=age :isSingle=isSingle :car=car :hobby=hobby /UserInfo /div/templatescriptimport UserInfo from ./components/UserInfo.vueexport default data() return username: 小帅, age: 28, isSingle: true, car: brand: 宝马, , hobby: [篮球, 足球, 羽毛球], , components: UserInfo, ,/scriptstyle/style 子组件UserInfo.vue template div class=userinfo h3我是个人信息组件/h3 div姓名：username/div div年龄：age/div div是否单身：isSingle/div div座驾：car.brand/div div兴趣爱好：hobby.join(、)/div /div/templatescriptexport default props:[username,age,isSingle,car,hobby]/scriptstyle.userinfo width: 300px; border: 3px solid #000; padding: 20px;.userinfo div margin: 20px 10px;/style 8.5 props校验 思考 组件的props可以乱传吗？ 作用 为组件的 prop 指定验证要求，不符合要求，控制台就会有错误提示 → 帮助开发者，快速发现错误 语法 类型校验 非空校验 默认值 自定义校验 props校验完整写法 语法 props: 校验的属性名: type: 类型, // Number String Boolean ... required: true, // 是否必填 default: 默认值, // 默认值 validator (value) // 自定义校验逻辑 return 是否通过校验 , 示例 scriptexport default // 完整写法（类型、默认值、非空、自定义校验） props: w: type: Number, // required: true, default: 0, validator(val) // console.log(val) if (val = 100 || val = 0) console.error(传入的范围必须是0-100之间) return false else return true , , /script 注意 default和required一般不同时写（因为当时必填项时，肯定是有值的） default后面如果是简单类型的值，可以直接写默认。如果是复杂类型的值，则需要以函数的形式return一个默认值 8.6 propsdata、单向数据流 共同点 都可以给组件提供数据 区别 data 的数据是自己的 → 随便改 prop 的数据是外部的 → 不能直接改，要遵循 单向数据流 单向数据流 父级props 的数据更新，会向下流动，影响子组件。这个数据流动是单向的 示例 App.vue template div class=app BaseCount/BaseCount /div/templatescriptimport BaseCount from ./components/BaseCount.vueexport default components: BaseCount , data() ,/scriptstyle/style BaseCount.vue template div class=base-count button @click=count---/button span count /span button @click=count+++/button /div/templatescriptexport default // 1.自己的数据随便修改 （谁的数据 谁负责） data () return count: 100, , // 2.外部传过来的数据 不能随便修改 //props: // count: // type: Number, // , ///scriptstyle.base-count margin: 20px;/style 8.7 非父子通信（event bus） 作用 非父子组件之间，进行简易消息传递。(复杂场景→ Vuex) 步骤 创建一个都能访问的事件总线 （空Vue实例） import Vue from vueconst Bus = new Vue()export default Bus A组件（接受方），监听Bus的 $on事件 created () Bus.$on(sendMsg, (msg) = this.msg = msg ) B组件（发送方），触发Bus的$emit事件 Bus.$emit(sendMsg, 这是一个消息) 示例 EventBus.js import Vue from vueconst Bus = new Vue()export default Bus BaseA.vue(接受方) template div class=base-a 我是A组件（接受方） pmsg/p /div/templatescriptimport Bus from ../utils/EventBus;export default data() return msg: ; , created() Bus.$on(sendMsg, msg = this.msg = msg; ); ;/scriptstyle scoped.base-a width: 200px; height: 200px; border: 3px solid #000; border-radius: 3px; margin: 10px;/style BaseB.vue(发送方) template div class=base-b div我是B组件（发布方）/div button @click=sendMsgFn发送消息/button /div/templatescriptimport Bus from ../utils/EventBus;export default methods: sendMsgFn() Bus.$emit(sendMsg, 这是一个消息); ;/scriptstyle scoped.base-b width: 200px; height: 200px; border: 3px solid #000; border-radius: 3px; margin: 10px;/style App.vue template div class=app BaseA/BaseA BaseB/BaseB /div/templatescriptimport BaseA from ./components/BaseA.vueimport BaseB from ./components/BaseB.vue export default components: BaseA, BaseB /scriptstyle/style 8.8 非父子通信-provideinject 作用 跨层级共享数据 场景 爷爷与孙子通信 语法 父组件 provide提供数据 export default provide () return // 普通类型【非响应式】 color: this.color, // 复杂类型【响应式】 userInfo: this.userInfo, 子孙组件 inject获取数据 export default inject: [color,userInfo], created () console.log(this.color, this.userInfo) 9. 进阶语法9.1 v-model原理 原理 v-model本质上是一个语法糖。例如应用在输入框上，就是value属性 和 input事件 的合写 template div id=app input v-model=msg type=text input :value=msg @input=msg = $event.target.value type=text /div/template 作用 提供数据的双向绑定 数据变，视图跟着变 :value 视图变，数据跟着变 @input 注意 $event 用于在模板中，获取事件的形参 示例 template div class=app input type=text v-model=msg1 / br / !-- v-model的底层其实就是：value和 @input的简写 -- input type=text :value=msg2 @input=msg2 = $event.target.value / /div/templatescriptexport default data() return msg1: , msg2: , ,/scriptstyle/style v-model使用在其他表单元素上的原理 不同的表单元素， v-model在底层的处理机制是不一样的。比如给checkbox使用v-model 底层处理的是 checked属性和change事件。 不过咱们只需要掌握应用在文本框上的原理即可 9.2 表单类组件封装 需求目标 实现子组件和父组件数据的双向绑定 （实现App.vue中的selectId和子组件选中的数据进行双向绑定） 代码演示 App.vue template div class=app BaseSelect :selectId=selectId @changeCity=selectId = $event /BaseSelect /div/templatescriptimport BaseSelect from ./components/BaseSelect.vueexport default data() return selectId: 102, , components: BaseSelect, ,/scriptstyle/style BaseSelect.vue template div select :value=selectId @change=selectCity option value=101北京/option option value=102上海/option option value=103武汉/option option value=104广州/option option value=105深圳/option /select /div/templatescriptexport default props: selectId: String, , methods: selectCity(e) this.$emit(changeCity, e.target.value) , ,/scriptstyle/style v-model简化代码 目标： 父组件通过v-model 简化代码，实现子组件和父组件数据 双向绑定 如何简化： v-model其实就是 :value和@change事件的简写 子组件：props通过value接收数据，事件触发 change 父组件：v-model直接绑定数据 示例： 子组件 select :value=value @change=handleChange.../selectprops: value: String,methods: handleChange (e) this.$emit(input, e.target.value) 父组件 BaseSelect v-model=selectId/BaseSelect 9.3 .sync修饰符 作用 可以实现 子组件 与 父组件数据 的 双向绑定，简化代码 简单理解：子组件可以修改父组件传过来的props值 场景 封装弹框类的基础组件， visible属性 true显示 false隐藏 本质 .sync修饰符 就是 :属性名 和 @update:属性名 合写 语法 父组件 //.sync写法BaseDialog :visible.sync=isShow /--------------------------------------//完整写法BaseDialog :visible=isShow @update:visible=isShow = $event / 子组件 props: visible: Boolean,this.$emit(update:visible, false) 示例 App.vue template div class=app button @click=openDialog退出按钮/button !-- isShow.sync = :isShow=isShow @update:isShow=isShow=$event -- BaseDialog :isShow.sync=isShow/BaseDialog /div/templatescriptimport BaseDialog from ./components/BaseDialog.vueexport default data() return isShow: false, , methods: openDialog() this.isShow = true // console.log(document.querySelectorAll(.box)); , , components: BaseDialog, ,/scriptstyle/style BaseDialog.vue template div class=base-dialog-wrap v-show=isShow div class=base-dialog div class=title h3温馨提示：/h3 button class=close @click=closeDialogx/button /div div class=content p你确认要退出本系统么？/p /div div class=footer button确认/button button取消/button /div /div /div/templatescriptexport default props: isShow: Boolean, , methods: closeDialog() this.$emit(update:isShow,false) /scriptstyle scoped.base-dialog-wrap width: 300px; height: 200px; box-shadow: 2px 2px 2px 2px #ccc; position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); padding: 0 10px;.base-dialog .title display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid #000;.base-dialog .content margin-top: 38px;.base-dialog .title .close width: 20px; height: 20px; cursor: pointer; line-height: 10px;.footer display: flex; justify-content: flex-end; margin-top: 26px;.footer button width: 80px; height: 40px;.footer button:nth-child(1) margin-right: 10px; cursor: pointer;/style 9.4 ref和$refs 作用 利用ref 和 $refs 可以用于 获取 dom 元素 或 组件实例 特点 查找范围 → 当前组件内(更精确稳定) 语法 给要获取的盒子添加ref属性 div class=box ref=chartRef我是渲染图表的容器/div 获取时通过 $refs获取 this.$refs.chartRef 获取 mounted () // document.querySelect(.box) console.log(this.$refs.chartRef) 恰当时机, 通过 this.$refs.xxx, 获取目标组件，就可以调用组件对象里面的方法 BaseForm ref=baseForm/BaseFormthis.$refs.baseForm.组件方法() 注意 之前只用document.querySelect(.box) 获取的是整个页面中的盒子 示例 App.vue template div class=app BaseChart/BaseChart /div/templatescriptimport BaseChart from ./components/BaseChart.vueexport default components: BaseChart /scriptstyle/style BaseChart.vue template div class=base-chart-box ref=baseChartBox子组件/div/templatescriptimport * as echarts from echartsexport default mounted() // 基于准备好的dom，初始化echarts实例 // document.querySelector 会查找项目中所有的元素 // $refs只会在当前组件查找盒子 // var myChart = echarts.init(document.querySelector(.base-chart-box)) var myChart = echarts.init(this.$refs.baseChartBox) // 绘制图表 myChart.setOption( title: text: ECharts 入门示例, , tooltip: , xAxis: data: [衬衫, 羊毛衫, 雪纺衫, 裤子, 高跟鞋, 袜子], , yAxis: , series: [ name: 销量, type: bar, data: [5, 20, 36, 10, 10, 20], , ], ) ,/scriptstyle scoped.base-chart-box width: 400px; height: 300px; border: 3px solid #000; border-radius: 6px;/style 9.5 异步更新 $nextTick 需求 编辑标题, 编辑框自动聚焦 点击编辑，显示编辑框 让编辑框，立刻获取焦点 实现 template div class=app div v-if=isShowEdit input type=text v-model=editValue ref=inp / button确认/button /div div v-else span title /span button @click=editFn编辑/button /div /div/templatescriptexport default data() return title: 大标题, isShowEdit: false, editValue: , , methods: editFn() // 显示输入框 this.isShowEdit = true // 获取焦点 this.$refs.inp.focus() ,/script 问题 “显示之后”，立刻获取焦点是不能成功的！ 原因：Vue 是异步更新DOM (提升性能) 解决方案 $nextTick：等 DOM更新后,才会触发执行此方法里的函数体 语法: this.$nextTick(函数体) this.$nextTick(() = this.$refs.inp.focus()) 注意：$nextTick 内的函数体 一定是箭头函数，这样才能让函数内部的this指向Vue实例 10. 插槽10.1 默认插槽 作用 让组件内部的一些 结构 支持 自定义 需求 将需要多次显示的对话框,封装成一个组件 问题 组件的内容部分，不希望写死，希望能使用的时候自定义。怎么办？ 插槽的基本语法 组件内需要定制的结构部分，改用****占位 使用组件时, ****标签内部, 传入结构替换slot 给插槽传入内容时，可以传入纯文本、html标签、组件 代码示例 MyDialog.vue template div class=dialog div class=dialog-header h3友情提示/h3 span class=close✖️/span /div div class=dialog-content !-- 1. 在需要定制的位置，使用slot占位 -- slot/slot /div div class=dialog-footer button取消/button button确认/button /div /div/templatescriptexport default data () return /scriptstyle scoped* margin: 0; padding: 0;.dialog width: 470px; height: 230px; padding: 0 25px; background-color: #ffffff; margin: 40px auto; border-radius: 5px;.dialog-header height: 70px; line-height: 70px; font-size: 20px; border-bottom: 1px solid #ccc; position: relative;.dialog-header .close position: absolute; right: 0px; top: 0px; cursor: pointer;.dialog-content height: 80px; font-size: 18px; padding: 15px 0;.dialog-footer display: flex; justify-content: flex-end;.dialog-footer button width: 65px; height: 35px; background-color: #ffffff; border: 1px solid #e1e3e9; cursor: pointer; outline: none; margin-left: 10px; border-radius: 3px;.dialog-footer button:last-child background-color: #007acc; color: #fff;/style App.vue template div !-- 2. 在使用组件时，组件标签内填入内容 -- MyDialog div你确认要删除么/div /MyDialog MyDialog p你确认要退出么/p /MyDialog /div/templatescriptimport MyDialog from ./components/MyDialog.vueexport default data () return , components: MyDialog /scriptstylebody background-color: #b3b3b3;/style 10.2 插槽默认值 问题 通过插槽完成了内容的定制，传什么显示什么, 但是如果不传，则是空白 能否给插槽设置 默认显示内容 呢？ 插槽的后备内容 封装组件时，可以为预留的 slot 插槽提供后备内容（默认内容） 语法 在 标签内，放置内容, 作为默认显示内容 效果 外部使用组件时，不传东西，则slot会显示后备内容 外部使用组件时，传东西了，则slot整体会被换掉 示例 App.vue template div MyDialog/MyDialog MyDialog 你确认要退出么 /MyDialog /div/templatescriptimport MyDialog from ./components/MyDialog.vueexport default data () return , components: MyDialog /scriptstylebody background-color: #b3b3b3;/style 10.3 具名插槽 需求 一个组件内有多处结构，需要外部传入标签，进行定制 上面的弹框中有三处不同，但是默认插槽只能定制一个位置，这时候怎么办呢? 语法 多个slot使用name属性区分名字 template配合v-slot:名字来分发对应标签 简写 v-slot写起来太长，vue给我们提供一个简单写法 # 示例 App.vue template div MyDialog !-- 需要通过template标签包裹需要分发的结构，包成一个整体 -- template v-slot:head div我是大标题/div /template template v-slot:content div我是内容/div /template template #footer button取消/button button确认/button /template /MyDialog /div/templatescriptimport MyDialog from ./components/MyDialog.vueexport default data () return , components: MyDialog /scriptstylebody background-color: #b3b3b3;/style MyDialog.vue template div class=dialog div class=dialog-header !-- 一旦插槽起了名字，就是具名插槽，只支持定向分发 -- slot name=head/slot /div div class=dialog-content slot name=content/slot /div div class=dialog-footer slot name=footer/slot /div /div/templatescriptexport default data () return /scriptstyle scoped* margin: 0; padding: 0;.dialog width: 470px; height: 230px; padding: 0 25px; background-color: #ffffff; margin: 40px auto; border-radius: 5px;.dialog-header height: 70px; line-height: 70px; font-size: 20px; border-bottom: 1px solid #ccc; position: relative;.dialog-header .close position: absolute; right: 0px; top: 0px; cursor: pointer;.dialog-content height: 80px; font-size: 18px; padding: 15px 0;.dialog-footer display: flex; justify-content: flex-end;.dialog-footer button width: 65px; height: 35px; background-color: #ffffff; border: 1px solid #e1e3e9; cursor: pointer; outline: none; margin-left: 10px; border-radius: 3px;.dialog-footer button:last-child background-color: #007acc; color: #fff;/style 10.4 作用域插槽 插槽分类 默认插槽 具名插槽 插槽只有两种，作用域插槽不属于插槽的一种分类 作用 定义slot 插槽的同时, 是可以传值的。给 插槽 上可以 绑定数据，将来 使用组件时可以用 场景 封装表格组件 使用步骤 给 slot 标签, 以 添加属性的方式传值 !-- 1. 给slot标签，添加属性的方式传值 --slot :row=item msg=测试文本/slot!-- 2. 将所有的属性，添加到一个对象中 --!-- row: id: 2, name: 孙大明, age: 19 , msg: 测试文本\t-- 所有添加的属性, 都会被收集到一个对象中 id: 3, msg: 测试文本 在template中, 通过 #插槽名= obj 接收，默认插槽名为 default MyTable :list=list !-- 3. 通过template #插槽名=变量名 接收 -- template #default=obj button @click=del(obj.row.id) 删除 /button /template/MyTable 示例 MyTable.vue template table class=my-table thead tr th序号/th th姓名/th th年纪/th th操作/th /tr /thead tbody tr v-for=(item, index) in data :key=item.id td index + 1 /td td item.name /td td item.age /td td !-- 1. 给slot标签，添加属性的方式传值 -- slot :row=item msg=测试文本/slot !-- 2. 将所有的属性，添加到一个对象中 -- !-- row: id: 2, name: 孙大明, age: 19 , msg: 测试文本 -- /td /tr /tbody /table/templatescriptexport default props: data: Array /scriptstyle scoped.my-table width: 450px; text-align: center; border: 1px solid #ccc; font-size: 24px; margin: 30px auto;.my-table thead background-color: #1f74ff; color: #fff;.my-table thead th font-weight: normal;.my-table thead tr line-height: 40px;.my-table th,.my-table td border-bottom: 1px solid #ccc; border-right: 1px solid #ccc;.my-table td:last-child border-right: none;.my-table tr:last-child td border-bottom: none;.my-table button width: 65px; height: 35px; font-size: 18px; border: 1px solid #ccc; outline: none; border-radius: 3px; cursor: pointer; background-color: #ffffff; margin-left: 5px;/style App.vue template div MyTable :data=list !-- 3. 通过template #插槽名=变量名 接收 -- template #default=obj button @click=del(obj.row.id) 删除 /button /template /MyTable MyTable :data=list2 template #default= row button @click=show(row)查看/button /template /MyTable /div/templatescriptimport MyTable from ./components/MyTable.vueexport default data () return list: [ id: 1, name: 张小花, age: 18 , id: 2, name: 孙大明, age: 19 , id: 3, name: 刘德忠, age: 17 , ], list2: [ id: 1, name: 赵小云, age: 18 , id: 2, name: 刘蓓蓓, age: 19 , id: 3, name: 姜肖泰, age: 17 , ] , methods: del (id) this.list = this.list.filter(item = item.id !== id) , show (row) // console.log(row); alert(`姓名：$row.name; 年纪：$row.age`) , components: MyTable /script 11. 路由入门11.1 单页应用程序 概念 单页应用程序：SPA【Single Page Application】是指所有的功能都在一个html页面上实现 示例 单页应用网站： 网易云音乐 https://music.163.com/ 多页应用网站：京东 https://jd.com/ 单页VS多页 单页应用类网站：系统类网站 内部网站 文档类网站 移动端站点 多页应用类网站：公司官网 电商类网站 11.2 路由 思考 单页面应用程序，之所以开发效率高，性能好，用户体验好 最大的原因就是：页面按需更新 比如当点击【发现音乐】和【关注】时，只是更新下面部分内容，对于头部是不更新的 要按需更新，首先就需要明确：访问路径和 组件的对应关系！ 访问路径 和 组件的对应关系如何确定呢？ 路由 介绍 生活中的路由：设备和ip的映射关系 Vue中的路由：路径和组件的映射关系 11.3 VueRouter的基本使用 作用 修改地址栏路径时，切换显示匹配的组件 说明 Vue 官方的一个路由插件，是一个第三方包 官网 https://v3.router.vuejs.org/zh/ 使用 下载 VueRouter 模块到当前工程，版本3.6.5 npm i vue-router@3.6.5 main.js中引入VueRouter import VueRouter from vue-router 安装注册 Vue.use(VueRouter) 创建路由对象 const router = new VueRouter() 注入，将路由对象注入到new Vue实例中，建立关联 new Vue( render: h = h(App), router:router).$mount(#app) 当我们配置完以上5步之后 就可以看到浏览器地址栏中的路由 变成了 #的形式。表示项目的路由已经被Vue-Router管理了 创建需要的组件 (views目录)，配置路由规则 配置导航，配置路由出口(路径匹配的组件显示的位置) App.vue div class=footer_wrap a href=#/find发现音乐/a a href=#/my我的音乐/a a href=#/friend朋友/a/divdiv class=top !-- 配置导航，配置路由出口(路径匹配的组件显示的位置) -- router-view/router-view/div 示例 Find.vue template div查找音乐/div/templatescriptexport default name: FindMysuic;/scriptstyle/style Friend.vue template div朋友/div/templatescriptexport default name: MyFriend;/scriptstyle/style Music.vue template div我的音乐/div/templatescriptexport default name: MyMusic;/scriptstyle/style main.js import Vue from vueimport App from ./App.vueimport VueRouter from vue-routerVue.config.productionTip = falseVue.use(VueRouter)import Find from ./views/Find.vue;import Music from ./views/Music.vue;import Friend from ./views/Friend.vue;const router = new VueRouter( routes: [ path: /find, component: Find , path: /music, component: Music , path: /friend, component: Friend ] )new Vue( render: h = h(App), router: router).$mount(#app) App.vue template div div class=footer_wrap a href=#/find发现音乐/a a href=#/music我的音乐/a a href=#/friend朋友/a /div div class=top !-- 路由出口，匹配组件展示位置 -- router-view/router-view /div /div/templatescriptexport default ;/scriptstylebody margin: 0; padding: 0;.footer_wrap position: relative; left: 0; top: 0; display: flex; width: 100%; text-align: center; background-color: #333; color: #ccc;.footer_wrap a flex: 1; text-decoration: none; padding: 20px 0; line-height: 20px; background-color: #333; color: #ccc; border: 1px solid black;.footer_wrap a:hover background-color: #555;/style 11.4 组件存放目录问题 组件分类 .vue文件分为2类，都是 .vue文件（本质无区别） 页面组件 （配置路由规则时使用的组件） 复用组件（多个组件中都使用到的组件） 存放目录 分类开来的目的就是为了 更易维护 srcviews文件夹 页面组件 - 页面展示 - 配合路由用 srccomponents文件夹 复用组件 - 展示数据 - 常用于复用 11.5 路由的封装抽离 问题 所有的路由配置都在main.js中合适吗？ 目标 将路由模块抽离出来。 好处：拆分模块，利于维护 示例 index.js import Vue from vueimport VueRouter from vue-router// 路径简写：// **脚手架环境下** @指代src目录，可以用于快速引入组件import Find from @/views/Find.vue;import Music from @/views/Music.vue;import Friend from @/views/Friend.vue;Vue.use(VueRouter)const router = new VueRouter( routes: [ path: /find, component: Find , path: /music, component: Music , path: /friend, component: Friend ] )export default router main.js import Vue from vueimport App from ./App.vueimport router from ./router/index.jsVue.config.productionTip = falseVue.directive(focus, inserted(el) el.focus() )new Vue( render: h = h(App), router: router).$mount(#app) 12. 路由进阶12.1 声明式导航12.1.1 导航高亮 需求 实现导航高亮效果 如果使用a标签进行跳转的话，需要给当前跳转的导航加样式，同时要移除上一个a标签的样式，太麻烦！！！ 解决方案 vue-router 提供了一个全局组件 router-link (取代 a 标签) 能跳转，配置 to 属性指定路径(必须) 。本质还是 a 标签 ，to 无需 # 能高亮，默认就会提供高亮类名，可以直接设置高亮样式 语法： router-link to=path的值发现音乐/router-link div div class=footer_wrap router-link to=/find发现音乐/router-link router-link to=/my我的音乐/router-link router-link to=/friend朋友/router-link /div div class=top !-- 路由出口 → 匹配的组件所展示的位置 -- router-view/router-view /div /divstyle.footer_wrap a.router-link-active background-color: purple;/style 原理： 通过router-link自带的两个样式进行高亮 使用router-link跳转后，我们发现。当前点击的链接默认加了两个class的值 router-link-exact-active和router-link-active 我们可以给任意一个class属性添加高亮样式即可实现功能 区别： router-link-active 模糊匹配（用的多） to”my” 可以匹配 my mya myb …. 只要是以my开头的路径 都可以和 to”my”匹配到 router-link-exact-active 精确匹配 to”my” 仅可以匹配 my 自定义类名： 问题： router-link的两个高亮类名 太长了，我们希望能定制怎么办 解决方案： 我们可以在创建路由对象时，额外配置两个配置项即可。 linkActiveClass和linkExactActiveClass const router = new VueRouter( routes: [...], linkActiveClass: 类名1, linkExactActiveClass: 类名2) 12.1.2 查询参数传参 目标 在跳转路由时，进行传参 比如：现在我们在搜索页点击了热门搜索链接，跳转到详情页，需要把点击的内容带到详情页，该怎么办呢？ 跳转传参 我们可以通过两种方式，在跳转的时候把所需要的参数传到其他页面中 查询参数传参 动态路由传参 查询参数传参 如何传参？ router-link to=/path?参数名=值/router-link 如何接受参数 固定用法：$router.query.参数名 示例 App.vue template div id=app div class=link router-link to=/home首页/router-link router-link to=/search搜索页/router-link /div router-view/router-view /div/templatescriptexport default ;/scriptstyle scoped.link height: 50px; line-height: 50px; background-color: #495150; display: flex; margin: -8px -8px 0 -8px; margin-bottom: 50px;.link a display: block; text-decoration: none; background-color: #ad2a26; width: 100px; text-align: center; margin-right: 5px; color: #fff; border-radius: 5px;/style Home.vue template div class=home div class=logo-box/div div class=search-box input type=text button搜索一下/button /div div class=hot-link 热门搜索： !-- 绑定参数 -- router-link to=/search?key=黑马程序员黑马程序员/router-link router-link to=/search?key=前端培训前端培训/router-link router-link to=/search?key=如何成为前端大牛如何成为前端大牛/router-link /div /div/templatescriptexport default name: FindMusic/scriptstyle.logo-box height: 150px; background: url(@/assets/logo.jpeg) no-repeat center;.search-box display: flex; justify-content: center;.search-box input width: 400px; height: 30px; line-height: 30px; border: 2px solid #c4c7ce; border-radius: 4px 0 0 4px; outline: none;.search-box input:focus border: 2px solid #ad2a26;.search-box button width: 100px; height: 36px; border: none; background-color: #ad2a26; color: #fff; position: relative; left: -2px; border-radius: 0 4px 4px 0;.hot-link width: 508px; height: 60px; line-height: 60px; margin: 0 auto;.hot-link a margin: 0 5px;/style Search.vue template div class=search !-- 接收参数 -- p搜索关键字: $route.query.key /p p搜索结果: /p ul li............./li li............./li li............./li li............./li /ul /div/templatescriptexport default name: MyFriend, created () // 在created中，获取路由参数 // this.$route.query.参数名 获取 console.log(this.$route.query.key); /scriptstyle.search width: 400px; height: 240px; padding: 0 20px; margin: 0 auto; border: 2px solid #c4c7ce; border-radius: 5px;/style routerindex.js import Home from @/views/Homeimport Search from @/views/Searchimport Vue from vueimport VueRouter from vue-routerVue.use(VueRouter) // VueRouter插件初始化// 创建了一个路由对象const router = new VueRouter( routes: [ path: /home, component: Home , path: /search, component: Search ])export default router main.js import Vue from vueimport App from ./App.vueimport router from ./router/indexVue.config.productionTip = falsenew Vue( render: h = h(App), router).$mount(#app) 12.1.3 动态路由传参 传参方式 配置动态路由 动态路由后面的参数可以随便起名，但要有语义 const router = new VueRouter( routes: [ ..., path: /search/:words, component: Search ]) 配置导航链接 to=/path/参数值 对应页面组件接受参数 $route.params.参数名 params后面的参数名要和动态路由配置的参数保持一致 示例 Home.vue template div class=home div class=logo-box/div div class=search-box input type=text button搜索一下/button /div div class=hot-link 热门搜索： router-link to=/search/黑马程序员黑马程序员/router-link router-link to=/search/前端培训前端培训/router-link router-link to=/search/如何成为前端大牛如何成为前端大牛/router-link /div /div/templatescriptexport default name: FindMusic/scriptstyle/style Search.vue template div class=search p搜索关键字: $route.params.words /p p搜索结果: /p ul li............./li li............./li li............./li li............./li /ul /div/templatescriptexport default name: MyFriend, created () // 在created中，获取路由参数 // this.$route.query.参数名 获取查询参数 // this.$route.params.参数名 获取动态路由参数 console.log(this.$route.params.words); /scriptstyle/style routerindex.js import Home from @/views/Homeimport Search from @/views/Searchimport Vue from vueimport VueRouter from vue-routerVue.use(VueRouter) // VueRouter插件初始化// 创建了一个路由对象const router = new VueRouter( routes: [ path: /home, component: Home , path: /search/:words, component: Search ])export default router 动态路由参数的可选符(了解)： 问题： 配了路由 path:”search:words” 为什么按下面步骤操作，会未匹配到组件，显示空白？ 原因 search:words 表示，必须要传参数。如果不传参数，也希望匹配，可以加个可选符”？” const router = new VueRouter( routes: [ ... path: /search/:words?, component: Search ]) 查询参数传参 VS 动态路由传参： 查询参数传参 (比较适合传多个参数) 跳转：to”path?参数名值参数名2值” 获取：$route.query.参数名 动态路由传参 (优雅简洁，传单个参数比较方便) 配置动态路由：path: “path:参数名” 跳转：to”path参数值” 获取：$route.params.参数名 注意：动态路由也可以传多个参数，但一般只传一个 总结： 声明式导航跳转时, 有几种方式传值给路由页面？ 查询参数传参（多个参数） 动态路由传参（一个参数，优雅简洁） 12.2 Vue路由12.2.1 重定向 问题 网页打开时， url 默认是 路径，未匹配到组件时，会出现空白 解决方案 重定向 → 匹配 后, 强制跳转 home 路径 语法 path: 匹配路径, redirect: 重定向到的路径 ,比如： path:/ ,redirect:/home 示例 routerindex.js import Home from @/views/Homeimport Search from @/views/Searchimport Vue from vueimport VueRouter from vue-routerVue.use(VueRouter) // VueRouter插件初始化// 创建了一个路由对象const router = new VueRouter( routes: [ // 匹配 / 重定向 /home path: /, redirect: /home , path: /home, component: Home , path: /search/:words?, component: Search ])export default router 12.2.2 404 作用 当路径找不到匹配时，给个提示页面 位置 404的路由，虽然配置在任何一个位置都可以，但一般都配置在其他路由规则的最后面 语法 path: “*” (任意路径) – 前面不匹配就命中最后这个 import NotFind from @/views/NotFindconst router = new VueRouter( routes: [ ... path: *, component: NotFind //最后一个 ]) 示例 NotFound.vue template div h1404 Not Found/h1 /div/templatescriptexport default /scriptstyle/style routerindex.js ...import NotFound from @/views/NotFound...// 创建了一个路由对象const router = new VueRouter( routes: [ ... path: *, component: NotFound ])export default router 12.2.3 模式设置 问题 路由的路径看起来不自然, 有#，能否切成真正路径形式? hash路由(默认) 例如: http://localhost:8080/#/home history路由(常用) 例如: http://localhost:8080/home (以后上线需要服务器端支持，开发环境webpack给规避掉了history模式的问题) 语法 const router = new VueRouter( mode:histroy, //默认是hash routes:[]) 12.3 编程式导航12.3.1 两种路由跳转方式 问题 点击按钮跳转如何实现？ 解决方案 编程式导航：用JS代码来进行跳转 语法 path 路径跳转 （简易方便） name 命名路由跳转 (适合 path 路径长的场景) 示例 path路径跳转语法 语法 特点：简易方便 //简单写法this.$router.push(路由路径)//完整写法this.$router.push( path: 路由路径) 示例 Home.vue template div class=home div class=logo-box/div div class=search-box input type=text button @click=goSearch搜索一下/button /div div class=hot-link 热门搜索： router-link to=/search/黑马程序员黑马程序员/router-link router-link to=/search/前端培训前端培训/router-link router-link to=/search/如何成为前端大牛如何成为前端大牛/router-link /div /div/templatescriptexport default name: FindMusic, methods: goSearch () // 1. 通过路径的方式跳转 // (1) this.$router.push(路由路径) [简写] // this.$router.push(/search) // (2) this.$router.push( [完整写法] // path: 路由路径 // ) this.$router.push( path: /search ) /scriptstyle/style name命名路由跳转 语法 特点：适合 path 路径长的场景 路由规则，必须配置name配置项 name: 路由名, path: /path/xxx, component: XXX , 通过name来进行跳转 this.$router.push( name: 路由名) 示例 routerindex.js import Home from @/views/Homeimport Search from @/views/Searchimport NotFound from @/views/NotFoundimport Vue from vueimport VueRouter from vue-routerVue.use(VueRouter) // VueRouter插件初始化// 创建了一个路由对象const router = new VueRouter( // 注意：一旦采用了 history 模式，地址栏就没有 #，需要后台配置访问规则 mode: history, routes: [ path: /, redirect: /home , path: /home, component: Home , // 配置name name: search, path: /search/:words?, component: Search , path: *, component: NotFound ])export default router Home.vue template div class=home div class=logo-box/div div class=search-box input type=text button @click=goSearch搜索一下/button /div div class=hot-link 热门搜索： router-link to=/search/黑马程序员黑马程序员/router-link router-link to=/search/前端培训前端培训/router-link router-link to=/search/如何成为前端大牛如何成为前端大牛/router-link /div /div/templatescriptexport default name: FindMusic, methods: goSearch () // 2. 通过命名路由的方式跳转 (需要给路由起名字) 适合长路径 // this.$router.push( // name: 路由名 // ) this.$router.push( name: search ) /scriptstyle/style 12.3.2 path路径跳转传参 问题 点击搜索按钮，跳转需要把文本框中输入的内容传到下一个页面如何实现？ 两种传参方式 查询参数 动态路由传参 传参 两种跳转方式，对于两种传参方式都支持： path 路径跳转传参 name 命名路由跳转传参 path路径跳转传参（query传参） 语法 //简单写法this.$router.push(/路径?参数名1=参数值1参数2=参数值2)//完整写法this.$router.push( path: /路径, query: 参数名1: 参数值1, 参数名2: 参数值2 ) 接受参数的方式依然是：$route.query.参数名 示例 Home.vue template div class=home div class=logo-box/div div class=search-box input v-model=inpValue type=text button @click=goSearch搜索一下/button /div div class=hot-link 热门搜索： router-link to=/search/黑马程序员黑马程序员/router-link router-link to=/search/前端培训前端培训/router-link router-link to=/search/如何成为前端大牛如何成为前端大牛/router-link /div /div/templatescriptexport default name: FindMusic, data () return inpValue: , methods: goSearch () // this.$router.push(路由路径?参数名=参数值) // this.$router.push(`/search?key=$this.inpValue`) // (2) this.$router.push( [完整写法] 更适合传参 // path: 路由路径 // query: // 参数名: 参数值, // 参数名: 参数值 // // ) // this.$router.push( // path: /search, // query: // key: this.inpValue // // ) /scriptstyle/style path路径跳转传参（动态路由传参） 语法： 绑定动态路由参数 name: search, path: /search/:参数名?, component: Search , 传参 //简单写法this.$router.push(/路径/参数值)//完整写法this.$router.push( path: /路径/参数值) 接收 p搜索关键字: $route.params.words /p 接受参数的方式依然是：$route.params.参数名 示例： Home.vue template div class=home div class=logo-box/div div class=search-box input v-model=inpValue type=text button @click=goSearch搜索一下/button /div div class=hot-link 热门搜索： router-link to=/search/黑马程序员黑马程序员/router-link router-link to=/search/前端培训前端培训/router-link router-link to=/search/如何成为前端大牛如何成为前端大牛/router-link /div /div/templatescriptexport default name: FindMusic, data () return inpValue: , methods: goSearch () // this.$router.push(`/search/$this.inpValue`) this.$router.push( path: `/search/$this.inpValue` ) /scriptstyle/style 12.3.3 name命名路由传参 name 命名路由跳转传参 (query传参) 语法 this.$router.push( name: 路由名字, query: 参数名1: 参数值1, 参数名2: 参数值2 ) 示例 template div class=home div class=logo-box/div div class=search-box input v-model=inpValue type=text button @click=goSearch搜索一下/button /div div class=hot-link 热门搜索： router-link to=/search/黑马程序员黑马程序员/router-link router-link to=/search/前端培训前端培训/router-link router-link to=/search/如何成为前端大牛如何成为前端大牛/router-link /div /div/templatescriptexport default name: FindMusic, data () return inpValue: , methods: goSearch () // 2. 通过命名路由的方式跳转 (需要给路由起名字) 适合长路径 // this.$router.push( // name: 路由名 // query: 参数名: 参数值 // ) this.$router.push( name: search, query: key: this.inpValue ) /scriptstyle/style name 命名路由跳转传参 (动态路由传参) 语法 this.$router.push( name: 路由名字, params: 参数名: 参数值, ) 示例 template div class=home div class=logo-box/div div class=search-box input v-model=inpValue type=text button @click=goSearch搜索一下/button /div div class=hot-link 热门搜索： router-link to=/search/黑马程序员黑马程序员/router-link router-link to=/search/前端培训前端培训/router-link router-link to=/search/如何成为前端大牛如何成为前端大牛/router-link /div /div/templatescriptexport default name: FindMusic, data () return inpValue: , methods: goSearch () // 2. 通过命名路由的方式跳转 (需要给路由起名字) 适合长路径 // this.$router.push( // name: 路由名 // params: 参数名: 参数值 // ) this.$router.push( name: search, params: // 与动态路由绑定的参数名一致 words: this.inpValue ) /scriptstyle/style 12.3.4 传参总结 编程式导航，如何跳转传参？ path路径跳转 query传参 this.$router.push(/路径?参数名1=参数值1参数2=参数值2)this.$router.push( path: /路径, query: 参数名1: 参数值1, 参数名2: 参数值2 ) 动态路由传参 this.$router.push(/路径/参数值)this.$router.push( path: /路径/参数值) name命名路由跳转 query传参 this.$router.push( name: 路由名字, query: 参数名1: 参数值1, 参数名2: 参数值2 ) 动态路由传参 (需要配动态路由) this.$router.push( name: 路由名字, params: 参数名: 参数值, ) 12.4 二级路由配置 二级路由也叫嵌套路由，当然也可以嵌套三级、四级… 使用场景 当在页面中点击链接跳转，只是部分内容切换时，我们可以使用嵌套路由 语法 在一级路由下，配置children属性即可 配置二级路由的出口 在一级路由下，配置children属性 注意:一级的路由path 需要加 / 二级路由的path不需要加 / const router = new VueRouter( routes: [ path: /, component: Layout, children:[ //children中的配置项 跟一级路由中的配置项一模一样 path:xxxx,component:xxxx.vue, path:xxxx,component:xxxx.vue, ] ]) 技巧：二级路由应该配置到哪个一级路由下呢？ 这些二级路由对应的组件渲染到哪个一级路由下，children就配置到哪个路由下边 配置二级路由的出口 注意： 配置了嵌套路由，一定配置对应的路由出口，否则不会渲染出对应的组件 Layout.vue template div class=h5-wrapper div class=content router-view/router-view /div .... /div/template 示例 routerindex.js ...import Article from @/views/Article.vueimport Collect from @/views/Collect.vueimport Like from @/views/Like.vueimport User from @/views/User.vue...const router = new VueRouter( routes: [ path: /, component: Layout, redirect: /article, children:[ path:/article, component:Article , path:/collect, component:Collect , path:/like, component:Like , path:/user, component:User ] , .... ]) Layout.vue template div class=h5-wrapper div class=content !-- 内容部分 -- router-view/router-view /div nav class=tabbar a href=#/article面经/a a href=#/collect收藏/a a href=#/like喜欢/a a href=#/user我的/a /nav /div/template 12.5 点击回退跳转 语法 $route.back() 示例 template div class=article-detail-page nav class=navspan class=back @click=$router.back()lt;/span 面经详情/nav .... /div/template 13. 缓存组件 问题 从面经列表 点到 详情页，又点返回，数据重新加载了 → 希望回到原来的位置 原因 当路由被跳转后，原来所看到的组件就被销毁了（会执行组件内的beforeDestroy和destroyed生命周期钩子），重新返回后组件又被重新创建了（会执行组件内的beforeCreate,created,beforeMount,Mounted生命周期钩子），所以数据被加载了 解决方案 利用keep-alive把原来的组件给缓存下来 什么是keep-alive? keep-alive 是 Vue 的内置组件，当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。 keep-alive 是一个抽象组件：它自身不会渲染成一个 DOM 元素，也不会出现在父组件中。 优点： 在组件切换过程中把切换出去的组件保留在内存中，防止重复渲染DOM， 减少加载时间及性能消耗，提高用户体验性。 App.vue template div class=h5-wrapper keep-alive router-view/router-view /keep-alive /div/template 问题： 缓存了所有被切换的组件，导致点击进入详细页面不会刷新 keep-alive的三个属性： ① include ： 组件名数组，只有匹配的组件会被缓存 ② exclude ： 组件名数组，任何匹配的组件都不会被缓存 ③ max ： 最多可以缓存多少组件实例 App.vue template div class=h5-wrapper keep-alive :include=[LayoutPage] router-view/router-view /keep-alive /div/template---------------------------------------------template div class=h5-wrapper keep-alive :include=keepArr router-view/router-view /keep-alive /div/templatescriptexport default name: h5-wrapper, data() return keepArr: [LayoutPage] ; ;/script 额外的两个生命周期钩子： keep-alive的使用会触发两个生命周期函数 activated 当组件被激活（使用）的时候触发 → 进入这个页面的时候触发 deactivated 当组件不被使用的时候触发 → 离开这个页面的时候触发 组件缓存后就不会执行组件的created, mounted, destroyed 等钩子了，所以其提供了actived 和deactived钩子，帮我们实现业务需求。 14. Vuex14.1 概述 是什么 Vuex 是一个 Vue 的 状态管理工具，状态就是数据。大白话：Vuex 是一个插件，可以帮我们管理 Vue 通用的数据 (多组件共享的数据)。例如：购物车数据 个人信息数 使用场景 某个状态 在 很多个组件 来使用 (个人信息) 多个组件 共同维护 一份数据 (购物车) 优势 共同维护一份数据，数据集中化管理 响应式变化 操作简洁 (vuex提供了一些辅助函数) 注意 不是所有的场景都适用于vuex，只有在必要的时候才使用vuex 使用了vuex之后，会附加更多的框架中的概念进来，增加了项目的复杂度 （数据的操作更便捷，数据的流动更清晰） 14.2 使用 需求 效果是三个组件共享一份数据: 任意一个组件都可以修改数据 三个组件的数据是同步的 创建项目 vue create vuex-demo 创建三个组件 |-components|--Son1.vue|--Son2.vue|-App.vue 示例 App.vue template div id=app h1根组件/h1 input type=text Son1/Son1 hr Son2/Son2 /div/templatescriptimport Son1 from ./components/Son1.vueimport Son2 from ./components/Son2.vueexport default name: app, data: function () return , components: Son1, Son2 /scriptstyle#app width: 600px; margin: 20px auto; border: 3px solid #ccc; border-radius: 3px; padding: 10px;/style main.js import Vue from vueimport App from ./App.vueVue.config.productionTip = falsenew Vue( render: h = h(App)).$mount(#app) Son1.vue template div class=box h2Son1 子组件/h2 从vuex中获取的值: label/label br button值 + 1/button /div/templatescriptexport default name: Son1Com/scriptstyle lang=css scoped.box border: 3px solid #ccc; width: 400px; padding: 10px; margin: 20px;h2 margin-top: 10px;/style Son2.vue template div class=box h2Son2 子组件/h2 从vuex中获取的值:label/label br / button值 - 1/button /div/templatescriptexport default name: Son2Com/scriptstyle lang=css scoped.box border: 3px solid #ccc; width: 400px; padding: 10px; margin: 20px;h2 margin-top: 10px;/style 引入vuex 安装vuex 安装vuex与vue-router类似，vuex是一个独立存在的插件，如果脚手架初始化没有选 vuex，就需要额外安装。 yarn add vuex@3 或者 npm i vuex@3 新建 store/index.js 专门存放 vuex 为了维护项目目录的整洁，在src目录下新建一个store目录其下放置一个index.js文件。 (和 router/index.js 类似) 创建仓库 store/index.js // 导入 vueimport Vue from vue// 导入 vueximport Vuex from vuex// vuex也是vue的插件, 需要use一下, 进行插件的安装初始化Vue.use(Vuex)// 创建仓库 storeconst store = new Vuex.Store()// 导出仓库export default store 在 main.js 中导入挂载到 Vue 实例上 import Vue from vueimport App from ./App.vueimport store from @/store/indexVue.config.productionTip = falsenew Vue( render: h = h(App), store).$mount(#app) 14.3 核心概念-state 概念 State提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储。 打开项目中的store.js文件，在state对象中可以添加我们要共享的数据。 // 创建仓库 storeconst store = new Vuex.Store( // state 状态, 即数据, 类似于vue组件中的data, // 区别： // 1.data 是组件自己的数据, // 2.state 中的数据整个vue项目的组件都能访问到 state: count: 101 ) 访问 问题: 如何获取count? 模板中 $store.state.xxx 组件中 this.$store.state.xxx JS模块中 store.state.xxx 示例 模板中使用 模板中可以使用 $store 获取到vuex中的store对象实例，可通过state属性属性获取count， 如下 template\th1state的数据 - $store.state.count /h1/template 组件逻辑中使用 将state属性定义在计算属性中 https://vuex.vuejs.org/zh/guide/state.html h1state的数据 - count /h1scriptexport default name: Son1Com, // 把state中数据，定义在组件内的计算属性中 computed: count() return this.$store.state.count /script js文件中使用 //main.jsimport store from @/storeconsole.log(store.state.count) 辅助函数： mapState是辅助函数，帮助我们把store中的数据映射到 组件的计算属性中, 它属于一种方便的用法 导入mapState scriptimport mapState from vuex;/script 采用数组形式引入state属性 export default name: Son2Com, computed: ...mapState([count]) 上面代码的最终得到的是 类似于export default name: Son1Com, computed: count() return this.$store.state.count 利用展开运算符将导出的状态映射给计算属性 computed: ...mapState([count]) 示例： template div class=box h2Son2 子组件/h2 从vuex中获取的值:label count /label br / button值 - 1/button /div/templatescriptimport mapState from vuex;export default name: Son2Com, computed: ...mapState([count]) /scriptstyle lang=css scoped.box border: 3px solid #ccc; width: 400px; padding: 10px; margin: 20px;h2 margin-top: 10px;/style 14.4 严格模式 目标 明确 vuex 同样遵循单向数据流，组件中不能直接修改仓库的数据 直接在组件中修改Vuex中state的值 button @click=handleAdd值 + 1/buttonmethods: handleAdd (n) // 错误代码(vue默认不会监测，监测需要成本) this.$store.state.count++ // console.log(this.$store.state.count) , 开启严格模式 通过 strict: true 可以开启严格模式,开启严格模式后，直接修改state中的值会报错 state数据的修改只能通过mutations，并且mutations必须是同步的 14.5 核心概念-mutations mutations是一个对象，对象中存放修改state的方法 14.5.1 无参mutations 定义 const store = new Vuex.Store( state: count: 0 , // 定义mutations mutations: ) 格式说明 mutations是一个对象，对象中存放修改state的方法 mutations: // 方法里参数 第一个参数是当前store的state属性 // payload 载荷 运输参数 调用mutaiions的时候 可以传递参数 传递载荷 addCount (state) state.count += 1 , 组件提交mutations this.$store.commit(addCount) 示例 index.js import Vue from vueimport Vuex from vuexVue.use(Vuex)const store = new Vuex.Store( state: count: 101 , // 所有mutation函数，第一个参数，都是 state mutations: addCount(state) state.count += 1 )export default store Son1.vue template div class=box h2Son1 子组件/h2 从vuex中获取的值: label $store.state.count /label hr 从vuex中获取的值: label count /label br button @click=add值 + 1/button /div/templatescriptexport default name: Son1Com, computed: count() return this.$store.state.count , methods: add() this.$store.commit(addCount) /scriptstyle lang=css scoped.box border: 3px solid #ccc; width: 400px; padding: 10px; margin: 20px;h2 margin-top: 10px;/style 总结 通过mutations修改state的步骤 定义 mutations 对象，对象中存放修改 state 的方法 组件中提交调用 mutations(通过this.$store.commit(mutations的方法名)) 14.5.2 带参mutations 语法 看下面这个案例，每次点击不同的按钮，加的值都不同，每次都要定义不同的mutations处理吗？ 提交 mutation 是可以传递参数的 this.$store.commit(xxx, 参数) 示例 index.js import Vue from vueimport Vuex from vuexVue.use(Vuex)const store = new Vuex.Store( state: count: 101, title: , // 所有mutation函数，第一个参数，都是 state mutations: addCount(state) state.count += 1 , addCountN(state, n) state.count += n , // 注意点：mutation另一个参数有且只能有一个，如果需要多个参数，包装成一个对象 addCountObj(state, obj) state.count += obj.count )export default store Son1.vue template div class=box h2Son1 子组件 /h2 从vuex中获取的值: label $store.state.count /label hr 从vuex中获取的值: label count /label br button @click=add值 + 1/button button @click=addN值 + n/button button @click=addObj值 + obj/button /div/templatescriptexport default name: Son1Com, computed: count() return this.$store.state.count , methods: add() this.$store.commit(addCount) , addN() this.$store.commit(addCountN, 10) , addObj() this.$store.commit(addCountObj, count: 12) /scriptstyle lang=css scoped.box border: 3px solid #ccc; width: 400px; padding: 10px; margin: 20px;h2 margin-top: 10px;/style 注意 提交的参数只能是一个, 如果有多个参数要传, 可以传递一个对象 14.5.3 辅助函数- mapMutations 语法 mapMutations和mapState很像，它把位于mutations中的方法提取了出来，我们可以将它导入 import mapMutations from vuexmethods: ...mapMutations([addCount]) 上面代码的含义是将mutations的方法导入了methods中，等价于 methods: // commit(方法名, 载荷参数) addCount () this.$store.commit(addCount) 此时，就可以直接通过this.addCount调用了 button @click=addCount值+1/button 但是请注意： Vuex中mutations中要求不能写异步代码，如果有异步的ajax请求，应该放置在actions中 示例 index.js import Vue from vueimport Vuex from vuexVue.use(Vuex)const store = new Vuex.Store( state: count: 101, title: , // 所有mutation函数，第一个参数，都是 state mutations: addCount(state) state.count += 1 , addCountN(state, n) state.count += n , // 注意点：mutation另一个参数有且只能有一个，如果需要多个参数，包装成一个对象 addCountObj(state, obj) state.count += obj.count )export default store Son2.vue template div class=box h2Son2 子组件/h2 从vuex中获取的值:label count /label br / button @click=addCount值 + 1/button button @click=addCountN(12)值 + n/button button @click=addCountObj(count: 10)值 + obj/button /div/templatescriptimport mapState, mapMutations from vuex;export default name: Son2Com, computed: ...mapState([count]) , methods: ...mapMutations([addCount, addCountN, addCountObj]) /scriptstyle lang=css scoped.box border: 3px solid #ccc; width: 400px; padding: 10px; margin: 20px;h2 margin-top: 10px;/style 14.6 核心概念-actions14.6.1 基础使用 概念 state是存放数据的，mutations是同步更新数据 (便于监测数据的变化, 更新视图等, 方便于调试工具查看变化)， actions则负责进行异步操作 说明 mutations必须是同步的 需求 一秒钟之后, 要给一个数 去修改state 语法 定义actions actions: setAsyncCount (context, num) // 一秒后, 给一个数, 去修改 num setTimeout(() = context.commit(changeCount, num) , 1000) , 组件中通过dispatch调用 setAsyncCount () this.$store.dispatch(setAsyncCount, 666) 示例 index.js import Vue from vueimport Vuex from vuexVue.use(Vuex)const store = new Vuex.Store( state: count: 101, title: , // 所有mutation函数，第一个参数，都是 state mutations: addCountN(state, n) state.count += n , actions: setAsyncCount(context, num) setTimeout(() = context.commit(addCountN, num) , 1000) )export default store Son1.vue template div class=box h2Son1 子组件 /h2 从vuex中获取的值: label $store.state.count /label hr 从vuex中获取的值: label count /label br button @click=setAsyncCount一秒后值 + 666/button /div/templatescriptexport default name: Son1Com, computed: count() return this.$store.state.count , methods: setAsyncCount() // 调用action // this.$store.dispatch(action名字, 额外参数) this.$store.dispatch(setAsyncCount, 666) /scriptstyle lang=css scoped.box border: 3px solid #ccc; width: 400px; padding: 10px; margin: 20px;h2 margin-top: 10px;/style 14.6.2 辅助函数-mapActions 概念 mapActions 是把位于 actions中的方法提取了出来，映射到组件methods中 示例 Son2.vue template div class=box h2Son2 子组件/h2 从vuex中获取的值:label count /label br / button @click=setAsyncCount(666)一秒后值 + 666/button /div/templatescriptimport mapState, mapMutations, mapActions from vuex;export default name: Son2Com, computed: ...mapState([count]) , methods: ...mapActions([setAsyncCount]) /scriptstyle lang=css scoped.box border: 3px solid #ccc; width: 400px; padding: 10px; margin: 20px;h2 margin-top: 10px;/style index.js import Vue from vueimport Vuex from vuexVue.use(Vuex)const store = new Vuex.Store( state: count: 101, title: , // 所有mutation函数，第一个参数，都是 state mutations: addCountN(state, n) state.count += n , actions: setAsyncCount(context, num) setTimeout(() = context.commit(addCountN, num) , 1000) )export default store 14.7 核心概念-getters14.7.1 基础使用 作用 除了state之外，有时我们还需要从state中筛选出符合条件的一些数据，这些数据是依赖state的，此时会用到getters 例如，state中定义了list，为1-10的数组， state: list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 组件中，需要显示所有大于5的数据，正常的方式，是需要list在组件中进行再一步的处理，但是getters可以帮助我们实现它 定义 getters: // getters函数的第一个参数是 state // 必须要有返回值 filterList(state) return state.list.filter(item = item 5) 使用 template div class=box 从getters获取list: $store.getters.filterList hr 从getters获取list: filterList /div/templatescriptexport default name: Son1Com, computed: filterList() return this.$store.getters.filterList /scriptstyle lang=css scoped.box border: 3px solid #ccc; width: 400px; padding: 10px; margin: 20px;h2 margin-top: 10px;/style 14.7.2 辅助函数-mapGetters 示例 template div class=box 从getters获取list: filterList /div/templatescriptimport mapState, mapMutations, mapActions, mapGetters from vuex;export default name: Son2Com, computed: ...mapGetters([filterList]) /scriptstyle lang=css scoped.box border: 3px solid #ccc; width: 400px; padding: 10px; margin: 20px;h2 margin-top: 10px;/style 14.8 使用小结 图例 14.9 核心概念-module14.9.1 module概念 问题 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 这句话的意思是，如果把所有的状态都放在state中，当项目变得越来越大的时候，Vuex会变得越来越难以维护。由此，又有了Vuex的模块化。 示例 定义两个模块 user 和 setting user中管理用户的信息状态 userInfo modules/user.js const state = userInfo: name: zs, age: 18 const mutations = const actions = const getters = export default state, mutations, actions, getters setting中管理项目应用的 主题色 theme，描述 desc， modules/setting.js const state = theme: dark desc: 描述真呀真不错const mutations = const actions = const getters = export default state, mutations, actions, getters 在store/index.js文件中的modules配置项中，注册这两个模块 import user from ./modules/userimport setting from ./modules/settingconst store = new Vuex.Store( modules: user, setting ) 14.9.2 模块内的state 尽管已经分模块了，但其实子模块的状态，还是会挂到根级别的 state 中，属性名就是模块名 直接访问 直接通过模块名访问 $store.state.模块名.xxx user.js // user模块const state = userInfo: name: zs, age: 18 , score: 80const mutations = const actions = const getters = export default namespaced:true, state, mutations, actions, getters Son1.vue $store.state.user.userInfo.name 辅助函数 通过 mapState 映射： 默认根级别的映射 mapState([ ‘xxx’ ]) 子模块的映射 ：mapState(‘模块名’, [‘xxx’]) - 需要开启命名空间 namespaced:true ...mapState(user, [userInfo]),...mapState(setting, [theme, desc]), 14.9.3 模块内的getters 示例 modules/user.js const getters = // 分模块后，state指代子模块的state UpperCaseName (state) return state.userInfo.name.toUpperCase() Son1.vue 直接访问getters !-- 测试访问模块中的getters - 原生 --div $store.getters[user/UpperCaseName] /div Son2.vue 通过命名空间访问 computed: ...mapGetters(user, [UpperCaseName]) 14.9.4 模块内的mutations 注意 默认模块中的 mutation 和 actions 会被挂载到全局，**需要开启命名空间**，才会挂载到子模块。 示例 modules/user.js const mutations = setUser (state, newUserInfo) state.userInfo = newUserInfo modules/setting.js const mutations = setTheme (state, newTheme) state.theme = newTheme Son1.vue button @click=updateUser更新个人信息/button button @click=updateTheme更新主题色/buttonexport default methods: updateUser () // $store.commit(模块名/mutation名, 额外传参) this.$store.commit(user/setUser, name: xiaowang, age: 25 ) , updateTheme () this.$store.commit(setting/setTheme, pink) Son2.vue button @click=setUser( name: xiaoli, age: 80 )更新个人信息/buttonbutton @click=setTheme(skyblue)更新主题/buttonmethods:// 分模块的映射...mapMutations(setting, [setTheme]),...mapMutations(user, [setUser]), 14.9.5 模块内的actions 注意 默认模块中的 mutation 和 actions 会被挂载到全局，**需要开启命名空间**，才会挂载到子模块。 示例 modules/user.js const actions = setUserSecond (context, newUserInfo) // 将异步在action中进行封装 setTimeout(() = // 调用mutation context上下文，默认提交的就是自己模块的action和mutation context.commit(setUser, newUserInfo) , 1000) Son1.vue 直接通过store调用 button @click=updateUser2一秒后更新信息/buttonmethods: updateUser2 () // 调用action dispatch this.$store.dispatch(user/setUserSecond, name: xiaohong, age: 28 ) , Son2.vue mapActions映射 button @click=setUserSecond( name: xiaoli, age: 80 )一秒后更新信息/buttonmethods: ...mapActions(user, [setUserSecond]) 14.9.6 使用总结 直接使用 state – $store.state.模块名.数据项名 getters – $store.getters[‘模块名属性名’] mutations – $store.commit(‘模块名方法名’, 其他参数) actions – $store.dispatch(‘模块名方法名’, 其他参数) 借助辅助函数 import { mapXxxx, mapXxx } from ‘vuex’ computed、methods: { ​ …mapState、…mapGetters放computed中； ​ …mapMutations、…mapActions放methods中； ​ …mapXxxx(‘模块名’, [‘数据项|方法’]), ​ …mapXxxx(‘模块名’, { 新的名字: 原来的名字 }), } 组件中直接使用 属性 age 或 方法 @click=updateAge(2)","tags":["Vue2","vuex"],"categories":["前端"]},{"title":"AJAX基础","path":"/2023/12/13/2023-12-13-AJAX基础/","content":"1. AJAX入门1.1 AJAX概念和axios使用 定义 AJAX 异步 JavaScript 和 XML。 AJAX 是一种用于创建快速动态网页的技术。 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。 概念 AJAX 是浏览器与服务器进行数据通信的技术 怎么用AJAX 先使用 axios 库，与服务器进行数据通信 基于 XMLHttpRequest 封装、代码简单、月下载量在 14 亿次 Vue、React 项目中都会用到 axios 再学习 XMLHttpRequest 对象的使用，了解 AJAX 底层原理 axios使用 引入 axios.js：https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js 使用 axios 函数 ✓ 传入配置对象 ✓ 再用 .then 回调函数接收结果，并做后续处理 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody p/p script src=https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js/script script axios( //url: http://hmajax.itheima.net/api/province // 直接拼接查询参数 url: `https://mock.boxuegu.com/mock/3083/articles/$id` ).then(result = console.log(result); ) /script/body/html 1.2 认识URL 定义 URL 代表着是统一资源定位符（Uniform Resource Locator）。URL 无非就是一个给定的独特资源在 Web 上的地址。理论上说，每个有效的 URL 都指向一个唯一的资源。这个资源可以是一个 HTML 页面，一个 CSS 文档，一幅图像，等等。而在实际中，也有一些例外，最常见的情况就是一个 URL 指向了不存在的或是被移动过的资源。由于通过 URL 呈现的资源和 URL 本身由 Web 服务器处理，因此 web 服务器的拥有者需要认真地维护资源以及与它关联的 URL。 概念 URL 就是统一资源定位符，简称网址，用于访问网络上的资源。 URL的组成 协议 域名：标记服务器在互联网中方位 资源路径：标记资源在服务器下的具体位置 1.3 URL查询参数 定义 浏览器提供给服务器的额外信息，让服务器返回浏览器想要的数据 语法 http://xxxx.com/xxx/xxx?参数名1=值1参数名2=值2 axios-查询参数 使用 axios 提供的 params 选项 使用 axios 提供的 params 选项 注意：axios 在运行时把参数名和值，会拼接到 url?参数名值 城市列表：http://hmajax.itheima.net/api/city?pname=河北省 axios( url: 目标资源地址, params: 参数名: 值 ).then(result = // 对服务器返回的数据做后续处理)axios( url: http://hmajax.itheima.net/api/city, params: pname: 河北省 ).then(result = console.log(result);) 直接拼接查询参数 axios.get(`https://mock.boxuegu.com/mock/3083/articles/$id`); 1.4 常用请求方法和数据提交 请求方法 对服务器资源，要执行的操作 请求方法 操作 GET 获取数据 POST 数据提交 PUT 修改数据（全部） DELETE 删除数据 PATCH 修改数据（部分） axios请求配置 url：请求的 URL 网址 method：请求的方法，GET可以省略（不区分大小写） data：提交数据 axios( url: 目标资源地址, method: 请求方法, data: 参数名: 值 ).then((result) = // 对服务器返回的数据做后续处理 ) 示例：数据提交-注册账号 axios( url: http://hmajax.itheima.net/api/register, method: POST, data: username: liming, password: 123456 ).then((result) = // 对服务器返回的数据做后续处理 ) axios核心配置 url：请求 URL 网址 method：请求方法，GET 可以省略（不区分大小写） params：查询参数 data：提交数据 axios错误处理 场景：再次注册相同的账号，会遇到报错信息 处理：用更直观的方式，给普通用户展示错误信息 语法：在 then 方法的后面，通过点语法调用 catch 方法，传入回调函数并定义形参 body button class=btn注册用户/button script src=https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js/script script /* 注册用户: http://hmajax.itheima.net/api/register 请求方法: POST 参数名: username: 用户名 (中英文和数字组成, 最少8位) password: 密码 (最少6位) 目标: 点击按钮, 通过axios提交用户和密码, 完成注册 需求: 使用axios错误处理语法, 拿到报错信息, 弹框反馈给用户 */ document.querySelector(.btn).addEventListener(click, () = axios( url: http://hmajax.itheima.net/api/register, method: post, data: username: itheima007, password: 7654321 ).then(result = // 成功 console.log(result) ).catch(error = // 失败 // 处理错误信息 console.log(error) console.log(error.response.data.message) alert(error.response.data.message) ) ) /script/body 1.5 HTTP协议-报文 概念 规定了浏览器发送及服务器返回内容的格式 请求报文 请求报文：浏览器按照 HTTP 协议要求的格式，发送给服务器的内容 请求行：请求方法，URL，协议 请求头：以键值对的格式携带的附加信息，比如：Content-Type 空行：分隔请求头，空行之后的是发送给服务器的资源 请求体：发送的资源 响应报文 响应报文：服务器按照 HTTP 协议要求的格式，返回给浏览器的内容 响应行（状态行）：协议、HTTP 响应状态码、状态信息 响应头：以键值对的格式携带的附加信息，比如：Content-Type 空行：分隔响应头，空行之后的是服务器返回的资源 响应体：返回的资源 状态码 HTTP 响应状态码：用来表明请求是否成功完成 状态码 说明 1xx 信息 2xx 成功 3xx 重定向消息 4xx 客户端错误 5xx 服务端错误 1.6 案例-用户登录 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title案例_登录_提示消息/title !-- 引入bootstrap.css -- link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css !-- 公共 -- style html, body background-color: #EDF0F5; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; .container width: 520px; height: 540px; background-color: #fff; padding: 60px; box-sizing: border-box; .container h3 font-weight: 900; /style !-- 表单容器和内容 -- style .form_wrap color: #8B929D !important; .form-text color: #8B929D !important; /style !-- 提示框样式 -- style .alert transition: .5s; opacity: 0; .alert.show opacity: 1; /style/headbody div class=container h3欢迎-登录/h3 !-- 登录结果-提示框 -- div class=alert alert-success role=alert 提示消息 /div !-- 表单 -- div class=form_wrap form div class=mb-3 label for=username class=form-label账号名/label input type=text class=form-control username /div div class=mb-3 label for=password class=form-label密码/label input type=password class=form-control password /div button type=button class=btn btn-primary btn-login 登 录 /button /form /div /div script src=https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js/script script // 目标1：点击登录时，用户名和密码长度判断，并提交数据和服务器通信 // 目标2：使用提示框，反馈提示消息 // 2.1 获取提示框 const myAlert = document.querySelector(.alert) /** * 2.2 封装提示框函数，重复调用，满足提示需求 * 功能： * 1. 显示提示框 * 2. 不同提示文字msg，和成功绿色失败红色isSuccess（true成功，false失败） * 3. 过2秒后，让提示框自动消失 */ function alertFn(msg, isSuccess) // 1 显示提示框 myAlert.classList.add(show) // 2 实现细节 myAlert.innerText = msg const bgStyle = isSuccess ? alert-success : alert-danger myAlert.classList.add(bgStyle) // 3 过2秒隐藏 setTimeout(() = myAlert.classList.remove(show) // 提示：避免类名冲突，重置背景色 myAlert.classList.remove(bgStyle) , 2000) // 1.1 登录-点击事件 document.querySelector(.btn-login).addEventListener(click, () = // 1.2 获取用户名和密码 const username = document.querySelector(.username).value const password = document.querySelector(.password).value // console.log(username, password) // 1.3 判断长度 if (username.length 8) alertFn(用户名必须大于等于8位, false) console.log(用户名必须大于等于8位) return // 阻止代码继续执行 if (password.length 6) alertFn(密码必须大于等于6位, false) console.log(密码必须大于等于6位) return // 阻止代码继续执行 // 1.4 基于axios提交用户名和密码 // console.log(提交数据到服务器) axios( url: http://hmajax.itheima.net/api/login, method: POST, data: username, password ).then(result = alertFn(result.data.message, true) console.log(result) console.log(result.data.message) ).catch(error = alertFn(error.response.data.message, false) console.log(error) console.log(error.response.data.message) ) ) /script/body/html 1.7 form-serialize插件 作用 快速收集表单元素的值 示例 登录案例使用插件 script src=https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js/script !-- 3.1 引入插件 -- script src=./lib/form-serialize.js/script script // 目标1：点击登录时，用户名和密码长度判断，并提交数据和服务器通信 // 目标2：使用提示框，反馈提示消息 // 目标3：使用form-serialize插件，收集用户名和密码 // 2.1 获取提示框 const myAlert = document.querySelector(.alert) /**2.2 封装提示框函数，重复调用，满足提示需求 * 功能： * 1. 显示提示框 * 2. 不同提示文字msg，和成功绿色失败红色isSuccess（true成功，false失败） * 3. 过2秒后，让提示框自动消失 */ function alertFn(msg, isSuccess) // 1 显示提示框 myAlert.classList.add(show) // 2 实现细节 myAlert.innerText = msg const bgStyle = isSuccess ? alert-success : alert-danger myAlert.classList.add(bgStyle) // 3 过2秒隐藏 setTimeout(() = myAlert.classList.remove(show) // 提示：避免类名冲突，重置背景色 myAlert.classList.remove(bgStyle) , 2000) // 1.1 登录-点击事件 document.querySelector(.btn-login).addEventListener(click, () = // 3.2 使用serialize函数，收集登录表单里用户名和密码 const form = document.querySelector(.login-form) const data = serialize(form, hash: true, empty: true ) console.log(data) // username: itheima007, password: 7654321 const username, password = data // 1.2 获取用户名和密码 // const username = document.querySelector(.username).value // const password = document.querySelector(.password).value console.log(username, password) // 1.3 判断长度 if (username.length 8) alertFn(用户名必须大于等于8位, false) console.log(用户名必须大于等于8位) return // 阻止代码继续执行 if (password.length 6) alertFn(密码必须大于等于6位, false) console.log(密码必须大于等于6位) return // 阻止代码继续执行 // 1.4 基于axios提交用户名和密码 // console.log(提交数据到服务器) axios( url: http://hmajax.itheima.net/api/login, method: POST, data: username, password ).then(result = alertFn(result.data.message, true) console.log(result) console.log(result.data.message) ).catch(error = alertFn(error.response.data.message, false) console.log(error) console.log(error.response.data.message) ) )/script 2. AJAX原理2.1 XMLHttpRequest 概念 XMLHttpRequest（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。XMLHttpRequest 在 AJAX 编程中被大量使用。 关系 axios 内部采用 XMLHttpRequest 与服务器交互。 XMLHttpRequest使用 创建 XMLHttpRequest 对象 配置请求方法和请求 url 地址 监听 loadend 事件，接收响应结果 发起请求 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleXMLHttpRequest_基础使用/title/headbody p class=my-p/p script /** * 目标：使用XMLHttpRequest对象与服务器通信 * 1. 创建 XMLHttpRequest 对象 * 2. 配置请求方法和请求 url 地址 * 3. 监听 loadend 事件，接收响应结果 * 4. 发起请求 */ // 1. 创建 XMLHttpRequest 对象 const xhr = new XMLHttpRequest() // 2. 配置请求方法和请求 url 地址 xhr.open(GET, http://hmajax.itheima.net/api/province) // 3. 监听 loadend 事件，接收响应结果 xhr.addEventListener(loadend, () = console.log(xhr.response) const data = JSON.parse(xhr.response) console.log(data.list.join(br)) document.querySelector(.my-p).innerHTML = data.list.join(br) ) // 4. 发起请求 xhr.send() /script/body/html XMLHttpRequest-查询参数 定义：浏览器提供给服务器的额外信息，让服务器返回浏览器想要的数据 语法：http://xxxx.com/xxx/xxx?参数名1=值1参数名2=值2 原生 XHR 需要自己在 url 后面携带查询参数字符串，没有 axios 帮助我们把 params 参数拼接到 url 字符串后面了 多个查询参数，如果自己拼接很麻烦，这里用 URLSearchParams 把参数对象转成“参数名值参数名值“格式的字符串，语法如下 // 1. 创建 URLSearchParams 对象const paramsObj = new URLSearchParams( 参数名1: 值1, 参数名2: 值2)// 2. 生成指定格式查询参数字符串const queryString = paramsObj.toString()// 结果：参数名1=值1参数名2=值2 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title案例_地区查询/title link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css style :root font-size: 15px; body padding-top: 15px; /style/headbody div class=container form id=editForm class=row !-- 输入省份名字 -- div class=mb-3 col label class=form-label省份名字/label input type=text value=北京 name=province class=form-control province placeholder=请输入省份名称 / /div !-- 输入城市名字 -- div class=mb-3 col label class=form-label城市名字/label input type=text value=北京市 name=city class=form-control city placeholder=请输入城市名称 / /div /form button type=button class=btn btn-primary sel-btn查询/button brbr p地区列表: /p ul class=list-group !-- 示例地区 -- li class=list-group-item东城区/li /ul /div script src=https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js/script script /** * 目标: 根据省份和城市名字, 查询对应的地区列表 */ // 1. 查询按钮-点击事件 document.querySelector(.sel-btn).addEventListener(click, () = // 2. 收集省份和城市名字 const pname = document.querySelector(.province).value const cname = document.querySelector(.city).value // 3. 组织查询参数字符串 const qObj = pname, cname // 查询参数对象 - 查询参数字符串 const paramsObj = new URLSearchParams(qObj) const queryString = paramsObj.toString() console.log(queryString) // 4. 使用XHR对象，查询地区列表 const xhr = new XMLHttpRequest() xhr.open(GET, `http://hmajax.itheima.net/api/area?$queryString`) xhr.addEventListener(loadend, () = console.log(xhr.response) const data = JSON.parse(xhr.response) console.log(data) const htmlStr = data.list.map(areaName = return `li class=list-group-item$areaName/li` ).join() console.log(htmlStr) document.querySelector(.list-group).innerHTML = htmlStr ) xhr.send() ) /script/body/html XMLHttpRequest-数据提交 需求：通过 XHR 完成注册用户功能 步骤和语法 注意1：但是这次没有 axios 帮我们了，我们需要自己设置请求头 Content-Type：applicationjson，来告诉服务器端，我们发过去的内容类型是 JSON 字符串，让他转成对应数据结构取值使用 注意2：没有 axios 了，我们前端要传递的请求体数据，也没人帮我把 JS 对象转成 JSON 字符串了，需要我们自己转换 注意3：原生 XHR 需要在 send 方法调用时，传入请求体携带 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleXMLHttpRequest_数据提交/title/headbody button class=reg-btn注册用户/button script /** * 目标：使用xhr进行数据提交-完成注册功能 */ document.querySelector(.reg-btn).addEventListener(click, () = const xhr = new XMLHttpRequest() xhr.open(POST, http://hmajax.itheima.net/api/register) xhr.addEventListener(loadend, () = console.log(xhr.response) ) // 设置请求头-告诉服务器内容类型（JSON字符串） xhr.setRequestHeader(Content-Type, application/json) // 准备提交的数据 const userObj = username: itheima007, password: 7654321 const userStr = JSON.stringify(userObj) // 设置请求体，发起请求 xhr.send(userStr) ) /script/body/html 2.2 Promise2.2.1 概念 什么是 Promise ？ Promise 对象用于表示一个异步操作的最终完成（或失败）及其结构值 Promise 的好处是什么？ 逻辑更清晰（成功或失败会关联后续的处理函数） 了解 axios 函数内部运作的机制 能解决回调函数地狱问题（后面会讲到），今天先来看下它的基础使用 Promise 管理异步任务，语法怎么用？ // 1. 创建 Promise 对象const p = new Promise((resolve, reject) = // 2. 执行异步任务-并传递结果 // 成功调用: resolve(值) 触发 then() 执行 // 失败调用: reject(值) 触发 catch() 执行)// 3. 接收结果p.then(result = // 成功).catch(error = // 失败) 示例代码： /** * 目标：使用Promise管理异步任务*/// 1. 创建Promise对象const p = new Promise((resolve, reject) = // 2. 执行异步代码 setTimeout(() = // resolve(模拟AJAX请求-成功结果) reject(new Error(模拟AJAX请求-失败结果)) , 2000))// 3. 获取结果p.then(result = console.log(result)).catch(error = console.log(error)) 2.2.2 Promise状态 为什么要了解 Promise 的三种状态 ？ 知道 Promise 对象如何关联的处理函数，以及代码的执行顺序 Promise 有哪三种状态？ 每个 Promise 对象必定处于以下三种状态之一 待定（pending）：初始状态，既没有被兑现，也没有被拒绝 已兑现（fulfilled）：操作成功完成 已拒绝（rejected）：操作失败 状态的英文字符串，可以理解为 Promise 对象内的字符串标识符，用于判断什么时候调用哪一个处理函数 Promise 的状态改变有什么用：调用对应函数，改变 Promise 对象状态后，内部触发对应回调函数传参并执行 注意：每个 Promise 对象一旦被兑现拒绝，那就是已敲定了，状态无法再被改变 2.2.3 使用Promise Promise 和 XHR 都已经学过基础语法了，我们可以来结合使用一下了 需求：使用 Promise 和 XHR 请求省份列表数据并展示到页面上 步骤 创建 Promise 对象 执行 XHR 异步代码，获取省份列表数据 关联成功或失败回调函数，做后续的处理 错误情况：用地址错了404演示 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title案例_使用Promise+XHR_获取省份列表/title/headbody p class=my-p/p script /** * 目标：使用Promise管理XHR请求省份列表 * 1. 创建Promise对象 * 2. 执行XHR异步代码，获取省份列表 * 3. 关联成功或失败函数，做后续处理 */ // 1. 创建Promise对象 const p = new Promise((resolve, reject) = // 2. 执行XHR异步代码，获取省份列表 const xhr = new XMLHttpRequest() xhr.open(GET, http://hmajax.itheima.net/api/province) xhr.addEventListener(loadend, () = // xhr如何判断响应成功还是失败的？ // 2xx开头的都是成功响应状态码 if (xhr.status = 200 xhr.status 300) resolve(JSON.parse(xhr.response)) else reject(new Error(xhr.response)) ) xhr.send() ) // 3. 关联成功或失败函数，做后续处理 p.then(result = console.log(result) document.querySelector(.my-p).innerHTML = result.list.join(br) ).catch(error = // 错误对象要用console.dir详细打印 console.dir(error) // 服务器返回错误提示消息，插入到p标签显示 document.querySelector(.my-p).innerHTML = error.message ) /script/body/html 2.3 封装简易版axios2.3.1 获取地区列表 需求 基于 Promise 和 XHR 封装 myAxios 函数，获取省份列表展示到页面 核心语法 function myAxios(config) return new Promise((resolve, reject) = // XHR 请求 // 调用成功/失败的处理程序 )myAxios( url: 目标资源地址).then(result = ).catch(error = ) 步骤： 定义 myAxios 函数，接收配置对象，返回 Promise 对象 发起 XHR 请求，默认请求方法为 GET 调用成功失败的处理程序 使用 myAxios 函数，获取省份列表展示 核心代码如下： /** * 目标：封装_简易axios函数_获取省份列表 * 1. 定义myAxios函数，接收配置对象，返回Promise对象 * 2. 发起XHR请求，默认请求方法为GET * 3. 调用成功/失败的处理程序 * 4. 使用myAxios函数，获取省份列表展示*/// 1. 定义myAxios函数，接收配置对象，返回Promise对象function myAxios(config) return new Promise((resolve, reject) = // 2. 发起XHR请求，默认请求方法为GET const xhr = new XMLHttpRequest() xhr.open(config.method || GET, config.url) xhr.addEventListener(loadend, () = // 3. 调用成功/失败的处理程序 if (xhr.status = 200 xhr.status 300) resolve(JSON.parse(xhr.response)) else reject(new Error(xhr.response)) ) xhr.send() )// 4. 使用myAxios函数，获取省份列表展示myAxios( url: http://hmajax.itheima.net/api/province).then(result = console.log(result) document.querySelector(.my-p).innerHTML = result.list.join(br)).catch(error = console.log(error) document.querySelector(.my-p).innerHTML = error.message) 2.3.2 注册用户 需求 修改 myAxios 函数支持传递请求体数据，完成注册用户功能 修改步骤 myAxios 函数调用后，判断 data 选项 转换数据类型，在 send 方法中发送 使用自己封装的 myAxios 函数完成注册用户功能 核心代码 function myAxios(config) return new Promise((resolve, reject) = const xhr = new XMLHttpRequest() if (config.params) const paramsObj = new URLSearchParams(config.params) const queryString = paramsObj.toString() config.url += `?$queryString` xhr.open(config.method || GET, config.url) xhr.addEventListener(loadend, () = if (xhr.status = 200 xhr.status 300) resolve(JSON.parse(xhr.response)) else reject(new Error(xhr.response)) ) // 1. 判断有data选项，携带请求体 if (config.data) // 2. 转换数据类型，在send中发送 const jsonStr = JSON.stringify(config.data) xhr.setRequestHeader(Content-Type, application/json) xhr.send(jsonStr) else // 如果没有请求体数据，正常的发起请求 xhr.send() )document.querySelector(.reg-btn).addEventListener(click, () = // 3. 使用myAxios函数，完成注册用户 myAxios( url: http://hmajax.itheima.net/api/register, method: POST, data: username: itheima999, password: 666666 ).then(result = console.log(result) ).catch(error = console.dir(error) )) 3. AJAX进阶3.1 同步代码和异步代码 同步代码：逐行执行，需原地等待结果后，才继续向下执行 异步代码：调用后耗时，不阻塞代码继续执行（不必原地等待），在将来完成后触发回调函数传递结果 回答代码打印顺序：发现异步代码接收结果，使用的都是回调函数 const result = 0 + 1console.log(result)setTimeout(() = console.log(2), 2000)document.querySelector(.btn).addEventListener(click, () = console.log(3))document.body.style.backgroundColor = pinkconsole.log(4) 结果：1， 4， 2 按钮点击一次打印一次 3 3.2 回调函数地狱 需求：展示默认第一个省，第一个城市，第一个地区在下拉菜单中 概念：在回调函数中嵌套回调函数，一直嵌套下去就形成了回调函数地狱 缺点：可读性差，异常无法捕获，耦合性严重，牵一发动全身 axios( url: http://hmajax.itheima.net/api/province ).then(result = const pname = result.data.list[0] document.querySelector(.province).innerHTML = pname // 获取第一个省份默认下属的第一个城市名字 axios( url: http://hmajax.itheima.net/api/city, params: pname ).then(result = const cname = result.data.list[0] document.querySelector(.city).innerHTML = cname // 获取第一个城市默认下属第一个地区名字 axios( url: http://hmajax.itheima.net/api/area, params: pname, cname ).then(result = document.querySelector(.area).innerHTML = result.data.list[0] ) )) 3.3 Promise链式调用 概念：依靠 then() 方法会返回一个新生成的 Promise 对象特性，继续串联下一环任务，直到结束 细节：then() 回调函数中的返回值，会影响新生成的 Promise 对象最终状态和结果 好处：通过链式调用，解决回调函数嵌套问题 按照图解，编写核心代码： /** * 目标：掌握Promise的链式调用 * 需求：把省市的嵌套结构，改成链式调用的线性结构*/// 1. 创建Promise对象-模拟请求省份名字const p = new Promise((resolve, reject) = setTimeout(() = resolve(北京市) , 2000))// 2. 获取省份名字const p2 = p.then(result = console.log(result) // 3. 创建Promise对象-模拟请求城市名字 // return Promise对象最终状态和结果，影响到新的Promise对象 return new Promise((resolve, reject) = setTimeout(() = resolve(result + --- 北京) , 2000) ))// 4. 获取城市名字p2.then(result = console.log(result))// then()原地的结果是一个新的Promise对象console.log(p2 === p) 3.4 Promise-链式调用_解决回调地狱 目标：使用 Promise 链式调用，解决回调函数地狱问题 做法：每个 Promise 对象中管理一个异步任务，用 then 返回 Promise 对象，串联起来 按照图解思路，编写核心代码： /** * 目标：把回调函数嵌套代码，改成Promise链式调用结构 * 需求：获取默认第一个省，第一个市，第一个地区并展示在下拉菜单中*/let pname = // 1. 得到-获取省份Promise对象axios(url: http://hmajax.itheima.net/api/province).then(result = pname = result.data.list[0] document.querySelector(.province).innerHTML = pname // 2. 得到-获取城市Promise对象 return axios(url: http://hmajax.itheima.net/api/city, params: pname )).then(result = const cname = result.data.list[0] document.querySelector(.city).innerHTML = cname // 3. 得到-获取地区Promise对象 return axios(url: http://hmajax.itheima.net/api/area, params: pname, cname )).then(result = console.log(result) const areaName = result.data.list[0] document.querySelector(.area).innerHTML = areaName) 3.5 asyn和await使用 概念：在 async 函数内，使用 await 关键字取代 then 函数，等待获取 Promise 对象成功状态的结果值 做法：使用 async 和 await 解决回调地狱问题 核心代码： /** * 目标：掌握async和await语法，解决回调函数地狱 * 概念：在async函数内，使用await关键字，获取Promise对象成功状态结果值 * 注意：await必须用在async修饰的函数内（await会阻止异步函数内代码继续执行，原地等待结果）*/// 1. 定义async修饰函数async function getData() // 2. await等待Promise对象成功的结果 const pObj = await axios(url: http://hmajax.itheima.net/api/province) const pname = pObj.data.list[0] const cObj = await axios(url: http://hmajax.itheima.net/api/city, params: pname ) const cname = cObj.data.list[0] const aObj = await axios(url: http://hmajax.itheima.net/api/area, params: pname, cname ) const areaName = aObj.data.list[0] document.querySelector(.province).innerHTML = pname document.querySelector(.city).innerHTML = cname document.querySelector(.area).innerHTML = areaNamegetData() 使用 await 替代 then 的方法 3.6 async 函数和 await 捕获错误 try 和 catch 的作用：语句标记要尝试的语句块，并指定一个出现异常时抛出的响应 try // 要执行的代码 catch (error) // error 接收的是，错误消息 // try 里代码，如果有错误，直接进入这里执行 try 里有报错的代码，会立刻跳转到 catch 中 尝试把代码中 url 地址写错，运行观察 try catch 的捕获错误信息能力 /** * 目标：async和await_错误捕获*/async function getData() // 1. try包裹可能产生错误的代码 try const pObj = await axios( url: http://hmajax.itheima.net/api/province ) const pname = pObj.data.list[0] const cObj = await axios( url: http://hmajax.itheima.net/api/city, params: pname ) const cname = cObj.data.list[0] const aObj = await axios( url: http://hmajax.itheima.net/api/area, params: pname, cname ) const areaName = aObj.data.list[0] document.querySelector(.province).innerHTML = pname document.querySelector(.city).innerHTML = cname document.querySelector(.area).innerHTML = areaName catch (error) // 2. 接着调用catch块，接收错误信息 // 如果try里某行代码报错后，try中剩余的代码不会执行了 console.dir(error) getData() 3.7 事件循环-EventLoop 事件循环（EventLoop）：掌握后知道 JS 是如何安排和运行代码的 请回答下面 2 段代码打印的结果，并说明原因 console.log(1)setTimeout(() = console.log(2), 2000) console.log(1)setTimeout(() = console.log(2), 0)console.log(3) 作用：事件循环负责执行代码，收集和处理事件以及执行队列中的子任务 原因：JavaScript 单线程（某一刻只能执行一行代码），为了让耗时代码不阻塞其他代码运行，设计了事件循环模型 概念：执行代码和收集异步任务的模型，在调用栈空闲，反复调用任务队列里回调函数的执行机制，就叫事件循环 /** * 目标：阅读并回答执行的顺序结果*/console.log(1)setTimeout(() = console.log(2), 0)console.log(3)setTimeout(() = console.log(4), 2000)console.log(5) 具体运行过程，请参考 PPT 动画和视频讲解 3.8 宏任务与微任务 ES6 之后引入了 Promise 对象， 让 JS 引擎也可以发起异步任务 异步任务划分为了 宏任务：由浏览器环境执行的异步代码 微任务：由 JS 引擎环境执行的异步代码 宏任务和微任务具体划分： 事件循环模型 具体运行效果，参考 PPT 动画或者视频 /** * 目标：阅读并回答打印的执行顺序*/console.log(1)setTimeout(() = console.log(2), 0)const p = new Promise((resolve, reject) = resolve(3))p.then(res = console.log(res))console.log(4) 注意：宏任务每次在执行同步代码时，产生微任务队列，清空微任务队列任务后，微任务队列空间释放！ 下一次宏任务执行时，遇到微任务代码，才会再次申请微任务队列空间放入回调函数消息排队 总结：一个宏任务包含微任务队列，他们之间是包含关系，不是并列关系 3.9 Promise.all静态方法 概念：合并多个 Promise 对象，等待所有同时成功完成（或某一个失败），做后续逻辑 语法： const p = Promise.all([Promise对象, Promise对象, ...])p.then(result = // result 结果: [Promise对象成功结果, Promise对象成功结果, ...]).catch(error = // 第一个失败的 Promise 对象，抛出的异常对象) 需求：同时请求“北京”，“上海”，“广州”，“深圳”的天气并在网页尽可能同时显示 核心代码如下： !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titlePromise的all方法/title/headbody ul class=my-ul/ul script src=https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js/script script /** * 目标：掌握Promise的all方法作用，和使用场景 * 业务：当我需要同一时间显示多个请求的结果时，就要把多请求合并 * 例如：默认显示北京, 上海, 广州, 深圳的天气在首页查看 * code： * 北京-110100 * 上海-310100 * 广州-440100 * 深圳-440300 */ // 1. 请求城市天气，得到Promise对象 const bjPromise = axios( url: http://hmajax.itheima.net/api/weather, params: city: 110100 ) const shPromise = axios( url: http://hmajax.itheima.net/api/weather, params: city: 310100 ) const gzPromise = axios( url: http://hmajax.itheima.net/api/weather, params: city: 440100 ) const szPromise = axios( url: http://hmajax.itheima.net/api/weather, params: city: 440300 ) // 2. 使用Promise.all，合并多个Promise对象 const p = Promise.all([bjPromise, shPromise, gzPromise, szPromise]) p.then(result = // 注意：结果数组顺序和合并时顺序是一致 console.log(result) const htmlStr = result.map(item = return `li$item.data.data.area --- $item.data.data.weather/li` ).join() document.querySelector(.my-ul).innerHTML = htmlStr ).catch(error = console.dir(error) ) /script/body/html 合并多个 Promise 对象并等待所有同时成功的结果，如果有一个报错就会最终为失败状态，当需要同时渲染多个接口数据同时到网页上时使用 3.10 案例-商品分类 需求：尽可能同时展示所有商品分类到页面上 步骤 获取所有的一级分类数据 遍历id，创建获取二级分类请求 合并所有二级分类Promise对象 等待同时成功，开始渲染页面 核心代码 /** * 目标：把所有商品分类“同时”渲染到页面上 * 1. 获取所有一级分类数据 * 2. 遍历id，创建获取二级分类请求 * 3. 合并所有二级分类Promise对象 * 4. 等待同时成功后，渲染页面*/// 1. 获取所有一级分类数据axios( url: http://hmajax.itheima.net/api/category/top).then(result = console.log(result) // 2. 遍历id，创建获取二级分类请求 const secPromiseList = result.data.data.map(item = return axios( url: http://hmajax.itheima.net/api/category/sub, params: id: item.id // 一级分类id ) ) console.log(secPromiseList) // [二级分类请求Promise对象，二级分类请求Promise对象，...] // 3. 合并所有二级分类Promise对象 const p = Promise.all(secPromiseList) p.then(result = console.log(result) // 4. 等待同时成功后，渲染页面 const htmlStr = result.map(item = const dataObj = item.data.data // 取出关键数据对象 return `div class=item h3$dataObj.name/h3 ul $dataObj.children.map(item = return `li a href=javascript:; img src=$item.picture p$item.name/p /a /li` ).join() /ul /div` ).join() console.log(htmlStr) document.querySelector(.sub-list).innerHTML = htmlStr ))","tags":["AJAX","AXIOS","XMLHTTPRequest","Promise","async","await"],"categories":["前端"]},{"title":"JavaScript进阶","path":"/2023/12/08/2023-12-08-JavaScrpit进阶/","content":"1. 作用域1.1 作用域 作用 规定了变量能够被访问的范围，离开了这个范围变量便不能被访问 分类 局部作用域 全局作用域 局部作用域 局部作用域分为函数作用域和块作用域 函数作用域 在函数内部声明的变量只能在函数内部被访问，外部无法直接访问 script function getSum() // 函数内部是函数作用域 属于局部变量 const num = 10 console.log(num); // 此处报错 函数外部不能使用局部作用域变量/script 总结： 函数内部声明的变量，在函数外部无法被访问 函数的参数也是函数内部的局部变量 同函数内部声明的变量无法互相访问 函数执行完毕后，函数内部的变量实际被清空了 块作用域 在 JavaScript 中使用 { } 包裹的代码称为代码块，代码块内部声明的变量外部将【有可能】无法被访问。 script for (let i = 1; i = 6; i++) console.log(i); // 访问正常 console.log(i); // 报错，超出i的作用域/script 总结： let 声明的变量会产生块作用域，var 不会产生块作用域 const 声明的常量也会产生块作用域 不同代码块之间的变量无法互相访问 推荐使用 let 或 const 全局作用域 全局作用域中声明的变量，任何其它作用域都可以被访问 script // 全局作用域 // 全局作用域下声明了 num 变量 const num = 10 function fn() // 函数内部可以使用全局作用域的变量 console.log(num); // 全局作用域/script 注意： 为 window 对象动态添加的属性默认也是全局的，不推荐！ 函数中未使用任何关键字声明的变量为全局变量，不推荐！！！ 尽可能少的声明全局变量，防止全局变量被污染 1.2 作用域链 作用 作用域链本质上是底层的变量查找机制 在函数被执行时，会优先查找当前函数作用域中查找变量 如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域 总结 嵌套关系的作用域串联起来形成了作用域链 相同作用域链中按着从小到大的规则查找变量 子作用域能够访问父作用域，父级作用域无法访问子级作用域 1.3 JS垃圾回收机制 概念 垃圾回收机制(Garbage Collection) 简称 GC JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题 但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况 不再用到的内存，没有及时释放，就叫做内存泄漏 内存生命周期 JS环境中分配的内存, 一般有如下生命周期 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存 内存使用：即读写内存，也就是使用变量、函数等 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存 说明 全局变量一般不会回收(关闭页面回收)； 一般情况下局部变量的值, 不用了, 会被自动回收掉 1.4 闭包 概念 一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域 简单理解：闭包 内层函数 + 外层函数的变量 作用 闭包作用：封闭数据，提供操作，外部也可以访问函数内部的变量 闭包的基本格式： 为什么要闭包 闭包应用：实现数据的私有 比如，我们要做个统计函数调用次数，函数调用一次，就++ 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script // 简单的写法 function outer() let a = 10 function fn() console.log(a) fn() outer() // 常见的闭包的形式 外部可以访问使用 函数内部的变量 function outer() let a = 100 function fn() console.log(a) return fn // outer() === fn === function fn() // const fun = function fn() // // 常见的写法2 function outer2() let a = 100 return function () console.log(a) const fun2 = outer2() fun2() // 调用函数 // 外面要使用这个 10 // 闭包的应用 // 普通形式 统计函数调用的次数 // let i = 0 // function fn() // i++ // console.log(`函数被调用了$i次`) // // 因为 i 是全局变量，容易被修改 // 闭包形式 统计函数调用的次数 function count() let i = 0 function fn() i++ console.log(`函数被调用了$i次`) return fn const fun3 = count() /script/body/html 1.5 变量提升 概念 变量提升是 JavaScript 中比较奇怪的现象，它允许在变量声明之前即被访问（仅存在于var声明变量） 注意 变量在未声明即被访问时会报语法错误 变量在var声明之前即被访问，变量的值为 undefined letconst 声明的变量不存在变量提升 变量提升出现在相同作用域当中 实际开发中推荐先声明再访问变量 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script // 1. 把所有var声明的变量提升到 当前作用域的最前面 // 2. 只提升声明， 不提升赋值 // var num // console.log(num + 件) // num = 10 // console.log(num) function fn() console.log(num) var num = 10 fn() /script/body/html 2. 函数进阶2.1 函数提升 概念 函数提升与变量提升比较类似，是指函数在声明之前即可被调用 总结 函数提升能够使函数的声明调用更灵活 函数表达式不存在提升的现象 函数提升出现在相同作用域当中 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script var fun // 1. 会把所有函数声明提升到当前作用域的最前面 // 2. 只提升函数声明，不提升函数调用 // fn() // function fn() // console.log(函数提升) // // fun() // var fun = function () // console.log(函数表达式) // // 函数表达式 必须先声明和赋值， 后调用 否则 报错 /script/body/html 2.2 函数参数 作用 提升函数应用的灵活度 动态参数 arguments 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参。 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script function getSum() // arguments 动态参数 只存在于 函数里面 // 是伪数组 里面存储的是传递过来的实参 // console.log(arguments) [2,3,4] let sum = 0 for (let i = 0; i arguments.length; i++) sum += arguments[i] console.log(sum) getSum(2, 3, 4) getSum(1, 2, 3, 4, 2, 2, 3, 4) /script/body/html 总结： arguments 是一个伪数组，只存在于函数中 arguments 的作用是动态获取函数的实参 可以通过for循环依次得到传递过来的实参 剩余参数 剩余参数允许我们将一个不定数量的参数表示为一个数组 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script function getSum(a, b, ...arr) console.log(arr) // 使用的时候不需要写 ... getSum(2, 3) getSum(1, 2, 3, 4, 5) /script/body/html 区别 ... 是语法符号，置于最末函数形参之前，用于获取多余的实参 借助 ... 获取的剩余实参，是个真数组 开发中，还是提倡多使用 剩余参数 2.3 展开运算符 作用 展开运算符 … ,将一个数组进行展开。且不会修改原数组 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script const arr1 = [1, 2, 3] // 展开运算符 可以展开数组 // console.log(...arr) // console.log(Math.max(1, 2, 3)) // ...arr1 === 1,2,3 // 1 求数组最大值 console.log(Math.max(...arr1)) // 3 console.log(Math.min(...arr1)) // 1 // 2. 合并数组 const arr2 = [3, 4, 5] const arr = [...arr1, ...arr2] console.log(arr) /script/body/html 2.4 箭头函数(重要) 作用 更简短的函数写法并且不绑定this，箭头函数的语法比函数表达式更简洁 使用场景 箭头函数更适用于那些本来需要匿名函数的地方 语法 语法1：基本写法 const fn = function() console.log(普通函数)fn()const fn = () = console.log(箭头函数)fn() 语法2：只有一个参数可以省略小括号 const fn = function(x) return x + xconsole.log(fn(1)) // 2const fn = x = return x + xconsole.log(fn(1)) // 2 语法3：如果函数体只有一行代码，可以写到一行上，并且无需写 return 直接返回值 const fn = function(x, y) return x + yconsole.log(fn(1, 2)) // 3const fn = (x, y) = x + yconsole.log(fn(1, 2)) // 3 语法4：加括号的函数体返回对象字面量表达式 const fn = uname = ( uname: uname )console.log(fn(pink老师)) // uname: pink老师 箭头函数参数 普通函数有arguments 动态参数 箭头函数没有 arguments 动态参数，但是有 剩余参数 ...args script const getSum = (...args) = let sum = 0 for (let i = 0; i args.length; i++) sum += args[i] return sum console.log(getSum(1, 2, 3));/script 箭头函数this 在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的this值， 非常令人讨厌 箭头函数不会创建自己的this,，只会从自己的作用域链的上一层沿用this !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script // 以前this的指向： 谁调用的这个函数，this 就指向谁 console.log(this) // window // 普通函数 function fn() console.log(this) // window window.fn() // 对象方法里面的this const obj1 = name: andy, sayHi: function () console.log(this) // obj obj1.sayHi() // 2. 箭头函数的this 是上一层作用域的this 指向 const fn2 = () = console.log(this) // window fn2() // 对象方法箭头函数 this const obj2 = uname: pink老师, sayHi: () = console.log(this) // this 指向谁？ window obj2.sayHi() const obj3 = uname: pink老师, sayHi: function () console.log(this) // obj let i = 10 const count = () = console.log(this) // obj count() obj3.sayHi() /script/body/html 在开发中【使用箭头函数前需要考虑函数中 this 的值】，事件回调函数使用箭头函数时，this 为全局的 window，因此DOM事件回调函数为了简便，还是不太推荐使用箭头函数 2.5 解构赋值 概念 解构赋值是一种快速为变量赋值的简洁语法，本质上仍然是为变量赋值 数组结构 数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法 赋值运算符 左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量。 变量的顺序对应数组单元值的位置依次进行赋值操作 。 典型应用交互2个变量 let a = 1let b = 3; ;[b, a] = [a, b] // 注意：这里必须要有分号 需求：有个数组： const pc [‘海尔’, ‘联想’, ‘小米’, ‘方正’]，解构为变量: hr lx mi fz script // const arr = [100, 60, 80] // 数组解构 赋值 // // const [max, min, avg] = arr const [max, min, avg] = [100, 60, 80] // // const max = arr[0] // // const min = arr[1] // // const avg = arr[2] console.log(max) // 100 console.log(avg) // 80 // 交换2个变量的值 let a = 1 let b = 2; [b, a] = [a, b] console.log(a, b)/script需求2：请将最大值和最小值函数返回值解构 max 和min 两个变量 变量多 单元值少的情况： const [a, b, c, d] = [1, 2, 3]console.log(a) // 1console.log(b) // 2console.log(c) // 3console.log(d) // undefined 变量的数量大于单元值数量时，多余的变量将被赋值为 undefined 变量少 单元值多的情况： const [a, b] = [1, 2, 3]console.log(a) // 1console.log(b) // 2 利用剩余参数解决变量少 单元值多的情况： const [a, b, ...c] = [1, 2, 3, 4]console.log(a) // 1console.log(b) // 2console.log(c) // [3, 4] 真数组 剩余参数返回的还是一个数组 防止有undefined传递单元值的情况，可以设置默认值： const [a = 0, b = 0] = [1, 2] // a=1, b=2const [a = 0, b = 0] = [] // a=0, b=0 允许初始化变量的默认值，且只有单元值为 undefined 时默认值才会生效 按需导入，忽略某些返回值： const [a, b, , d] = [1, 2, 3, 4]console.log(a) // 1console.log(b) // 2console.log(d) // 4 支持多维数组的结构： const arr = [1, 2, [3, 4]]console.log(arr[0]) // 1console.log(arr[1]) // 2console.log(arr[2]) // [3,4]console.log(arr[2][0]) // 3// 多维数组解构const arr = [1, 2, [3, 4]]const [a, b, c] = [1, 2, [3, 4]]console.log(a) // 1console.log(b) // 2console.log(c) // [3,4]// 多维数组解构const [a, b, [c, d]] = [1, 2, [3, 4]]console.log(a) // 1console.log(b) // 2console.log(c) // 3console.log(d) // 4 对象结构 对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法 赋值运算符 左侧的 {} 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量 对象属性的值将被赋值给与属性名相同的变量 注意解构的变量名不要和外面的变量名冲突否则报错 对象中找不到与变量名一致的属性时变量值为 undefined const user = name: 小明, age: 18const name, age = userconsole.log(name) // 小明console.log(age) // 18 给新的变量名赋值： 可以从一个对象中提取变量并同时修改新的变量名 const user = name: 小明, age: 18// 把原来的 name 变量重命名为 unameconst name: uname, age = userconsole.log(uname) // 小明console.log(age) // 18 冒号表示“什么值：赋值给谁” 数组对象解构 const user = [ name: 小明, age: 18 ]// 把原来的 name 变量重命名为 unameconst [ name, age ] = userconsole.log(name) // 小明console.log(age) // 18 多级对象解构： const person = [ name: 佩奇, family: mother: 猪妈妈, father: 猪爸爸, sister: 乔治 , age: 6 ]const [ name, family: mother, father, sister ] = personconsole.log(name)console.log(mother)console.log(father)console.log(sister) script // 1. 这是后台传递过来的数据 const msg = code: 200, msg: 获取新闻列表成功, data: [ id: 1, title: 5G商用自己，三大运用商收入下降, count: 58 , id: 2, title: 国际媒体头条速览, count: 56 , id: 3, title: 乌克兰和俄罗斯持续冲突, count: 1669 , ] // 需求1： 请将以上msg对象 采用对象解构的方式 只选出 data 方面后面使用渲染页面 // const data = msg // console.log(data) // 需求2： 上面msg是后台传递过来的数据，我们需要把data选出当做参数传递给 函数 // const data = msg // msg 虽然很多属性，但是我们利用解构只要 data值 function render( data ) // const data = arr // 我们只要 data 数据 // 内部处理 console.log(data) render(msg) // 需求3， 为了防止msg里面的data名字混淆，要求渲染函数里面的数据名改为 myData function render( data: myData ) // 要求将 获取过来的 data数据 更名为 myData // 内部处理 console.log(myData) render(msg) /script 2.6 构造函数2.6.1 创建对象的三种方式 利用对象字面量创建对象 const o = name: 佩奇 利用 new Object 创建对象 const o = new Object(name:佩奇)console.log(o) 利用构造函数创建对象 构造函数 ：是一种特殊的函数，主要用来初始化对象 使用场景 常规的 {…} 语法允许创建一个对象。比如我们创建了佩奇的对象，继续创建乔治的对象还需要重新写一遍，此时可以通过构造函数来快速创建多个类似的对象 const Pepa = name: 佩奇, age: 6, gender: 女const George name: 乔治, age: 3, gender: 男const Mum = name: 猪妈妈, age: 30, gender: 女const Dab = name: 猪爸爸, age: 32, gender: 男//----------------------------------function Pig(name, age, gender) this.name = name this.age = age this.gender = genderconst Peppa = new Pig(佩奇, 6, 女)const George = new Pig(乔治, 3, 男)const Mum = new Pig(猪妈妈, 30, 女)const Dad = new Pig(猪爸爸, 32, 男) 构造函数在技术上是常规函数。不过有两个约定： 它们的命名以大写字母开头。 它们只能由 “new” 操作符来执行。 2.6.2 构造函数 语法 大写字母开头的函数 // 1.创建构造函数function Pig(name) this.name = name// 2.new 关键字调用函数new Pig(佩奇)// 3.接收创建的对象const peppa = new Pig(佩奇)console.log(peppa) // name: 佩奇 说明 使用 new 关键字调用函数的行为被称为实例化 实例化构造函数时没有参数时可以省略 () 构造函数内部无需写return，返回值即为新创建的对象 构造函数内部的 return 返回的值无效，所以不要写return new Object（） new Date（） 也是实例化构造函数 示例 需求：①：写一个Goods构造函数②：里面包含属性 name 商品名称 price 价格 count 库存数量③：实例化多个商品对象，并打印到控制台，例如小米 1999 20 华为 3999 59 vivo 1888 100htmlbody script function Goods(name, price, count) this.name = name this.price = price this.count = count this.sayhi = function () const mi = new Goods(小米, 1999, 20) console.log(mi) const hw = new Goods(华为, 3999, 59) console.log(hw) console.log(mi === hw) mi.name = vivo console.log(mi) console.log(hw) // const date = new Date(2022-4-8) // console.log(date) // 静态成员 Goods.num = 10 console.log(Goods.num) Goods.sayhi = function () /script/body/html 实例化执行过程 创建新对象 构造函数this指向新对象 执行构造函数代码，修改this，添加新的属性 返回新对象 2.6.3 实例成员 概念 通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员 说明 实例对象的属性和方法即为实例成员 为构造函数传入参数，动态创建结构相同但值不同的对象 构造函数创建的实例对象彼此独立互不影响 示例 function Person() // 构造函数内部的 this 就是实例对象 // 实例对象中动态添加属性 this.name = 小明 // 实例对象中动态添加方法 this.sayHi = function() console.log(大家好~) // 实例化， p1是实例对象const p1 = new Person()console.log(p1)console.log(p1.name) // 访问实例属性p1.sayHi() // 调用实例方法 2.6.4 静态成员 概念 构造函数的属性和方法被称为静态成员 说明 构造函数的属性和方法被称为静态成员 一般公共特征的属性或方法静态成员设置为静态成员 静态成员方法中的 this 指向构造函数本身 示例 function Person(name, age) // 省略实例成员// 静态属性Person.eyes = 2Person.arms = 2// 静态方法Person.walk = function() console.log(人人都会走路) // this 指向 Person console.log(this.eyes) 2.6.5 内置构造函数 在 JavaScript 中最主要的数据类型有 6 种 基本数据类型： 字符串、数值、布尔、undefined、null 引用类型: 对象 但是，我们会发现有些特殊情况 // 普通字符串const str = andyconsole.log(str.length) 其实字符串、数值、布尔、等基本类型也都有专门的构造函数，这些我们称为包装类型 JS中几乎所有的数据都可以基于构造函数创建 引用类型：Object，Array，RegExp，Date 等 包装类型：String，Number，Boolean 等 Object Object 是内置的构造函数，用于创建普通对象。 // 通过构造函数创建普通对象const user = new Object(name: 小明, age: 15)// 字面量方式创建普通对象const user = name: 小明, age: 15 推荐使用字面量方式声明对象，而不是 Object 构造函数 学习三个常用静态方法（静态方法就是只有构造函数Object可以调用的）。 // 想要获得对象里面的属性和值怎么做？const o = name: 小明, age: 15for (let k in o) console.log(k) // 属性 name age console.log(o[k]) // 值 小明 15 Object.keys 作用：Object.keys 静态方法获取对象中所有属性（键） 语法： const o = name: 小明, age: 15// 获取对象的所有键，并且返回的是一个数组const arr = Object.keys(o)console.log(arr) // [name, age] 注意：返回的是一个数组 Object.values 作用：Object.values 静态方法获取对象中所有属性值 语法： const o = name: 小明, age: 15// 获取对象的所有键，并且返回的是一个数组const arr = Object.values(o)console.log(arr) // [小明, 15] 注意： 返回的是一个数组 Object. assign 作用：Object. assign 静态方法常用于对象拷贝，经常使用的场景给对象添加属性 语法： // 拷贝对象 把 0 拷贝给 objconst o = name: 佩奇, age: 6const obj = Object.assign(obj, o)console.log(obj) // name: 佩奇, age: 6Object.assign(o, gender: 女)console.log(o) // name: 佩奇, age: 6, gender: 女 Array 数组常见实例方法-核心方法 方法 作用 说明 forEach 遍历数组 不返回，用于不改变值，经常用于查找打印输出值 filter 过滤数组 筛选数组元素，并生成新数组 map 迭代数组 返回新数组，新数组里面的元素处理之后的值，经常用于处理数据 reduce 累计器 返回函数累计处理的结果，经常用于求和等 reduce 作用：reduce 返回函数累计处理的结果，经常用于求和等 基本语法： arr.reduce(function(), 起始值) 参数： 起始值可以省略，如果写就作为第一次累计的起始值 语法： arr.reduce(function(累计值, 当前元素 [,索引号][,源数组]), 起始值) 累计值参数： 如果有起始值，则以起始值为准开始累计， 累计值 起始值 如果没有起始值， 则累计值以数组的第一个数组元素作为起始值开始累计 后面每次遍历就会用后面的数组元素 累计到 累计值 里面 （类似求和里面的 sum ） 使用场景：求和运算 const arr = [1, 5, 9]const count = arr.reduce((prev, item) = prev + item)console.log(count) 练习 需求：①：给员工每人涨薪 30%②：然后计算需要支出的费用数据：const arr = [ name: 张三, salary: 10000, name: 李四, salary: 10000, name: 王五, salary: 10000,]const total = arr.reduce((prev, item) = prev += item.salary * 0.3, 0) 数组常见方法- 伪数组转换为真数组 静态方法 Array.from() 其它方法 String 在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法 之所以具有对象特征的原因是字符串、数值、布尔类型数据是 JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script //1. split 把字符串 转换为 数组 和 join() 相反 // const str = pink,red // const arr = str.split(,) // console.log(arr) // const str1 = 2022-4-8 // const arr1 = str1.split(-) // console.log(arr1) // 2. 字符串的截取 substring(开始的索引号[， 结束的索引号]) // 2.1 如果省略 结束的索引号，默认取到最后 // 2.2 结束的索引号不包含想要截取的部分 // const str = 今天又要做核酸了 // console.log(str.substring(5, 7)) // 3. startsWith 判断是不是以某个字符开头 // const str = pink老师上课中 // console.log(str.startsWith(pink)) // 4. includes 判断某个字符是不是包含在一个字符串里面 const str = 我是pink老师 console.log(str.includes(pink)) // true /script/body/html 常见实例方法和属性 实例属性length用来获取字符串的长度（重点） 实例方法split(分隔符)用来将字符串拆分成数组（重点） 实例方法substring(需要截取的第一个字符的索引[,结束的索引号])用于字符串截取（重点） 实例方法startWith(检测字符串[,检测位置索引号])检测是否以某字符开头（重点） 实例方法includes(搜索的字符串[,检测位置索引号])判断一个字符串是否包含在另一个字符串中，根据情况返回true或者false（重点） 实例方法toUpperCase用于字母转换成大写 实例方法toLowerCase用于字母转换成小写 实例方法indexOf检测是否包含某字符 实例方法endsWith检测是否以某字符结尾 实例方法replace用于替换字符串，支持正则匹配 实例方法math用于查找字符串，支持正则匹配 Number Number 是内置的构造函数，用于创建数值 常用方法：toFixed() 设置保留小数位的长度 const price = 12.345// 四舍五入console.log(price.toFixed(2)) // 12.35 3. 深入对象3.1 编程思想 面向过程 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了 举个栗子：蛋炒饭 面向过程，就是按照我们分析好了的步骤，按照步骤解决问题 面向对象 面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作 举个栗子：盖浇饭 面向对象是以对象功能来划分问题，而不是步骤 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。 面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目 面向对象的特性： 封装性 继承性 多态性 对比 面向过程编程 优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程程。 缺点：没有面向对象易维护、易复用、易扩展 面向对象编程 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 缺点：性能比面向过程低 3.2 构造函数 封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装 同样的将变量和函数组合到了一起并能通过 this 实现数据的共享，所不同的是借助构造函数创建出来的实例对象之间是彼此不影响的 总结 构造函数体现了面向对象的封装特性 构造函数实例创建的对象彼此独立、互不影响 封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装 前面我们学过的构造函数方法很好用，但是 存在浪费内存的问题 function Star(uname, age) this.uname = uname this.age = age this.sing = function() console.log(我会唱歌) const ldh = new Star(刘德华, 18)const zxy = new Star(张学友, 19)console.log(ldh.sing === zxy.sing) // false, 说明俩函数不一样 我们希望所有的对象使用同一个函数，这样就比较节省内存，那么我们要怎样做呢？ 3.3 原型 作用 构造函数通过原型分配的函数是所有对象所 共享的 JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，所以我们也称为原型对象 这个对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存 我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法 构造函数和原型对象中的this 都指向 实例化的对象 示例 function Star(uname, age) this.uname = uname this.age = age console.log(Start.prototype) // 返回一个对象的原型对象Start.prototype.sing = function() console.log(我会唱歌)const ldh = new Star(刘德华, 18)const zxy = new Star(张学友, 19)console.log(ldh.sing === zxy.sing) // true, 说明俩函数一样 3.4 constructor 属性 概念 在哪里？ 每个原型对象里面都有个constructor 属性（constructor 构造函数） 作用 该属性指向该原型对象的构造函数， 简单理解，就是指向我的爸爸 使用场景 如果有多个对象的方法，我们可以给原型对象采取对象形式赋值。 但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了。 此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。 示例 function Star(name) this.name = nameStart.prototype = sing: function() console.log(唱歌) dance: function() console.log(跳舞)console.log(Start.prototype.constructor) // 指向 Object======================================== function Start(name) this.name = nameStart.prototype = // 手动利用 constructor 指回 Start构造函数 constructor: Start, sing: function() console.log(唱歌) dance: function() console.log(跳舞)console.log(Start.prototype.constructor) // 指向 Start 3.5 对象原型 概念 对象都会有一个属性 __proto__ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __proto__ 原型的存在 注意 __proto__ 是JS非标准属性 [[prototype]]和__proto__意义相同 用来表明当前实例对象指向哪个原型对象prototype __proto__对象原型里面也有一个 constructor属性，指向创建该实例对象的构造函数 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script function Star() const ldh = new Star() // 对象原型__proto__ 指向 改构造函数的原型对象 console.log(ldh.__proto__) // console.log(ldh.__proto__ === Star.prototype) // 对象原型里面有constructor 指向 构造函数 Star console.log(ldh.__proto__.constructor === Star) /script/body/html 3.6 原型继承 作用 继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承的特性 示例 原始代码 function Man() this.head = 1 this.eyes = 2 this.legs = 2 this.say = function() this.eat = function() const pink = new Man()function Woman() this.head = 1 this.eyes = 2 this.legs = 2 this.say = function() this.eat = function() this.baby = function() const red = new Woman() 封装-抽取公共部分 // 把男人和女人公共的部分抽取出来放到人类里面// 人类const People = head: 1, eyes: 2, legs: 2, say: function(), eat: function()// 男人function Man()// 女人function Woman() this.baby = function() 继承-让男人和女人都能继承人类的一些属性和方法 把男人女人公共的属性和方法抽取出来 People 然后赋值给Man的原型对象，可以共享这些属性和方法 注意让constructor指回Man这个构造函数 // 人类const People = head: 1, eyes: 2, legs: 2, say: function(), eat: function()// 男人function Man()// 把公共的属性和方法给原型，这样就可以共享了Man.prototype = People// 注意让原型里面的constructor重新指回Man找自己的爸爸Man.prototype.constructor = Manconst pink = new Man()console.log(pink) 问题 如果我们给男人添加了一个吸烟的方法，发现女人自动也添加这个方法 Man.prototype = People// 注意让原型里面的constructor重新指回Man找自己的爸爸Man.prototype.constructor = Manconst pink = new Man()Man.prototype.smoking = function() console.log(pink)// 女人function Woman() this.baby = function()// 把公共的属性和方法给原型，这样就可以共享了Woman.prototype = People// 注意让原型里面的constructor重新指回Woman找自己的爸爸Woman.prototype.constructor = Womanconst red = new Woman()console.log(red) 问题–原因 男人和女人都同时使用了同一个对象，根据引用类型的特点，他们指向同一个对象，修改一个就会都影响 解决 需求：男人和女人不要使用同一个对象，但是不同对象里面包含相同的属性和方法 答案：构造函数 new 每次都会创建一个新的对象 function Star(uname, age) this.uname = uname this.age = age this.sing = function() console.log(我会唱歌) const ldh = new Star(刘德华, 18)const zxy = new Star(张学友, 19)console.log(ldh.sing === zxy.sing) // false, 说明俩函数不一样 继承写法完善 // 人类function Person = head: 1, eyes: 2, legs: 2, say: function(), eat: function()// 男人function Man()// 把公共的属性和方法给原型，这样就可以共享了Man.prototype = new Person()// 注意让原型里面的constructor重新指回Man找自己的爸爸Man.prototype.constructor = Manconst pink = new Man()Man.prototype.smoking = function() console.log(pink)// 女人function Woman() this.baby = function()// 把公共的属性和方法给原型，这样就可以共享了Woman.prototype = new Person()// 注意让原型里面的constructor重新指回Woman找自己的爸爸Woman.prototype.constructor = Womanconst red = new Woman()console.log(red) 思路 真正做这个案例，我们的思路应该是先考虑大的，后考虑小的 人类共有的属性和方法有哪些，然后做个构造函数，进行封装，一般公共属性写到构造函数内部，公共方法，挂载到构造函数原型身上 男人继承人类的属性和方法，之后创建自己独有的属性和方法 女人同理 3.7 原型链 概念 基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对象的链状结构关系称为原型链 查找规则 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。 如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象） 如果还没有就查找原型对象的原型（Object的原型对象） 依此类推一直找到 Object 为止（null） __proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线 可以使用 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script // function Objetc() console.log(Object.prototype) console.log(Object.prototype.__proto__) function Person() const ldh = new Person() // console.log(ldh.__proto__ === Person.prototype) // console.log(Person.prototype.__proto__ === Object.prototype) console.log(ldh instanceof Person) console.log(ldh instanceof Object) console.log(ldh instanceof Array) console.log([1, 2, 3] instanceof Array) console.log(Array instanceof Object) /script/body/html 4. 高级技巧4.1 深浅拷贝 问题 开发中我们经常需要复制一个对象。如果直接用赋值会有下面问题 const pink = name: pink老师, age: 18const red = pinkconsole.log(red) // name: pink老师, age: 18red.name = redconsole.log(red) // name: red, age: 18// pink对象里的name值也发生了变化console.log(pink) // name: red, age: 18 浅拷贝 首先浅拷贝和深拷贝只针对引用类型 浅拷贝：拷贝的是地址 常见方法： 拷贝对象：Object.assgin() 展开运算符 {…obj} 拷贝对象 拷贝数组：Array.prototype.concat() 或者 […arr] const obj = uname: pinkconst o = ...obj console.log(o) // uname: pinko.uname = redconsole.log(o) // uname: redconsole.log(obj) // uname: pinkconst pink = name: pink老师, age: 18const red = Object.assign(red, pink)console.log(red) // name: pink老师, age: 18red.name = redconsole.log(red) // name: red, age: 18// 不会影响pinkconsole.log(pink) // name: pink老师, age: 18// 如果是简单数据类型拷贝值，引用数据类型拷贝的是地址 (简单理解： 如果是单层对象，没问题，如果有多层就有问题)const pink = name: pink老师, age: 18, family: mother: pink妈妈 const red = Object.assign(red, pink)console.log(red) // name: pink老师, age: 18, family: mother: pink妈妈red.name = redred.family.mother = red妈妈console.log(red) // name: pink老师, age: 18, family: mother: red妈妈console.log(pink) // name: pink老师, age: 18, family: mother: red妈妈 直接赋值和浅拷贝有什么区别？ 直接赋值的方法，只要是对象，都会相互影响，因为是直接拷贝对象栈里面的地址 浅拷贝如果是一层对象，不相互影响，如果出现多层对象拷贝还会相互影响 浅拷贝怎么理解？ 拷贝对象之后，里面的属性值是简单数据类型直接拷贝值 如果属性值是引用数据类型则拷贝的是地址 深拷贝 常见方法： 通过递归实现深拷贝 lodashcloneDeep 通过JSON.stringify()实现 函数递归： 如果一个函数在内部可以调用其本身，那么这个函数就是递归函数 简单理解:函数内部自己调用自己, 这个函数就是递归函数 递归函数的作用和循环效果类似 由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件 return const o = function deepCopy(newObj, oldObj) for (let k in oldObj) if (oldObj[k] instanceof Array) newObj[k] = [] deepCopy(newObj[k], oldObj[k]) else if (oldObj[k] instanceof Object) newObj[k] = deepCopy(newObj[k], oldObj[k]) else newObj[k] = oldObj[k] js库lodash里面cloneDeep内部实现了深拷贝 const obj = uname: pink, age: 18, hobby: [篮球, 足球], family: baby: 小pink // 语法：_.cloneDeep(要被克隆的对象)const o = _.cloneDeep(obj)console.log(o) 通过JSON.stringify()实现 const obj = uname: pink, age: 18, hobby: [篮球, 足球], family: baby: 小pink // 语法：_.cloneDeep(要被克隆的对象)const o = JSON.parse(JSON.stringify(obj))console.log(o) 4.2 异常处理4.2.1 throw 概念 异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行 语法 function counter(x, y) if (!x || !y) throw new Error(参数不能为空) return x + ycounter() 总结 throw 抛出异常信息，程序也会终止执行 throw 后面跟的是错误提示信息 Error 对象配合 throw 使用，能够设置更详细的错误信息 4.2.2 trycatch 捕获异常 作用 我们可以通过try catch 捕获错误信息（浏览器提供的错误信息） try 试试 catch 拦住 finally 示例 function foo() try // 查找dom节点 const p = document.querySelector(.p) p.style.color = red catch (error) // try 代码段中执行有错误时，会执行 catch 代码段 // 查看错误信息 console.log(error.message) return finally alert(运行) console.log(如果出现错误，这句不会执行)foo() 总结 try…catch 用于捕获错误信息 将预估可能发生错误的代码写在 try 代码段中 如果 try 代码段中出现错误后，会执行 catch 代码段，并截获到错误信息 finally 不管是否有错误，都会执行 4.2.3 debugger 可以通过try catch 捕获错误信息（浏览器提供的错误信息）","tags":["JavaScript","JS异常处理","JS作用域","JS对象原型"],"categories":["前端"]},{"title":"MyBatis（二）查询解析","path":"/2023/12/06/2023-12-06-MyBatis（二）查询解析/","content":"在MyBatis（一）配置解析中我们了解到了MyBatis如何解析配置文件，使用配置文件构建了Configuration对象。并根据Configuration对象构建出一个SqlSessionFactory对象。本篇将介绍如何根据构建的SqlSessionFactory对象生成一个SqlSession对象，并执行相应的查询操作。 1. JDK动态代理 在分析mapper接口查询前流程前，我们首先需要了解下动态代理功能 动态代理是Java中一种强大的机制，允许在运行时生成代理类，而不是在编译时预先创建代理类。Java中的动态代理通常通过java.lang.reflect包中的Proxy类和InvocationHandler接口来实现 创建接口 首先，定义一个接口，该接口将由动态代理类实现。这个接口是你要代理的目标接口 public interface MyInterface void doSomething(); 实现InvocationHandler接口 创建一个类实现InvocationHandler接口，该接口中有一个方法invoke，它在代理对象上执行方法调用 import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class MyInvocationHandler implements InvocationHandler private Object realObject; public MyInvocationHandler(Object realObject) this.realObject = realObject; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable // 在这里执行额外的逻辑 System.out.println(Before method invocation); // 调用实际对象的方法 Object result = method.invoke(realObject, args); // 在这里执行额外的逻辑 System.out.println(After method invocation); return result; 创建动态代理对象 使用Proxy.newProxyInstance方法创建动态代理对象 import java.lang.reflect.Proxy;public class Main public static void main(String[] args) MyInterface realObject = new MyInterfaceImpl(); // 实际对象 MyInvocationHandler handler = new MyInvocationHandler(realObject); // 创建动态代理对象 MyInterface proxyObject = (MyInterface) Proxy.newProxyInstance( MyInterface.class.getClassLoader(), new Class[]MyInterface.class, handler ); // 使用代理对象调用方法 proxyObject.doSomething(); 在上述例子中，MyInterfaceImpl是MyInterface接口的实际实现类。通过动态代理，我们可以在方法调用前后执行额外的逻辑。 请注意，动态代理只能代理接口，而不是具体的类。如果需要代理具体的类，可以考虑使用第三方库，如CGLIB 示例 import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;// 接口interface Calculator int add(int a, int b);// 接口的实现类class CalculatorImpl implements Calculator @Override public int add(int a, int b) return a + b; // InvocationHandler 实现类class LoggingHandler implements InvocationHandler private Object target; public LoggingHandler(Object target) this.target = target; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable System.out.println(Before invoking method: + method.getName()); // 调用实际对象的方法 Object result = method.invoke(target, args); System.out.println(After invoking method: + method.getName()); return result; public class DynamicProxyExample public static void main(String[] args) // 创建实际对象 Calculator calculator = new CalculatorImpl(); // 创建动态代理对象 Calculator proxyCalculator = (Calculator) Proxy.newProxyInstance( Calculator.class.getClassLoader(), new Class[]Calculator.class, new LoggingHandler(calculator) ); // 使用代理对象调用方法 int result = proxyCalculator.add(3, 5); System.out.println(Result: + result); 2. 构建SqlSession 获取SqlSession public class MyBatisDemoTest @Test public void test() throws IOException // 第一阶段：MyBatis初始化阶段 // 读取 MyBatis 配置文件 InputStream inputStream = Resources.getResourceAsStream(mybatis-config.xml); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 第二阶段：数据处理阶段 // 打开一个 SqlSession try (SqlSession sqlSession = sqlSessionFactory.openSession()) // 获取 Mapper UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = new User(); user.setSchoolName(清华大学); // 调用 Mapper 中的方法 ListUser users = userMapper.queryUserBySchoolName(user.getSchoolName()); // 处理查询结果 for (User user1 : users) System.out.println(user1.getName() + : + user1.getSchoolName()); 在MyBatis（一）配置解析中介绍了new SqlSessionFactoryBuilder().build(inputStream)返回了DefaultSqlSessionFactory 执行openSession()得到返回的DefaultSqlSession DefaultSqlSession中封装了执行sql的Executor映射器（默认是CachingExecutor) SqlSession sqlSession = sqlSessionFactory.openSession()private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) Transaction tx = null; try final Environment environment = configuration.getEnvironment(); // 获取事务工厂 final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment); // 获取事务对象 tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit); final Executor executor = configuration.newExecutor(tx, execType); // 返回DefaultSqlSession return new DefaultSqlSession(configuration, executor, autoCommit); catch (Exception e) closeTransaction(tx); // may have fetched a connection so lets call close() throw ExceptionFactory.wrapException(Error opening session. Cause: + e, e); finally ErrorContext.instance().reset(); 在上述代码中返回了DefaultSqlSession，我们可以看到在它继承的接口SqlSession中提供了查询、增加、更新、删除、提交、回滚等大量的方法 /* * Copyright 2009-2011 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the License); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an AS IS BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.ibatis.session;import java.io.Closeable;import java.sql.Connection;import java.util.List;import java.util.Map;import org.apache.ibatis.executor.BatchResult;/** * The primary Java interface for working with MyBatis. * Through this interface you can execute commands, get mappers and manage transactions. * * @author Clinton Begin *//** * 这是MyBatis主要的一个类，用来执行SQL，获取映射器，管理事务 * * 通常情况下，我们在应用程序中使用的Mybatis的API就是这个接口定义的方法。 * */public interface SqlSession extends Closeable /** * Retrieve a single row mapped from the statement key * 根据指定的SqlID获取一条记录的封装对象 * @param T the returned object type 封装之后的对象类型 * @param statement sqlID * @return Mapped object 封装之后的对象 */ T T selectOne(String statement); /** * Retrieve a single row mapped from the statement key and parameter. * 根据指定的SqlID获取一条记录的封装对象，只不过这个方法容许我们可以给sql传递一些参数 * 一般在实际使用中，这个参数传递的是pojo，或者Map或者ImmutableMap * @param T the returned object type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @return Mapped object */ T T selectOne(String statement, Object parameter); /** * Retrieve a list of mapped objects from the statement key and parameter. * 根据指定的sqlId获取多条记录 * @param E the returned list element type * @param statement Unique identifier matching the statement to use. * @return List of mapped object */ E ListE selectList(String statement); /** * Retrieve a list of mapped objects from the statement key and parameter. * 获取多条记录，这个方法容许我们可以传递一些参数 * @param E the returned list element type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @return List of mapped object */ E ListE selectList(String statement, Object parameter); /** * Retrieve a list of mapped objects from the statement key and parameter, * within the specified row bounds. * 获取多条记录，这个方法容许我们可以传递一些参数，不过这个方法容许我们进行 * 分页查询。 * * 需要注意的是默认情况下，Mybatis为了扩展性，仅仅支持内存分页。也就是会先把 * 所有的数据查询出来以后，然后在内存中进行分页。因此在实际的情况中，需要注意 * 这一点。 * * 一般情况下公司都会编写自己的Mybatis 物理分页插件 * @param E the returned list element type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param rowBounds Bounds to limit object retrieval * @return List of mapped object */ E ListE selectList(String statement, Object parameter, RowBounds rowBounds); /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * Eg. Return a of Map[Integer,Author] for selectMap(selectAuthors,id) * 将查询到的结果列表转换为Map类型。 * @param K the returned Map keys type * @param V the returned Map values type * @param statement Unique identifier matching the statement to use. * @param mapKey The property to use as key for each value in the list. 这个参数会作为结果map的key * @return Map containing key pair data. */ K, V MapK, V selectMap(String statement, String mapKey); /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * 将查询到的结果列表转换为Map类型。这个方法容许我们传入需要的参数 * @param K the returned Map keys type * @param V the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ K, V MapK, V selectMap(String statement, Object parameter, String mapKey); /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * 获取多条记录,加上分页,并存入Map * @param K the returned Map keys type * @param V the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @param rowBounds Bounds to limit object retrieval * @return Map containing key pair data. */ K, V MapK, V selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds); /** * Retrieve a single row mapped from the statement key and parameter * using a @code ResultHandler. * * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param handler ResultHandler that will handle each retrieved row * @return Mapped object */ void select(String statement, Object parameter, ResultHandler handler); /** * Retrieve a single row mapped from the statement * using a @code ResultHandler. * 获取一条记录,并转交给ResultHandler处理。这个方法容许我们自己定义对 * 查询到的行的处理方式。不过一般用的并不是很多 * @param statement Unique identifier matching the statement to use. * @param handler ResultHandler that will handle each retrieved row * @return Mapped object */ void select(String statement, ResultHandler handler); /** * Retrieve a single row mapped from the statement key and parameter * using a @code ResultHandler and @code RowBounds * 获取一条记录,加上分页,并转交给ResultHandler处理 * @param statement Unique identifier matching the statement to use. * @param rowBounds RowBound instance to limit the query results * @param handler ResultHandler that will handle each retrieved row * @return Mapped object */ void select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler); /** * Execute an insert statement. * 插入记录。一般情况下这个语句在实际项目中用的并不是太多，而且更多使用带参数的insert函数 * @param statement Unique identifier matching the statement to execute. * @return int The number of rows affected by the insert. */ int insert(String statement); /** * Execute an insert statement with the given parameter object. Any generated * autoincrement values or selectKey entries will modify the given parameter * object properties. Only the number of rows affected will be returned. * 插入记录，容许传入参数。 * @param statement Unique identifier matching the statement to execute. * @param parameter A parameter object to pass to the statement. * @return int The number of rows affected by the insert. 注意返回的是受影响的行数 */ int insert(String statement, Object parameter); /** * Execute an update statement. The number of rows affected will be returned. * 更新记录。返回的是受影响的行数 * @param statement Unique identifier matching the statement to execute. * @return int The number of rows affected by the update. */ int update(String statement); /** * Execute an update statement. The number of rows affected will be returned. * 更新记录 * @param statement Unique identifier matching the statement to execute. * @param parameter A parameter object to pass to the statement. * @return int The number of rows affected by the update. 返回的是受影响的行数 */ int update(String statement, Object parameter); /** * Execute a delete statement. The number of rows affected will be returned. * 删除记录 * @param statement Unique identifier matching the statement to execute. * @return int The number of rows affected by the delete. 返回的是受影响的行数 */ int delete(String statement); /** * Execute a delete statement. The number of rows affected will be returned. * 删除记录 * @param statement Unique identifier matching the statement to execute. * @param parameter A parameter object to pass to the statement. * @return int The number of rows affected by the delete. 返回的是受影响的行数 */ int delete(String statement, Object parameter); //以下是事务控制方法,commit,rollback /** * Flushes batch statements and commits database connection. * Note that database connection will not be committed if no updates/deletes/inserts were called. * To force the commit call @link SqlSession#commit(boolean) */ void commit(); /** * Flushes batch statements and commits database connection. * @param force forces connection commit */ void commit(boolean force); /** * Discards pending batch statements and rolls database connection back. * Note that database connection will not be rolled back if no updates/deletes/inserts were called. * To force the rollback call @link SqlSession#rollback(boolean) */ void rollback(); /** * Discards pending batch statements and rolls database connection back. * Note that database connection will not be rolled back if no updates/deletes/inserts were called. * @param force forces connection rollback */ void rollback(boolean force); /** * Flushes batch statements. * 刷新批处理语句,返回批处理结果 * @return BatchResult list of updated records * @since 3.0.6 */ ListBatchResult flushStatements(); /** * Closes the session * 关闭Session */ @Override void close(); /** * Clears local session cache * 清理Session缓存 */ void clearCache(); /** * Retrieves current configuration * 得到配置 * @return Configuration */ Configuration getConfiguration(); /** * Retrieves a mapper. * 得到映射器 * 这个巧妙的使用了泛型，使得类型安全 * 到了MyBatis 3，还可以用注解,这样xml都不用写了 * @param T the mapper type * @param type Mapper interface class * @return a mapper bound to this SqlSession */ T T getMapper(ClassT type); /** * Retrieves inner database connection * 得到数据库连接 * @return Connection */ Connection getConnection(); 3. 使用mapper接口查询3.1 构建mapper代理对象 获取mapper public class MyBatisDemoTest @Test public void test() throws IOException // 第一阶段：MyBatis初始化阶段 // 读取 MyBatis 配置文件 InputStream inputStream = Resources.getResourceAsStream(mybatis-config.xml); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 第二阶段：数据处理阶段 // 打开一个 SqlSession try (SqlSession sqlSession = sqlSessionFactory.openSession()) // 获取 Mapper UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = new User(); user.setSchoolName(清华大学); // 调用 Mapper 中的方法 ListUser users = userMapper.queryUserBySchoolName(user.getSchoolName()); // 处理查询结果 for (User user1 : users) System.out.println(user1.getName() + : + user1.getSchoolName()); 回到主代码可以看到根据sqlSession.getMapper可以得到一个mapper映射器。通过调用mapper中的查询方法就能够直接执行sql查询得到数据，这个是怎么做到的？ 使用动态代理技术 构建mapper代理对象 public T void addMapper(ClassT type) if (type.isInterface()) ... try knownMappers.put(type, new MapperProxyFactory(type)); ... finally ... public T T getMapper(ClassT type, SqlSession sqlSession) // 初始化时已经将mapper对应的类型通过addMapper(ClassT type)方法加入到了knownMappers中 final MapperProxyFactoryT mapperProxyFactory = (MapperProxyFactoryT) knownMappers.get(type); if (mapperProxyFactory == null) throw new BindingException(Type + type + is not known to the MapperRegistry.); try return mapperProxyFactory.newInstance(sqlSession); catch (Exception e) throw new BindingException(Error getting mapper instance. Cause: + e, e); 根据下面代码可以看出当执行mapperProxyFactory.newInstance(sqlSession)时，会根据JDK动态代理生成MapperProxy的代理对象。代理对象中封装了sqlSession public class MapperProxyFactoryT ... @SuppressWarnings(unchecked) protected T newInstance(MapperProxyT mapperProxy) //用JDK动态代理生成映射器代理对象 return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] mapperInterface , mapperProxy); public T newInstance(SqlSession sqlSession) final MapperProxyT mapperProxy = new MapperProxy(sqlSession, mapperInterface, methodCache); return newInstance(mapperProxy); 3.2 代理对象查询 当我们执行userMapper.queryUserBySchoolName(user.getSchoolName())会触发MapperProxy的invoke方法 /** * 映射器代理，代理模式 */public class MapperProxyT implements InvocationHandler, Serializable private static final long serialVersionUID = -6424540398559729838L; private final SqlSession sqlSession; private final ClassT mapperInterface; private final MapMethod, MapperMethod methodCache; public MapperProxy(SqlSession sqlSession, ClassT mapperInterface, MapMethod, MapperMethod methodCache) this.sqlSession = sqlSession; this.mapperInterface = mapperInterface; this.methodCache = methodCache; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable //代理以后，所有Mapper的方法调用时，都会调用这个invoke方法 //并不是任何一个方法都需要执行调用代理对象进行执行，如果这个方法是Object中通用的方法（toString、hashCode等）无需执行 if (Object.class.equals(method.getDeclaringClass())) try return method.invoke(this, args); catch (Throwable t) throw ExceptionUtil.unwrapThrowable(t); //这里优化了，去缓存中找MapperMethod final MapperMethod mapperMethod = cachedMapperMethod(method); //执行 return mapperMethod.execute(sqlSession, args); //去缓存中找MapperMethod private MapperMethod cachedMapperMethod(Method method) MapperMethod mapperMethod = methodCache.get(method); if (mapperMethod == null) //找不到才去new mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()); methodCache.put(method, mapperMethod); return mapperMethod; 在invoke方法中最终执行mapperMethod.execute(sqlSession, args) 可以看到执行时就是4种情况，insert|update|delete|select，分别调用SqlSession的4大类方法 /** * 映射器方法 */public class MapperMethod private final SqlCommand command; private final MethodSignature method; public MapperMethod(Class? mapperInterface, Method method, Configuration config) this.command = new SqlCommand(config, mapperInterface, method); this.method = new MethodSignature(config, method); //执行 public Object execute(SqlSession sqlSession, Object[] args) Object result; //可以看到执行时就是4种情况，insert|update|delete|select，分别调用SqlSession的4大类方法 if (SqlCommandType.INSERT == command.getType()) Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.insert(command.getName(), param)); else if (SqlCommandType.UPDATE == command.getType()) Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.update(command.getName(), param)); else if (SqlCommandType.DELETE == command.getType()) Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.delete(command.getName(), param)); else if (SqlCommandType.SELECT == command.getType()) if (method.returnsVoid() method.hasResultHandler()) //如果有结果处理器 executeWithResultHandler(sqlSession, args); result = null; else if (method.returnsMany()) //如果结果有多条记录 result = executeForMany(sqlSession, args); else if (method.returnsMap()) //如果结果是map result = executeForMap(sqlSession, args); else //否则就是一条记录 Object param = method.convertArgsToSqlCommandParam(args); result = sqlSession.selectOne(command.getName(), param); else throw new BindingException(Unknown execution method for: + command.getName()); if (result == null method.getReturnType().isPrimitive() !method.returnsVoid()) throw new BindingException(Mapper method + command.getName() + attempted to return null from a method with a primitive return type ( + method.getReturnType() + ).); return result; ... sqlSession执行查询方法 创建MapperMethod对象时会根据method创建MethodSignature对象，根据returnType确认返回类型 public MapperMethod(Class? mapperInterface, Method method, Configuration config) this.command = new SqlCommand(config, mapperInterface, method); this.method = new MethodSignature(config, method);public MethodSignature(Configuration configuration, Method method) this.returnType = method.getReturnType(); // 判断返回类型 this.returnsVoid = void.class.equals(this.returnType); this.returnsMany = (configuration.getObjectFactory().isCollection(this.returnType) || this.returnType.isArray()); this.mapKey = getMapKey(method); this.returnsMap = (this.mapKey != null); this.hasNamedParameters = hasNamedParams(method); //以下重复循环2遍调用getUniqueParamIndex，是不是降低效率了 //记下RowBounds是第几个参数 this.rowBoundsIndex = getUniqueParamIndex(method, RowBounds.class); //记下ResultHandler是第几个参数 this.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.class); this.params = Collections.unmodifiableSortedMap(getParams(method, this.hasNamedParameters)); 因为返回参数是一个List，会执行executeForMany(sqlSession, args)方法 private E Object executeForMany(SqlSession sqlSession, Object[] args) ListE result; Object param = method.convertArgsToSqlCommandParam(args); //代入RowBounds if (method.hasRowBounds()) RowBounds rowBounds = method.extractRowBounds(args); result = sqlSession.EselectList(command.getName(), param, rowBounds); else result = sqlSession.EselectList(command.getName(), param); // issue #510 Collections arrays support if (!method.getReturnType().isAssignableFrom(result.getClass())) if (method.getReturnType().isArray()) return convertToArray(result); else return convertToDeclaredCollection(sqlSession.getConfiguration(), result); return result; PreparedStatement执行查询 获取MappedStatement对象 解析mapper.xml中封装的sql封装到BoundSql解析后的sql语句存入BoundSql中的sql字段 创建缓存key 判读是否开启缓存，如果开启缓存先查缓存 使用PreparedStatement的execute方法执行查询操作 private E ListE selectList(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler) try // 获取MappedStatement // 每个MappedStatement对象对应了我们设置的一个数据库操作节点，它主要定义了数据库操作语句、输入/输出参数等信息 MappedStatement ms = configuration.getMappedStatement(statement); dirty |= ms.isDirtySelect(); return executor.query(ms, wrapCollection(parameter), rowBounds, handler); catch (Exception e) throw ExceptionFactory.wrapException(Error querying database. Cause: + e, e); finally ErrorContext.instance().reset(); @Overridepublic E ListE query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException // 获取sql BoundSql boundSql = ms.getBoundSql(parameterObject); // 创建缓存key CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql); return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);@Overridepublic E ListE query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException Cache cache = ms.getCache(); //默认情况下是没有开启缓存的(二级缓存).要开启二级缓存,你需要在你的 SQL 映射文件中添加一行: cache/ //简单的说，就是先查CacheKey，查不到再委托给实际的执行器去查 if (cache != null) flushCacheIfRequired(ms); if (ms.isUseCache() resultHandler == null) ensureNoOutParams(ms, boundSql); @SuppressWarnings(unchecked) ListE list = (ListE) tcm.getObject(cache, key); if (list == null) list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql); tcm.putObject(cache, key, list); // issue #578 and #116 return list; return delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);@Overridepublic E ListE query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException ... list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql); ...private E ListE queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException ListE list; //先向缓存中放入占位符？？？ localCache.putObject(key, EXECUTION_PLACEHOLDER); try list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql); finally //最后删除占位符 localCache.removeObject(key); //加入缓存 localCache.putObject(key, list); //如果是存储过程，OUT参数也加入缓存 if (ms.getStatementType() == StatementType.CALLABLE) localOutputParameterCache.putObject(key, parameter); return list;@Overridepublic E ListE doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException Statement stmt = null; try Configuration configuration = ms.getConfiguration(); //新建一个StatementHandler //这里看到ResultHandler传入了 StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql); //准备语句 stmt = prepareStatement(handler, ms.getStatementLog()); return handler.query(stmt, resultHandler); finally closeStatement(stmt); @Overridepublic E ListE query(Statement statement, ResultHandler resultHandler) throws SQLException PreparedStatement ps = (PreparedStatement) statement; // ps.execute（）真正执行了SQL语句，然后把执行结果交给ResultHandler对象处理。 // 而PreparedStatement类并不是MyBatis中的类，因而ps.execute（）的执行不再由MyBatis负责，而是由com.mysql.cj.jdbc包中的类负责 ps.execute(); return resultSetHandler.handleResultSets(ps); 4. 处理结果集 主要关注该方法DefaultResultSetHandler.getRowValue private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap, String columnPrefix) throws SQLException final ResultLoaderMap lazyLoader = new ResultLoaderMap(); Object rowValue = createResultObject(rsw, resultMap, lazyLoader, columnPrefix); if (rowValue != null !hasTypeHandlerForResultObject(rsw, resultMap.getType())) final MetaObject metaObject = configuration.newMetaObject(rowValue); boolean foundValues = this.useConstructorMappings; if (shouldApplyAutomaticMappings(resultMap, false)) foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues; foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues; foundValues = lazyLoader.size() 0 || foundValues; rowValue = foundValues || configuration.isReturnInstanceForEmptyRow() ? rowValue : null; return rowValue; 创建Mapper接口中的返回对象，得到一个空对象 // 创建结果集对象private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, ListClass? constructorArgTypes, ListObject constructorArgs, String columnPrefix) throws SQLException //得到result type final Class? resultType = resultMap.getType(); final MetaClass metaType = MetaClass.forClass(resultType); final ListResultMapping constructorMappings = resultMap.getConstructorResultMappings(); if (typeHandlerRegistry.hasTypeHandler(resultType)) //基本型 return createPrimitiveResultObject(rsw, resultMap, columnPrefix); else if (!constructorMappings.isEmpty()) //有参数的构造函数 return createParameterizedResultObject(rsw, resultType, constructorMappings, constructorArgTypes, constructorArgs, columnPrefix); else if (resultType.isInterface() || metaType.hasDefaultConstructor()) //普通bean类型 return objectFactory.create(resultType); else if (shouldApplyAutomaticMappings(resultMap, false)) //自动映射 return createByConstructorSignature(rsw, resultType, constructorArgTypes, constructorArgs, columnPrefix); throw new ExecutorException(Do not know how to create an instance of + resultType); applyAutomaticMappings方法 在自动属性映射功能开启的情况下，该方法将数据记录的值赋给输出结果对象 循环遍历每个属性，然后调用metaObject.setValue（mapping.property，value）语句为属性赋值 private boolean applyAutomaticMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix) throws SQLException ListUnMappedColumnAutoMapping autoMapping = createAutomaticMappings(rsw, resultMap, metaObject, columnPrefix); boolean foundValues = false; if (!autoMapping.isEmpty()) for (UnMappedColumnAutoMapping mapping : autoMapping) final Object value = mapping.typeHandler.getResult(rsw.getResultSet(), mapping.column); if (value != null) foundValues = true; if (value != null || configuration.isCallSettersOnNulls() !mapping.primitive) // gcode issue #377, call setter on nulls (value is not found) // 设置对象中每个的属性值 metaObject.setValue(mapping.property, value); return foundValues; applyPropertyMappings方法 该方法按照用户的映射设置，给输出结果对象的属性赋值 private boolean applyPropertyMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, ResultLoaderMap lazyLoader, String columnPrefix) throws SQLException final ListString mappedColumnNames = rsw.getMappedColumnNames(resultMap, columnPrefix); boolean foundValues = false; final ListResultMapping propertyMappings = resultMap.getPropertyResultMappings(); for (ResultMapping propertyMapping : propertyMappings) String column = prependPrefix(propertyMapping.getColumn(), columnPrefix); if (propertyMapping.getNestedResultMapId() != null) // the user added a column attribute to a nested result map, ignore it column = null; if (propertyMapping.isCompositeResult() || column != null mappedColumnNames.contains(column.toUpperCase(Locale.ENGLISH)) || propertyMapping.getResultSet() != null) Object value = getPropertyMappingValue(rsw.getResultSet(), metaObject, propertyMapping, lazyLoader, columnPrefix); // issue #541 make property optional final String property = propertyMapping.getProperty(); if (property == null) continue; if (value == DEFERRED) foundValues = true; continue; if (value != null) foundValues = true; if (value != null || configuration.isCallSettersOnNulls() !metaObject.getSetterType(property).isPrimitive()) // gcode issue #377, call setter on nulls (value is not found) metaObject.setValue(property, value); return foundValues; 5. 总结 在整个数据库操作阶段，MyBatis完成的工作可以概述为以下几条 建立连接数据库的SqlSession 根据mapper接口生成代理对象 执行mapper接口中方法时触发代理对象invoke方法执行sqlSession中数据库的操作方法 解析mapper.xml各种sql标签中的语句得到标准sql 尝试从缓存中查询结果，找到则返回；找不到继续查询数据库 查询数据数据库得到结果 处理数据库返回结果，将返回结果映射到mapper接口方法返回数据类型","tags":["MyBatis","Java","ORM"],"categories":["Java"]},{"title":"JavaScript Web API基础","path":"/2023/12/05/2023-12-05-JavaScript-Web-Apis基础/","content":"1. Web API基本认知1.1 作用和分类 作用 就是使用 JS 去操作 html 和浏览器 分类 DOM (文档对象模型)、BOM（浏览器对象模型） 1.2 DOM 概念 DOM（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML文档交互的API 白话文：DOM是浏览器提供的一套专门用来 操作网页内容 的功能 作用 开发网页内容特效和实现用户交互 1.3 DOM树 概念 将 HTML 文档以树状结构直观的表现出来，我们称之为文档树或 DOM 树 描述网页内容关系的名词 作用 文档树直观的体现了标签与标签之间的关系 1.4 DOM对象（重要） DOM对象 浏览器根据html标签生成的 JS对象 所有的标签属性都可以在这个对象上面找到 修改这个对象的属性会自动映射到标签身上 DOM的核心思想 把网页内容当做对象来处理 document 对象 是 DOM 里提供的一个对象 所以它提供的属性和方法都是用来访问和操作网页内容的 网页所有内容都在document里面 1.5 获取DOM对象1.5.1 选择匹配的第一个元素 语法 document.querySelector(css选择器) 参数 包含一个或多个有效的CSS选择器 字符串 返回值 CSS选择器匹配的第一个元素,一个 HTMLElement对象。 如果没有匹配到，则返回null。 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody div我是一个盒子/div div我是er个盒子/div div class=three我是三个盒子/div ul li1/li li2/li li3/li /ul span就1个/span script // 1. js 获取 第一个元素 let div = document.querySelector(div) let div2 = document.querySelector(.three) console.log(div) let li = document.querySelector(ul li:last-child) console.log(li) /script/body/html 1.5.2 选择匹配的多个元素 语法 document.querySelectorAll(css选择器)document.querySelectorAll(ul li) 参数 包含一个或多个有效的CSS选择器 字符串 返回值 CSS选择器匹配的NodeList对象集合。得到的是一个伪数组： 有长度有索引号的数组 但是没有 pop() push() 等数组方法 想要得到里面的每一个对象，则需要遍历（for）的方式获得。 注意 哪怕只有一个元素，通过querySelectAll() 获取过来的也是一个伪数组，里面只有一个元素而已 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody div我是一个盒子/div div我是er个盒子/div div class=three我是三个盒子/div ul li1/li li2/li li3/li /ul span就1个/span script // 2. 获取多个元素 伪数组 let lis = document.querySelectorAll(ul li) // console.log(lis) [div, div, div] // 通过遍历的方式，获得里面的每一个dom对象（元素） for (let i = 0; i lis.length; i++) console.log(lis[i]) let span = document.querySelectorAll(span) console.log(span) /script/body/html 1.6 操作元素内容 DOM对象都是根据标签生成的,所以操作标签,本质上就是操作DOM对象。 就是操作对象使用的点语法。 如果想要修改标签元素的里面的内容，则可以使用如下几种方式 对象.innerText 属性 对象.innerHTML 属性 元素 innerText 属性 作用 将文本内容添加更新到任意标签位置 显示纯文本，不解析标签 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style div width: 200px; height: 200px; background-color: pink; /style/headbody div 粉红色的回忆 /div script // 1. 获取标签(元素) let box = document.querySelector(div) // 2. 修改标签（元素）内容 box是对象 innerText 属性 // 对象.属性 = 值 不识别标签 box.innerText = 有点意思~ box.innerText = strong有点意思~/strong /script/body/html 元素 innerHTML 属性 作用 将文本内容添加更新到任意标签位置 会解析标签，多标签建议使用模板字符 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style div width: 200px; height: 200px; background-color: pink; /style/headbody div 粉红色的回忆 /div script // 1. 获取标签(元素) let box = document.querySelector(div) // 2. innerHTML解析标签 box.innerHTML = strong有点意思~/strong /script/body/html 1.7 操作元素属性1.7.1 操作元素常用属性 作用 可以通过 JS 设置修改标签元素属性，比如通过 src更换 图片 语法 对象.属性 = 值 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody img src=./images/1.webp alt= script // 1. 获取元素 图片 let pic = document.querySelector(img) // 2. 修改元素属性 src 对象.属性 = 值 pic.src = ./images/3.webp pic.title = 我是pink老师 /script/body/html 1.7.2 操作元元素样式属性 作用 可以通过 JS 设置修改标签元素的样式属性 比如通过 轮播图小圆点自动更换颜色样式 点击按钮可以滚动图片，这是移动的图片的位置 left 等等 通过 style 属性操作CSS 语法 对象.style.样式属性 = 值 注意 修改样式通过style属性引出 如果属性有-连接符，需要转换为小驼峰命名法 赋值的时候，需要的时候不要忘记加css单位 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style div width: 300px; height: 300px; background-color: pink; /style/headbody div /div script // 1. 获取元素 let box = document.querySelector(div) // 2. 改变背景颜色 样式 style box.style.backgroundColor = hotpink box.style.width = 400px box.style.marginTop = 100px /script/body/html 操作类名(className) 操作CSS 如果修改的样式比较多，直接通过style属性修改比较繁琐，我们可以通过借助于css类名的形式。 语法 // active 是一个css类名元素.className = active 注意 由于class是关键字, 所以使用className去代替 className是使用新值换旧值, 如果需要添加一个类,需要保留之前的类名 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style div width: 200px; height: 200px; background-color: pink; .active width: 300px; height: 300px; background-color: hotpink; margin-left: 100px; /style/headbody div class=one/div script // 1.获取元素 // let box = document.querySelector(css选择器) let box = document.querySelector(div) // 2 设置样式div // box.style.width = 300px // box.style.height = 300px // box.style.backgroundColor = hotpink // box.style.marginLeft = 100px box.className = one active /script/body/html 通过 classList 操作类控制CSS 为了解决 className 容易覆盖以前的类名，我们可以通过classList方式追加和删除类名。 语法 // 追加一个类元素.classList.add(类名)// 删除一个类元素.classList.remove(类名)// 切换一个类元素.classList.toggle(类名) 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style div width: 200px; height: 200px; background-color: pink; .active width: 300px; height: 300px; background-color: hotpink; margin-left: 100px; /style/headbody div class=one/div script // 1.获取元素 // let box = document.querySelector(css选择器) let box = document.querySelector(div) // add是个方法 添加 追加 // box.classList.add(active) // remove() 移除 类 // box.classList.remove(one) // 切换类 box.classList.toggle(one) /script/body/html 1.7.3 操作表单元素属性 作用 表单很多情况，也需要修改属性，比如点击眼睛，可以看到密码，本质是把表单类型转换为文本框 正常的有属性有取值的跟其他的标签属性没有任何区别 获取: DOM对象.属性名 设置: DOM对象.属性名 新值 表单属性中添加就有效果，移除就没有效果，一律使用布尔值表示 如果为 true 代表添加了该属性 如果是 false 代表移除了该属性 比如： disabled、checked、selected 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody input type=text value=请输入 button disabled按钮/button input type=checkbox name= id= class=agree script // 1. 获取元素 let input = document.querySelector(input) // 2. 取值或者设置值 得到input里面的值可以用 value // console.log(input.value) input.value = 小米手机 input.type = password // 2. 启用按钮 let btn = document.querySelector(button) // disabled 不可用 = false 这样可以让按钮启用 btn.disabled = false // 3. 勾选复选框 let checkbox = document.querySelector(.agree) checkbox.checked = false /script/body/html 1.7.4 自定义属性 标准属性 标签天生自带的属性 比如class id title等。可以直接使用点语法操作比如： disabled、checked、selected 自定义属性 在html5中推出来了专门的 data- 自定义属性 在标签上一律以 data-开头 在DOM对象上一律以 dataset 对象方式获取 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody div data-id=1 data-spm=不知道1/div div data-id=22/div div data-id=33/div div data-id=44/div div data-id=55/div script const one = document.querySelector(div) console.log(one.dataset.id) // 1 console.log(one.dataset.spm) // 不知道 /script/body/html 1.8 定时器 网页中经常会需要一种功能：每隔一段时间需要自动执行一段代码，不需要我们手动去触发 例如：网页中的倒计时，要实现这种需求，需要定时器函数 1.8.1 间歇函数 作用 定时器函数可以开启和关闭定时器 开启定时器 语法 setInterval(函数, 间歇时间)- 作用：每隔一段时间调用这个函数- 间隔时间单位是毫秒 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script // 1 setInterval(function () console.log(高薪就业) , 1000) // 2 function show() console.log(月薪过2万) setInterval(show, 1000) /script/body/html 关闭定时器 语法 let 变量名 = setInterval(函数, 间歇时间)clearInterval(变量名) 注意 函数名字不需要加括号 定时器返回的是一个id数字 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script function show() console.log(月薪过2万) let timer = setInterval(show, 1000) // 清除定时器 clearInterval(timer) /script/body/html 2. DOM事件基础2.1 事件监听（绑定） 什么是事件？ 事件是在编程时系统内发生的动作或者发生的事情 比如用户在网页上单击一个按钮 什么是事件监听？ 就是让程序检测是否有事件产生，一旦有事件触发，就立即调用一个函数做出响应，也称为 绑定事件或者注册事件 比如鼠标经过显示下拉菜单，比如点击可以播放轮播图等等 语法 元素对象.addEventListener(事件类型, 要执行的函数) 事件监听三要素 事件源： 那个dom元素被事件触发了，要获取dom元素 事件类型： 用什么方式触发，比如鼠标单击 click、鼠标经过 mouseover 等 事件调用的函数： 要做什么事 注意 事件类型要加引号 函数是点击之后再去执行，每次点击都会执行一次 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody button点击/button script // 需求： 点击了按钮，弹出一个对话框 // 1. 事件源 按钮 // 2.事件类型 点击鼠标 click 字符串 // 3. 事件处理程序 弹出对话框 const btn = document.querySelector(button) btn.addEventListener(click, function () alert(你早呀~) ) /script/body/html 2.2 事件类型 事件的类型 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style div width: 200px; height: 200px; background-color: pink; /style/headbody div/div script const div = document.querySelector(div) // 鼠标经过 div.addEventListener(mouseenter, function () console.log(`轻轻的我来了`) ) // 鼠标离开 div.addEventListener(mouseleave, function () console.log(`轻轻的我走了`) ) /script/body/html 2.3 事件对象 事件对象是什么 也是个对象，这个对象里有事件触发时的相关信息 例如：鼠标点击事件中，事件对象就存了鼠标点在哪个位置等信息 使用场景 可以判断用户按下哪个键，比如按下回车键可以发布新闻 可以判断鼠标点击了哪个元素，从而做相应的操作 获取事件对象 在事件绑定的回调函数的第一个参数就是事件对象 一般命名为event、ev、e // e为事件对象元素对象.addEventListener(事件类型, function(e) ) 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody !-- button点击/button -- input type=text script // const btn = document.querySelector(button) // btn.addEventListener(click, function (e) // console.log(e) // ) const input = document.querySelector(input) input.addEventListener(keyup, function (e) // console.log(11) // console.log(e.key) if (e.key === Enter) console.log(我按下了回车键) ) /script/body/html 事件对象常用属性 type 获取当前的事件类型 clientXclientY 获取光标相对于浏览器可见窗口左上角的位置 offsetXoffsetY 获取光标相对于当前DOM元素左上角的位置 key 用户按下的键盘键的值 现在不提倡使用keyCode 2.4 环境对象 概念 指的是函数内部特殊的变量 this ，它代表着当前函数运行时所处的环境 作用 函数的调用方式不同，this 指代的对象也不同 【谁调用， this 就是谁】 是判断 this 指向的粗略规则 直接调用函数，其实相当于是 window.函数，所以 this 指代 window 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody button点击/button script // 每个函数里面都有this 环境对象 普通函数里面this指向的是window // function fn() // console.log(this) // // window.fn() const btn = document.querySelector(button) btn.addEventListener(click, function () // console.log(this) // btn 对象 // btn.style.color = red this.style.color = red ) /script/body/html 2.5 回调函数 概念 如果将函数 A 做为参数传递给函数 B 时，我们称函数 A 为回调函数 简单理解： 当一个函数当做参数来传递给另外一个函数的时候，这个函数就是回调函数 示例 script function fn() console.log(我是回调函数); setInterval(fn, 1000) btn.addEventListener(click, function () alert(我也是回调函数~) )/script 3. DOM事件进阶3.1 事件流 概念 事件流指的是事件完整执行过程中的流动路径 假设页面里有个div，当触发事件时，会经历两个阶段，分别是捕获阶段、冒泡阶段 简单来说：捕获阶段是 从父到子 冒泡阶段是 从子到父 注意 实际工作都是使用事件冒泡为主 3.2 事件捕获 概念 从DOM的根元素开始去执行对应的事件 (从外到里) 语法 DOM.addEventListener(事件类型, 事件处理函数, 是否使用捕获机制) 说明 addEventListener第三个参数传入 true 代表是捕获阶段触发（很少使用） 若传入false代表冒泡阶段触发，默认就是false 若是用 L0 事件监听，则只有冒泡阶段，没有捕获 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style .father width: 500px; height: 500px; background-color: pink; .son width: 200px; height: 200px; background-color: purple; /style/headbody div class=father div class=son/div /div script const fa = document.querySelector(.father) const son = document.querySelector(.son) // 山东 济南 蓝翔 目标（pink老师） 捕获阶段 // 蓝翔 济南 山东 冒泡阶段 document.addEventListener(click, function () alert(我是爷爷) , true) fa.addEventListener(click, function () alert(我是爸爸) , true) son.addEventListener(click, function () alert(我是儿子) , true) /script/body/html 效果 https://font-demo.pages.dev/js/web_api_3/03-%E4%BA%8B%E4%BB%B6%E6%B5%81 3.3 事件冒泡 概念 当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为事件冒泡 简单理解：当一个元素触发事件后，会依次向上调用所有父级元素的 同名事件 说明 事件冒泡是默认存在的 L2事件监听第三个参数是 false，或者默认都是冒泡 3.4 阻止冒泡 问题 因为默认就有冒泡模式的存在，所以容易导致子元素事件影响到父级元素 需求 若想把事件就限制在当前元素内，就需要阻止事件冒泡 前提 阻止事件冒泡需要拿到事件对象 语法 事件对象.stopPropagation() 注意 此方法可以阻断事件流动传播，不光在冒泡阶段有效，捕获阶段也有效 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style .father width: 500px; height: 500px; background-color: pink; .son width: 200px; height: 200px; background-color: purple; /style/headbody div class=father div class=son/div /div script const fa = document.querySelector(.father) const son = document.querySelector(.son) // 山东 济南 蓝翔 目标（pink老师） 捕获阶段 // 蓝翔 济南 山东 冒泡阶段 document.addEventListener(click, function () alert(我是爷爷) ) fa.addEventListener(click, function () alert(我是爸爸) ) son.addEventListener(click, function (e) alert(我是儿子) // 组织流动传播 事件对象.stopPropagation() e.stopPropagation() ) /script/body/html 效果 https://font-demo.pages.dev/js/web_api_3/04-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1 3.5 阻止默认行为 作用 我们某些情况下需要 阻止默认行为的发生，比如 阻止 链接的跳转，表单域跳转 语法 e.preventDefault() 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody form action=http://www.itcast.cn input type=submit value=免费注册 /form a href=http://www.baidu.com百度一下/a script const form = document.querySelector(form) form.addEventListener(submit, function (e) // 阻止默认行为 提交 e.preventDefault() ) const a = document.querySelector(a) a.addEventListener(click, function (e) e.preventDefault() ) /script/body/html 3.6 解绑事件 作用 解除元素绑定的事件 语法 - on方式直接使用null覆盖偶就可以实现事件的解绑btn.onclick = function () alert(点击了)// L0 事件移除解绑btn.onclick = null- addEventListener方式removeEventListener(事件类型, 事件处理函数, [获取捕获或者冒泡阶段]) 注意 匿名函数无法被解绑 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody button点击/button script const btn = document.querySelector(button) // btn.onclick = function () // alert(点击了) // // L0 事件移除解绑 // btn.onclick = null // function fn() alert(点击了) btn.addEventListener(click, fn) // L2 事件移除解绑 btn.removeEventListener(click, fn) /script/body/html 3.7 鼠标经过事件的区别 鼠标经过事件 mouseover 和 mouseout 会有冒泡效果 mouseenter 和 mouseleave 没有冒泡效果 (推荐) 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style .dad width: 400px; height: 400px; background-color: pink; .baby width: 200px; height: 200px; background-color: purple; /style/headbody div class=dad div class=baby/div /div script const dad = document.querySelector(.dad) const baby = document.querySelector(.baby) dad.addEventListener(mouseenter, function () console.log(鼠标经过) ) dad.addEventListener(mouseleave, function () console.log(鼠标离开) ) /script/body/html 3.8 两种注册事件的区别 传统on注册（L0） 同一个对象,后面注册的事件会覆盖前面注册(同一个事件) 直接使用null覆盖就可以实现事件的解绑 都是冒泡阶段执行的 事件监听注册（L2） 后面注册的事件不会覆盖前面注册的事件(同一个事件) 可以通过第三个参数去确定是在冒泡或者捕获阶段执行 必须使用removeEventListener(事件类型, 事件处理函数, 获取捕获或者冒泡阶段) 匿名函数无法被解绑 3.9 事件委托 如果同时给多个元素注册事件，我们怎么做的？ for循环注册事件 问题 有没有一种技巧 注册一次事件就能完成以上效果呢？ 作用 事件委托是利用事件流的特征解决一些开发需求的知识技巧 优点 减少注册次数，可以提高程序性能 原理 事件委托其实是利用事件冒泡的特点 给父元素注册事件，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件 核心逻辑 // 可以获得真正触发事件的元素事件对象.target.tagName 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody ul li第1个孩子/li li第2个孩子/li li第3个孩子/li li第4个孩子/li li第5个孩子/li p我不需要变色/p /ul script // 点击每个小li 当前li 文字变为红色 // 按照事件委托的方式 委托给父级，事件写到父级身上 // 1. 获得父元素 const ul = document.querySelector(ul) ul.addEventListener(click, function (e) // alert(11) // this.style.color = red // console.dir(e.target) // 就是我们点击的那个对象 // e.target.style.color = red // 我的需求，我们只要点击li才会有效果 if (e.target.tagName === LI) e.target.style.color = red ) /script/body/html 3.10 其他事件3.10.1 页面加载事件 作用 加载外部资源（如图片、外联CSS和JavaScript等）加载完毕时触发的事件 为什么要学？ 有些时候需要等页面资源全部处理完了做一些事情 老代码喜欢把 script 写在 head 中，这时候直接找 dom 元素找不到 事件名：load 作用 监听页面所有资源加载完毕 注意 不光可以监听整个页面资源加载完毕，也可以针对某个资源绑定load事件 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script // 等待页面所有资源加载完毕，就回去执行回调函数 window.addEventListener(load, function () const btn = document.querySelector(button) btn.addEventListener(click, function () alert(11) ) ) img.addEventListener(load, function () // 等待图片加载完毕，再去执行里面的代码 ) /script/headbody button点击/button/body/html 事件名：DOMContentLoaded 作用 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像等完全加载 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title script document.addEventListener(DOMContentLoaded, function () const btn = document.querySelector(button) btn.addEventListener(click, function () alert(11) ) ) /script/headbody button点击/button/body/html 3.10.2 页面滚动事件 作用 滚动条在滚动的时候持续触发的事件 为什么要学？ 很多网页需要检测用户把页面滚动到某个区域后做一些处理， 比如固定导航栏，比如返回顶部 事件名：scroll 语法 监听整个页面滚动 window.addEventListener(scroll, function () // 执行相关操作) 场景 我们想要页面滚动一段距离，比如100px，就让某些元素显示隐藏，那我们怎么知道，页面滚动了100像素呢？ 就可以使用scroll 来检测滚动的距离~~~ 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style body padding-top: 100px; height: 3000px; div display: none; margin: 100px; overflow: scroll; width: 200px; height: 200px; border: 1px solid #000; /style/headbody div 我里面有很多很多的文字 我里面有很多很多的文字 我里面有很多很多的文字 我里面有很多很多的文字 我里面有很多很多的文字 我里面有很多很多的文字 我里面有很多很多的文字 我里面有很多很多的文字 我里面有很多很多的文字 我里面有很多很多的文字 我里面有很多很多的文字 我里面有很多很多的文字 我里面有很多很多的文字 我里面有很多很多的文字 /div script const div = document.querySelector(div) // 页面滚动事件 window.addEventListener(scroll, function () // console.log(我滚了) // 我想知道页面到底滚动了多少像素， 被卷去了多少 scrollTop // 获取html元素写法 // document.documentElement // console.log(document.documentElement.scrollTop) const n = document.documentElement.scrollTop if (n = 100) div.style.display = block else div.style.display = none ) // const div = document.querySelector(div) // div.addEventListener(scroll, function () // // console.log(111) // // scrollTop 被卷去的头部 // console.log(div.scrollTop) // ) /script/body/html 3.10.3 获取滚动位置 属性 scrollLeft和scrollTop （属性） 获取被卷去的大小 获取元素内容往左、往上滚出去看不到的距离 这两个值是可读写的 注意 需要在scroll事件里面获取被卷去的距离 div.addEventListener(scroll, function () console.log(this.scrollTop)) 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style body height: 3000px; /style/headbody script document.documentElement.scrollTop = 800 window.addEventListener(scroll, function () // 必须写到里面 const n = document.documentElement.scrollTop // 得到是什么数据 数字型 不带单位 // console.log(n) ) /script/body/html 3.10.4 滚动到指定的坐标 作用 scrollTo() 方法可把内容滚动到指定的坐标 语法 元素.scrollTo(x, y) 示例 // 让页面滚动到 y 轴 1000像素的位置window.scrollTo(0, 1000) 3.10.5 页面尺寸事件 作用 会在窗口尺寸改变的时候触发事件 语法 resize window.addEventListener(resize, function () // 执行代码) 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style div display: inline-block; /* width: 200px; */ height: 200px; background-color: pink; padding: 10px; border: 20px solid red; /style/headbody div123123123123123123123123123123123123123/div script const div = document.querySelector(div) console.log(div.clientWidth) // resize 浏览器窗口大小发生变化的时候触发的事件 window.addEventListener(resize, function () console.log(1) ) /script/body/html 3.10.6 获取元素高度获取宽高 作用 获取元素的可见部分宽高（不包含边框，margin，滚动条等） clientWidth和clientHeight 3.10.7 元素尺寸与位置 使用场景 前面案例滚动多少距离，都是我们自己算的，最好是页面滚动到某个元素，就可以做某些事 简单说，就是通过js的方式，得到元素在页面中的位置 这样我们可以做，页面滚动到这个位置，就可以做某些操作，省去计算了 获取宽高 获取元素的自身宽高、包含元素自身设置的宽高、padding、border offsetWidth和offsetHeight 获取出来的是数值,方便计算 注意: 获取的是可视宽高, 如果盒子是隐藏的,获取的结果是0 获取位置 获取元素距离自己定位父级元素的左、上距离，如果都没有则以 文档左上角 为准 offsetLeft和offsetTop注意是只读属性 总结 属性 作用 说明 scrollLeft和scrollTop 被卷去的头部和左侧 配合页面滚动来用，可读写 clientWidth 和 clientHeight 获得元素宽度和高度 不包含border,margin，滚动条 用于js获取元素大小，只读属性 offsetWidth和offsetHeight 获得元素宽度和高度 包含border、padding，滚动条等，只读 offsetLeft和offsetTop 获取元素距离自己定位父 获取元素位置的时候使用，只读属性 4. DOM节点移动端滑动4.1 日期对象4.1.1 实例化 概念 在代码中发现了 new 关键字时，一般将这个操作称为实例化 示例 创建一个时间对象并获取时间 获取当前时间 const date = new Date()console.log(date); // Thu Sep 14 2023 14:15:58 GMT+0800 (中国标准时间) 获取指定时间 const date2 = new Date(2023-9-14)console.log(date2); // Thu Sep 14 2023 00:00:00 GMT+0800 (中国标准时间) 4.1.2 日期对象方法 场景 因为日期对象返回的数据我们不能直接使用，所以需要转换为实际开发中常用的格式 方法 作用 说明 getFullYear() 获得年份 获取四位年份 getMonth() 获得月份 取值为 0 ~ 11 getDate() 获取月份中的每一天 不同月份取值也不相同 getDay() 获取星期 取值为 0 ~ 6 getHours() 获取小时 取值为 0 ~ 23 getMinutes() 获取分钟 取值为 0 ~ 59 getSeconds() 获取秒 取值为 0 ~ 59 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script // 获得日期对象 const date = new Date() // 使用里面的方法 console.log(date.getFullYear()) console.log(date.getMonth() + 1) // 月份要 + 1 console.log(date.getDate()) console.log(date.getDay()) // 星期几 /script/body/html 4.1.3 时间戳 场景 如果计算倒计时效果，前面方法无法直接计算，需要借助于时间戳完成 时间戳 是指1970年01月01日00时00分00秒起至现在的毫秒数，它是一种特殊的计量时间的方式 算法 将来的时间戳 - 现在的时间戳 剩余时间毫秒数 剩余时间毫秒数 转换为 剩余时间的 年月日时分秒 就是 倒计时时间 比如 将来时间戳 2000ms - 现在时间戳 1000ms 1000ms 1000ms 转换为就是 0小时0分1秒 三种获取时间戳的方式 使用 getTime() 方法 const date = new Date()console.log(date.getTime()); // 1694672721925 简写 +new Date() console.log(+new Date()); // 1694672721925 使用 Date.now() 无需实例化 但是只能得到当前的时间戳， 而前面两种可以返回指定时间的时间戳 console.log(Date.now()) // 1694672721925 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script // 1. getTime() const date = new Date() console.log(date.getTime()) // 2. +new Date() console.log(+new Date()) // 3. Date.now() console.log(Date.now()); // 2. +new Date() console.log(+new Date()) console.log(-----------------); console.log(+new Date(2022-4-1 18:30:00)) // 我要根据日期 Day() 0 ~ 6 返回的是 星期一 const arr = [星期天, 星期一, 星期二, 星期三, 星期四, 星期五, 星期六] // const date = new Date() console.log(arr[new Date().getDay()]) /script/body/html 4.2 节点操作4.2.1 DOM节点 概念 DOM树里每一个内容都称之为节点 类型 元素节点 所有的标签 比如 body、 div html 是根节点 属性节点 所有的属性 比如 href 文本节点 所有文本 其他 4.2.2 查找节点DOM节点 作用 根据节点关系查找目标节点 节点关系 父节点 子节点 兄弟节点 父节点查找 parentNode 属性 返回最近一级的父节点找不到返回为null 子元素.parentNode 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody div class=yeye div class=dad div class=babyx/div /div /div script const baby = document.querySelector(.baby) console.log(baby) // 返回dom对象 console.log(baby.parentNode) // 返回dom对象 console.log(baby.parentNode.parentNode) // 返回dom对象 /script/body/html 子节点查找 childNodes 获得所有子节点、包括文本节点（空格、换行）、注释节点等 children 属性 （重点） 仅获得所有元素节点 返回的还是一个伪数组 父元素.children 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody ul li1/li li2/li li3/li li4/li li5/li /ul script // const ul = document.querySelector(ul) // ul console.log(ul.children) // 得到伪数组 选择的是 亲儿子 /script/body/html 兄弟关系查找 下一个兄弟节点 nextElementSibling属性 上一个兄弟节点 previousElementSibling属性 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody ul li1/li li2/li li3/li li4/li li5/li /ul script const li2 = document.querySelector(ul li:nth-child(2)) console.log(li2.previousElementSibling) // 上一个兄弟 console.log(li2.nextElementSibling) // 下一个兄弟 /script/body/html 4.2.3 增加节点 场景 很多情况下，我们需要在页面中增加元素 比如，点击发布按钮，可以新增一条信息 创建节点 即创造出一个新的网页元素，再添加到网页内，一般先创建节点，然后插入节点 创建元素节点方法 // 创建一个新的元素节点document.createElement(标签名) 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody ul li我是老大/li /ul script // // 1. 创建节点 // const div = document.createElement(div) // // console.log(div) // 2. 追加节点 作为最后一个子元素 // document.body.appendChild(div) const ul = document.querySelector(ul) const li = document.createElement(li) li.innerHTML = 我是li // ul.appendChild(li) // ul.children // 3. 追加节点 // insertBefore(插入的元素, 放到哪个元素的前面) ul.insertBefore(li, ul.children[0]) /script/body/html 追加节点 插入到父元素的最后一个子元素 // 插入到这个父元素的最后父元素.appendChild(要插入的元素) 插入到父元素中某个子元素的前面 // 插入到某个子元素的前面父元素.insertBefore(要插入的元素，在哪个元素前面) 克隆节点 方法 // 克隆一个已有的元素节点元素.cloneNode(布尔值)cloneNode会克隆出一个跟原标签一样的元素，括号内传入布尔值- 若为true，则代表克隆时会包含后代节点一起克隆- 若为false，则代表克隆时不包含后代节点- 默认为false 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody ul li1/li li2/li li3/li /ul script const ul = document.querySelector(ul) // 1 克隆节点 元素.cloneNode(true) // const li1 = ul.children[0].cloneNode(true) // console.log(li1) // 2. 追加 ul.appendChild(ul.children[0].cloneNode(true)) /script/body/html 4.2.4 删除节点 作用 若一个节点在页面中已不需要时，可以删除它 语法 父元素.removeChild(要删除的元素) 注意 在 JavaScript 原生DOM操作中，要删除元素必须通过父元素删除 如不存在父子关系则删除不成功 删除节点和隐藏节点（display:none） 有区别的： 隐藏节点还是存在的，但是删除，则从html中删除节点 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style .box display: none; /style/headbody div class=box123/div ul li没用了/li /ul script const ul = document.querySelector(ul) // 删除节点 父元素.removeChlid(子元素) ul.removeChild(ul.children[0]) /script/body/html 5. BOM操作5.1 Window对象5.1.1 BOM 概念 BOM(Browser Object Model ) 是浏览器对象模型 window对象是一个全局对象，也可以说是JavaScript中的顶级对象 像document、alert()、console.log()这些都是window的属性，基本BOM的属性和方法都是window的。 所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法 window对象下的属性和方法调用的时候可以省略window 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script // document.querySelector() // window.document.querySelector() console.log(document === window.document) function fn() console.log(11) window.fn() var num = 10 console.log(window.num) /script/body/html 5.1.2 定时器-延时函数 作用 JavaScript 内置的一个用来让代码延迟执行的函数，叫 setTimeout 语法 setTimeout(回调函数, 等待的毫秒数) setTimeout 仅仅只执行一次，所以可以理解为就是把一段代码延迟执行, 平时省略window 清除延时函数 let timer = setTimeout(回调函数, 等待的毫秒数)clearTimeout(timer) 注意 延时器需要等待,所以后面的代码先执行 每一次调用延时器都会产生一个新的延时器 对比 延时函数：执行一次 间歇函数：没隔一段时间就执行一次，除非手动清除 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style img position: fixed; left: 0; bottom: 0; /style/headbody img src=./images/ad.png alt= script // 1.获取元素 const img = document.querySelector(img) setTimeout(function () img.style.display = none , 3000) /script/body/html 5.1.3 JS执行机制 思考？ 输出结果是什么？ console.log(111);setTimeout(function () console.log(222);, 0)console.log(333); JS执行机制 JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事 这是因为 Javascript 这门脚本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作DOM 而诞生的。比如我们对某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉 为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程。于是，JS 中出现了同步和异步 同步 前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜 异步 你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜 他们的本质区别： 这条流水线上各个流程的执行顺序不同 同步任务 同步任务都在主线程上执行，形成一个执行栈 异步任务 JS 的异步是通过回调函数实现的 一般而言，异步任务有以下三种类型: 普通事件，如 click、resize 等 资源加载，如 load、error 等 定时器，包括 setInterval、setTimeout 等 异步任务相关添加到任务队列中（任务队列也称为消息队列） 执行顺序 先执行执行栈中的同步任务 异步任务放入任务队列中 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行 由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（ event loop） 5.1.4 location对象 作用 location 的数据类型是对象，它拆分并保存了 URL 地址的各个组成部分 常用属性和方法 href 属性获取完整的 URL 地址，对其赋值时用于地址的跳转 search属性获取地址中携带的参数，符号 ？后面部分 hash 属性获取地址中的啥希值，符号 # 后面部分 reload方法用来刷新当前页面，传入参数 true 时表示强制刷新 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody form action= input type=text name=username input type=password name=pwd button提交/button /form a href=#/my我的/a a href=#/friend关注/a a href=#/download下载/a button class=reload刷新/button script // console.log(window.location) // console.log(location) // console.log(location.href) // 1. href 经常用href 利用js的方法去跳转页面 // location.href = http://www.baidu.com const reload = document.querySelector(.reload) reload.addEventListener(click, function () // f5 刷新页面 // location.reload() // 强制刷新 ctrl+f5 location.reload(true) ) /script/body/html 5.1.5 navigator对象 作用 navigator的数据类型是对象，该对象下记录了浏览器自身的相关信息 常用属性和方法 通过 userAgent 检测浏览器的版本及平台 // 检测 userAgent（浏览器信息）!(function () const userAgent = navigator.userAgent// 验证是否为Android或iPhoneconst android = userAgent.match(/(Android);?[\\s\\/]+([\\d.]+)?/)const iphone = userAgent.match(/(iPhone\\sOS)\\s([\\d_]+)/)// 如果是Android或iPhone，则跳转至移动站点if (android || iphone) location.href = http://m.itcast.cn )() 5.1.6 histroy对象 作用 history 的数据类型是对象，主要管理历史记录， 该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等 常用属性和方法 方法 作用 back() 后退功能 forward() 前进功能 go(参数) 前进后退功能 参数如果是 1 前进1个页面 如果是-1 后退1个页面 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody button后退/button button前进/button script const back = document.querySelector(button:first-child) const forward = back.nextElementSibling back.addEventListener(click, function () // 后退一步 // history.back() history.go(-1) ) forward.addEventListener(click, function () // 前进一步 // history.forward() history.go(1) ) /script/body/html 5.2 本地存储5.2.1 本地存储介绍 以前我们页面写的数据一刷新页面就没有了，是不是？ 随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案 数据存储在用户浏览器中 设置、读取方便、甚至页面刷新不丢失数据 容量较大，sessionStorage和localStorage约 5M 左右 常见的使用场景： https://todomvc.com/examples/vanilla-es6/ 页面刷新数据不丢失 5.2.2 本地存储分类 localStorage 能够使用localStorage 把数据存储的浏览器中 作用 可以将数据永久存储在本地(用户的电脑), 除非手动删除，否则关闭页面也会存在 特性 可以多窗口（页面）共享（同一浏览器可以共享） 以键值对的形式存储使用 语法 // 存储数据localStorage.setItem(key, value)// 获取数据localStorage.getItem(key)// 删除数据localStorage.removeItem(key) 浏览器查看本地数据 sessionStorage 特性 生命周期为关闭浏览器窗口 在同一个窗口(页面)下数据可以共享 以键值对的形式存储使用 用法跟localStorage 基本相同 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script // 1. 要存储一个名字 uname， pink老师 // localStorage.setItem(键，值) localStorage.setItem(uname, pink老师) // 2. 获取方式 都加引号 console.log(localStorage.getItem(uname)) // 3. 删除本地存储 只删除名字 // localStorage.removeItem(uname) // 4. 改 如果原来有这个键，则是改，如果么有这个键是增 localStorage.setItem(uname, red老师) // 我要存一个年龄 // 2. 本地存储只能存储字符串数据类型 localStorage.setItem(age, 18) console.log(localStorage.getItem(age)) /script/body/html 5.2.3 存储复杂数据类型 问题1 本地只能存储字符串,无法存储复杂数据类型 解决 需要将复杂数据类型转换成JSON字符串,在存储到本地 语法 JSON.stringify(复杂数据类型) 问题2 因为本地存储里面取出来的是字符串，不是对象，无法直接使用 解决 把取出来的字符串转换为对象 语法 JSON.parse(JSON字符串) 将JSON字符串转换成对象 取出 时候使用 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script const obj = uname: pink老师, age: 18, gender: 女 // // 存储 复杂数据类型 无法直接使用 // localStorage.setItem(obj, obj) [object object] // // 取 // console.log(localStorage.getItem(obj)) // 1.复杂数据类型存储必须转换为 JSON字符串存储 localStorage.setItem(obj, JSON.stringify(obj)) // JSON 对象 属性和值有引号，而是引号统一是双引号 // uname:pink老师,age:18,gender:女 // 取 // console.log(typeof localStorage.getItem(obj)) // 2. 把JSON字符串转换为 对象 const str = localStorage.getItem(obj) // uname:pink老师,age:18,gender:女 console.log(JSON.parse(str)) /script/body/html 6. 正则表达式6.1 介绍 正则表达式（Regular Expression）是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象 通常用来查找、替换那些符合正则表达式的文本 请在下图中找出【戴帽子和眼镜的男人】 戴帽子、戴眼镜、男人都是描述信息，通过这些信息能够在人群中查找到确定的某个人，那么这些用于查找的描述信息编写一个模式，对应到计算机中就是所谓的正则表达式 正则表达式在 JavaScript中的使用场景 例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(匹配) 比如用户名: ^[a-z0-9_-]{3,16}$ 过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 6.2 语法 我们想要查找是否有戴眼镜的人, 怎么做呢？ 定义规则： 戴眼镜的 根据规则去查找：找到则返回 正则同样道理，我们分为两步 定义规则 查找 语法 定义正则表达式语法 const 变量名 = /表达式/其中 / / 是正则表达式字面量比如：const reg = /前端/ 判断是否有符合规则的字符串 test()方法 用来查看正则表达式与指定的字符串是否匹配 regObj.test(被检测的字符串)// 要检测的字符串const str = IT培训,前端那开发培训,web前端,软件测试// 定义正则表达式，检测规则const reg = /前端/reg.test(str) //true 检索（查找）符合规则的字符串 exec() 方法 在一个指定字符串中执行一个搜索匹配 regObj.exec(被检测的字符串)// 要检测的字符串const str = IT培训,前端那开发培训,web前端,软件测试// 定义正则表达式，检测规则const reg = /前端/reg.exec(str) //返回数组 如果匹配成功，exec() 方法返回一个数组，否则返回null 替换字符串 replace ()方法 字符串.replace(/正则表达式/, 替换文本) 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script const str = 我们在学习前端，希望学习前端能高薪毕业 // 正则表达式使用： // 1. 定义规则 const reg = /前端/ // 2. 是否匹配 // console.log(reg.test(str)) // true // 3. exec() console.log(reg.exec(str)) // 返回数组 /script/body/html 6.3 元字符 普通字符 大多数的字符仅能够描述它们本身，这些字符称作普通字符，例如所有的字母和数字 也就是说普通字符只能够匹配字符串中与它们相同的字符 元字符(特殊字符） 是一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能。 比如，规定用户只能输入英文26个英文字母，普通字符的话 abcdefghijklm….. 但是换成元字符写法： [a-z] 为了方便记忆和学习，我们对众多的元字符进行了分类 边界符（表示位置，开头和结尾，必须用什么开头，用什么结尾） 量词 （表示重复次数） 字符类 （比如 \\d 表示 0~9） 边界符 正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符 边界符 说明 ^ 表示匹配行首的文本（以谁开始） $ 表示匹配行尾的文本（以谁结束） 如果 ^ 和 $ 在一起，表示必须是精确匹配 示例 // 1. 边界符console.log(/^哈/.test(哈)) // trueconsole.log(/^哈/.test(哈哈)) // trueconsole.log(/^哈/.test(二哈)) // flaseconsole.log(/^哈$/.test(哈)) // true 只有这种情况为true 否则全是falseconsole.log(/^哈$/.test(哈哈)) // falseconsole.log(/^哈$/.test(二哈)) // false 量词 （表示重复次数） 量词用来 设定某个模式出现的次数 量词 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 注意： 逗号左右两侧千万不要出现空格 示例 // 量词 * 类似 =0 次console.log(/^哈$/.test(哈)) // trueconsole.log(/^哈*$/.test()) // trueconsole.log(/^哈*$/.test(哈)) // trueconsole.log(/^哈*$/.test(哈哈)) // trueconsole.log(/^哈*$/.test(二哈很傻)) // falseconsole.log(/^哈*$/.test(哈很傻)) // falseconsole.log(/^哈*$/.test(哈很哈)) // falseconsole.log(------------------)// 量词 + 类似 =1 次console.log(/^哈$/.test(哈)) // trueconsole.log(/^哈+$/.test()) // falseconsole.log(/^哈+$/.test(哈)) // trueconsole.log(/^哈+$/.test(哈哈)) // trueconsole.log(/^哈+$/.test(二哈很傻)) // falseconsole.log(/^哈+$/.test(哈很傻)) // falseconsole.log(/^哈+$/.test(哈很哈)) // falseconsole.log(------------------)// 量词 ? 类似 0 || 1console.log(/^哈?$/.test()) // trueconsole.log(/^哈?$/.test(哈)) // trueconsole.log(/^哈?$/.test(哈哈)) // trueconsole.log(/^哈?$/.test(二哈很傻)) // falseconsole.log(/^哈?$/.test(哈很傻)) // falseconsole.log(/^哈?$/.test(哈很哈)) // falseconsole.log(------------------)// 量词 n 写几，就必须出现几次console.log(/^哈4$/.test(哈))console.log(/^哈4$/.test(哈哈))console.log(/^哈4$/.test(哈哈哈))console.log(/^哈4$/.test(哈哈哈哈))console.log(/^哈4$/.test(哈哈哈哈哈))console.log(/^哈4$/.test(哈哈哈哈哈哈))console.log(------------------)// 量词 n, =nconsole.log(/^哈4,$/.test(哈))console.log(/^哈4,$/.test(哈哈))console.log(/^哈4,$/.test(哈哈哈))console.log(/^哈4,$/.test(哈哈哈哈))console.log(/^哈4,$/.test(哈哈哈哈哈))console.log(/^哈4,$/.test(哈哈哈哈哈哈))console.log(------------------)// 量词 n,m 逗号左右两侧千万不能有空格 =n = mconsole.log(/^哈4,6$/.test(哈))console.log(/^哈4,6$/.test(哈哈))console.log(/^哈4,6$/.test(哈哈哈))console.log(/^哈4,6$/.test(哈哈哈哈))console.log(/^哈4,6$/.test(哈哈哈哈哈))console.log(/^哈4,6$/.test(哈哈哈哈哈哈))console.log(/^哈4,6$/.test(哈哈哈哈哈哈哈)) 字符类 （比如 \\d 表示 0~9） [ ] 匹配字符集合 后面的字符串只要包含 abc 中任意一个字符，都返回 true 。 [ ] 里面加上 - 连字符 使用连字符 - 表示一个范围 [a-z] 表示 a 到 z 26个英文字母都可以 [a-zA-Z] 表示大小写都可以 [0-9] 表示 0~9 的数字都可以 [ ] 里面加上 ^ 取反符号 [^a-z] 匹配除了小写字母以外的字符 注意要写到中括号里面 . 匹配除换行符之外的任何单个字符 预定义 指的是 某些常见模式的简写方式 预定类 说明 \\d 匹配0-9间的任一数字，相当于[0-9] \\D 匹配所有0-9以外的字符，相当于[ ^0-9] \\w 匹配任意的字母、数字和下划线相当于[A-Za-z0-9_] \\W 除所有字母、数字和下划线以外的字符，相当于[ ^A-Za-z0-9_] \\s 匹配空格（包括换行符、制表符、空格符等），相当于[\\t\\r \\v\\f] \\S 匹配非空格的字符，相当于[ ^\\t\\r \\v\\f] 示例 // 字符类 [abc] 只选1个console.log(/^[abc]$/.test(a)) // trueconsole.log(/^[abc]$/.test(b)) // trueconsole.log(/^[abc]$/.test(c)) // trueconsole.log(/^[abc]$/.test(ab)) // falseconsole.log(/^[abc]2$/.test(ab)) // trueconsole.log(------------------)// 字符类 [a-z] 只选1个console.log(/^[A-Z]$/.test(p)) // falseconsole.log(/^[A-Z]$/.test(P)) // trueconsole.log(/^[0-9]$/.test(2)) // trueconsole.log(/^[a-zA-Z0-9]$/.test(2)) // trueconsole.log(/^[a-zA-Z0-9]$/.test(p)) // trueconsole.log(/^[a-zA-Z0-9]$/.test(P)) // true 6.4 修饰符 作用 修饰符约束正则执行的某些细节行为，如是否区分大小写、是否支持多行匹配等 语法 /表达式/修饰符 i 是单词 ignore 的缩写，正则匹配时字母不区分大小写 g 是单词 global 的缩写，匹配所有满足正则表达式的结果 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script console.log(/^java$/.test(java)) console.log(/^java$/i.test(JAVA)) console.log(/^java$/i.test(Java)) const str = java是一门编程语言， 学完JAVA工资很高 // const re = str.replace(/java|JAVA/g, 前端) const re = str.replace(/java/ig, 前端) console.log(re) // 前端是一门编程语言， 学完前端工资很高 /script/body/html","tags":["DOM","BOM","DOM事件","正则表达式"],"categories":["前端"]},{"title":"JavaScript基础","path":"/2023/12/04/2023-12-04-JavaScrpit基础/","content":"JavaScript 简介JavaScript 是什么 JavaScript （是什么？） 是一种运行在客户端（浏览器）的编程语言，实现人机交互效果 作用（做什么？） 网页特效 (监听用户的一些行为让网页作出对应的反馈) 表单验证 (针对表单数据的合法性进行判断) 数据交互 (获取后台的数据, 渲染到前端) 服务端编程 (node.js) JavaScript 的组成 权威网站：MDN Web Docs (mozilla.org) ECMAScript：规定了 js 基础语法核心知识。比如：变量、分支语句、循环语句、对象等等 Web APIs DOM：操作文档，比如对页面元素进行移动、大小、添加删除等操作 BOM：操作浏览器，比如页面弹窗，检测窗口宽度、存储数据到浏览器等等 JavaScript 书写位置 内部 JavaScript 位置 直接写在 HTML 文件里，用 script 标签包住 规范 script 标签写在 /body 上面 注意 我们将 script 放在 HTML 文件的底部 附近的原因是浏览器会按照代码在文件中的 顺序加载 HTML。如果先加载的 JavaScript 期望修改其下方的 HTML，那么它可能由于 HTML 尚未被加载而失效。因此，将 JavaScript 代码放在 HTML 页面的底部附近通常是最好的策略 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script alert(你好！) /script/body/html 外部 JavaScript 位置 代码写在以.js 结尾的文件里 规范 通过 script 标签，引入到 HTML 页面中 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script src=my.js/script/body/html 内联 JavaScript 位置 代码写在标签内部 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody button onclick=alert(你好)“点击/button/body/html 注释 单行注释 符号： 作用：右边这一行的代码会被忽略 快捷键：ctrl + / 块注释 符号：** 作用：在和 之间的所有内容都会被忽略 快捷键：shift + alt + A 输入输出语法 输出语法 输出语法 1 语法：document.write() 作用：向 body 内输出内容 输出语法 2 语法：alert() 作用：页面弹出警告对话框 输出语法 3 语法：console.log() 作用：控制台输出语法，程序员调试使用 输入语法 语法：prompt() 作用：显示一个对话框，对话框中包含一条文字信息，用来提示用户输入文字 字面量在计算机科学中，字面量（literal）是在计算机中描述 事物 我们工资是： 1000 此时 1000 就是 数字字面量 程序员 字符串字面量 还有接下来我们学的 [] 数组字面量 {} 对象字面量 等等 变量变量命名规则与规范 规则 不能用关键字 关键字：有特殊含义的字符，JavaScript 内置的一些英语词汇。例如：let、var、if、for 等 只能用下划线、字母、数字、$组成，且数字不能开头 字母严格区分大小写，如 Age 和 age 是不同的变量 规范 起名要有意义 遵守小驼峰命名法 第一个单词首字母小写，后面每个单词首字母大写。例：userName 示例 # 变量声明let 变量名示例：let age# 变量赋值let name = 张三# 变量更新name = 李四 let 与 var 的区别 区别 在较旧的 JavaScript，使用关键字 var 来声明变量 ，而不是 let var 现在开发中一般不再使用它，只是我们可能再老版程序中看到它 let 为了解决 var 的一些问题。 var 声明 可以先使用 在声明 (不合理) var 声明过的变量可以重复声明(不合理) 比如变量提升、全局变量、没有块级作用域等等 常量 概念 使用 const 声明的变量称为“常量” 使用场景 当某个变量永远 不会改变 的时候，就可以使用 const 来声明，而不是 let 命名规范：和变量一致 常量使用 const G = 9.8console.log(G) 注意 常量不允许重新赋值, 声明的时候必须赋值（初始化） 数据类型 基本数据类型 number 数字型string 字符串型boolean 布尔型undefined 未定义型null 空类型 引用数据类型 object 对象 数字类型（Number） 概念 即我们数学中学习到的数字，可以是整数、小数、正数、负数。 JavaScript 中的正数、负数、小数等 统一称为 数字类型。 示例 let age = 18let price = 88.99 注意 JS 是弱数据类型，变量到底属于那种类型，只有赋值之后，我们才能确认。 NaN NaN 代表一个计算错误。它是一个不正确的或者一个未定义的数学操作所得到的结果。 console.log(老师 - 2) // NaN NaN 是粘性的，任何对 NaN 的操作都会返回 NaN console.log(NaN + 2) // NaN 字符串类型（string） 概念 通过单引号（’’） 、双引号（””）或反引号() 包裹的数据都叫字符串，单引号和双引号没有本质上的区别，推荐使用单引号。 模板字符串 使用场景：拼接字符串和变量 语法： (反引号) 内容拼接变量时，用 ${ } 包住变量 document.write(`大叫好，我叫$name`) 布尔类型（boolean） 概念 表示肯定或否定时在计算机中对应的是布尔类型数据 它有两个固定的值 true 和 false，表示肯定的数据用 true（真），表示否定的数据用 false（假） 示例 script // 1. 布尔型 true false console.log(true) console.log(false)/script 未定义类型（undefined） 概念 未定义是比较特殊的类型，只有一个值 undefined。 什么情况出现未定义类型？ 只声明 变量，不赋值 的情况下，变量的默认值为 undefined，一般很少【直接】为某个变量赋值为 undefined。 使用场景 我们开发中经常声明一个变量，等待传送过来的数据。 如果我们不知道这个数据是否传递过来，此时我们可以通过检测这个变量是不是 undefined，就判断用户是否有数据传递过来 示例 // undefined 只声明不赋值let ageconsole.log(age) null（空类型） 概念 JavaScript 中的 null 仅仅是一个代表 “无”、“空” 或 “值未知” 的特殊值。 null 和 undefined 区别 undefined 表示没有赋值 null 表示赋值了，但是内容为空 使用场景 官方解释：把 null 作为尚未创建的对象 大白话： 将来有个变量里面存放的是一个对象，但是对象还没创建好，可以先给个 null 示例 // null 空let obj = nullconsole.log(obj) 检测数据类型 作用 typeof 运算符可以返回被检测的数据类型。 语法 作为运算符： typeof x （常用的写法） 函数形式： typeof(x) 换言之，有括号和没有括号，得到的结果是一样的，所以我们直接使用运算符的写法。 示例 script // 返回的什么类型 console.log(typeof 123) //number console.log(typeof 123) //string console.log(typeof true) //boolean console.log(typeof undefined) //undefined console.log(typeof null) //object let num = 10 console.log(typeof num + 11) //number11/script 类型转换 为什么需要类型转换？ JavaScript 是弱数据类型： JavaScript 也不知道变量到底属于那种数据类型，只有赋值了才清楚。 坑： 使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算。 隐式转换 某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。 规则 +号两边只要有一个是字符串，都会把另外一个转成字符串 除了+以外 的算术运算符 比如 - * 等都会把数据转成 数字类型 小技巧 + 号作为正号解析可以转换成数字型 任何数据和字符串相加结果都是字符串 示例 script // let num = prompt(请输入一个数字) // console.log(num, typeof num) // 内部悄悄的把 18 转换为了字符串的 18 console.log(pink老师 + 18) console.log(10 + 10) // 1010 // - * / 把 字符串的 10 转换为 数字型 10 console.log(10 - 10) // 0 // 小技巧 let num = 10 console.log(num) console.log(+num) // console.log(-num) console.log(10 + +10)/script 显式转换 编写程序时过度依靠系统内部的隐式转换是不严禁的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。 概念 自己写代码告诉系统该转成什么类型 转成数字类型 Number(数据) 如果字符串内容里有非数字，转换失败时结果为 NaN（Not a Number）即不是一个数字 NaN 也是 number 类型的数据，代表非数字 parseInt(数据) 只保留整数 parseFloat(数据) 可以保留小数 示例 script // let num = 10 // Number(数据) console.log(Number(10.01)) //10.01 // 转换为数字型，只保留整数，没有四舍五入 console.log(parseInt(10)) //10 console.log(parseInt(10.111)) //10 console.log(parseInt(10.999px)) //10 // 转换为数字型，会保留小数 console.log(parseFloat(10.999)) //10.999 // 区别： // 1.Number() 只能放数字类型的字符，不能放abc这样的 // 否则返回的是 NaN not A number console.log(Number(10.01abc)) //NaN // parseFloat 经常用于过滤px单位 console.log(parseFloat(10.01abc)) //10.01 console.log(parseFloat(100px)) // 100 console.log(parseFloat(px100px)) //NaN/script 转换为字符型 String(数据) console.log(String(10)) 变量.toString(进制) let age = 10console.log(age.toString())// 括号里面如果是2 转换为 二进制console.log(age.toString(2)) //1010 运算符赋值运算符 作用 对变量进行赋值的运算符 类型 将等号右边的值赋予给左边, 要求左边必须是一个容器 + - * % 示例 script let num = 18 num = num + 1 num = num + 3 num += 3 console.log(num) // 两个变量的 把i加到 sum 里面去 let i = 1 let sum = 0 sum = sum + i sum += i /script 一元运算符 自增 符号：++ 作用：让变量的值 +1 自减 符号：– 作用：让变量的值 -1 场景 经常用于计数来使用。 比如进行 10 次操作，用它来计算进行了多少次了 示例 script let num = 10 // 一元运算符 // ++num 等价于 num += 1 num++ console.log(num) // 前置自增 let i = 1 // 先自加 再使用 console.log(++i + 2) // 4 // 后置自增 let i = 1 // 先使用 后自加 console.log(i++ + 2) // console.log(i) /script 比较运算符 比较运算符 ： 左边是否大于右边： 左边是否小于右边=： 左边是否大于或等于右边=： 左边是否小于或等于右边==： 左右两边值是否相等===： 左右两边是否类型和值都相等!==： 左右两边是否不全等// 比较结果为boolean类型，即只会得到 true 或 false 对比 = 单等是赋值== 是判断=== 是全等// 开发中判断是否相等，强烈推荐使用 === 字符串比较，是比较的字符对应的 ASCII 码 从左往右依次比较 如果第一位一样再比较第二位，以此类推 比较的少，了解即可 NaN 不等于任何值，包括它本身 涉及到 “NaN” 都是 false 尽量不要比较小数，因为小数有精度问题 不同类型之间比较会发生隐式转换 最终把数据隐式转换转成 number 类型再比较 示例 开发中，如果进行准确的比较我们更喜欢 === 或者 !== script console.log(3 5) // false console.log(5 = 5) // true // console.log(5 = 5) console.log(5 == 5) // true // == 只要值一样就是true 不管数据类型 console.log(5 == 5) // true console.log(5 == pink) // false // === 以后判断要用 === 开发常用 要求值和数据类型都一样 console.log(5 === 5) // true console.log(5 === 5) // false // 特殊情况 console.log(pink red) // false console.log(pink pin) // true console.log(1 === NaN) // false console.log(NaN === NaN) // false console.log(0.1 + 0.2 === 0.3) // false console.log(0.1 + 0.2) // 0.30000000000000004 console.log(3 2) // ture/script 逻辑运算符 作用 符号 名称 日常读法 特点 口诀 逻辑与 并且 符号两边都为 true 结果才为 true 一假则假 || 逻辑或 或者 符号两边有一个 true 就为 true 一真则真 ! 逻辑非 取反 true 变 false 真变假，假变真\\ 示例 script // 逻辑与 一假则假 console.log(true true) console.log(false true) // 逻辑或 一真则真 console.log(false || true) console.log(false || false) // 逻辑非 取反 console.log(!true) console.log(!false) // 有5个值是当 false 来看的 其余是真的 // false 数字0 undefined null /script 语句表达式和语句 概念 表达式：表达式是可以被求值的代码，JavaScript 引擎会将其计算出一个结果 语句：语句是一段可以执行的代码 比如： prompt() 可以弹出一个输入框，还有 if 语句 for 循环语句等等 区别 表达式：因为表达式可被求值，所以它可以写在赋值语句的右侧 表达式 num = 3 + 4 语句：而语句不一定有值，所以比如 alert()、for 和 break 等语句就不能被用于赋值 语句 alert() 弹出对话框 console.log() 控制台打印输出 分支语句if 分支语句 if 语句有三种使用：单分支、双分支、多分支 单分支 if (false) alert(11) 双分支 // 计算工资// 1. 用户输入工龄let age = +prompt(请输入工龄)let money = 10000// 2. 执行分支语句if (age = 1) alert(`您实发工资:$money + 2000`) else alert(`您实发工资:$money`) 多分支 // 1. 用户输入时间 等我们学api 自动获取时间let time = prompt(请输入小时：)// 2. 多分支判断if (time 12) document.write(`上午好，好好工作`) else if (time 18) document.write(`下午好，好好工作`) else if (time 20) document.write(`晚上好，好好加班`) else document.write(`夜深了，头发还有吗？`) 三元运算符 符号：? 与 : 配合使用 语法 条件 ? 满足条件执行代码 : 不满足条件执行的代码 示例 // 3 5 ? alert(第一个) : alert(第二个)let num1 = 40let num2 = 30num1 num2 ? console.log(num1) : console.log(num2)// let re = num1 num2 ? num1 : num2let re = num1 num2 ? num1 : num2console.log(re) switch switch 语句 switch(数据) case 值1: 代码1 break case 值2: 代码2 break default: 代码n break 注意 switch case 语句一般用于等值判断，不适合于区间判断 switch case 一般需要配合 break 关键字使用，没有 break 会造成 case穿透 示例 switch (2) case 1: alert(1) break case 2: alert(2) break case 3: alert(3) break default: alert(没有数据) 循环语句while 语法 while(循环条件) 要重复执行的代码(循环体) 作用 循环的本质就是以某个变量为起始值，然后不断产生变化量，慢慢靠近终止条件的过程。 所以，while 循环需要具备三要素： 变量起始值 终止条件（没有终止条件，循环会一直执行，造成死循环） 变量变化量（用自增或者自减） 退出循环 continue 结束本次循环 继续下一次循环 continue 结束本次循环 继续下一次循环 break 可以直接退出循环 示例 // 求 1~100 之间的偶数累加和let i = 1let sum = 0while (i = 100) if (i % 2 === 0) // 此时 i 一定是偶数 sum = sum + i // 不管你是偶数还是奇数我都要++ i++console.log(sum)// 退出循环-我们要打印吃包子let i = 1while (i = 6) if (i === 3) i++ // continue 结束本次循环 继续下一次循环 // continue // 退出循环 break document.write(`我要吃第$i个包子 br`) i++ for 作用 重复执行代码 好处 把声明起始值、循环条件、变化值写到一起，让人一目了然，它是最常使用的循环形式 for(变量起始值; 终止条件; 变量变化量) // 循环体 退出循环 continue 退出本次循环，一般用于排除或者跳过某一个选项的时候, 可以使用 continue break 退出整个 for 循环，一般用于结果已经得到, 后续的循环不需要的时候可以使用 示例 for (let i = 1; i 6; i++) if (i === 2) // continue // 1345 继续 退出本次循环，继续下一次循环 break // 结束循环 退出整个循环 document.write(i)// 循环嵌套for (let i = 1; i 6; i++) for (let j = 1; j 6; j++) document.write(星) // 外面循环执行一次，里面循环执行全部（5次） 数组数组基本使用 概念 一种将一组数据存储在单个变量名下的优雅方式 示例 let 数组名 = [数据1,数据2,...,数据n]// 示例let names = [小明,小白,小往,小宏]// 取值数组名[下标]// 示例names[0] // 小明names[1] // 小白// 数组长度names.length 遍历数组 for 循环遍历数组 let nums = [10,20,30,40,50]for (let i = 0; i nums.length; i++) document.write(nums[i]) map 迭代数组 const arr = [pink, red, black]arr.map(function (item, index) console.log(item); // item 得到数组元素 console.log(index); // index 得到索引号) forEach(重点) 语法：被遍历的数组.forEach(function(当前数组元素，当前元素索引号) // 函数体)// forEach 就是遍历 加强版的for循环 适合于遍历数组对象const arr = [red, green, pink]const result = arr.forEach(function (item, index) console.log(item) // 数组元素 red green pink console.log(index) // 索引号)// console.log(result) 注意 forEach 主要是遍历数组 参数当前数组元素是必须要写的， 索引号可选 操作数组操作总览 查询 语法 数组[下标] 示例 let arr = [pink, hotpink, deeppink]// 访问 / 查询console.log(arr[0]) 添加 push 作用 数组.push() 方法将一个或多个元素添加到数组的 末尾，并返回该 数组的新长度 (重点) 示例 // 语法arr.push(元素1,...,元素n)// 示例let arr = [red, green]arr.push(pink, hot)console.log(arr) // [red, green, pink, hot] unshift 作用 arr.unshift(新增的内容) 方法将一个或多个元素添加到数组的 开头，并返回该 数组的新长度 示例 // 语法arr.unshift(元素1,...,元素n)// 示例let arr = [red, green]arr.unshift(pink, hot)console.log(arr) // [pink, hot,red, green] 删除 pop 作用 数组. pop() 方法从数组中删除 最后一个元素，并返回 该元素的值 示例 // 语法arr.pop()// 示例let arr = [red, green]arr.pop() // greenconsole.log(arr) // [red] shift 作用 数组. shift() 方法从数组中删除 第一个元素，并返回 该元素的值 示例 // 语法arr.shift()// 示例let arr = [red, green]arr.shift() // redconsole.log(arr) // [green] splice 作用 数组. splice() 方法 删除 指定元素 示例 // 语法arr.splice(start, deleteCount)arr.splice(起始位置, 删除几个元素)start 起始位置：指定修改的开始位置（从0计数）deleteCount： - 表示要移除的数组元素的个数 - 可选的。 如果省略则默认从指定的起始位置删除到最后 数组常用方法map 作用 map() 可以处理数据，并且 返回新的数组 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script const arr = [red, blue, green] // map 方法也是遍历 处理数据 可以返回一个数组 const newArr = arr.map(function (item, i) // console.log(item) // 数组元素 red // console.log(i) // 下标 return item + 老师 ) console.log(newArr) [red老师, blue老师, green老师] const arr1 = [10, 20, 30] const newArr1 = arr1.map(function (item) return item + 10 ) console.log(newArr1) /script/body/html join 作用 join() 方法用于把数组中的所有元素转换一个字符串 参数 数组元素是通过参数里面指定的分隔符进行分隔的 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title/headbody script const arr = [red, blue, green] // 把数组元素转换为字符串 console.log(arr.join(*)) /script/body/html filter 作用 filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中 符合条件 的所有元素 使用场景 筛选数组符合条件的元素，并返回筛选之后元素的新数组 语法 被遍历的数组.filter(function(currentValue, index)) return 筛选条件 返回值 返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组 因为返回新数组，所以不会影响原数组 参数 currentValue 必须写 index 可选 示例 被遍历的数组.filter(function(currentValue, index)) return 筛选条件const arr = [10, 20, 30]// const newArr = arr.filter(function (item, index) // // console.log(item)// // console.log(index)// return item = 20// )// 返回的符合条件的新数组const newArr = arr.filter(item = item = 20)console.log(newArr) 函数 function，是被设计为执行特定任务的代码块 函数可以把具有相同或相似逻辑的代码 “包裹” 起来，通过函数调用执行这些被 “包裹” 的代码逻辑，这么做的优势是有利于 精简代码方便复用 比如我们前面使用的 alert() 、 prompt() 和 console.log() 都是一些 js 函数，只不过已经封装好了，我们直接使用的 函数使用 声明 1.函数声明function 函数名() 函数体示例：function sayHi() document.write(hi) 调用 2.函数的调用函数名()示例：// 函数一次声明可以多次调用，每一次函数调用函数体里面的代码都会执行一次sayHi()sayHi() 函数体函数体是函数的构成部分，它负责将相同或相似代码 “包裹” 起来，直到函数调用时函数体内的代码才会被执行。函数的功能代码都要写在函数体当中 函数传参 声明 1.声明语法function 函数名(参数列表) 函数体示例：- 单个参数function getSquare(num1) document.write(num1 * num1)- 多个参数function getSquare(num1, num2) document.write(num1 * num2) 调用 2.调用语法函数名(传递的参数列表)示例：getSquare(8)getSquare(10,20) 形参：声明函数 时写在函数名右边小括号里的叫形参（形式上的参数） 实参：调用函数 时写在函数名右边小括号里的叫实参（实际上的参数） 形参可以理解为是 在这个函数内声明的 变量（比如 num1 10）实参可以理解为是给这个变量赋值 开发中尽量保持形参和实参个数一致 我们曾经使用过的 alert(‘打印’), parseInt(‘11’), Number(‘11’) 本质上都是函数调用的传参 参数默认值 3.参数默认值形参： 可以看做变量，但是如果一个变量不给值，默认是什么？- undefined但是如果做用户不输入实参，刚才的案例，则出现 undefined + undefined 结果是什么？- NaN我们可以改进下，用户不输入实参，可以给 形参默认值，可以默认为 0, 这样程序更严谨，可以如下操作：function getSum(x=0, y=0) document.write(x + y)getSum() // 0getSum(1, 2) // 3说明：这个默认值只会在缺少实参参数传递时 才会被执行，所以有参数会优先执行传递过来的实参, 否则默认为undefined 函数返回值当函数需要返回数据出去时，用 return 关键字。 1.语法return 数据示例：function getSum(x=0, y=0) return x + ylet num = getSum(10, 30) 在函数体中使用 return 关键字能将内部的执行结果交给函数外部使用 return 后面代码不会再被执行，会立即结束 当前函数，所以 return 后面的数据不要换行写 return函数 可以没有 return，这种情况函数默认返回值为 undefined 函数细节补充 两个相同的函数后面的会覆盖前面的函数 在 JavaScript 中 实参的个数和形参的个数可以不一致 如果形参过多 会自动填上 undefined (了解即可) 如果实参过多 那么多余的实参会被忽略 (函数内部有一个 arguments, 里面装着所有的实参) 函数一旦碰到 return 就不会在往下执行了 函数的结束用 return 作用域 概述 通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的 可用性的代码范围 就是这个名字的 作用域 变量的作用域 分类 全局变量 全局变量在任何区域都可以访问和修改 局部变量 局部变量只能在当前函数内部访问和修改 变量有一个坑， 特殊情况 如果函数内部，变量没有声明，直接赋值，也当全局变量看，但是强烈不推荐 但是有一种情况，函数内部的形参可以看做是局部变量 示例 script // 1. 全局变量 全局能用 // let num = 10 // console.log(num) // function fn() // console.log(num) // // fn() // if (true) // console.log(num) // // 2. 在局部作用域下，变量是 局部变量 // 函数内的变量，只能给内部使用，函数外面不能使用 // function fn() // let num = 10 // console.log(num) // function fn1() // console.log(num) // let num2 = 20 // // fn1() // // console.log(num2) num2 is not defined // // fn() // console.log(num) num is not defined // 3. 块级变量 // if (true) // let num = 10 // // // console.log(num) // for (let i = 0; i 5; i++) // console.log(i) // // console.log(i) // function fn() // // let num = 10 // num = 10 // // fn() // if (true) // num = 10 // // console.log(num) // function fn(x, y) // // x 和 y 可以看做是 局部变量 // document.write(x + y) // // fn(1, 2) // console.log(x) 错误了 let num = 10 function fn() let i = 0 console.log(i); fn() if (true) let j = 0 /script 变量访问原则-作用域链 只要是代码，就至少有一个作用域写在函数内部的局部作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。 根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作 作用域链 采取 就近原则 的方式来查找变量最终的值 示例 script let a = 1 function fn1() let a = 2 let b = 22 fn2() function fn2() let a = 3 fn3() function fn3() let a = 4 console.log(a) // 4 console.log(b) // 22 let b = 33 fn1()/script 匿名函数概念：没有名字的函数, 无法直接使用 函数表达式 概念 将匿名函数赋值给一个变量，并且通过变量名称进行调用 我们将这个称为函数表达式 语法 // 语法let fn = function() 函数体 示例 script let num = 10 // 函数表达式 let fn = function () console.log(111) fn() // let fn = function (x, y) // console.log(x + y) // // fn(1, 2) let btn = document.querySelector(button) // btn.onclick = function () // alert(月薪过万) // btn.addEventListener(click, function () alert(月薪过10万) )/script 立即执行函数 作用 避免全局变量之间的污染 语法 // 方式1(function () console.log(11) )();// 方式2(function () console.log(11) ()); 不需要调用，立即执行 多个立即执行函数要用 ; 隔开，要不然会报错 示例 script // 立即执行函数 立即执行， 无需调用 // let fn = function() // fn() // 1 第一个小括号放的 形参 第二个小括号放的是实参 // (function () // console.log(111) // )() // (function (x, y) // console.log(x + y) // )(1, 2) // let num = 10 // (function () // // 防止变量污染 // let num = 20 // )() // (function () // console.log(111) // ()) // (function fn() // console.log(111) // ()) // let num = 10 // let num = 20 (function () console.log(111) )(); let num = 10 ; (function () console.log(222) )()/script 对象对象是什么 对象（object）：JavaScript 里的一种数据类型 可以理解为是一种无序的数据集合， 注意数组是有序的数据集合 用来描述某个事物，例如描述一个人 人有姓名、年龄、性别等信息、还有吃饭睡觉打代码等功能 如果用多个变量保存则比较散，用对象比较统一 比如描述 班主任 信息 静态特征 (姓名, 年龄, 身高, 性别, 爱好) 可以使用数字, 字符串, 数组, 布尔类型等表示 动态行为 (点名, 唱, 跳, rap) 使用函数表示 对象使用声明语法 语法 let 对象名 = // 定义一个构造函数（类）function Person(name, age) this.name = name; this.age = age; 注意事项：如果构造函数没有通过 return 语句显式返回一个对象，那么 new 操作符会隐式返回 this 对象。如果构造函数返回的是一个对象类型，那么 new 将返回这个对象，而不是 this。 function TestObject() {this.name “Default”;return { name: “Override” }; 返回一个新对象} let test1 new TestObject();console.log(test1.name); 输出: Override，不是 Default 箭头函数不能作为构造函数使用，因为它们没有自己的 this，因此不能与 new 一起使用const ArrowFunc () {this.name “Arrow”;};let arrowObj new ArrowFunc(); 这会抛出 TypeError: ArrowFunc is not a constructor 示例 // 声明人对象let person = uname: 刘德华, age: 18, sex: 男, // 方法名：function() sayHi: function () console.log(hi~~~) , mtv: function (s) console.log(s) // 使用 new 创建 Person 的实例let person1 = new Person(Alice, 30);console.log(person1.name); // 输出: Aliceconsole.log(person1.age); // 输出: 30 对象组成 属性 信息或叫特征（名词）。 比如 手机尺寸、颜色、重量等… 方法 功能或叫行为（动词）。 比如 手机打电话、发短信、玩游戏… 示例 let 对象名 = 属性名：属性值, 方法名：函数// 对象是有属性和方法组成的，那么属性和方法都要写在对象里面let ldh = // 属性 uname: 刘德华, // 方法 方法名: function() sing: function () console.log(唱歌) , dance: function (s) console.log(s) 属性 概念 数据描述性的信息称为属性，如人的姓名、身高、年龄、性别等，一般是名词性的。 示例 let obj = user-name: pink, age: 18, gender: 男 属性都是成对出现的，包括属性名和值，它们之间使用英文 : 分隔 多个属性之间使用英文 , 分隔 属性就是依附在对象上的变量（外面是变量，对象内是属性） 属性名可以使用 或 ，一般情况下省略，除非名称遇到特殊符号如空格、中横线等 属性操作 对象本质是无序的数据集合, 操作数据无非就是 增 删 改 查 语法 查 声明对象，并添加了若干属性后，可以使用 . 获得对象中属性对应的值，称之为属性访问。 语法：对象名.属性 let obj = uname: pink, age: 18, gender: 男console.log(person.uname)console.log(person.age)console.log(person.gender)let obj = user-name: pink, age: 18, gender: 男console.log(person.user-name) // NaN对于多词属性或者 - 等属性，点操作就不能用了。console.log(person[user-name]) // pink 没有必要的时候直接使用点语法, 在需要解析变量的时候使用 [] 语法 改 语法：对象名.属性 = 新值 let obj = uname: pink, age: 18, gender: 男person.gender = 女console.log(person.uname)console.log(person.age)console.log(person.gender) // 女 增 语法：对象名.新属性 = 新值 let obj = uname: pink, age: 18, gender: 男person.address = 深圳console.log(person.uname)console.log(person.age)console.log(person.address) // 深圳 删 语法：delete 对象名.属性 let obj = uname: pink, age: 18, gender: 男delete person.genderconsole.log(person.uname)console.log(person.age) 对象中的方法 概念 数据行为性的信息称为方法。如跑步、唱歌等，一般是动词性的，其本质是函数 示例 let person = name: andy, sayHi: function() alert(hi) // 调用person.sayHi()// 动态新增方法person.move = function() alert(移动) 方法是由方法名和函数两部分构成，它们之间使用 : 分隔 多个属性之间使用英文 , 分隔 方法是依附在对象中的函数 遍历对象 for 遍历对象的问题 对象没有像数组一样的 length 属性, 所以无法确定长度 对象里面是无序的键值对, 没有规律. 不像数组里面有规律的下标 遍历对象 let obj = uname: andy, age: 18, sex: 男for(let k in obj) console.log(k) // 属性名 console.log(obj[k]) // 打印属性值 一般不用这种方式遍历数组、主要是用来遍历对象 for in 语法中的 k 是一个变量, 在循环的过程中依次代表对象的属性名 由于 k 是变量, 所以必须使用 [ ] 语法解析 一定记住： k 是获得对象的 属性名， 对象名[k] 是获得 属性值 遍历数组对象 script let students = [ name: 小明, age: 18, gender: 男, hometown: 河北省 , name: 小红, age: 19, gender: 女, hometown: 河南省 , name: 小刚, age: 17, gender: 男, hometown: 山西省 , name: 小丽, age: 18, gender: 女, hometown: 山东省 ] for (let i = 0; i students.length; i++) // console.log(i) // 下标索引号 // console.log(students[i]) // 每个对象 console.log(students[i].name) console.log(students[i].hometown) /script 内置对象JavaScript 内部提供的对象，包含各种属性和方法给开发者调用 内置对象 Math 概念 Math 对象是 JavaScript 提供的一个 数学 对象 作用 提供了一系列做数学运算的方法 包含方法 random：生成0-1之间的随机数（包含0不包括1）ceil：向上取整floor：向下取整max：找最大数min：找最小数pow：幂运算abs：绝对值 示例 script // 属性 console.log(Math.PI) // 方法 // ceil 天花板 向上取整 console.log(Math.ceil(1.1)) // 2 console.log(Math.ceil(1.5)) // 2 console.log(Math.ceil(1.9)) // 2 // floor 地板 向下取整 console.log(Math.floor(1.1)) // 1 console.log(Math.floor(1.5)) // 1 console.log(Math.floor(1.9)) // 1 console.log(Math.floor(12px)) // 1 console.log(----------------) // 四舍五入 round console.log(Math.round(1.1)) // 1 console.log(Math.round(1.49)) // 1 console.log(Math.round(1.5)) // 2 console.log(Math.round(1.9)) // 2 console.log(Math.round(-1.1)) // -1 console.log(Math.round(-1.5)) // -1 console.log(Math.round(-1.51)) // -2 // 取整函数 parseInt(1.2) // 1 // 取整函数 parseInt(12px) // 12 console.log(Math.max(1, 2, 3, 4, 5)) console.log(Math.min(1, 2, 3, 4, 5)) console.log(Math.abs(-1)); // null 类似 let obj = let obj = null /script","tags":["JavaScript"],"categories":["前端"]},{"title":"MyBatis（一）配置解析","path":"/2023/11/30/2023-11-30-MyBatis（一）配置解析/","content":"传统数据库读取方式 连接 MySQL 数据库的传统方式通常涉及使用 JDBC（Java Database Connectivity） 以下是一个简单的步骤示例，演示如何使用 Java 和 JDBC 连接到 MySQL 数据库 加载 JDBC 驱动程序 在连接到数据库之前，你需要加载相应的 JDBC 驱动程序。对于 MySQL，通常使用 com.mysql.cj.jdbc.Driver 驱动程序。 Class.forName(com.mysql.cj.jdbc.Driver); 创建数据库连接使用 DriverManager.getConnection 方法创建与 MySQL 数据库的连接。需要提供数据库的 URL、用户名和密码 String url = jdbc:mysql://localhost:3306/your_database;String username = your_username;String password = your_password;Connection connection = DriverManager.getConnection(url, username, password); 创建 Statement 对象 使用 connection.createStatement() 方法创建一个 Statement 对象，用于执行 SQL 查询和更新 Statement statement = connection.createStatement(); 执行 SQL 查询使用 Statement 对象执行 SQL 查询，并获取结果集 String sqlQuery = SELECT * FROM your_table;ResultSet resultSet = statement.executeQuery(sqlQuery); 处理结果集遍历结果集并处理检索到的数据 在这里，column1 是表中的列名 while (resultSet.next()) // 处理每一行的数据 String column1Value = resultSet.getString(column1); // 其他列的处理... 关闭连接最后，不要忘记关闭连接，以释放资源 resultSet.close();statement.close();connection.close(); 完整的示例如下所示 package com.github.lianyutian.mybatisdemo;import com.github.lianyutian.mybatisdemo.model.User;import org.junit.jupiter.api.Test;import java.sql.*;import java.util.ArrayList;import java.util.List;public class DemoTest @Test public void testQuery() throws Exception String url = jdbc:mysql://127.0.0.1:3306/mybatis?serverTimezone=UTC; String userName = root; String password = 123456; User userParam = new User(); userParam.setId(1); // 第一步：加载驱动程序 Class.forName(com.mysql.cj.jdbc.Driver); // 第二步：获得数据库的连接 Connection conn = DriverManager.getConnection(url, userName, password); // 第三步：创建语句并执行 Statement stmt = conn.createStatement(); ResultSet resultSet = stmt.executeQuery(SELECT * FROM `user` WHERE id = \\ + userParam.getId() + \\;); // 第四步：处理数据库操作结果 ListUser userList = new ArrayList(); while (resultSet.next()) User user = new User(); user.setId(resultSet.getInt(id)); user.setName(resultSet.getString(name)); user.setEmail(resultSet.getString(email)); user.setAge(resultSet.getInt(age)); user.setSex(resultSet.getInt(sex)); user.setSchoolName(resultSet.getString(schoolName)); userList.add(user); // 第五步：关闭连接 stmt.close(); for (User user : userList) System.out.println(name : + user.getName() + ; email : + user.getEmail()); @Test public void testInsert() String url = jdbc:mysql://127.0.0.1:3306/mybatis?serverTimezone=UTC; String userName = root; String password = 123456; // SQL 插入语句 String insertSql = INSERT INTO mybatis.user (name, email, age, sex, schoolName) VALUES (?, ?, ?, ?, ?); // 设置是否自动提交事务为 false try (Connection connection = DriverManager.getConnection(url, userName, password)) connection.setAutoCommit(false); try (PreparedStatement preparedStatement = connection.prepareStatement(insertSql)) // 设置参数 preparedStatement.setString(1, 李四); preparedStatement.setString(2, 321@qq.com); preparedStatement.setInt(3, 18); preparedStatement.setInt(4, 1); preparedStatement.setString(5, 北京大学); // 执行插入操作 int rowsAffected = preparedStatement.executeUpdate(); if (rowsAffected 0) System.out.println(Data inserted successfully!); else System.out.println(Insert failed.); // 提交事务 connection.commit(); catch (SQLException e) // 回滚事务 connection.rollback(); e.printStackTrace(); catch (SQLException e) e.printStackTrace(); MyBatis介绍MyBatis简介MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 MyBatis基础使用 引入 MyBatis 依赖首先在项目中引入 MyBatis 的依赖 dependency groupIdorg.mybatis/groupId artifactIdmybatis/artifactId version3.5.13/version/dependency 配置 MyBatis 数据源(xml方式） !-- mybatis-config.xml --!DOCTYPE configuration PUBLIC -//mybatis.org//DTD Config 3.0//EN http://mybatis.org/dtd/mybatis-3-config.dtdconfiguration environments default=development environment id=development transactionManager type=JDBC/ dataSource type=POOLED property name=driver value=com.mysql.cj.jdbc.Driver/ property name=url value=jdbc:mysql://localhost:3306/mybatis/ property name=username value=root/ property name=password value=123456/ /dataSource /environment /environments !-- 配置Mapper扫描 -- mappers mapper resource=com/github/lianyutian/mybatisdemo/UserMapper.xml/ /mappers/configuration 创建数据模型（POJO）与 XML 配置方式相同，创建用于映射数据库表的 Java 类 package com.github.lianyutian.mybatisdemo;import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class User private Integer id; private String name; private String email; private Integer age; private Integer sex; private String schoolName; 创建 MyBatis 接口创建一个 Mapper 接口，用于定义 SQL 查询、插入、更新等操作 package com.github.lianyutian.mybatisdemo;import java.util.List;public interface UserMapper ListUser queryUserBySchoolName(String schoolName); 创建 MyBatis 映射文件 为每个数据模型创建一个 MyBatis 映射文件，其中定义了 SQL 查询、插入、更新等操作 ?xml version=1.0 encoding=UTF-8 ?!DOCTYPE mapper PUBLIC -//mybatis.org//DTD Mapper 3.0//EN http://mybatis.org/dtd/mybatis-3-mapper.dtdmapper namespace=com.github.lianyutian.mybatisdemo.UserMapper select id=queryUserBySchoolName parameterType=java.lang.String resultType=com.github.lianyutian.mybatisdemo.User SELECT * FROM `user` if test=schoolName != null WHERE schoolName = #schoolName /if /select/mapper 在这里，com.github.lianyutian.mybatisdemo.UserMapper 是对应的 Java 接口 使用 MyBatis 操作数据库在应用程序中使用 MyBatis 进行数据库操作 package com.github.lianyutian.mybatisdemo;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.jupiter.api.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;/** * @author : [lm] * @version : [v1.0] * @createTime : [2023/11/30 20:54] */public class MyBatisDemoTest @Test public void test() throws IOException // 读取 MyBatis 配置文件 InputStream inputStream = Resources.getResourceAsStream(mybatis-config.xml); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 打开一个 SqlSession try (SqlSession sqlSession = sqlSessionFactory.openSession()) // 获取 Mapper UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = new User(); user.setSchoolName(清华大学); // 调用 Mapper 中的方法 ListUser users = userMapper.queryUserBySchoolName(user.getSchoolName()); // 处理查询结果 for (User user1 : users) System.out.println(user1.getName() + : + user1.getSchoolName()); 解析mybatis-config.xml MyBatis怎么获取到数据源的？ Mapper.java如何和Mapper.xml关联？ 读取mybatis-config.xml读取mybatis-config.xml文件，形成InputStream // 第一阶段：MyBatis初始化阶段// 读取 MyBatis 配置文件InputStream inputStream = Resources.getResourceAsStream(mybatis-config.xml);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 解析mybatis-config.xml解析inputStream使用 XMLConfigBuilder 解析 inputStream public SqlSessionFactory build(InputStream inputStream) try // 使用 XMLConfigBuilder 解析 inputStream XMLConfigBuilder parser = new XMLConfigBuilder(inputStream); return build(parser.parse()); catch (Exception e) throw ExceptionFactory.wrapException(Error building SqlSession., e); finally ... 解析 configuration 节点 执行 parse() 方法从 configuration节点 开始解析 xml public Configuration parse() if (parsed) throw new BuilderException(Each XMLConfigBuilder can only be used once.); parsed = true; // 从 configuration 开始解析 xml parseConfiguration(parser.evalNode(/configuration)); return configuration; configuration environments default=development environment id=development transactionManager type=JDBC/ dataSource type=POOLED property name=driver value=com.mysql.cj.jdbc.Driver/ property name=url value=jdbc:mysql://localhost:3306/mybatis/ property name=username value=root/ property name=password value=123456/ /dataSource /environment /environments !-- 配置Mapper扫描 -- mappers mapper resource=com/github/lianyutian/mybatisdemo/UserMapper.xml/ /mappers/configuration 设置 configuration 对象这里解析 mybatis-config.xml 中从 configuration 节点开始的各个节点的配置 从进入各个子方法可以发现从 mybatis-config.xml解析的数据都存入到了 Configuration对象中，这个对象非常重要！ private void parseConfiguration(XNode root) try // issue #117 read properties first propertiesElement(root.evalNode(properties)); Properties settings = settingsAsProperties(root.evalNode(settings)); loadCustomVfs(settings); loadCustomLogImpl(settings); typeAliasesElement(root.evalNode(typeAliases)); pluginElement(root.evalNode(plugins)); objectFactoryElement(root.evalNode(objectFactory)); objectWrapperFactoryElement(root.evalNode(objectWrapperFactory)); reflectorFactoryElement(root.evalNode(reflectorFactory)); settingsElement(settings); // read it after objectFactory and objectWrapperFactory issue #631 // 解析数据源 environmentsElement(root.evalNode(environments)); databaseIdProviderElement(root.evalNode(databaseIdProvider)); typeHandlerElement(root.evalNode(typeHandlers)); // 解析mapper mapperElement(root.evalNode(mappers)); catch (Exception e) throw new BuilderException(Error parsing SQL Mapper Configuration. Cause: + e, e); 解析数据源解析数据源 private void environmentsElement(XNode context) throws Exception if (context != null) if (environment == null) environment = context.getStringAttribute(default); for (XNode child : context.getChildren()) String id = child.getStringAttribute(id); if (isSpecifiedEnvironment(id)) TransactionFactory txFactory = transactionManagerElement(child.evalNode(transactionManager)); DataSourceFactory dsFactory = dataSourceElement(child.evalNode(dataSource)); DataSource dataSource = dsFactory.getDataSource(); Environment.Builder environmentBuilder = new Environment.Builder(id).transactionFactory(txFactory) .dataSource(dataSource); configuration.setEnvironment(environmentBuilder.build()); break; 解析mapper 解析 mybatis-config.xml 中 mappers 节点 private void mapperElement(XNode parent) throws Exception if (parent != null) for (XNode child : parent.getChildren()) if (package.equals(child.getName())) String mapperPackage = child.getStringAttribute(name); configuration.addMappers(mapperPackage); else // com/github/lianyutian/mybatisdemo/UserMapper.xml String resource = child.getStringAttribute(resource); String url = child.getStringAttribute(url); String mapperClass = child.getStringAttribute(class); if (resource != null url == null mapperClass == null) ErrorContext.instance().resource(resource); // 读取UserMapper.xml文件 try (InputStream inputStream = Resources.getResourceAsStream(resource)) XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments()); // 解析Mapper文件 mapperParser.parse(); else if (resource == null url != null mapperClass == null) ... else if (resource == null url == null mapperClass != null) ... else throw new BuilderException( A mapper element may only specify a url, resource or class, but not more than one.); 使用 XMLMapperBuilder 解析 mapper.xml public void parse() if (!configuration.isResourceLoaded(resource)) configurationElement(parser.evalNode(/mapper)); configuration.addLoadedResource(resource); // 绑定Mapper接口和Mapper.xml文件的关系 bindMapperForNamespace(); parsePendingResultMaps(); parsePendingCacheRefs(); parsePendingStatements();private void configurationElement(XNode context) try String namespace = context.getStringAttribute(namespace); if (namespace == null || namespace.isEmpty()) throw new BuilderException(Mappers namespace cannot be empty); builderAssistant.setCurrentNamespace(namespace); cacheRefElement(context.evalNode(cache-ref)); cacheElement(context.evalNode(cache)); // 解析入参 parameterMapElement(context.evalNodes(/mapper/parameterMap)); // 解析返回结果类型 resultMapElements(context.evalNodes(/mapper/resultMap)); sqlElement(context.evalNodes(/mapper/sql)); // 解析sql语句 buildStatementFromContext(context.evalNodes(select|insert|update|delete)); catch (Exception e) throw new BuilderException(Error parsing Mapper XML. The XML location is + resource + . Cause: + e, e); 解析SQL语句 public void parseStatementNode() ... // 获取入参类类型 String parameterType = context.getStringAttribute(parameterType); Class? parameterTypeClass = resolveClass(parameterType); ... // 获取返回类类型 String resultType = context.getStringAttribute(resultType); Class? resultTypeClass = resolveClass(resultType); String resultMap = context.getStringAttribute(resultMap); if (resultTypeClass == null resultMap == null) resultTypeClass = MapperAnnotationBuilder.getMethodReturnType(builderAssistant.getCurrentNamespace(), id); String resultSetType = context.getStringAttribute(resultSetType); ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType); if (resultSetTypeEnum == null) resultSetTypeEnum = configuration.getDefaultResultSetType(); String keyProperty = context.getStringAttribute(keyProperty); String keyColumn = context.getStringAttribute(keyColumn); String resultSets = context.getStringAttribute(resultSets); boolean dirtySelect = context.getBooleanAttribute(affectData, Boolean.FALSE); builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType, fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass, resultSetTypeEnum, flushCache, useCache, resultOrdered, keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets, dirtySelect); 构建 MappedStatement 并加入 configuration 中 public MappedStatement addMappedStatement(String id, SqlSource sqlSource, StatementType statementType, ... MappedStatement statement = statementBuilder.build(); configuration.addMappedStatement(statement); return statement; 绑定 mapper 接口和 mapper.xml 关系 private void bindMapperForNamespace() // com.github.lianyutian.mybatisdemo.UserMapper String namespace = builderAssistant.getCurrentNamespace(); if (namespace != null) Class? boundType = null; try boundType = Resources.classForName(namespace); catch (ClassNotFoundException e) // ignore, bound type is not required if (boundType != null !configuration.hasMapper(boundType)) // Spring may not know the real resource name so we set a flag // to prevent loading again this resource from the mapper interface // look at MapperAnnotationBuilder#loadXmlResource configuration.addLoadedResource(namespace: + namespace); configuration.addMapper(boundType); 总结根据源码追踪，MyBatis 初始化阶段主要进行了下列几项工作 根据 mybatis-config.xml 获取输入流 InputStream 从 mybatis-config.xml 根节点开始，逐层解析配置，包括对应的 mapper.xml。并将解析后的数据存入 Configuration 对象中 以配置好的 Configuration 构建一个 SqlSessionFactory 对象","tags":["MyBatis","Java","ORM"],"categories":["Java"]},{"title":"前端常见小案例","path":"/2023/11/28/2023-11-28-前端常见小案例/","content":"案例代码库 https://github.com/lianyutian/font_demo/blob/main 1. CSS常见案例1.1 行高-垂直居中 垂直居中技巧 行高属性值等于盒子高度属性值 注意 该技巧适用于单行文字垂直居中效果 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title垂直居中/title style div height: 100px; background-color: skyblue; /* 注意：只能是单行文字垂直居中 */ line-height: 100px; /style/headbody div文字/div/body/html 1.2 清除默认内外边距 场景 浏览器会默认给部分标签设置默认的margin和padding，但一般在项目开始前需要先清除这些标签默认的margin和padding，后续自己设置 比如：body标签默认有margin：8px 比如：p标签默认有上下的margin 比如：ul标签默认由上下的margin和padding-left 解决方法 * margin: 0; padding: 0; 1.3 盒子模型-圆角 常见应用 - 正圆形状 给正方形盒子设置圆角属性值为 宽高的一半 50% 效果：font-demo.pages.dev !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title圆角-基本使用/title style div margin: 50px auto; width: 200px; height: 200px; background-color: orange; /* border-radius: 20px; */ /* 记忆：从左上角顺时针赋值，没有取值的角与对角取值相同 */ /* 四值：左上 右上 右下 左下 */ /* border-radius: 10px 20px 40px 80px; */ /* 三值：左上 右上+左下 右下 */ /* border-radius: 10px 40px 80px; */ /* 两值：左上+右下 右上+左下 */ border-radius: 10px 80px; /style/headbody div/div/body/html 常见应用 – 胶囊形状 给长方形盒子设置圆角属性值为 盒子高度的一半 效果：font-demo.pages.dev !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title圆角-特殊场景/title style img width: 200px; height: 200px; /* border-radius: 100px; */ /* 最大值是50%。超过50%没有效果 */ border-radius: 50%; div width: 200px; height: 80px; background-color: orange; border-radius: 40px; /style/headbody !-- 正圆形 -- 头像 -- img src=./images/1.jpg alt= !-- 胶囊状 -- div/div/body/html 1.4 盒子模型 - 阴影 作用 给元素设置阴影效果 属性名 box-shadow 属性值 X 轴偏移量 Y 轴偏移量 模糊半径 扩散半径 颜色 内外阴影 注意 X 轴偏移量 和 Y 轴偏移量 必须书写 默认是外阴影，内阴影需要添加 inset 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title盒子阴影/title style div margin: 50px auto; width: 200px; height: 80px; background-color: orange; box-shadow: 2px 5px 10px 1px rgba(0,0,0,0.5) inset; /style/headbody div/div/body/html 1.5 轮播图-无动态效果 效果 font-demo.pages.dev 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title轮播图/title link rel=stylesheet href=./iconfont/iconfont.css style * margin: 0; padding: 0; box-sizing: border-box; li list-style: none; .banner position: relative; margin: 100px auto; width: 564px; height: 315px; /* background-color: pink; */ overflow: hidden; /* 图片 */ .banner img width: 564px; border-radius: 12px; vertical-align: middle; .banner ul display: flex; /* 箭头 */ .banner .prev, .banner .next /* 隐藏 */ display: none; position: absolute; top: 50%; transform: translateY(-50%); width: 20px; height: 30px; background-color: rgba(0,0,0, 0.3); text-decoration: none; color: #fff; line-height: 30px; /* 鼠标滑到banner区域，箭头要显示 display:block */ .banner:hover .prev, .banner:hover .next display: block; .banner .prev left: 0; border-radius: 0 15px 15px 0; .banner .next right: 0; border-radius: 15px 0 0 15px; text-align: center; /* 圆点 */ .banner ol position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); height: 13px; background-color: rgba(255,255,255,0.3); display: flex; border-radius: 10px; .banner ol li margin: 3px; width: 8px; height: 8px; background-color: #fff; border-radius: 50%; cursor: pointer; /* 橙色的li */ .banner ol .active background-color: #ff5000; /style/headbody div class=banner !-- 图: ul li -- ul lia href=#img src=./images/banner1.jpg alt=/a/li lia href=#img src=./images/banner2.jpg alt=/a/li lia href=#img src=./images/banner3.jpg alt=/a/li /ul !-- 箭头 -- !-- 上一张 prev -- a href=# class=prev i class=iconfont icon-zuoce/i /a !-- 下一张 next -- a href=# class=next i class=iconfont icon-youce/i /a !-- 圆点 -- ol li/li li class=active/li li/li /ol /div/body/html 2. JS常见案例2.1 轮播图 效果 https://font-demo.pages.dev/js/web_api_2/08-%E8%BD%AE%E6%92%AD%E5%9B%BE%E5%AE%8C%E6%95%B4%E7%89%88 需求 当点击左右的按钮，可以切换轮播图 分析 ①：右侧按钮点击，变量++，如果大于等于8，则复原0 ②：左侧按钮点击，变量–，如果小于0，则复原最后一张 ③：鼠标经过暂停定时器 ④：鼠标离开开启定时器 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 / meta http-equiv=X-UA-Compatible content=IE=edge / meta name=viewport content=width=device-width, initial-scale=1.0 / title轮播图点击切换/title style * box-sizing: border-box; .slider width: 560px; height: 400px; overflow: hidden; .slider-wrapper width: 100%; height: 320px; .slider-wrapper img width: 100%; height: 100%; display: block; .slider-footer height: 80px; background-color: rgb(100, 67, 68); padding: 12px 12px 0 12px; position: relative; .slider-footer .toggle position: absolute; right: 0; top: 12px; display: flex; .slider-footer .toggle button margin-right: 12px; width: 28px; height: 28px; appearance: none; border: none; background: rgba(255, 255, 255, 0.1); color: #fff; border-radius: 4px; cursor: pointer; .slider-footer .toggle button:hover background: rgba(255, 255, 255, 0.2); .slider-footer p margin: 0; color: #fff; font-size: 18px; margin-bottom: 10px; .slider-indicator margin: 0; padding: 0; list-style: none; display: flex; align-items: center; .slider-indicator li width: 8px; height: 8px; margin: 4px; border-radius: 50%; background: #fff; opacity: 0.4; cursor: pointer; .slider-indicator li.active width: 12px; height: 12px; opacity: 1; /style/headbody div class=slider div class=slider-wrapper img src=./images/slider01.jpg alt= / /div div class=slider-footer p对人类来说会不会太超前了？/p ul class=slider-indicator li class=active/li li/li li/li li/li li/li li/li li/li li/li /ul div class=toggle button class=prevlt;/button button class=nextgt;/button /div /div /div script // 1. 初始数据 const data = [ url: ./images/slider01.jpg, title: 对人类来说会不会太超前了？, color: rgb(100, 67, 68) , url: ./images/slider02.jpg, title: 开启剑与雪的黑暗传说！, color: rgb(43, 35, 26) , url: ./images/slider03.jpg, title: 真正的jo厨出现了！, color: rgb(36, 31, 33) , url: ./images/slider04.jpg, title: 李玉刚：让世界通过B站看到东方大国文化, color: rgb(139, 98, 66) , url: ./images/slider05.jpg, title: 快来分享你的寒假日常吧~, color: rgb(67, 90, 92) , url: ./images/slider06.jpg, title: 哔哩哔哩小年YEAH, color: rgb(166, 131, 143) , url: ./images/slider07.jpg, title: 一站式解决你的电脑配置问题！！！, color: rgb(53, 29, 25) , url: ./images/slider08.jpg, title: 谁不想和小猫咪贴贴呢！, color: rgb(99, 72, 114) , ] // 获取元素 const img = document.querySelector(.slider-wrapper img) const p = document.querySelector(.slider-footer p) const footer = document.querySelector(.slider-footer) // 1. 右按钮业务 // 1.1 获取右侧按钮 const next = document.querySelector(.next) let i = 0 // 信号量 控制播放图片张数 // 1.2 注册点击事件 next.addEventListener(click, function () // console.log(11) i++ // 1.6判断条件 如果大于8 就复原为 0 // if (i = 8) // i = 0 // i = i = data.length ? 0 : i // 1.3 得到对应的对象 // console.log(data[i]) // 调用函数 toggle() ) // 2. 左侧按钮业务 // 2.1 获取左侧按钮 const prev = document.querySelector(.prev) // 1.2 注册点击事件 prev.addEventListener(click, function () i-- // 判断条件 如果小于0 则爬到最后一张图片索引号是 7 // if (i 0) // i = 7 // i = i 0 ? data.length - 1 : i // 1.3 得到对应的对象 // console.log(data[i]) // 调用函数 toggle() ) // 声明一个渲染的函数作为复用 function toggle() // 1.4 渲染对应的数据 img.src = data[i].url p.innerHTML = data[i].title footer.style.backgroundColor = data[i].color // 1.5 更换小圆点 先移除原来的类名， 当前li再添加 这个 类名 document.querySelector(.slider-indicator .active).classList.remove(active) document.querySelector(`.slider-indicator li:nth-child($i + 1)`).classList.add(active) // 3. 自动播放模块 let timerId = setInterval(function () // 利用js自动调用点击事件 click() 一定加小括号调用函数 next.click() , 1000) // 4. 鼠标经过大盒子，停止定时器 const slider = document.querySelector(.slider) // 注册事件 slider.addEventListener(mouseenter, function () // 停止定时器 clearInterval(timerId) ) // 5. 鼠标离开大盒子，开启定时器 // 注册事件 slider.addEventListener(mouseleave, function () // 停止定时器 if (timerId) clearInterval(timerId) // 开启定时器 timerId = setInterval(function () // 利用js自动调用点击事件 click() 一定加小括号调用函数 next.click() , 1000) ) /script/body/html 2.2 Tab栏切换 效果 https://font-demo.pages.dev/js/web_api_2/18-tab%E6%A0%8F%E5%88%87%E6%8D%A2 需求 鼠标经过不同的选项卡，底部可以显示不同的内容 分析 ①：给a的父级 注册点击事件，采取事件委托方式 ②： 如果点击的是A , 则进行排他思想，删除添加类 ③： 注意判断的方式 利用 e.target.tagName ④： 因为没有索引号了，所以这里我们可以自定义属性，给5个链接添加序号 ⑤： 下面大盒子获取索引号的方式 e.target.dataset.id 号， 然后进行排他思想 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 / meta http-equiv=X-UA-Compatible content=IE=edge / meta name=viewport content=width=device-width, initial-scale=1.0 / titletab栏切换/title style * margin: 0; padding: 0; .tab width: 590px; height: 340px; margin: 20px; border: 1px solid #e4e4e4; .tab-nav width: 100%; height: 60px; line-height: 60px; display: flex; justify-content: space-between; .tab-nav h3 font-size: 24px; font-weight: normal; margin-left: 20px; .tab-nav ul list-style: none; display: flex; justify-content: flex-end; .tab-nav ul li margin: 0 20px; font-size: 14px; .tab-nav ul li a text-decoration: none; border-bottom: 2px solid transparent; color: #333; .tab-nav ul li a.active border-color: #e1251b; color: #e1251b; .tab-content padding: 0 16px; .tab-content .item display: none; .tab-content .item.active display: block; /style/headbody div class=tab div class=tab-nav h3每日特价/h3 ul lia class=active href=javascript:; data-id=0精选/a/li lia href=javascript:; data-id=1美食/a/li lia href=javascript:; data-id=2百货/a/li lia href=javascript:; data-id=3个护/a/li lia href=javascript:; data-id=4预告/a/li /ul /div div class=tab-content div class=item activeimg src=./images/tab00.png alt= //div div class=itemimg src=./images/tab01.png alt= //div div class=itemimg src=./images/tab02.png alt= //div div class=itemimg src=./images/tab03.png alt= //div div class=itemimg src=./images/tab04.png alt= //div /div /div script // 采取事件委托的形式 tab栏切换 // 1. 获取 ul 父元素 因为 ul只有一个 const ul = document.querySelector(.tab-nav ul) // 获取 5个 item const items = document.querySelectorAll(.tab-content .item) // 2. 添加事件 ul.addEventListener(click, function (e) // console.log(e.target) // e.target是我们点击的对象 // 我们只有点击了 a 才会 进行 添加类和删除类操作 // console.log(e.target.tagName) // e.target.tagName 点击那个对象的 标签名 if (e.target.tagName === A) // console.log(我选的是a) // 排他思想 ，先移除原来的active document.querySelector(.tab-nav .active).classList.remove(active) //当前元素添加 active 是 e.target // this 指向ul 不能用this e.target.classList.add(active) // 下面大盒子模块 // console.log(e.target.dataset.id) const i = +e.target.dataset.id // 排他思想 ，先移除原来的active document.querySelector(.tab-content .active).classList.remove(active) // 对应的大盒子 添加 active // document.querySelector(`.tab-content .item:nth-child($i + 1)`).classList.add(active) items[i].classList.add(active) ) /script/body/html 2.3 仿京东固定导航栏案例 效果 https://font-demo.pages.dev/js/web_api_3/16-%E4%BB%BF%E6%96%B0%E6%B5%AA%E5%9B%BA%E5%AE%9A%E5%A4%B4%E9%83%A8 需求 当页面滚动到秒杀模块，导航栏自动滑入，否则滑出 分析 ①：用到页面滚动事件 ②：检测页面滚动大于等于 秒杀模块的位置 则滑入，否则滑出 ③：主要移动的是秒杀模块的顶部位置 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style * margin: 0; padding: 0; box-sizing: border-box; .content overflow: hidden; width: 1000px; height: 3000px; background-color: pink; margin: 0 auto; .backtop display: none; width: 50px; left: 50%; margin: 0 0 0 505px; position: fixed; bottom: 60px; z-index: 100; .backtop a height: 50px; width: 50px; background: url(./images/bg2.png) 0 -600px no-repeat; opacity: 0.35; overflow: hidden; display: block; text-indent: -999em; cursor: pointer; .header position: fixed; top: -80px; left: 0; width: 100%; height: 80px; background-color: purple; text-align: center; color: #fff; line-height: 80px; font-size: 30px; transition: all .3s; .sk width: 300px; height: 300px; background-color: skyblue; margin-top: 500px; /style/headbody div class=header我是顶部导航栏/div div class=content div class=sk秒杀模块/div /div div class=backtop img src=./images/close2.png alt= a href=javascript:;/a /div script const sk = document.querySelector(.sk) const header = document.querySelector(.header) // 1. 页面滚动事件 window.addEventListener(scroll, function () // 当页面滚动到 秒杀模块的时候，就改变 头部的 top值 // 页面被卷去的头部 = 秒杀模块的位置 offsetTop const n = document.documentElement.scrollTop // if (n = sk.offsetTop) // header.style.top = 0 // else // header.style.top = -80px // header.style.top = n = sk.offsetTop ? 0 : -80px ) /script/body/html 2.4 bilibili 点击小滑块移动效果 效果 https://font-demo.pages.dev/js/web_api_3/m-bilibili/ 需求 当点击链接，下面红色滑块跟着移动 分析 ①：用到事件委托 ②：点击链接得到当前元素的 offsetLeft值 ③：修改line 颜色块的 left 值 点击链接的offsetLeft ④： 添加过渡效果 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titlebilibili-干杯~~~/title !-- 引入favicon图标 -- link rel=shortcut icon href=favicon.ico type=image/x-icon !-- 引入css文件 -- link rel=stylesheet href=./css/index.css !-- 引入字体图标文件 -- link rel=stylesheet href=./fonts/iconfont.css/headbody !-- 头部模块 -- header class=suspension div class=m-navbar !-- logo -- a href=# class=logo i class=iconfont Navbar_logo/i /a !-- 右侧 -- div class=right a href=# class=search i class=iconfont ic_search_tab/i /a a href=# class=face img src=./images/login.png alt= /a div class=app-btn img src=./images/download.png alt= /div /div /div div class=channel-menu div class=tabs !-- 很宽的盒子 -- div class=tabs-list a href=#首页/a a href=#动画/a a href=#番剧/a a href=#果蔬/a a href=#音乐/a a href=#舞蹈/a a href=#鬼畜/a a href=#吹鬼/a !-- 红色线 -- div class=line/div /div /div div class=after i class=iconfont general_pulldown_s/i /div /div /header !-- 主体部分 -- div class=m-home div class=video-list a href=# class=video-item div class=card img src=./images/dog.jpg@480w_270h_1c alt= !-- 播放量 -- div class=count span i class=iconfont icon_shipin_bofangshu/i 播放量 /span span i class=iconfont icon_shipin_danmushu/i 评论数 /span /div /div p class=title ellipsis-2 315晚会能不能曝光下智能电视？N重广告、套娃会员、操作反人类，当代年轻人是怎么被智能电视逼疯的？【商业B面牛顿】 /p /a a href=# class=video-item div class=card img src=./images/dog.jpg@480w_270h_1c alt= !-- 播放量 -- div class=count span i class=iconfont icon_shipin_bofangshu/i 播放量 /span span i class=iconfont icon_shipin_danmushu/i 评论数 /span /div /div p class=title ellipsis-2 315晚会能不能曝光下智能电视？N重广告、套娃会员、操作反人类，当代年轻人是怎么被智能电视逼疯的？【商业B面牛顿】 /p /a a href=# class=video-item div class=card img src=./images/dog.jpg@480w_270h_1c alt= !-- 播放量 -- div class=count span i class=iconfont icon_shipin_bofangshu/i 播放量 /span span i class=iconfont icon_shipin_danmushu/i 评论数 /span /div /div p class=title ellipsis-2 315晚会能不能曝光下智能电视？N重广告、套娃会员、操作反人类，当代年轻人是怎么被智能电视逼疯的？【商业B面牛顿】 /p /a a href=# class=video-item div class=card img src=./images/dog.jpg@480w_270h_1c alt= !-- 播放量 -- div class=count span i class=iconfont icon_shipin_bofangshu/i 播放量 /span span i class=iconfont icon_shipin_danmushu/i 评论数 /span /div /div p class=title ellipsis-2 315晚会能不能曝光下电视？ /p /a a href=# class=video-item div class=card img src=./images/dog.jpg@480w_270h_1c alt= !-- 播放量 -- div class=count span i class=iconfont icon_shipin_bofangshu/i 播放量 /span span i class=iconfont icon_shipin_danmushu/i 评论数 /span /div /div p class=title ellipsis-2 315晚会能不能曝光下智能电视？N重广告、套娃会员、操作反人类，当代年轻人是怎么被智能电视逼疯的？【商业B面牛顿】 /p /a a href=# class=video-item div class=card img src=./images/dog.jpg@480w_270h_1c alt= !-- 播放量 -- div class=count span i class=iconfont icon_shipin_bofangshu/i 播放量 /span span i class=iconfont icon_shipin_danmushu/i 评论数 /span /div /div p class=title ellipsis-2 315晚会能不能曝光下智能电视？N重广告、套娃会员、操作反人类，当代年轻人是怎么被智能电视逼疯的？【商业B面牛顿】 /p /a a href=# class=video-item div class=card img src=./images/dog.jpg@480w_270h_1c alt= !-- 播放量 -- div class=count span i class=iconfont icon_shipin_bofangshu/i 播放量 /span span i class=iconfont icon_shipin_danmushu/i 评论数 /span /div /div p class=title ellipsis-2 315晚会能不能曝光下智能电视？N重广告、套娃会员、操作反人类，当代年轻人是怎么被智能电视逼疯的？【商业B面牛顿】 /p /a a href=# class=video-item div class=card img src=./images/dog.jpg@480w_270h_1c alt= !-- 播放量 -- div class=count span i class=iconfont icon_shipin_bofangshu/i 播放量 /span span i class=iconfont icon_shipin_danmushu/i 评论数 /span /div /div p class=title ellipsis-2 315晚会能不能曝光下智能电视？N重广告、套娃会员、操作反人类，当代年轻人是怎么被智能电视逼疯的？【商业B面牛顿】 /p /a a href=# class=video-item div class=card img src=./images/dog.jpg@480w_270h_1c alt= !-- 播放量 -- div class=count span i class=iconfont icon_shipin_bofangshu/i 播放量 /span span i class=iconfont icon_shipin_danmushu/i 评论数 /span /div /div p class=title ellipsis-2 315晚会能不能曝光下智能电视？N重广告、套娃会员、操作反人类，当代年轻人是怎么被智能电视逼疯的？【商业B面牛顿】 /p /a a href=# class=video-item div class=card img src=./images/dog.jpg@480w_270h_1c alt= !-- 播放量 -- div class=count span i class=iconfont icon_shipin_bofangshu/i 播放量 /span span i class=iconfont icon_shipin_danmushu/i 评论数 /span /div /div p class=title ellipsis-2 315晚会能不能曝光下智能电视？N重广告、套娃会员、操作反人类，当代年轻人是怎么被智能电视逼疯的？【商业B面牛顿】 /p /a a href=# class=video-item div class=card img src=./images/dog.jpg@480w_270h_1c alt= !-- 播放量 -- div class=count span i class=iconfont icon_shipin_bofangshu/i 播放量 /span span i class=iconfont icon_shipin_danmushu/i 评论数 /span /div /div p class=title ellipsis-2 315晚会能不能曝光下智能电视？N重广告、套娃会员、操作反人类，当代年轻人是怎么被智能电视逼疯的？【商业B面牛顿】 /p /a /div /div !-- 底部模块 -- footer class=app div class=btn-app i class=iconfont Navbar_logo/i 打开App，看你感兴趣的视频 /div /footer script // 1. 事件委托的方法 获取父元素 tabs-list const list = document.querySelector(.tabs-list) const line = document.querySelector(.line) // 2. 注册点击事件 list.addEventListener(click, function (e) // 只有点击了A 才有触发效果 if (e.target.tagName === A) // console.log(11) // 当前元素是谁 ？ e.target // 得到当前点击元素的位置 // console.log(e.target.offsetLeft) // line.style.transform = translateX(100px) // 把我们点击的a链接盒子的位置 然后移动 line.style.transform = `translateX($e.target.offsetLeftpx)` ) /script/body/html 2.5 电梯导航 效果 https://font-demo.pages.dev/js/web_api_3/%E7%94%B5%E6%A2%AF%E5%AF%BC%E8%88%AA%E7%B4%A0%E6%9D%90/%E7%94%B5%E6%A2%AF%E5%AF%BC%E8%88%AA 需求 当点击不同的模块，页面可以自动跳转不同的位置 分析 ①：页面滚动到对应位置，导航显示，否则隐藏模块 ②：点击导航对应小模块，页面 会跳到对应大模块位置 ③：页面滚动到对应位置，电梯导航对应模块自动发生变化 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 title小兔鲜儿 - 新鲜 惠民 快捷!/title meta http-equiv=X-UA-Compatible content=IE=edge meta name=renderer content=webkit link rel=stylesheet href=./css/common.css link rel=stylesheet href=./css/index.css/headbody ... !-- 电梯 -- div class=xtx-elevator ul class=xtx-elevator-list lia href=javascript:; data-name=new新鲜好物/a/li lia href=javascript:; data-name=popular人气推荐/a/li lia href=javascript:; data-name=brand热门品牌/a/li lia href=javascript:; data-name=topic最新专题/a/li lia href=javascript:; id=backTopi class=sprites/i顶部/a/li /ul /div script // 第一大模块，页面滑动可以显示和隐藏 (function () // 获取元素 const entry = document.querySelector(.xtx_entry) const elevator = document.querySelector(.xtx-elevator) // 1. 当页面滚动大于 300像素，就显示 电梯导航 // 2. 给页面添加滚动事件 window.addEventListener(scroll, function () // 被卷去的头部大于 300 const n = document.documentElement.scrollTop // if (n = 300) // elevator.style.opacity = 1 // else // elevator.style.opacity = 0 // // 简写 elevator.style.opacity = n = entry.offsetTop ? 1 : 0 ) // 点击返回页面顶部 const backTop = document.querySelector(#backTop) backTop.addEventListener(click, function () // 可读写 // document.documentElement.scrollTop = 0 // window.scrollTo(x, y) window.scrollTo(0, 0) ) )(); // 第二第三都放到另外一个执行函数里面 (function () // 2. 点击页面可以滑动 const list = document.querySelector(.xtx-elevator-list) list.addEventListener(click, function (e) // console.log(11) if (e.target.tagName === A e.target.dataset.name) // 排他思想 // 先移除原来的类active // 先获取这个active的对象 const old = document.querySelector(.xtx-elevator-list .active) // console.log(old) // 判断 如果原来有active类的对象，就移除类，如果开始就没有对象，就不删除，所以不报错 if (old) old.classList.remove(active) // 当前元素添加 active e.target.classList.add(active) // 获得自定义属性 new topic // console.log(e.target.dataset.name) // 根据小盒子的自定义属性值 去选择 对应的大盒子 // console.log(document.querySelector(`.xtx_goods_$e.target.dataset.name`).offsetTop) // 获得对应大盒子的 offsetTop const top = document.querySelector(`.xtx_goods_$e.target.dataset.name`).offsetTop // 让页面滚动到对应的位置 document.documentElement.scrollTop = top ) // 3. 页面滚动，可以根据大盒子选 小盒子 添加 active 类 window.addEventListener(scroll, function () // 3.1 先移除类 // 先获取这个active的对象 const old = document.querySelector(.xtx-elevator-list .active) // console.log(old) // 判断 如果原来有active类的对象，就移除类，如果开始就没有对象，就不删除，所以不报错 if (old) old.classList.remove(active) // 3.2 判断页面当前滑动的位置，选择小盒子 // 获取4个大盒子 const news = document.querySelector(.xtx_goods_new) const popular = document.querySelector(.xtx_goods_popular) const brand = document.querySelector(.xtx_goods_brand) const topic = document.querySelector(.xtx_goods_topic) const n = document.documentElement.scrollTop if (n = news.offsetTop n popular.offsetTop) // 选择第一个小盒子 document.querySelector([data-name=new]).classList.add(active) else if (n = popular.offsetTop n brand.offsetTop) document.querySelector([data-name=popular]).classList.add(active) else if (n = brand.offsetTop n topic.offsetTop) document.querySelector([data-name=brand]).classList.add(active) else if (n = topic.offsetTop) document.querySelector([data-name=topic]).classList.add(active) ) )(); // let n = 10 // n = 20 /script/body/html","tags":["CSS","实战案例"],"categories":["前端"]},{"title":"CSS基础","path":"/2023/11/27/2023-11-27-CSS基础/","content":"CSS 的介绍 CSS 是什么 层叠样式表（Cascading Style Sheets，缩写为 CSS）是一种 样式表 语言，用来描述 HTML 或 XML（包括如 SVG、MathML 或 XHTML 之类的 XML 分支语言）文档的呈现方式。CSS 描述了在屏幕、纸质、音频等其他媒体上的元素应该如何被渲染的问题。 CSS 的作用 给页面中的 HTML 标签设置样式 CSS 的引入方式 内嵌式：CSS 写在 style 标签中 • 提示：style 标签虽然可以写在页面任意位置，但是通常约定写在 head 标签 外联式：CSS 写在一个单独的.CSS 文件中 • 提示：需要通过 link 标签在网页中引入 行内式：CSS 写在标签的 style 属性中 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title !-- 关系: 样式表 -- link rel=stylesheet href=./my.css/headbody !-- css到底能写在哪里 -- p这是p标签/p div style=color: green; font-size: 30px;这是div标签/div div这个div是什么颜色/div/body/html 选择器选择器的作用：选择页面中对应的标签（找），方便后续设置样式（改） 标签选择器 结构 标签名 { CSS 属性名: 属性值; } 作用 通过 标签名，找到页面中 所有这类 标签，设置样式 注意 标签选择器选择的是一类标签，而不是单独某一个 标签选择器无论嵌套关系有多深，都能找到对应的标签 标签选择器 无法差异化 同名标签的显示效果 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style /* 选择器 */ /* 标签选择器 就是 以标签名命名的选择器 */ p color: red; /* 标签选择器 选中所有的这个标签都生效css */ /style/headbody ppppppppp/p p这个p是什么颜色呢/p p2222/p/body/html 类选择器 结构 .类名 { CSS 属性名: 属性值; } 作用 通过类名，找到页面中 所有 带有这个类名的标签，设置样式 注意 所有标签上都有 class 属性，class 属性的属性值称为类名（类似于名字） 类名可以由数字、字母、下划线、中划线组成，但不能以数字或者中划线开头 一个标签可以同时有 多个类名，类名之间以 空格 隔开 类名可以重复，一个类选择器可以同时选中多个标签 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style .red color: red; .size font-size: 66px; /style/headbody !-- 类: 定义 和 使用才能生效 -- p111/p !-- 一个标签可以使用多个类名 , 需要空格隔开即可 -- p class=red size222/p div class=red这个标签文字也要变红/div/body/html id 选择器 结构 #id 属性值 { CSS 属性名: 属性值; } 作用 通过 id 属性值，找到页面中带有这个 id 属性值的标签，设置样式 注意 所有标签上都有 id 属性 id 属性值类似于身份证号码，在一个页面中是唯一的，不可重复的！ 一个标签上只能有一个 id 属性值 一个 id 选择器只能选中一个标签 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style /* 定义id选择器 */ #blue color: skyblue; /style/headbody div id=blue这个div文字是蓝色的/div p id=blue111/p/body/html 类与 id 的区别 class 类名与 id 属性值的区别 class 类名相当于姓名，可以重复，一个标签可以同时有多个 class 类名 id 属性值相当于身份证号码，不可重复，一个标签只能有一个 id 属性值 类选择器与 id 选择器的区别 类选择器以 . 开头 id 选择器以 # 开头 实际开发的情况 类选择器用的最多 id 一般配合 js 使用，除非特殊情况，否则不要使用 id 设置样式 实际开发中会遇到 冗余代码的抽取 （可以将一些公共的代码抽取到一个公共的类中去） 通配符选择器 结构 * { 属性名: 属性值; } 作用 找到页面中 所有的标签，设置样式 注意 开发中使用极少，只会在极特殊情况下才会用到 可能会用于去除标签默认的 margin 和 padding（后续讲解） * margin: 0; padding: 0; 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style * color: red; /style/headbody divdiv/div ppppp/p h1h1/h1 spanspan/span ppppp/p h2h2/h2/body/html 复合选择器后代选择器：空格 结构 选择器 1 选择器 2 { } 作用 根据 HTML 标签的嵌套关系，选择父元素 后代中 满足条件的元素 注意 后代包括：儿子、孙子、重孙子…… 后代选择器中，选择器与选择器之前通过 空格 隔开 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style /* 找到div的儿子p设置文字颜色是红色 */ /* 父选择器 后代选择器 */ div p color: red; /style/headbody !-- 后代: 儿子, 孙子, 重孙子..... -- p这是一个p标签/p div p 这是div的儿子p p这是孙子/p /p /div/body/html 子代选择器： 结构 选择器 1 选择器 2 { } 作用 根据 HTML 标签的嵌套关系，选择父元素 子代中 满足条件的元素 注意 子代只包括：儿子 子代选择器中，选择器与选择器之前通过 隔开 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style /* 空格隔开的是后代, 儿子,孙子,重孙子 */ /* div a color: red; */ /* 只想选中儿子a */ /* div的儿子a文字颜色是红色 */ diva color: red; /style/headbody div 父级 a href=#这是div里面的a/a p a href=#这是div里面的p里面的a/a /p /div/body/html 并集选择器 结构 选择器 1 , 选择器 2 { } 作用 同时选择多组标签，设置相同的样式 注意 并集选择器中的每组选择器之间通过 , 分隔 并集选择器中的每组选择器可以是基础选择器或者复合选择器 并集选择器中的每组选择器通常一行写一个，提高代码的可读性 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style /* p div span h1 文字颜色是红色 */ /* 选择器1, 选择器2 */ p, div, span, h1 color: red; /style/headbody pppp/p divdiv/div spanspan/span h1h1/h1 h2h2/h2/body/html 交集选择器：紧挨着 结构 选择器 1 选择器 2 { } 作用 选中页面中 同时满足 多个选择器的标签。（既又原则）找到页面中 既 能被选择器 1 选中，又 能被选择器 2 选中的标签，设置样式 注意 交集选择器中的选择器之间是紧挨着的，没有东西分隔 交集选择器中如果有标签选择器，标签选择器必须写在最前面 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style /* p color: red; */ /* .box color: red; */ /* 必须是p标签,而且添加了box类 */ p.box color: red; /* #dilireba color: red; */ .box1 color: green; /style/headbody !-- 找到第一个p,带box类的, 设置文字颜色是红色 -- p class=box box1 id=dilireba这是p标签:box/p p class=box这是p标签:box/p ppppppp/p div class=box这是div标签:box/div/body/html 嵌套选择器 结构 parentRule /* 父规则样式属性 */ childRule /* 子规则样式属性 */ 作用 它提供将一个样式规则嵌套至另一个规则内的能力。 示例 html p class=example 这段文字a href=#包含一个链接/a，尝试悬停或聚焦它。 /p style /* .example font-family: system-ui; font-size: 1.2rem; .example a color: tomato; .example a:hover, .example a:focus color: ivory; background-color: tomato; */ .example font-family: system-ui; font-size: 1.2rem; a color: tomato; :hover, :focus color: ivory; background-color: tomato; /style/html html !-- 如果不在一个嵌套规则里使用，则 嵌套选择器将代表其根作用域。 -- p在结果框上方悬停以更改文档的背景颜色。/p style color: blue; font-weight: bold; :hover background-color: wheat; /style/html hover 伪类选择器 伪类：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes 结构 选择器: hover { } 作用 选中鼠标 悬停 在元素上的 状态，设置样式 注意 伪类选择器选中的元素的 某种状态 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style /* 悬停的时候文字颜色是红色 */ a:hover color: red; background-color: green; /* 用户鼠标悬停到div的时候, 文字是绿色 */ div:hover color: green; /style/headbody a href=#这是超链接/a !-- 任何标签都可以添加伪类, 任何一个标签都可以鼠标悬停 -- divdiv/div/body/html 伪类-超链接 超链接一共有四个状态 选择器 作用 : link 访问前 : visted 访问后 : hover 鼠标悬停 : active 点击时（激活） 提示：如果要给超链接设置以上四个状态，需要按照 LVHA 的顺序书写。 结构伪类选择器 结构 选择器 说明 E: first-child{} 匹配父元素中第一个子元素，并且是 E 元素 E: last-child{} 匹配父元素中最后个子元素，并且是 E 元素 E: nth-child(n){} 匹配父元素中第 n 个子元素，并且是 E 元素 E: nth-last-child(n){} 匹配父元素中倒数第 n 个子元素，并且是 E 元素 作用 根据元素在 HTML 中的 结构关系 查找元素 场景 常用于查找某父级选择器中的子元素 注意 n 为：0、1、2、3、4、…… 通过 n 可以组成常见公式 功能 公式 偶数 2n、even 奇书 2n+1、2n-1、odd 找到前 5 个 -n+5 找到从第 5 个往后 n+5 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title !-- style /* 第一个li里面的a */ li:first-child a /* background-color: green; */ color: red; /style -- style /* 找到第一个li 里面的 第三个a 设置文字颜色是红色 */ li:first-child a:nth-child(3) color: red; /style/headbody ul li a href=#这是第1个li里面的a1/a a href=#这是第1个li里面的a2/a !-- 选中第三个a -- a href=#这是第1个li里面的a3/a a href=#这是第1个li里面的a4/a a href=#这是第1个li里面的a5/a /li lia href=#这是第2个li里面的a/a/li lia href=#这是第3个li里面的a/a/li lia href=#这是第4个li里面的a/a/li lia href=#这是第5个li里面的a/a/li lia href=#这是第6个li里面的a/a/li lia href=#这是第7个li里面的a/a/li lia href=#这是第8个li里面的a/a/li /ul/body/html 伪元素选择器 结构 选择器 说明 E:: before 在 E 元素 里面 最 前 面添加一个伪元素 E:: after 在 E 元素 里面 最 后 面添加一个伪元素 作用 创建 虚拟 元素（伪元素），用来摆放 装饰性 的内容 注意 必须 设置 content: ” ” 属性，用来 设置 伪元素的内容，如果没有内容，则引号 留空 即可。 伪元素默认是 行内 显示模式 权重 和 标签选择器 相同 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title伪元素选择器/title style div::after display: block; content: after伪元素; width: 300px; height: 300px; background-color: pink; /style/headbody !-- 标签内容：老鼠爱大米 -- div爱/div/body/html 链接伪类选择器 结构 选择器语法 功能 a: link { } 选中 a 链接 未访问过 的状态 a: visited { } 选中 a 链接 访问过后 的状态 a: hover { } 选中 鼠标悬停 的状态 a: active { } 选中 鼠标按下 的状态 场景 常用于选中超链接的不同状态 注意 如果需要同时实现以上四种伪类状态效果，需要按照 LVHA 顺序书写 其中 : hover 伪类选择器 使用更为频繁，常用于选择各类元素的悬停状态 焦点伪类选择器 结构 input: focus {} 场景 用于选中元素获取焦点时状态，常用于表单控件 示例 input:focus background-color: pink; 字体和文本样式字体样式字体大小 属性名 font-size 取值 文字尺寸，PC 端网页最常用的单位 px 注意点 谷歌浏览器默认文字大小是 16px 单位需要设置，否则无效 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title字体大小/title style /* 经验：谷歌浏览器文字有默认大小 16px */ p /* font-size 属性必须有单位，否则属性不生效 */ font-size: 30px; /style/headbody p测试字体大小/p div测试默认字体大小/div/body/html 字体粗细 属性名 font-weight 取值 数字（开发使用） 正常 400 加粗 700 关键字 正常 normal 加粗 bold 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title字体粗细/title style h3 font-weight: 700; div font-weight: bold; /style/headbody h3h3 标题/h3 divdiv 标签/div/body/html 字体样式（是否倾斜） 属性名 font-style 取值 正常：normal 倾斜：italic 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title字体倾斜/title style em font-style: normal; div font-style: italic; /style/headbody emem 标签/em divdiv 标签/div/body/html 行高 作用 控制一行的上下行间距 属性名 line-height 取值： 数字+px 倍数（当前标签 font-size 的倍数） 应用： 让单行文本垂直居中可以设置 line-height : 文字父元素高度 网页精准布局时，会设置 line-height : 1 可以取消上下间距 行高与 font 连写的注意点： 如果同时设置了行高和 font 连写，注意覆盖问题 font : style weight size line-height family 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title行高/title style p font-size: 20px; /* line-height: 30px; */ /* 行高值是数字，表示是当前标签字体大小的倍数 */ line-height: 2; /style/headbody p今年受成本驱动、需求拉动以及全球粮价上涨等各种因素叠加影响，我国粮食价格整体上扬，小麦、玉米、大豆价格高位波动，水稻价格运行平稳，优质优价特征明显，农民择机择时售粮，实现种粮收益最大化。但种粮成本持续攀升成为影响农民增收的“拦路虎”。这是因为，在去年高粮价的刺激下，今年土地租金以及化肥、农药、柴油等农资价格大幅上涨，种粮成本随之增加。加之今年粮食生产遭遇去年北方罕见秋雨秋汛、今年“南旱北涝”等极端天气，虽然没有带来灾害性后果，但一些农户为抗灾付出更多生产成本，种粮农户收益空间进一步收窄。/p/body/html 行高的测量方法： 从一行文字的最顶端（最底端）量到下一行文字的最顶端（最底端）。 行高-垂直居中 垂直居中技巧 行高属性值等于盒子高度属性值 注意 该技巧适用于单行文字垂直居中效果 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title垂直居中/title style div height: 100px; background-color: skyblue; /* 注意：只能是单行文字垂直居中 */ line-height: 100px; /style/headbody div文字/div/body/html 字体族 属性名 font-family 取值 字体名 1, 字体名 2…., 字体族名（可以只写一个字体名） 注意 从左向右依次查找 建议 font-family 属性最后设置一个字体族名 网页开发建议使用无衬线字体 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title字体族/title style div font-family: 楷体; /style/headbody div测试文字/div/body/html 样式层叠问题 问题 给同一个标签设置了相同的样式，此时浏览器会如何渲染呢？ 结果 如果给同一个标签设置了相同的属性，此时样式会层叠（覆盖），写在最下面的会生效 TIPS CSS （Cascading style sheets） 层叠样式表 所谓的层叠即叠加的意思，表示样式可以一层一层的层叠覆盖 字体 font 相关属性连写 属性名 font (复合属性) 取值 font : style weight size family; 省略要求 只能省略前两个，如果省略了相当于设置了默认值 注意点：如果需要同时设置单独和连写形式 要么把单独的样式写在连写的下面 要么把单独的样式写在连写的里面 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style p /* font-size: ; font-style: ; font-weight: ; font-family: ; */ /* font: style weight size 字体; */ /* font: italic 700 66px 宋体; font-style: normal; */ font: 100px 微软雅黑; /* 一个属性冒号后面书写多个值的写法 -- 复合属性 */ /style/headbody p这是p标签/p/body/html 文本样式文本缩进 属性名 text-indent 取值 数字+px 数字+em（推荐：1em 当前标签的 font-size 的大小） 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style p /* text-indent: 50px; */ /* 首行缩进2个字的大小 */ /* 默认字号: 16px ; 32 */ /* text-indent: 40px; font-size: 20px; */ /* em: 一个字的大小 */ text-indent: 2em; font-size: 40px; /style/headbody p2019年，事件视界望远镜团队让世界首次看到了黑洞的样子。不过，研究人员公布的这张发光环形物体的图像并不是传统的图片，而是经过计算获得的。利用位于美国、墨西哥、智利、西班牙和南极地区的射电望远镜所得到的数据，研究人员进行了数学转换，最终合成了这张标志性的图片。研究团队还发布了实现这一壮举所用的编程代码，并撰文记录这一发现，其他研究者也可以在此基础上进一步加以分析。/p/body/html 文本水平线对齐方式 属性名 text-align 取值 属性值 效果 left 左对齐 center 居中对齐 right 右对齐 注意 如果需要让文本水平居中，text-align 属性给文本所在标签（文本的父元素）设置 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style h1 /* text-align: left; */ /* text-align: right; */ text-align: center; div text-align: center; /style/headbody h1新闻标题/h1 div img src=./images/1.jpg alt= /div/body/html 文本修饰线 属性名 text-decoration 取值 属性值 效果 underline 下划线（常用） line-through 删除线（不常用） overline 上划线（几乎不用） none 无装饰线（常用） 注意 开发中会使用 text-decoration : none ; 清除 a 标签默认的下划线 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style div text-decoration: underline; p text-decoration: line-through; h2 text-decoration: overline; a text-decoration: none; /style/headbody divdiv/div pppp/p h2h2/h2 a href=#我是超链接, 点呀/a/body/html 文本颜色 属性名 color 取值 颜色表示方式 属性值 说明 使用场景 颜色关键字 颜色英文单词 red、blue 学习测试 rgb 表示 rgb(r, g, b) r, g, b 表示红绿蓝三原色，取值：0-1 了解 rgba 表示 rgb(r, g, b，a) a 表示透明度，取值：0-1 开发使用，实现 透明色 十六进制表示 #RRGGBB #000000，#ffcc00，简写：#000，#fc0 开发使用 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title文字颜色/title style h1 background-color: aqua; /* color: red; */ /* color: rgb(0,255,0); */ /* color: rgba(0,0,0,0.8); */ /* color: #0000ff; */ color: #00f; /style/headbody h1h1 标签/h1/body/html 背景相关属性背景色 属性名 background-color（bgc） 属性值： 颜色取值：关键字、rgb 表示法、rgba 表示法、十六进制…… 注意点： 背景颜色默认值是 透明： rgba(0,0,0,0) 、transparent 背景颜色不会影响盒子大小，并且还能看清盒子的大小和位置，一般在布局中会习惯先给盒子设置背景颜色 示例： !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style div width: 400px; height: 400px; /* background-color: pink; */ /* background-color: #ccc; */ /* 红绿蓝三原色, a是透明度0-1 */ /* background-color: rgba(0, 0, 0, 0.5); */ background-color: rgba(0, 0, 0, .5); /style/headbody divdiv/div/body/html 背景图背景图片 属性名 background-image（bgi） 属性值： background-image: url(‘图片路径’); 注意点： 背景图片中 url 中可以省略引号 背景图片默认是在水平和垂直方向平铺的 背景图片仅仅是指给盒子起到装饰效果，类似于背景颜色，是 不能撑开盒子的 示例： !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style div width: 400px; height: 400px; background-color: pink; background-image: url(./images/1.jpg); /style/headbody div文字/div/body/html 背景图平铺 属性名 background-repeat（bgr） 属性值： 取值 效果 repeat （默认值）水平和垂直方向都平铺 no-repeat 不平铺 repeat-x 沿着水平方向（x 轴）平铺 repeat-y 沿着垂直方向（y 周）平铺 示例： !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title背景图平铺方式/title style div width: 400px; height: 400px; background-color: pink; background-image: url(./images/1.png); /* 不平铺：盒子的左上角显示一张背景图 */ background-repeat: no-repeat; /* background-repeat: repeat; */ /* background-repeat: repeat-x; */ /* background-repeat: repeat-y; */ /style/headbody divdiv 标签/div/body /html 背景图位置 属性名 background-position（bgp） 属性值 background-position：水平方向 垂直方向; 关键字 位置 left 左侧 right 右侧 center 居中 top 顶部 bottom 底部 坐标 水平：正数向右；负数向左 垂直：正数向下；负数向上 注意点 方位名词取值和坐标取值可以混使用，第一个取值表示水平，第二个取值表示垂直 示例： !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title背景图位置/title style div width: 400px; height: 400px; background-color: pink; background-image: url(./images/1.png); background-repeat: no-repeat; /* 左上角 */ /* background-position: 0 0; */ /* background-position: left top; */ /* background-position: right bottom; */ /* 水平：正数向右，负数向左 */ /* background-position: 50px 0; */ /* background-position: -50px 0; */ /* 垂直：正数向下，负数向上 */ /* background-position: 0 100px; */ /* background-position: 0 -100px; */ /* background-position: 50px center; */ /* 特殊写法 */ /* background-position: bottom left; */ /* 关键字可以只写一个，另一个方向居中 */ /* background-position: bottom; */ /* 只写一个数字表示水平方向，垂直方向居中 */ background-position: 50px; /style/headbody divdiv 标签/div/body/html 背景图缩放 属性名 background-size（bgz） 属性值 关键字 cover：等比例缩放背景图片以完全覆盖背景区，可能背景图片部分看不见 contain：等比例缩放背景图片以完全装入背景区，可能背景区部分空白 百分比 根据盒子尺寸计算图片大小 数字+单位（px） 注意点 工作中，图片比例与盒子比例相同，使用 cover 或 contain 缩放背景图效果相同。 示例： !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title背景图缩放/title style div width: 500px; height: 300px; background-color: pink; background-image: url(./images/1.png); background-repeat: no-repeat; /* contain：如果图的宽高跟盒子尺寸相等停止缩放，可能导致盒子有露白 */ /* background-size: contain; */ /* cover：图片完全覆盖盒子，可能导致图片显示不全 */ /* background-size: cover; */ /* 100% 图片的宽度跟盒子宽度一样，图片的高度按照图片比例等比缩放 */ background-size: 100%; /style/headbody divdiv 标签/div/body/html 背景图固定 属性名 background-attachment（bga） 作用 背景不会随着元素的内容滚动 属性值 fixed 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title背景图固定/title style body background-image: url(./images/bg.jpg); background-repeat: no-repeat; background-position: center top; background-attachment: fixed; /style/headbody p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p p测试文字，撑开body，让浏览器有滚动条/p/body/html 背景复合属性 属性名 background（bg） 属性值 单个属性值的合写，取值之间以空格隔开 书写顺序 推荐：background：color image repeat position 省略问题 可以按照需求省略 特殊情况 在 pc 端，如果盒子大小和背景图片大小一样，此时可以直接写 background：url() 注意点 如果需要设置单独的样式和连写 要么把单独的样式写在连写的下面 要么把单独的样式写在连写的里面 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style div width: 400px; height: 400px; /* 不分先后顺序 背景色 背景图 背景图平铺 背景图位置 */ /* background: pink url(./images/1.jpg) no-repeat center bottom; */ /* 背景图位置如果是英文单词可以颠倒顺序 */ background: pink url(./images/1.jpg) no-repeat bottom center ; /* 测试背景图位置如果是数值 不要颠倒顺序 */ /* 水平50px, 垂直100px */ /* background: pink url(./images/1.jpg) no-repeat 50px 100px; */ background: pink url(./images/1.jpg) no-repeat 100px 50px; /style/headbody div/div/body/html 元素显示模式显示模式 块级元素 显示特点： 独占一行（一行只能显示一个） 宽度默认是父元素的宽度，高度默认由内容撑开 可以设置宽高 块元素是一个容器及盒子，其中可以再放 行内或者块级元素 代表标签： h1~h6、p、div、ul、ol、li 行内元素 显示特点： 一行可放多个行内元素，即相邻行内元素在一行 对行内元素的 高、宽直接设置是无效 的 行内元素的 默认宽度为其所含内容的宽度 行内元素中只能容纳 文本 或者 行内元素 代表标签： a、strong、b、em、I、del、s、ins、u、span 行内块元素 显示特点： 和相邻行内元素在一行上，但是元素之间会有空隙 默认宽度为该元素本身内容的宽度 高度、宽度、外边距以及内边距都可以控制 代表标签： img/、input/、td 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title显示模式/title style /* 块级：独占一行；宽度默认是父级的100%；加宽高生效 */ div width: 100px; height: 100px; .div1 background-color: brown; .div2 background-color: orange; /* 行内：一行共存多个；尺寸由内容撑开；加宽高 不 生效 */ span width: 200px; height: 200px; .span1 background-color: brown; .span2 background-color: orange; /* 行内块：一行共存多个；默认尺寸由内容撑开；加宽高生效 */ img width: 100px; height: 100px; /style/headbody !-- 块元素 -- div class=div1div 标签1/div div class=div2div 标签2/div !-- 行内元素 -- span class=span1span11111111/span span class=span2span1/span !-- 行内块元素 -- img src=./images/1.png alt= img src=./images/1.png alt= /body/html 元素示模式转换 目的 改变元素默认的显示特点，让元素符合布局要求 语法 属性 效果 使用频率 display: block 转换成块级元素 较多 display: inline-block 转换成行内块元素 较多 display: inline 转换成行内元素 较少 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title显示模式转换/title style /* 块级：独占一行；宽度默认是父级的100%；加宽高生效 */ div width: 100px; height: 100px; /* display: inline-block; */ display: inline; .div1 background-color: brown; .div2 background-color: orange; /* 行内：一行共存多个；尺寸由内容撑开；加宽高 不 生效 */ span width: 200px; height: 200px; /* display: block; */ display: inline-block; .span1 background-color: brown; .span2 background-color: orange; /* 行内块：一行共存多个；默认尺寸由内容撑开；加宽高生效 */ img width: 100px; height: 100px; display: block; /style/headbody !-- 块元素 -- div class=div1div 标签1/div div class=div2div 标签2/div !-- 行内元素 -- span class=span1span11111111/span span class=span2span1/span !-- 行内块元素 -- img src=./images/1.png alt= img src=./images/1.png alt= /body/html CSS 特性继承性 特性 子元素有默认继承父元素样式的特点（子承父业） 可以继承的常见属性(文字控制属性都可以继承) color font-style、font-weight、font-size、font-family text-indent、text-align line-height 注意点 可以通过调试工具判断样式是否可以继承 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleCSS特性-继承性/title style body font-size: 30px; color: red; font-weight: 700; /style/headbody divdiv 标签/div pp 标签/p spanspan 标签/span !-- 如果标签自己有样式则生效自己的样式，不继承 -- a href=#a 标签/a h1h1 标签/h1/body/html 层叠性 特性 给同一个标签设置不同的样式 → 此时样式会层叠叠加 → 会共同作用在标签上 给同一个标签设置相同的样式 → 此时样式会层叠覆盖 → 最终写在最后的样式会生效 注意点 当样式冲突时，只有当选择器优先级相同时，才能通过层叠性判断结果 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleCSS特性-层叠性/title style /* 覆盖；叠加 */ div color: green; font-size: 30px; div color: red; font-weight: 700; /style/headbody divdiv 标签/div/body/html 优先级 特性 不同选择器具有不同的优先级，优先级高的选择器样式会覆盖优先级低选择器样式 优先级公式 继承 通配符选择器 标签选择器 类选择器 id 选择器 行内样式 ! important 注意点 ! important 写在属性值的后面，分号的前面！ ! important 不能提升继承的优先级，只要是 继承 优先级最低！ 实际开发中不建议使用 ! important 权重叠加计算 场景 如果是复合选择器，此时需要通过权重叠加计算方法，判断最终哪个选择器优先级最高会生效 权重叠加计算公式：（每一级之间不存在进位） （行内 样式, id 选择器个数, 类 选择器个数, 标签 选择器个数） 比较规则 • 先比较第一级数字，如果比较出来了，之后的统统不看 • 如果第一级数字相同，此时再去比较第二级数字，如果比较出来了，之后的统统不看 • 如果最终所有数字都相同，表示优先级相同，则比较层叠性（谁写在下面，谁说了算!） 注意点 ! important 如果不是继承，则权重最高，天下第一！ 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleCSS 特性-优先级/title style /* 技巧：选择器选中标签的范围越大，优先级/权重 越低 */ div color: green; /* !important 提权功能，提高权重/优先级到 最高，慎用 */ * color: red !important; .box color: blue; #test color: orange; /style/headbody div class=box id=test style=color: purple;div 标签/div/body/html 盒子模型盒子模型介绍 盒子的概念 页面中的每一个标签，都可看做是一个 盒子，通过盒子的视角更方便的进行布局 浏览器在渲染（显示）网页时，会将网页中的元素看做是一个个的矩形区域，我们也形象的称之为 盒子 盒子模型 CSS 中规定每个盒子分别由：内容区域（content）、内边距区域（padding）、边框区域（border）、外边距区域（margin）构成，这就是 盒子模型 盒子模型 – 组成 盒子模型重要组成部分 内容区域 – width height 内边距 – padding（出现在内容与盒子边缘之间） 边框线 – border 外边距 – margin（出现在盒子外面） 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title盒子模型-组成/title style #div1 background: blue; #div2 width: 200px; height: 200px; background-color: pink; /* 内容与盒子边缘之间 */ padding: 20px; border: 10px solid #000; /* 出现在盒子外面，拉开两个盒子之间的距离 */ margin: 50px; /style/headbody div id=div1 标签1 div id=div2div 标签/div 标签1 /div/body/html 盒子模型 – 边框线 作用 给设置边框粗细、边框样式、边框颜色效果 属性 作用 属性名 属性值 边框粗细 border-width 数字+px 边框样式 border-style 实线 solid、虚线 dashed、点线 dotted 边框颜色 border-color 颜色取值 连写 属性名：border 属性值：单个取值的连写，取值之间以空格隔开 border : 10px solid red; 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style div width: 200px; height: 200px; background-color: pink; /* border: 粗细 线条样式 颜色 -- 不分先后顺序 */ /* solid : 实线 */ /* border: 1px solid #000; */ /* dashed: 虚线 */ /* border: 5px dashed #000; */ /* dotted : 点线 */ /* border: 5px dotted #000; */ /* 设置单方向 */ border-left: 5px dotted #000; border-right: 5px dotted #000; border-top: 1px solid red; border-bottom: 1px solid red; /style/headbody div内容/div/body/html 盒子模型 – 内边距 内边距（padding）- 取值 作用：设置边框与内容区域之间的距离 属性名：padding 常见取值： 取值 示例 含义 一个值 padding: 10px; 上下左右 都设置为 10px 两个值 padding: 10px 20px; 上下设置为 10px，左右设置为 20px 三个值 padding: 10px 20px 30px; 上设置为 10px、左右设置为 20px、下设置为 30px 四个值 padding: 10px 20px 30px 40px; 上设置为 10px、右设置为 20px、下设置为 30px，左设置为 40px 记忆规则：从上开始赋值，然后顺时针赋值，如果设置赋值的，看对面的！！ 内边距（padding）- 单方向设置 场景：只给盒子的某个方向单独设置内边距 属性名：padding - 方位名词 属性值：数字 + px 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title盒子模型-内边距/title style div width: 200px; height: 200px; background-color: pink; /* padding: 20px; */ padding-top: 10px; padding-right: 20px; padding-bottom: 40px; padding-left: 80px; /style/headbody divdiv 标签/div/body/html 盒子模型 – 外边距 外边距（margin）- 取值 作用：设置边框以外，盒子与盒子之间 的距离 属性名：margin 常见取值： 取值 示例 含义 一个值 margin: 10px; 上下左右 都设置为 10px 两个值 margin: 10px 20px; 上下设置为 10px，左右设置为 20px 三个值 margin: 10px 20px 30px; 上设置为 10px、左右设置为 20px、下设置为 30px 四个值 margin: 10px 20px 30px 40px; 上设置为 10px、右设置为 20px、下设置为 30px，左设置为 40px 外边距（ margin ）- 单方向设置 场景：只给盒子的某个方向单独设置外边距 属性名：margin- 方位名词 属性值：数字 + px 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title版心居中/title style div /* 版心居中要求：盒子要有宽度 */ width: 1000px; height: 200px; background-color: pink; /* 外边距 不会 撑大盒子 */ /* margin: 50px; */ /* margin-left: 100px; */ /* margin: 50px 100px; */ margin: 0 auto; /style/headbody div版心内容/div/body/html 盒子模型 – 尺寸计算 默认情况 盒子尺寸 内容尺寸 + border 尺寸 + 内边距尺寸 结论 给盒子加 border padding 会撑大盒子 解决 手动做减法，减掉 border padding 的尺寸 內减模式：box-sizing: border-box 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title盒子模型-尺寸计算/title style div width: 200px; height: 200px; /* 手动减法 */ /* width: 160px; height: 160px; */ background-color: pink; padding: 20px; /* 內减模式：不需要手动减法，加padding和border不会撑大盒子 */ box-sizing: border-box; /style/headbody divdiv 标签/div/body/html 盒子模型-元素溢出 作用 控制溢出元素的内容的显示方式。 属性名 overflow 属性值 属性值 效果 hidden 溢出隐藏 scroll 溢出滚动（无论是否溢出，都显示滚动条的位置） auto 溢出滚动（溢出才显示滚动条的位置） 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title元素溢出/title style div width: 200px; height: 200px; background-color: pink; overflow: hidden; /* overflow: scroll; */ /* overflow: auto; */ /style/headbody div 文字内容测试 文字内容测试 文字内容测试 文字内容测试 文字内容测试 文字内容测试 文字内容测试 文字内容测试 文字内容测试 文字内容测试 文字内容测试 文字内容测试 文字内容测试 文字内容测试 文字内容测试 文字内容测试 文字内容测试 文字内容测试 文字内容测试 文字内容测试 文字内容测试 文字内容测试 文字内容测试 文字内容测试 /div/body/html 外边距问题 – 合并现象 场景 垂直布局 的 块级元素，上下的 margin 会合并 结果 最终两者距离为 margin 的最大值 解决方法 只给其中一个盒子设置 margin 即可 现象代码 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style div width: 100px; height: 100px; background-color: pink; .one /* margin-bottom: 50px; */ margin-bottom: 60px; .two margin-top: 50px; /style/headbody div class=one11/div div class=two22/div/body/html 外边距问题 – 塌陷问题 场景 互相嵌套 的 块级元素，子元素的 margin-top 会作用在父元素上 结果 导致父元素一起往下移动 解决方法： 给父元素设置 border-top 或者 padding-top（分隔父子元素的 margin-top） 给父元素设置 overflow：hidden 转换成行内块元素 设置浮动 现象代码 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleDocument/title style .father width: 300px; height: 300px; background-color: pink; /* 解决方式： */ /* padding-top: 50px; */ /* 如果设计稿没有border, 不能使用这个解决办法 */ /* border: 1px solid #000; */ /* overflow: hidden; */ .son width: 100px; height: 100px; background-color: skyblue; margin-top: 50px; /* 解决方式 */ /* display: inline-block; */ /style/headbody div class=father div class=sonson/div /div/body/html 行内元素 - 内外边距问题 场景 行内 元素添加 margin 和 padding，无法改变元素 垂直 位置 解决办法 给行内元素添加 line-height 可以改变垂直位置 解决代码 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title行内元素的垂直内外边距/title style span margin: 50px; padding: 20px; /* line-height: 100px; */ background-color: aqua; /style/headbody spanspan标签/span spanspan标签/span/body/html CSS 布局标准流 标准流 又称 文档流，是浏览器在渲染显示网页内容时默认采用的一套排版规则，规定了应该以何种方式排列元素 常见标准流排版规则 块级元素：从上往下，垂直布局，独占一行 行内元素或行内块元素：从左往右，水平布局，空间不够自动折行 Flex 布局简介Flex 布局也叫弹性布局，是浏览器提倡的布局模型，非常适合结构化布局，提供了强大的空间分布和对齐能力。Flex 模型不会产生浮动布局中脱标现象，布局网页更简单、更灵活。 组成 设置方式 给 父 元素设置 display: flex，子 元素可以 自动挤压或拉伸 组成部分 弹性容器 弹性盒子 主轴：默认在 水平 方向 侧轴 交叉轴：默认在 垂直 方向 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleflex布局-组成/title style /* 弹性容器 */ .box /* 布局方式为 flex */ display: flex; height: 300px; border: 1px solid #000; /* 弹性盒子：沿着主轴方向排列 */ .box div width: 200px; height: 100px; background-color: pink; /style/headbody div class=box div1/div div2/div div3/div /div/body/html 对齐方式 主轴对齐 属性名：justify-content 属性值 属性值 效果 flex-start 默认值，弹性盒子从起点开始依次排列 flex-end 弹性盒子从终点开始依次排列 center 弹性盒子沿主轴居中排列 space-between 弹性盒子沿主轴均匀排列，父级剩余的尺寸分配成间距，空白间距均分在弹性盒子之间 space-around 弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子两侧，弹性盒子之间的间距是两端间距的2倍 space-evenly 弹性盒子沿主轴均匀排列，弹性盒子与容器之间间距相等 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleflex布局-主轴对齐方式/title style .box display: flex; /* justify-content: flex-start; */ /* justify-content: flex-end; */ /* 居中 */ /* justify-content: center; */ /* 父级剩余的尺寸分配成间距 */ /* 弹性盒子之间的间距相等 */ /* justify-content: space-between; */ /* 间距出现在弹性盒子两侧 */ /* 视觉效果：弹性盒子之间的间距是两端间距的2倍 */ /* justify-content: space-around; */ /* 各个间距都相等 */ justify-content: space-evenly; height: 300px; border: 1px solid #000; .box div width: 200px; height: 100px; background-color: pink; /style/headbody div class=box div1/div div2/div div3/div /div/body/html flex-start flex-end center space-between space-around space-evenly 侧轴对齐 属性名 align-items：当前弹性容器内 所有 弹性盒子的侧轴对齐方式（给弹性容器设置） align-self：单独控制 某个 弹性盒子的侧轴对齐方式（给弹性盒子设置） 属性值 属性值 效果 stretch 弹性盒子沿着恻轴线被拉伸至铺满容器（弹性盒子没有设置恻轴方向尺寸则默认拉伸） center 弹性盒子沿恻轴居中排列 flex-start 弹性盒子从起点开始依次排列 flex-end 弹性盒子从终点开始依次排列 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleflex布局-侧轴对齐方式/title style .box display: flex; /* 弹性盒子在侧轴方向没有尺寸才能拉伸 */ /* align-items: stretch; */ /* align-items: center; */ /* align-items: flex-start; */ align-items: flex-end; height: 300px; border: 1px solid #000; /* 第二个div，侧轴居中对齐 */ .box div:nth-child(2) align-self: center; .box div width: 200px; height: 100px; background-color: pink; /style/headbody div class=box div1/div div2/div div3/div /div/body/html stretch !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleflex布局-侧轴对齐方式/title style .box display: flex; /* 弹性盒子在侧轴方向没有尺寸才能拉伸 */ align-items: stretch; height: 300px; border: 1px solid #000; .box div width: 200px; /* 如果设置了尺寸就不会拉伸 */ /* height: 100px; */ background-color: pink; /style/headbody div class=box div1/div div2/div div3/div /div/body/html center !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleflex布局-侧轴对齐方式/title style .box display: flex; /* 弹性盒子在侧轴方向没有尺寸才能拉伸 */ align-items: center; height: 300px; border: 1px solid #000; .box div width: 200px; /* 如果设置了尺寸就不会拉伸 */ height: 100px; background-color: pink; /style/headbody div class=box div1/div div2/div div3/div /div/body/html flex-start flex-end align-self !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleflex布局-侧轴对齐方式/title style .box display: flex; height: 400px; border: 1px solid #000; /* 第二个div，侧轴居中对齐 */ .box div:nth-child(2) align-self: center; .box div width: 200px; height: 100px; background-color: pink; /style/headbody div class=box div1/div div2/div div3/div /div/body/html 修改主轴方向 作用 主轴 默认在水平方向，侧轴默认在垂直方向 属性名 flex-direction 属性值 属性值 效果 row 水平方向，从左向右（默认） column 垂直方向，从上向下 row-reverse 水平方向，从右向左 column-reverse 垂直方向，从下向 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleflex布局-修改主轴方向/title style .box display: flex; /* 修改主轴方向 垂直方向；侧轴自动变换到水平方向 */ flex-direction: column; /* 主轴在垂直，视觉效果：垂直居中 */ justify-content: center; /* 侧轴在水平，视觉效果：水平居中 */ align-items: center; width: 150px; height: 120px; background-color: pink; img width: 32px; height: 32px; /style/headbody div class=box img src=./images/1.png alt= span媒体/span /div/body/html 弹性伸缩比 作用 控制弹性盒子的 主轴 方向的尺寸。 属性名 flex 属性值 整数数字，表示占用父级 剩余 尺寸的 份数。 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleflex布局-弹性伸缩比/title style /* 默认情况下，主轴方向尺寸是靠内容撑开；侧轴默认拉伸 */ .box display: flex; height: 300px; border: 1px solid #000; .box div /* height: 100px; */ background-color: pink; border: solid 2px; .box div:nth-child(1) width: 200px; .box div:nth-child(2) flex: 1; .box div:nth-child(3) flex: 2; /style/headbody div class=box div1/div div2/div div3/div /div/body/html 弹性盒子换行 作用 弹性盒子可以自动挤压或拉伸，默认情况下，所有弹性盒子都在一行显示。 属性名 flex-wrap 属性值 wrap：换行 nowrap：不换行（默认） 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleflex布局-弹性换行/title style .box display: flex; flex-wrap: wrap; /* 不换行 */ /* flex-wrap: nowrap; */ justify-content: space-between; height: 300px; border: 1px solid #000; .box div width: 200px; height: 100px; background-color: pink; /style/headbody div class=box div1/div div2/div div3/div div4/div div5/div div6/div div7/div div8/div div9/div div10/div div11/div div12/div /div/body/html nowrap wrap 行对齐方式 属性名 align-content 属性值 属性值 效果 flex-start 默认值，弹性盒子从起点开始依次排列 flex-end 弹性盒子从终点开始依次排列 center 弹性盒子沿主轴居中排列 space-between 弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子之间 space-around 弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子两侧 space-evenly 弹性盒子沿主轴均匀排列，弹性盒子与容器之间间距相等 注意 该属性对 单行 弹性盒子模型 无效。 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 titleflex布局-行对齐方式/title style .box display: flex; flex-wrap: wrap; justify-content: space-between; /* 调整 行对齐方式：对单行弹性盒子不生效 */ /* align-content: flex-start; */ /* align-content: flex-end; */ /* align-content: center; */ /* align-content: space-between; */ /* align-content: space-around; */ /* 没有代码提示 */ align-content: space-evenly; height: 400px; border: 1px solid #000; .box div width: 200px; height: 100px; background-color: pink; /style/headbody div class=box div1/div div2/div div3/div div4/div div5/div div6/div div7/div div8/div /div/body/html 定位网页常见布局方式 标准流 块级元素独占一行 → 垂直布局 行内元素行内块元素一行显示多个 → 水平布局 浮动 可以让原本垂直布局的 块级元素变成水平布局 flex 弹性布局，Flex 模型不会产生浮动布局中脱标现象，布局网页更简单、更灵活。 定位 可以让元素自由的摆放在网页的任意位置 一般用于 盒子之间的层叠情况 定位常见应用场景 可以解决盒子与盒子之间的层叠问题 定位之后的元素 层级最高，可以层叠在其他盒子上面 可以让盒子始终固定在屏幕中的某个位置 定位使用步骤 设置定位方式 属性名 position 常见属性值 定位方式 属性值 静态定位 static 相对定位 relative 绝对定位 absolute 固定定位 fixed 设置偏移值 偏移值设置分为两个方向，水平和垂直方向各选一个使用即可 选取的原则一般是就近原则 （离哪边近用哪个） 方向 属性名 属性值 含义 水平 left 数字+px 距离左边的距离 水平 right 数字+px 距离右边的距离 垂直 top 数字+px 距离上边的距离 垂直 bottom 数字+px 距离下边的距离 静态定位 介绍 静态定位是默认值，就是之前认识的标准流 属性值 position:static; 注意点 静态定位就是之前标准流，不能通过方位属性进行移动 之后说的定位不包括静态定位，一般特指后几种：相对、绝对、固定 相对定位 介绍 自恋型定位，相对于自己之前的位置进行移动 属性值 position:relative; 注意点 需要配合方位属性实现移动 相对于自己原来位置进行移动 在页面中占位置 → 没有脱标 应用场景 配合绝对定位组 CP（子绝父相） 用于小范围的移动 示例 !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title相对定位/title style * margin: 0; padding: 0; /* 1. 改变位置的参照物是 自己原来的位置 2. 不脱标，占位 3. 标签显示模式特点 不变 */ div position: relative; top: 100px; left: 200px; /style/headbody pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p divimg src=./images/1.webp alt=/div pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p/body/html 绝对定位 介绍 拼爹型定位，相对于非静态定位的父元素进行定位移动 属性值 position:absolute; 注意点 需要配合方位属性实现移动 默认相对于浏览器可视区域进行移动 在页面中不占位置 → 已经脱标 应用场景 配合绝对定位组 CP（子绝父相） 示例 效果：font-demo.pages.dev !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title绝对定位/title style * margin: 0; padding: 0; img width: 400px; .news position: relative; margin: 100px auto; width: 400px; height: 350px; background-color: #f8f8f8; /* 1. 脱标，不占位 2. 参照物：先找最近的已经定位的祖先元素；如果所有祖先元素都没有定位，参照浏览器可视区改位置 3. 显示模式特点改变：宽高生效（具备了行内块的特点） */ .news span position: absolute; top: 0; right: 0; /* display: block; */ width: 92px; height: 32px; background-color: rgba(0,0,0,0.6); text-align: center; line-height: 32px; color: #fff; /style/headbody div class=news img src=./images/news.jpg alt= span展会活动/span h42222世界移动大会/h4 /div/body/html 效果：font-demo.pages.dev !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title绝对定位-居中/title style img position: absolute; left: 50%; top: 50%; /* margin-left: -265px; margin-top: -127px; */ /* 方便： 50% 就是自己宽高的一半 */ transform: translate(-50%, -50%); /style/headbody img src=./images/login.webp alt=/body/html 固定定位 介绍 死心眼型定位，相对于浏览器进行定位移动 属性值 position:fixed; 注意点 需要配合方位属性实现移动 相对于浏览器可视区域进行移动 在页面中不占位置 → 已经脱标 应用场景 让盒子固定在屏幕中的某个位置 示例 效果：font-demo.pages.dev !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title固定定位/title style * margin: 0; padding: 0; /* 1. 脱标，不占位 2. 参照物：浏览器窗口 3. 显示模式特点 具备行内块特点 */ div position: fixed; top: 0; right: 0; width: 500px; /style/headbody pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p divimg src=./images/1.webp alt=/div pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p pVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [5] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。/p/body/html 元素层级 不同布局方式元素的层级关系 标准流 浮动 定位 不同定位之间的层级关系 相对、绝对、固定默认层级相同 此时 HTML 中写在下面的元素层级更高，会覆盖上面的元素 修改定位元素层级 场景：改变定位元素的层级 属性名：z-index 属性值：数字 数字越大，层级越高 示例 效果：font-demo.pages.dev !DOCTYPE htmlhtml lang=enhead meta charset=UTF-8 meta http-equiv=X-UA-Compatible content=IE=edge meta name=viewport content=width=device-width, initial-scale=1.0 title堆叠顺序-z-index/title style div position: absolute; width: 200px; height: 200px; .box1 background-color: pink; /* 取值是整数，默认是0，取值越大显示顺序越靠上 */ z-index: 1; .box2 background-color: skyblue; left: 100px; top: 100px; z-index: 2; /style/headbody div class=box1box1/div div class=box2box2/div/body/html","tags":["CSS","选择器","盒子模型","flex布局","定位","装饰"],"categories":["前端"]},{"title":"HTML简介","path":"/2023/11/20/2023-11-20 HTML简介/","content":"概念 HTML（Hyper Text Markup Language）中文译为：超文本标记语言。专门用于网页开发的语言，主要通过 HTML 标签 对网页中的文本、图片、音频、视频等内容进行描述。 HTML 标签标签的结构 标签结构 !-- 开始标签 --strong 文字要变粗 !-- 包裹内容 --/strong!-- 结束标签 -- 结构说明 标签由 、、、英文单词或字母组成。并且把标签中 包括起来的英文单词或字母称为 标签名 常见标签由两部分组成，我们称之为：双标签。前部分叫 开始标签，后部分叫 结束标签，两部分之间包裹内容 少数标签由一部分组成，我们称之为：单标签。自成一体，无法包裹内容 标签的关系HTML 标签与标签之间的关系可分为： 父子关系（嵌套关系） head title/title/head 兄弟关系（并列关系） head/headbody/body 常用标签排版标签标题标签 场景：在新闻和文章的页面中，都离不开 标题，用来突出显示文章主题 代码：h 系列标签 h1一级标题/h1h2二级标题/h2h3三级标题/h3h4四级标题/h4h5五级标题/h5h6六级标题/h6 语义：1~6 级标题，重要程度依次递减 特点： 文字都有加粗 文字都有变大，并且从 h1 → h6 文字逐渐减小 独占一行 注意点： h1 标签对于网页尤为重要，一个网页中只能用一次，开发中有特定的使用场景，如：新闻的标题、网页的 logo 部分 段落标签 场景：在新闻和文章的页面中，用于分段显示 代码： p我是一段蚊子/p 语义：段落 特点： 段落之间存在间隙 独占一行 换行标签 场景：让文字强制换行显示 代码： br 语义：换行 特点： 单标签 让文字强制换行 水平线标签 场景：分割不同主题内容的水平线 代码： hr 语义：主题的分割转换 特点： 单标签 在页面中显示一条水平线 文本格式化标签 场景：需要让文字 加粗、下划线、倾斜、删除线 等效果 代码： 标签 说明 b 加粗 u 下划线 i 倾斜 s 删除线 标签 说明 strong 加粗 ins 下划线 em 倾斜 del 删除线 语义：突出重要性的强调语境 媒体标签图片标签 场景：在网页中显示图片 代码： img src= alt= 特点： 单标签 img 标签需要展示对应的效果，需要借助标签的属性进行设置！ 图片标签属性 src 属性值：目标图片的路径 注意点： 当前网页和目标图片在同一个文件夹中，路径直接写目标图片的名字即可（包括后缀名） alt 属性值：替换文本 当图片加载失败时，才显示 alt 的文本 当图片加载成功时，不会显示 alt 的文本 titile 属性值：提示文本 当鼠标悬停时，才显示的文本 注意点：title 属性不仅仅可以用于图片标签，还可以用于其他标签 width 和 height 属性值：宽度和高度 注意点： 如果只设置 width 或 height 中的一个，另一个没设置的会自动等比例缩放（此时图片不会变形） 如果同时设置了 width 和 height 两个，若设置不当此时图片可能会变形 路径 场景：页面需要加载图片，需要先找到对应的图片 类似于：生活中两个人，我要去找你，需要通过一定的路径才能找到！ 同理：页面需要找到图片，也是需要通过路径才能找到 路径可分为： 绝对路径（了解） 指目录下的绝对位置，可直接到达目标位置，通常 从盘符开始 的路径。 例如： 盘符开头：D:\\day01\\images\\1.jpg 完整的网络地址：https://www.itcast.cn/2018czgw/images/logo.gif 相对路径（常用） 音频标签 场景：在页面中插入音频 代码： audio src=./music.mp3 controls/audio 常见属性： 属性名 功能 src 音频的路径 controls 显示播放的控件 autoplay 自动播放（部分浏览器不支持） loop 循环播放 视频标签 场景：在页面中插入视频 代码： video src=./video.mp4 controls/video 常见属性： 属性名 功能 src 视频的路径 controls 显示播放的控件 autoplay 自动播放（谷歌浏览器中需配合 muted 实现静音播放） loop 循环播放 注意点： 视频标签目前仅支持三种格式：MP4、WebM、Ogg 链接标签 场景：点击之后，从一个页面跳转到另一个页面 代码： a href=./目标网页.html超链接/a 特点： 双标签，内部可以包裹内容 如果需要 a 标签点击之后去指定页面，需要设置 a 标签的 href 属性 属性 href 属性值：点击之后跳转去哪一个网页（目标网页的路径） 外部链接：a href=https://www.baidu.com/百度一下/a 内部链接：a href=./目标网页.html超链接/a target 属性值：目标网页打开的形式 取值 效果 _self 默认值，在当前窗口中跳转（覆盖原网页） _blank 在新窗口中跳转（保留原网页） a href=https://www.baidu.com/ target=_blank百度一下/a 空链接 a href=#空链接/a 点击之后回到网页顶部 开发中不确定该链接最终跳转位置，用空链接占个位置 列表标签列表的应用场景 场景：在网页中按照行展示关联性的内容，如：新闻列表、排行榜、账单等 特点：按照行的方式，整齐显示内容 种类：无序列表、有序列表、自定义列表 无序列表 场景：在网页中表示一组无顺序之分的列表，如：新闻列表 标签组成： 标签名 说明 ul 表示无序列表的整体，用于包裹 li 标签 li 表示无序列表的每一项，用于包含每一行的内容 显示特点： 列表的没一项默认显示原点标识 注意点： ul 标签中只允许包含 li 标签 li 标签可以包含任意内容 代码： body ul li榴莲/li li香蕉/li li苹果/li /ul/body 有序列表 场景：在网页中表示一组有顺序之分的列表，如：排行榜 标签组成： 标签名 说明 ol 表示有序列表的整体，用于包裹 li 标签 li 表示有序列表的每一项，用于包含每一行的内容 显示特点： 列表的没一项前默认显示序号标识 注意点： ol 标签中只允许包含 li 标签 li 标签可以包含任意内容 代码： body ol li张三:100/li li李四: 80/li /ol/body 自定义列表 场景：在网页的底部导航中通常会使用自定义列表实现 标签组成： 标签名 说明 dl 表示自定义列表的整体，用于包裹 dtdd 标签 dt 表示自定义列表的主题 dd 表示自定义列表的针对主题的每一项内容 显示特点： dd 会默认显示缩进效果 注意点： dl 标签中只允许包含 dtdd 标签 dtdd 标签可以包含任意内容 代码： body dl dt帮助中心/dt dd账户管理/dd dd购物指南/dd /dl/body 表格标签表格基本标签 场景：在网页中以行+列的单元格的方式整齐展示和数据，如：学生成绩表 基本标签： 标签名 说明 table 表格整体，可用于包裹多个 tr tr 表格每行，可用于包裹 td th 表头单元格 td 表格单元格，可用于包裹内容 注意点： 标签的嵌套关系：table tr th td 表格相关属性 场景：设置表格基本展示效果 常见相关属性： 属性名 属性值 效果 border 数字 边框宽度 width 数字 表格宽度 height 数字 表格高度 注意点： 实际开发时针对于样式效果 推荐用 CSS 设置 表格标题和表格单元头标签 场景：在表格中表示整体大标题和一列小标题 其他标签： 标签名 名称 说明 caption 表格大标题 表示表格整体大标题，默认在表格整体顶部居中位置显示 th 表格单元格 表示一系列小标题，通常用于表格第一行，默认内部文字加粗并居中显示 注意点： caption 标签书写在 table 标签内部 th 标签书写在 tr 标签内部（用于替换 td 标签） 表格结构标签 场景：让表格的内容结构分组，突出表格的不同部分（头部、主体、底部），使语义更加清晰 结构标签： 标签名 名称 thead 表格头部 tbody 表格主体 tfoot 表格底部 注意点： 表格结构标签内部用于包裹 tr 标签 表格的结构标签可以省略 代码: table border=1 width=300 height=300 captionstrong学生成绩单/strong/caption thead tr th姓名/th th成绩/th th评价/th /tr /thead tbody tr td张三/td td优秀/td /tr tr td李四/td td优秀/td /tr tr td王二麻子/td td良好/td /tr /tbody tfoot tr td总结/td td哈哈/td /tr /tfoot/table 合并单元格 场景：将 水平或垂直 多个单元格 合并成一个单元格 合并单元格步骤： 明确合并哪几个单元格 通过左上原则，确定保留谁删除谁 上下合并 → 只保留最上的，删除其他 左右合并 → 只保留最左的，删除其他 给保留的单元格设置：跨行合并（rowspan）或者跨列合并（colspan） 属性名 属性值 说明 rowspan 合并单元格的个数 跨行合并，将多行的单元格垂直合并 colspan 合并单元格的个数 跨列合并，将多列的单元格水平合并 注意点：只有同一个结构标签中的单元格才能合并，不能跨结构标签合并（不能跨：thead、tbody、tfoot） 代码： body table border=1 width=300 height=300 caption学生成绩单/caption tr th姓名/th th成绩/th th评语/th /tr tr td王五/td td rowspan=2100/td td优秀/td /tr tr td赵四/td td牛批/td /tr tr td总结/td td colspan=2叼叼叼/td /tr /table/body 表单标签input 系列input 系列标签的基本介绍 场景：在网页中显示收集用户信息的表单效果，如：登录页、注册页 标签名：input input 标签可以通过 type 属性值 的不同，展示不同效果 type 属性值： 标签名 type 属性值 说明 input text 文本框，用于输入单行文本 input password 密码框，用于输入密码 input radio 单选框，用于多选一 input checkbox 多选框，用于多选多 input file 文件选择，用于之后上传文件 input submit 提交按钮，用于提交 input reset 重置按钮，用于重置 input button 普通按钮，默认无功能，之后配合 js 添加功能 value 属性和 name 属性 value 属性：用户输入的内容，提交之后会发送给后端服务器 name 属性：当前控件的含义，提交之后可以告诉后端发送过去的数据是什么含义 后端接收到数据的格式是：name 的属性值 value 的属性值 input 系列标签-文本框 场景：在网页中显示 输入单行文本 的表单控件 type 属性值：text 常用属性： 属性名 说明 placeholder 占位符，提示用户输入内容的文本 代码： body input type=text placeholder=请输入用户名/body input 系列标签-密码框 场景：在网页中显示 输入密码 的表单控件 type 属性值：password 常用属性： 属性名 说明 placeholder 占位符，提示用户输入内容的文本 注意点： • type 属性值不要拼错或者多加空格，否则相当于设置了默认值状态：text→ 文本框 代码： body input type=password placeholder=请输入密码/body input 系列标签-单选框 场景：在网页中显示 多选一的单选 表单控件 type 属性值：radio 常用属性： 属性名 说明 name 分组，有相同 name 属性值的单选框为一组，一组中同时只能有一个被选中的 checked 默认选中 注意点： name 属性对于单选框有分组功能 有相同 name 属性值的单选框为一组，一组中只能同时有一个被选中 代码： body 性别: input type=radio name=sex男 input type=radio name=sex checked女/body input 系列标签-复选框 场景：在网页中显示 多选多的多选 表单控件 type 属性值：checkbox 常用属性： 属性名 说明 checked 默认选中 代码： body input type=checkbox checked/body input 系列标签-文件选择 场景：在网页中显示 文件选择的 表单控件 type 属性值：file 常用属性： 属性名 说明 multiple 多文件选择 代码： body input type=file multiple/body input 系列标签-按钮 场景：在网页中显示 不同功能的按钮 表单控件 type 属性值： 标签名 type 属性值 说明 input submit 提交按钮。点击之后提交数据给后端服务器 input reset 重置按钮。点击之后回复表单默认值 input button 普通按钮。默认无功能，之后配合 js 添加功能 注意点： 如果需要实现以上按钮功能，需要配合 form 标签使用 form 使用方法：用 form 标签把表单标签一起包裹起来即可 代码： body form action= 用户名: input type=text br br 密码: input type=password br br !-- 按钮 -- input type=submit value=免费注册 input type=reset input type=button value=普通按钮 !-- 属性 xx=xxx -- /form/body button 按钮标签 场景：在网页中显示用户点击的按钮 标签名：button type 属性值（同 input 的按钮系列）： 标签名 type 属性值 说明 button submit 提交按钮。点击之后提交数据给后端服务器 button reset 重置按钮。点击之后回复表单默认值 button button 普通按钮。默认无功能，之后配合 js 添加功能 注意点： 谷歌浏览器中 button 默认是提交按钮 button 标签是双标签，更便于包裹其他内容：文字、图片等 代码： body button我是按钮/button button type=submit提交按钮/button button type=reset重置按钮/button button type=button普通按钮, 没有任何功能/button/body select 下拉菜单标签 场景：在网页中提供多个选择项的下拉菜单表单控件 标签组成： select 标签：下拉菜单的整体 option 标签：下拉菜单的每一项 常见属性： selected：下拉菜单的默认选中 代码： body select option北京/option option上海/option option广州/option option selected深圳/option /select/body textarea 文本域标签 场景：在网页中提供可输入多行文本的表单控件 标签名：textarea 常见属性： cols：规定了文本域内可见宽度 rows：规定了文本域内可见行数 注意点： 右下角可以拖拽改变大小 实际开发时针对于样式效果 推荐用 CSS 设置 代码： body textarea cols=60 rows=30/textarea/body label 标签 场景：常用于绑定内容与表单标签的关系（通过点击文字可以直接选中单选框） 标签名：label 使用方法 ①： 使用 label 标签把内容（如：文本）包裹起来 在表单标签上添加 id 属性 在 label 标签的 for 属性中设置对应的 id 属性值 使用方法 ②： 直接使用 label 标签把内容（如：文本）和表单标签一起包裹起来 需要把 label 标签的 for 属性删除即可 代码： body 性别: input type=radio name=sex id=nan label for=nan男/label labelinput type=radio name=sex 女/label/body 语义化标签没有语义的布局标签-div 和 span 场景：实际开发网页时会大量频繁的使用到 div 和 span 这两个没语义的布局标签 div 标签：一行只显示一个（独占一行） span 标签：一行可以显示多个 有语义的布局标签（了解） 场景：在 HTML5 新版本中，推出了一些有语义的布局标签供开发者使用 标签： 标签名 语义 header 网页头部 nav 网页导航 footer 网页底部 aside 网页侧边栏 section 网页区块 article 网页文章 综合案例 学生信息表 body table border=1 width=500 height=300 captionh3优秀学生信息表格/h3/caption tr th年级/th th姓名/th th学号/th th班级/th /tr tr td rowspan=2高三/td td迪丽热巴/td td110/td td三年二班/td /tr tr td古力娜扎/td td120/td td三年三班/td /tr tr td评语/td td colspan=3你们很优秀/td /tr /table/body 注册表单 body h1青春不常在，抓紧谈恋爱/h1 hr form action= 昵称: input type=text placeholder=请输入昵称 br br 性别: labelinput type=radio name=sex checked 男/label labelinput type=radio name=sex 女/label brbr 所在城市: select option北京/option option selected上海/option option广州/option /select br br 喜欢的类型: labelinput type=checkbox checked 可爱/label labelinput type=checkbox checked 性感/label labelinput type=checkbox 御姐/label br br 个人介绍: br textarea name= id= cols=60 rows=10/textarea h3我承诺/h3 ul li年满18岁、单身/li li年满18岁、单身/li li年满18岁、单身/li /ul !-- 按钮: input button -- input type=submit value=免费注册 button type=reset重置/button /form/body","tags":["HTML","HTML标签"],"categories":["HTML"]},{"title":"Go基础","path":"/wiki/Go/Go基础学习.html","content":"安装https://go.dev/dl/ 下载安装版的，直接安装 安装完成后可以输入 go version 查看安装版本，输出对应版本表示安装成功。 设置代理 export GOPROXY=https://goproxy.cn Go Module概念Go module 是 Go 编程语言中的一种依赖管理机制，引入于 Go 1.11，并在 Go 1.13 之后成为默认的依赖管理方式。Go module 旨在解决管理项目依赖版本、模块化开发以及构建更大规模 Go 项目时的痛点。 采用 Go Modules，下载下来的第三方依赖就位于 GOPATH/pkg/mod 目录下。 常用命令初始化: go mod init [module 名称] 检测和清理依赖: go mod tidy 安装指定包: go get -v github.com/go-ego/gse@v0.60.0-rc4.2 更新依赖 go get -u 更新指定包依赖: go get -u github.com/go-ego/gse 指定版本: go get -u github/com/go-ego/gse@v0.60.0-rc4.2 Replace: go mod edit -replace github.com/go-ego/gse=/path/to/local/gsego mod edit -replace github.com/go-ego/gse=github.com/vcaesar/gse 也可以直接修改模块文件: replace github.com/go-ego/gse = github.com/vcaesar/gse go mod init # 初始化 go.modgo mod tidy # 更新依赖文件go mod download # 下载依赖文件go mod vendor # 将依赖转移至本地的 vendor 文件go mod edit # 手动修改依赖文件go mod graph # 打印依赖图go mod verify # 校验依赖 基础语法包每个 Go 程序都由包构成。程序从 main 包开始运行。本程序通过导入路径 fmt 和 math/rand 来使用这两个包。按照约定，包名与导入路径的最后一个元素一致。例如，math/rand 包中的源码均以 package rand 语句开始。 package mainimport ( fmt math/rand)func main() fmt.Println(Hello World!) 包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在 Go 语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的。 导入代码用圆括号将导入的包分成一组，这是“分组”形式的导入语句。 当然也可以编写多个导入语句，例如： import fmtimport math 不过使用分组导入语句要更好。 import ( fmt math) 注意：导入包未使用时会编译不通过 package mainimport ( fmt math)func main() fmt.Println(1) 导出名在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，math 包中 Pi。 pi 并未以大写字母开头，所以是未导出的。 在导入一个包时，只能引用其中已导出的名字。 任何「未导出」的名字在该包外均无法访问。 package mainimport ( fmt math)func main() fmt.Println(math.Pi) 函数函数可接受零个或多个参数。 在本例中，add 接受两个 int 类型的参数。 注意类型在变量名的 后面。（参考这篇关于 Go 声明语法 的文章，了解为何使用这种类型声明的形式。） package mainimport fmtfunc add(x int, y int) int return x + yfunc main() fmt.Println(add(1, 2)) 当两个或多个参数类型重复时可以在最后申明类型 func add(x, y int) int return x + y 函数可以返回任意数量的返回值。 package mainimport fmtfunc swap(x, y string) (string, string) return y, xfunc main() a, b := swap(hello, world)\tfmt.Println(a, b) 函数中的返回值可以被命名，可以被视为定义在函数顶部的变量。 这些变量名称应该标识返回值的含义。 不带参数的 return 语句返回指定的返回值。这就是所谓的“裸”返回。 裸返回只建议在较短的函数中使用。 package mainimport fmtfunc split(sum int) (x, y int) x = sum * 4 / 9\ty = sum - x\treturnfunc main() fmt.Println(split(17)) 3.5 varvar 语句声明一个变量列表; 与函数参数列表一样，类型放后面。 package mainimport fmtvar c, python, java boolfunc main() var i int\tfmt.Println(i, c, python, java) var 可以放在包级别或者函数级别。 var 类型定义变量可以设定初始值，如果设定了初始值可以省略变量类型。变量将采用初始值设定的类型。 package mainimport fmtvar i, j int = 1, 2func main() var c, python, java = true, false, no\tfmt.Println(i, j, c, python, java) 在函数内部，可以使用 : = short 赋值语句代替隐式类型的 var 声明。 在函数之外，每个语句都以关键字(var、 func 等)开头，因此: 结构不可用。 package mainimport fmtfunc main() var i, j int = 1, 2\tk := 3\tc, python, java := true, false, no!\tfmt.Println(i, j, k, c, python, java) 3.6 基本变量Go 语言按类别有以下几种数据类型： 序号 类型和描述 1 布尔型 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool true。 2 数字类型 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。 3 字符串类型: 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。 4 派生类型: 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型 字符串类型有两种写法： 使用双引号 “。如果在字符串里 ” 就需要使用 \\ 转义 println(hello \\ world) 使用反引号。这种写法可以换行，但是内部不用有反引号或转义。 println(`hello world`) 字符串操作：strings 包含字符串常用操作方法 数字类型Go 也有基于架构的类型，例如：int、uint 和 uintptr。 序号 类型和描述 1 uint8 无符号 8 位整型 (0 到 255) 2 uint16 无符号 16 位整型 (0 到 65535) 3 uint32 无符号 32 位整型 (0 到 4294967295) 4 uint64 无符号 64 位整型 (0 到 18446744073709551615) 5 int8 有符号 8 位整型 (-128 到 127) 6 int16 有符号 16 位整型 (-32768 到 32767) 7 int32 有符号 32 位整型 (-2147483648 到 2147483647) 8 int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) 极值在 math 包中 浮点型 序号 类型和描述 1 float32 IEEE-754 32 位浮点型数 2 float64 IEEE-754 64 位浮点型数 3 complex64 32 位实数和虚数 4 complex128 64 位实数和虚数 其他数字类型以下列出了其他更多的数字类型： 序号 类型和描述 1 byte 本质 uint8 2 rune 类似 int32 3 uint 32 或 64 位 4 int 与 uint 一样大小 5 uintptr 无符号整型，用于存放一个指针 零值没有显式初始值的变量声明给出了它们的零值。 零值是: 0 表示数字类型, 布尔类型为 false，并且 “”(空字符串)表示字符串。 package mainimport fmtfunc main() var i int\tvar f float64\tvar b bool\tvar s string // 0 0 false fmt.Printf(%v %v %v %q , i, f, b, s) 3.7 类型转换表达式 T(v) 将值 v 转换为类型 T。 一些数值类型的转换： var i int = 42var f float64 = float64(i)var u uint = uint(f) 或者，更加简短的形式： i := 42f := float64(i)u := uint(f) 与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换，Go 中没有隐式转换。 i := 42var f float64f = icannot use i (variable of type int) as float64 value in assignment 3.8 类型推断（短变量）在声明一个变量而不指定其类型时（即使用不带类型的 := 语法 或 var = 表达式语法），变量的类型会通过右值推断出来。 当声明的右值确定了类型时，新变量的类型与其相同： var i intj := i // j 也是一个 int 不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 int、float64 或 complex128 了，这取决于常量的精度： i := 42 // intf := 3.142 // float64g := 0.867 + 0.5i // complex128 package mainimport fmtfunc main() v := 42 // v is of type int\tfmt.Printf(v is of type %T , v) 包级别的变量会在 main 方法执行前初始化，局部变量在函数被调用时才初始化。 短变量中有相同变量名的参数，第二个参数是赋值 in, err := os.Open(infile)// 此时err为赋值out, err := os.Create(outfile) 但是第二次使用短变量赋值时最少需要一个新的变量名，如果还是相同那么编译报错 f, err := os.Open(infile)// ...f, err := os.Create(outfile) // compile error: no new variables 3.9 常量常量的声明与变量类似，只不过使用 const 关键字。 常量可以是字符、字符串、布尔值或数值。 常量不能用 := 语法声明。 package mainimport fmtconst Pi = 3.14func main() const World = 世界\tfmt.Println(Hello, World)\tfmt.Println(Happy, Pi, Day)\tconst Truth = true\tfmt.Println(Go rules?, Truth) iota 常量生成器 常量声明可以使用 iota 常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个 const 声明语句中，在第一个声明的常量所在的行，iota 将会被置为 0，然后在每一个有常量声明的行加一。 定义了一个 Weekday 命名类型，然后为一周的每天定义了一个常量，从周日 0 开始。 type Weekday intconst ( Sunday Weekday = iota //0 Monday //1 Tuesday //2 Wednesday //3 Thursday //4 Friday //5 Saturday //6) 3.10 new 函数new(T)可以创建一个 T 类型的匿名变量，初始化为 T 类型的零值，然后返回变量地址，返回的指针类型为*T。 p := new(int) // p, *int 类型, 指向匿名的 int 变量fmt.Println(*p) // 0*p = 2 // 设置 int 匿名变量的值为 2fmt.Println(*p) 使用 new 创建的变量和普通变量声明语句方式创建变量无区别。 3.11 元组赋值元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。 x, y = y, xa[i], a[j] = a[j], a[i] 和变量声明一样，我们可以用下划线空白标识符_来丢弃不需要的值。 _, err = io.Copy(dst, src) // 丢弃字节数_, ok = x.(T) // 只检测类型，忽略具体值 3.12 隐式赋值赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值 赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量也会产生 赋值行为。 medals := []stringgold, silver, bronze 隐式地对 slice 的每个元素进行赋值操作，类似这样写的行为： medals[0] = goldmedals[1] = silvermedals[2] = bronze 不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。 更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。 4. 流程控制语句4.1 for 循环Go 只有一种循环结构：for 循环。 基本的 for 循环由三部分组成，它们用分号隔开： 初始化语句：在第一次迭代前执行 条件表达式：在每次迭代前求值 后置语句：在每次迭代的结尾执行 初始化语句通常为一句短变量声明，该变量声明仅在 for 语句的作用域中可见。 一旦条件表达式求值为 false，循环迭代就会终止。 注意：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面的三个构成部分外没有小括号， 大括号 则是必须的。 package mainimport fmtfunc main() sum := 0\tfor i := 0; i 10; i++ sum += i fmt.Println(sum) sum2 := 1\tfor sum2 100 sum2 += sum2 fmt.Println(sum2) 初始化语句和后置语句都是可选的，如果去掉 ; for 还可以做 while 的语义。 package mainimport fmtfunc main() sum2 := 1\tfor sum2 100 sum2 += sum2 fmt.Println(sum2) 无限循环 package mainimport fmtfunc main() for 警告：捕获迭代变量 考虑这个样一个问题：首先创建一些目录，再将目录删除。在下面的例子中我们用函数值来完成删除操作。下面的示例代码需要引入 os 包。为了使代码简单，我们忽略了所有的异常处理。 var rmdirs []func()for _, d := range tempDirs() dir := d // NOTE: necessary!\tos.MkdirAll(dir, 0755) // creates parent directories too\trmdirs = append(rmdirs, func() os.RemoveAll(dir)\t)// ...do some work…for _, rmdir := range rmdirs rmdir() // clean up 这里为什么要在循环体中用循环变量 d 赋值一个新的局部变量，而不是像下面的代码一样直接使用循环变量 dir。需要注意，下面的代码是错误的。 var rmdirs []func()for _, dir := range tempDirs() os.MkdirAll(dir, 0755)\trmdirs = append(rmdirs, func() os.RemoveAll(dir) // NOTE: incorrect!\t) 问题的原因在于循环变量的作用域。在上面的程序中，for 循环语句引入了新的词法块，循环变量 dir 在这个词法块中被声明。在该循环中生成的所有函数值都共享相同的循环变量。需要注意，函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。以 dir 为例，后续的迭代会不断更新 dir 的值，当删除操作执行时，for 循环已完成，dir 中存储的值等于最后一次迭代的值。这意味着，每次对 os.RemoveAll 的调用删除的都是相同的目录。 通常，为了解决这个问题，我们会引入一个与循环变量同名的局部变量，作为循环变量的副本。 4.2 ifGo 的 if 语句与 for 循环类似，表达式外无需小括号 ( )，而大括号 则是必须的。 package mainimport (\tfmt\tmath)func sqrt(x float64) string if x 0 return sqrt(-x) + i return fmt.Sprint(math.Sqrt(x))func main() fmt.Println(sqrt(2), sqrt(-4)) 和 for 一样，if 语句可以在条件表达式前执行一个简短语句。 该语句声明的变量作用域仅在 if 之内。 package mainimport (\tfmt\tmath)func pow(x, n, lim float64) float64 if v := math.Pow(x, n); v lim return v return limfunc main() fmt.Println( pow(3, 2, 10), pow(3, 3, 20),\t) 在 if 的简短语句中声明的变量同样可以在对应的任何 else 块中使用。 package mainimport (\tfmt\tmath)func pow(x, n, lim float64) float64 if v := math.Pow(x, n); v lim return v else fmt.Printf(%g = %g , v, lim) // cant use v here, though\treturn limfunc main() fmt.Println( pow(3, 2, 10), pow(3, 3, 20),\t) 4.3 switch 分支switch 语句是编写一连串 if - else 语句的简便方法。它运行第一个 case 值 值等于条件表达式的子句。 Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只会运行选定的 case，而非之后所有的 case。 在效果上，Go 的做法相当于这些语言中为每个 case 后面自动添加了所需的 break 语句。在 Go 中，除非以 fallthrough 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不限于整数。 package mainimport (\tfmt\truntime)func main() fmt.Print(Go 运行的系统环境)\tswitch os := runtime.GOOS; os case darwin: fmt.Println(mac.Os)\tcase linux: fmt.Println(Linux)\tdefault: fmt.Printf(%s , os) switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。 例如， switch i case 0:case f(): 在 i==0 时，f 不会被调用。 无条件的 switch 同 switch true 一样。 这种形式能将一长串 if-then-else 写得更加清晰。 package mainimport (\tfmt\ttime)func main() t := time.Now()\tswitch case t.Hour() 12: fmt.Println(早上好！)\tcase t.Hour() 17: fmt.Println(下午好！)\tdefault: fmt.Println(晚上好！) 4.4 defer 推迟defer 语句会将函数推迟到外层函数返回之后执行。 推迟调用的函数其参数 会立即求值，但直到外层函数返回前该函数都不会被调用。 package mainimport fmtfunc main() defer fmt.Println(world)\tfmt.Println(hello) 4.5 defer 栈推迟调用的函数调用会被压入一个栈中。 当外层函数返回时，被推迟的调用会按照后进先出的顺序调用。 package mainimport fmtfunc main() fmt.Println(counting)\tfor i := 0; i 10; i++ defer fmt.Println(i) fmt.Println(done)countingdone9876543210 5. 结构体5.1 指针Go 拥有指针。指针保存了值的内存地址。 指针零值为 nil。 // 类型 *T 是指向 T 类型值的指针，其零值为 nil。// 变量p是指向int类型的指针var p *inti := 42// 操作符会生成一个指向其操作数的指针。// i 生成一个指针并赋值给pp = i// 只有指针指向同一个变量或者都为nil时，指针才相等var x, y intfmt.Println(x == x, x == y, x == nil) // true false false * 操作符表示指针指向的底层值。 fmt.Println(*p) // 通过指针 p 读取 i*p = 21 // 通过指针 p 设置 i 这也就是通常所说的「解引用」或「间接引用」。 与 C 不同，Go 没有指针运算。 package mainimport fmtfunc main() i, j := 42, 2701 // 生成指向i的指针赋值给p\tp := i\tfmt.Println(*p) //42\t*p = 21\tfmt.Println(i) //21\tp = j\t*p = *p / 37\tfmt.Println(j) //73 5.2 结构体一个 结构体（struct）就是一组 字段（field）。 package mainimport fmttype Vertex struct X int\tY inttype V float64func main() fmt.Println(Vertex1, 2) fmt.Println(V(1)) 结构体中的字段可通过点号 . 来访问。 package mainimport fmttype Vertex struct X int\tY intfunc main() v := Vertex1, 2\tv.X = 4\tfmt.Println(v.X) 5.3 结构体指针结构体字段可通过结构体指针来访问。 如果我们有一个指向结构体的指针 p 那么可以通过 (*p).X 来访问其字段 X。 不过这么写太啰嗦了，所以语言也允许我们使用隐式解引用，直接写 p.X 就可以。 package mainimport fmttype Vertex struct X int\tY intfunc main() v := Vertex1, 2\tp := v\tp.X = 1e9\tfmt.Println(v) 5.4 结构体字面量使用 Name: 语法可以仅列出部分字段（字段名的顺序无关）。 特殊的前缀 返回一个指向结构体的指针。 package mainimport fmttype Vertex struct X, Y intvar (\tv1 = Vertex1, 2 // 创建一个 Vertex 类型的结构体\tv2 = VertexX: 1 // Y:0 被隐式地赋予零值 // v = Vertex1 // 这种会报错 v3 = Vertex // X:0 Y:0\tp = Vertex1, 2 // 创建一个 *Vertex 类型的结构体（指针）)func main() fmt.Println(v1, p, v2, v3) 5.5 结构体比较如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用 或! 运算符进行比较。相等比较运算符 将比较两个结构体的每个成员，因此下面两个比较的表达式是等价的： type Point struct X, Y int p := Point1, 2q := Point2, 1fmt.Println(p.X == q.X p.Y == q.Y) // falsefmt.Println(p == q) // false 5.6 结构体嵌入和匿名成员考虑一个二维的绘图程序，提供了一个各种图形的库，例如矩形、椭圆形、星形和轮形等几何形状。这里是其中两个的定义： type Circle struct X, Y, Radius inttype Wheel struct X, Y, Radius, Spokes int 一个 Circle 代表的圆形类型包含了标准圆心的 X 和 Y 坐标信息，和一个 Radius 表示的半径信息。一个 Wheel 轮形除了包含 Circle 类型所有的全部成员外，还增加了 Spokes 表示径向辐条的数量。我们可以这样创建一个 wheel 变量： var w Wheelw.X = 8w.Y = 8w.Radius = 5w.Spokes = 20 随着库中几何形状数量的增多，我们一定会注意到它们之间的相似和重复之处，所以我们可能为了便于维护而将相同的属性独立出来： type Point struct X, Y inttype Circle struct Center Point\tRadius inttype Wheel struct Circle Circle\tSpokes int 这样改动之后结构体类型变的清晰了，但是这种修改同时也导致了访问每个成员变得繁琐： var w Wheelw.Circle.Center.X = 8w.Circle.Center.Y = 8w.Circle.Radius = 5w.Spokes = 20 Go 语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。下面的代码中，Circle 和 Wheel 各自都有一个匿名成员。我们可以说 Point 类型被嵌入到了 Circle 结构体，同时 Circle 类型被嵌入到了 Wheel 结构体。 type Circle struct Point\tRadius inttype Wheel struct Circle //直接给定类型\tSpokes int 得意于匿名嵌入的特性，我们可以直接访问叶子属性而不需要给出完整的路径： var w Wheelw.X = 8 // equivalent to w.Circle.Point.X = 8w.Y = 8 // equivalent to w.Circle.Point.Y = 8w.Radius = 5 // equivalent to w.Circle.Radius = 5w.Spokes = 20 但是这样定义后，结构体字面量不能用以下方式初始化: w = Wheel8, 8, 5, 20 // compile error: unknown fieldsw = WheelX: 8, Y: 8, Radius: 5, Spokes: 20 // compile error: unknown fields 结构体字面值必须遵循形状类型声明时的结构，所以我们只能用下面的两种语法，它们彼此是等价的： w = WheelCirclePoint8, 8, 5, 20w = Wheel\tCircle: Circle Point: PointX: 8, Y: 8, Radius: 5,\t,\tSpokes: 20, // NOTE: trailing comma necessary here (and at Radius) 6. 数组类型 [n]T 表示一个数组，它拥有 n 个类型为 T 的值。 表达式：var a [10]int 会将变量 a 声明为拥有 10 个整数的数组。 数组的长度是其类型的一部分，因此数组不能改变大小。 这看起来是个限制，不过没关系，Go 拥有更加方便的使用数组的方式。 package mainimport fmtfunc main() var a [2]string\ta[0] = hello\ta[1] = world\tfmt.Println(a[0], a[1])\tfmt.Println(a)\tprimes := [6]int2, 3, 4, 5, 6, 7\tfmt.Println(primes) 6.1 切片每个数组的大小都是固定的。而切片则为数组元素提供了动态大小的、灵活的视角。 在实践中，切片比数组更常用。 类型 []T 表示一个元素类型为 T 的切片。 切片通过两个下标来界定，一个下界和一个上界，二者以冒号分隔： a[low : high] 它会选出一个半闭半开区间，包括第一个元素，但排除最后一个元素。 以下表达式创建了一个切片，它包含 a 中下标从 1 到 3 的元素： a[1:4] package mainimport fmtfunc main() // 创建一个数组\tprimes := [6]int2, 3, 4, 5, 6, 7\t// 创建一个切片\tvar s []int = primes[1:4]\tfmt.Println(s) 切片就像数组的引用 切片并不存储任何数据，它只是描述了底层数组中的一段。更改切片的元素会修改其底层数组中对应的元素（原始数组中的数据不会改变，改的只是切片），和它共享底层数组的切片都会观测到这些修改。 package mainimport fmtfunc main() names := [4]string lala, dd, dx, po, fmt.Println(names)\ta := names[0:2]\tb := names[1:3]\tfmt.Println(a, b)\t// 修改切片数据，共享底层数组的切片中数据会修改，但底层数组数据不变\tb[0] = XX\tfmt.Println(a, b) //[lala XX] [XX dx]\tfmt.Println(names) //[lala XX dx po] 6.2 切片字面量切片字面量类似于没有长度的数组字面量。 这是一个数组字面量： [3]booltrue, true, false 下面这样则会 先创建一个和上面相同的数组，然后再构建一个引用了它的切片： []booltrue, true, false package mainimport fmtfunc main() q := []int2, 3, 4, 5, 6\tfmt.Println(q)\tr := []booltrue, false, true\tfmt.Println(r)\ts := []struct i int b bool 2, true, 3, false, 4, true, fmt.Println(s) 6.3 切片默认行为在进行切片时，可以利用它的默认行为来忽略上下界。 切片下界的默认值为 0，上界则是该切片的长度。 对于数组 var a [10]int 来说，以下切片表达式和它是等价的： a[0:10]a[:10]a[0:]a[:] package mainimport fmtfunc main() s := []int2, 3, 4, 5, 6\ts = s[0:4]\tfmt.Println(s)\ts = s[:4]\tfmt.Println(s)\ts = s[0:]\tfmt.Println(s) 6.4 切片的长度与容量切片拥有 长度 和 容量。 切片的长度就是它所包含的元素个数。 切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。 切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。 可以通过重新切片来扩展一个切片，给它提供足够的容量。 package mainimport fmtfunc main() s := []int2, 3, 5, 7, 11, 13\tprintSlice(s)\t// 截取切片使其长度为 0\ts = s[:0]\tprintSlice(s)\t// 扩展其长度\ts = s[:4]\tprintSlice(s)\t// 舍弃前两个值\ts = s[2:]\tprintSlice(s)func printSlice(s []int) fmt.Printf(len=%d cap=%d %v , len(s), cap(s), s)len=6 cap=6 [2 3 5 7 11 13]len=0 cap=6 []len=4 cap=6 [2 3 5 7]len=2 cap=4 [5 7] s s [2:] 的容量为什么是 4？ 可以理解为切片是一种引用类型，在这指向数组 s 的指针。s [2:] 将指针移动到了元素 5 的位置，此时计算容量就是 4 了。 6.5 nil 切片切片的零值是 nil。 nil 切片的长度和容量为 0 且没有底层数组。 package mainimport fmtfunc main() var s []int\tfmt.Println(s, len(s), cap(s))\tif s == nil fmt.Println(nil!) 6.6 使用 make 创建切片切片可以用内置函数 make 来创建，这也是创建动态数组的方式。 make 函数会分配一个元素为零值的数组并返回一个引用了它的切片： a := make([]int, 5) // len(a)=5 要指定它的容量，需向 make 传入第三个参数： b := make([]int, 0, 5) // len(b)=0, cap(b)=5b = b[:cap(b)] // len(b)=5, cap(b)=5b = b[1:] // len(b)=4, cap(b)=4 package mainimport fmtfunc main() a := make([]int, 5)\tprintSlice(a, a)\tb := make([]int, 0, 5)\tprintSlice(b, b)\tc := b[:2]\tprintSlice(c, c)\td := c[2:5]\tprintSlice(d, d)func printSlice(s string, x []int) fmt.Printf(%s len=%d cap=%d %v , s, len(x), cap(x), x)a len=5 cap=5 [0 0 0 0 0]b len=0 cap=5 []c len=2 cap=5 [0 0]d len=3 cap=3 [0 0 0] 6.7 切片的切片切片可以包含任何类型，当然也包括其他切片。 package mainimport (\tfmt\tstrings)func main() // 创建一个井字棋（经典游戏）\tboard := [][]string []string_, _, _, []string_, _, _, []string_, _, _, // 两个玩家轮流打上 X 和 O\tboard[0][0] = X\tboard[2][2] = O\tboard[1][2] = X\tboard[1][0] = O\tboard[0][2] = X\tfor i := 0; i len(board); i++ fmt.Printf(%s , strings.Join(board[i], )) 6.8 向切片添加元素为切片追加新的元素是种常见的操作，为此 Go 提供了内置的 append 函数。内置函数的 文档 对该函数有详细的介绍。 func append(s []T, vs ...T) []T append 的第一个参数 s 是一个元素类型为 T 的切片，其余类型为 T 的值将会追加到该切片的末尾。 append 的结果是一个包含原切片所有元素加上新添加元素的切片。 当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。 返回的切片会指向这个新分配的数组。 （要了解关于切片的更多内容，请阅读文章 Go 切片：用法和本质。） package mainimport fmtfunc main() var s []int\tprintSlice(s)\ts = append(s, 0)\tprintSlice(s)\ts = append(s, 1)\tprintSlice(s)\ts = append(s, 3, 4, 5)\tprintSlice(s)func printSlice(s []int) fmt.Printf(len=%d cap=%d %v , len(s), cap(s), s)len=0 cap=0 []len=1 cap=1 [0]len=2 cap=2 [0 1]len=5 cap=6 [0 1 3 4 5] 7. range 遍历for 循环的 range 形式可遍历切片或映射。 当使用 for 循环遍历切片时，每次迭代都会返回两个值。 第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。 package mainimport fmtvar pow = []int1, 2, 3, 4, 5, 6, 7, 8func main() for i, v := range pow fmt.Printf(i=%d v=%d , i, v)\ti=0 v=1i=1 v=2i=2 v=3i=3 v=4i=4 v=5i=5 v=6i=6 v=7i=7 v=8 可以将下标或值赋予 _ 来忽略它。 for i, _ := range powfor _, value := range pow 若只需要索引，忽略第二个变量即可。 for i := range pow package mainimport fmtfunc main() pow := make([]int, 5)\tfor i := range pow pow[i] = 1 uint(i) // 2^i for _, v := range pow fmt.Printf(%d , v)\t124816 8. map8.1 创建映射map 映射将键映射到值。 映射的零值为 nil 。nil 映射既没有键，也不能添加键。(使用 var 定义) make 函数会返回给定类型的映射，并将其初始化备用。 package mainimport fmttype Vertex struct Lat, Long float64var m map[string]Vertexfunc main() m = make(map[string]Vertex)\tm[gege] = Vertex 3.14, 15926.1, fmt.Println(m[gege]) 8.2 映射字面量映射的字面量和结构体类似，只不过必须有键名。 package mainimport fmttype Vertex struct Lat, Long float64var m = map[string]Vertex\tBell Labs: Vertex 40.68433, -74.39967,\t,\tGoogle: Vertex 37.42202, -122.08408,\t,func main() fmt.Println(m 若顶层类型只有一个类型名，那么你可以在字面量的元素中省略它。 package mainimport fmttype Vertex struct Lat, Long float64var m = map[string]Vertex\tBell Labs: 40.68433, -74.39967,\t,\tGoogle: 37.42202, -122.08408,\t,func main() fmt.Println(m 8.3 修改映射在映射 m 中插入或修改元素： m[key] = elem 获取元素： elem = m[key] 删除元素： delete(m, key) 通过双赋值检测某个键是否存在： elem, ok = m[key] 若 key 在 m 中，ok 为 true ；否则，ok 为 false。 若 key 不在映射中，则 elem 是该映射元素类型的零值。 注：若 elem 或 ok 还未声明，你可以使用短变量声明： elem, ok := m[key] package mainimport fmtfunc main() m := make(map[string]int)\tm[答案] = 42\tfmt.Println(值：, m[答案])\tm[答案] = 48\tfmt.Println(值：, m[答案])\tdelete(m, 答案)\tfmt.Println(值：, m[答案])\tv, ok := m[答案]\tfmt.Println(值：, v, 是否存在？, ok)值： 42值： 48值： 0值： 0 是否存在？ false 9. JSONGo 中提供对 JSON 格式数据处理的 API type Movie struct Title string Year int `json:released` // `json:released`:结构体成员Tag\tColor bool `json:color,omitempty`\tActors []stringvar movies = []Movie\tTitle: Casablanca, Year: 1942, Color: false, Actors: []stringHumphrey Bogart, Ingrid Bergman,\tTitle: Cool Hand Luke, Year: 1967, Color: true, Actors: []stringPaul Newman,\tTitle: Bullitt, Year: 1968, Color: true, Actors: []stringSteve McQueen, Jacqueline Bisset,\t// ...func main() // 返回一个编码后的字节slice，包含很长的字符串，并且没有空白缩进\tdata, _ := json.Marshal(movies)\tfmt.Printf(%s , data) // 多了格式化\tdata, _ = json.MarshalIndent(movies, , )\tfmt.Printf(%s , data)========================================================================================PS D:\\work\\sty_project\\sty_go\\basic go run .\\54.json.go[Title:Casablanca,released:1942,Actors:[Humphrey Bogart,Ingrid Bergman],Title:Cool Hand Luke,released:1967,color:true,Actors:[Paul Newman],Title:Bullitt,released:1968,color:true,Actors:[Steve McQueen,Jacqueline Bisset]][ Title: Casablanca, released: 1942, Actors: [ Humphrey Bogart, Ingrid Bergman ] , Title: Cool Hand Luke, released: 1967, color: true, Actors: [ Paul Newman ] , Title: Bullitt, released: 1968, color: true, Actors: [ Steve McQueen, Jacqueline Bisset ] ] 在编码时，默认使用 Go 语言结构体的成员名字作为 JSON 的对象（通过 reflect 反射技术）。只有导出的结构体成员才会被编码，这也就是我们为什么选择用大写字母开头的成员名称。 其中 Year 名字的成员在编码后变成了 released，还有 Color 成员编码后变成了小写字母开头的 color。这是因为构体成员 Tag 所导致的。一个构体成员 Tag 是和在编译阶段关联到该成员的元信息字符串： Year int `json:released`Color bool `json:color,omitempty` 结构体的成员 Tag 可以是任意的字符串面值，但是通常是一系列用空格分隔的 key: “value” 键值对序列；因为值中含义双引号字符，因此成员 Tag 一般用原生字符串面值的形式书写。json 开头键名对应的值用于控制 encodingjson 包的编码和解码的行为，并且 encoding…下面其它的包也遵循这个约定。成员 Tag 中 json 对应值的第一部分用于指定 JSON 对象的名字，比如将 Go 语言中的 Year 成员对应到 JSON 中的 released 对象。Color 成员的 Tag 还带了一个额外的 omitempty 选项，表示当 Go 语言结构体成员为空或零值时不生成 JSON 对象（这里 false 为零值）。 var titles []struct Title string if err := json.Unmarshal(data, titles); err != nil log.Fatalf(JSON unmarshaling failed: %s, err)fmt.Println(titles) // [Casablanca Cool Hand Luke Bullitt] 编码的逆操作是解码，对应将 JSON 数据解码为 Go 语言的数据结构，Go 语言中一般叫 unmarshaling，通过 json.Unmarshal 函数完成。下面的代码将 JSON 格式的电影数据解码为一个结构体 slice，结构体中只有 Title 成员。通过定义合适的 Go 语言数据结构，我们可以选择性地解码 JSON 中感兴趣的成员。当 Unmarshal 函数调用返回，slice 将被只含有 Title 信息值填充，其它 JSON 成员将被忽略。 9. 函数9.1 函数值函数也是值。它们可以像其他值一样传递。 函数值可以用作函数的参数或返回值。 package mainimport (\tfmt\tmath)// 入参为函数fn(float64, float64) float64func compute(fn func(float64, float64) float64) float64 return fn(3, 4)func main() hypot := func(x, y float64) float64 return math.Sqrt(x*x + y*y) fmt.Println(hypot(5, 12)) // hypot(3,4)，把函数传入compute，执行hypot(3,4)\tfmt.Println(compute((hypot))) // math.pow(3,4)\tfmt.Println(compute(math.Pow)) 9.2 函数闭包Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。 该函数可以访问并赋予其引用的变量值，换句话说，该函数被“绑定”到了这些变量。 以下实例中，我们创建了函数 getSequence() ，返回另外一个函数。该函数的目的是在闭包中递增 i 变量，代码如下： package mainimport fmtfunc getSequence() func() int i:=0 return func() int i+=1 return i func main() /* nextNumber 为一个函数，函数 i 为 0 */ nextNumber := getSequence() /* 调用 nextNumber 函数，i 变量自增 1 并返回 */ fmt.Println(nextNumber()) fmt.Println(nextNumber()) fmt.Println(nextNumber()) /* 创建新的函数 nextNumber1，并查看结果 */ nextNumber1 := getSequence() fmt.Println(nextNumber1()) fmt.Println(nextNumber1())12312 getSequence()的例子证明，函数值不仅仅是一串代码，还记录了状态。在 getSequence()中定义的匿名内部函数可以访问和更新 getSequence()方法中的局部变量，这意味着匿名函数和 getSequence()中，存在变量引用。这就是函数值属于引用类型和函数值不可比较的原因。Go 使用闭包（closures）技术实现函数值，Go 程序员也把函数值叫做闭包。 通过这个例子，我们看到变量的生命周期不由它的作用域决定：getSequence()返回后，变量 i 仍然隐式的存在于 nextNumber 中。 10. 方法10.1 定义Go 没有类。 不过你可以为类型定义方法。 方法就是一类带特殊的 入参 的函数。 方法入参在它自己的参数列表内，位于 func 关键字和方法名之间。 方法一般是面向对象编程(OOP)的一个特性，在 C++ 语言中方法对应一个类对象的成员函数，是关联到具体对象上的虚表中的。但是 Go 语言的方法却是关联到类型的，这样可以在编译阶段完成方法的静态绑定。一个面向对象的程序会用方法来表达其属性对应的操作，这样使用这个对象的用户就不需要直接去操作对象，而是借助方法来做这些事情。面向对象编程进入主流开发领域一般认为是从 C++ 开始的，C++ 就是在兼容 C 语言的基础之上支持了 class 等面向对象的特性。然后 Java 编程则号称是纯粹的面向对象语言，因为 Java 中函数是不能独立存在的，每个函数都必然是属于某个类的。 面向对象编程更多的只是一种思想，很多号称支持面向对象编程的语言只是将经常用到的特性内置到语言中了而已。Go 语言的祖先 C 语言虽然不是一个支持面向对象的语言，但是 C 语言的标准库中的 File 相关的函数也用到了的面向对象编程的思想。下面我们实现一组 C 语言风格的 File 函数： // 文件对象type File struct fd int// 打开文件func OpenFile(name string) (f *File, err error) // ...// 关闭文件func CloseFile(f *File) error // ...// 读文件数据func ReadFile(f *File, offset int64, data []byte) int // ... 其中 OpenFile 类似构造函数用于打开文件对象，CloseFile 类似析构函数用于关闭文件对象，ReadFile 则类似普通的成员函数，这三个函数都是普通的函数。CloseFile 和 ReadFile 作为普通函数，需要占用包级空间中的名字资源。不过 CloseFile 和 ReadFile 函数只是针对 File 类型对象的操作，这时候我们更希望 这类函数和操作对象的类型紧密绑定在一起。 Go 语言中的做法是，将 CloseFile 和 ReadFile 函数的第一个参数移动到函数名的开头： // 关闭文件func (f *File) CloseFile() error // ...// 读文件数据func (f *File) ReadFile(offset int64, data []byte) int // ... 这样的话，CloseFile 和 ReadFile 函数就成了 File 类型独有的方法了（而不是 File 对象方法）。它们也不再占用包级空间中的名字资源，同时 File 类型已经明确了它们操作对象，因此方法名字一般简化为 Close 和 Read： // 关闭文件func (f *File) Close() error // ...// 读文件数据func (f *File) Read(offset int64, data []byte) int // ... 将第一个函数参数移动到函数前面，从代码角度看虽然只是一个小的改动，但是从编程哲学角度来看，Go 语言已经是进入面向对象语言的行列了。我们可以给任何自定义类型添加一个或多个方法。每种类型对应的方法必须和类型的定义在同一个包中，因此是无法给 int 这类内置类型添加方法的（因为方法的定义和类型的定义不在一个包中）。对于给定的类型，每个方法的名字必须是唯一的，同时方法和函数一样也不支持重载。 方法即函数 package mainimport (\tfmt\tmath)type Vertex struct X, Y float64// Abs 方法拥有一个名字为 v，类型为 Vertex 的入参。func (v Vertex) Abs() float64 return math.Sqrt(v.X*v.X + v.Y*v.Y)// 现在这个 Abs 的写法就是个正常的函数，功能并没有什么变化。func Abs2(v Vertex) float64 return math.Sqrt(v.X*v.X + v.Y*v.Y)func main() v := Vertex3, 4 // 函数与操作对象类型绑定\tfmt.Println(v.Abs()) fmt.Println(Abs2(v)) 你也可以为非结构体类型声明方法。 在此例中，我们看到了一个带 Abs 方法的数值类型 MyFloat。 你只能为在同一个包中定义的入参类型声明方法，而不能为其它别的包中定义的类型 （包括 int 之类的内置类型）声明方法。（就是入参的类型定义和方法声明必须在同一包内） package mainimport (\tfmt\tmath)type MyFloat float64func (f MyFloat) Abs() float64 if f 0 return float64(-f) return float64(f)func main() f := MyFloat(-math.Sqrt2)\tfmt.Println(f.Abs()) 10.2 指针类型入参你可以为指针类型的入参声明方法。 这意味着对于某类型 T，入参的类型可以用 *T 的文法。 （此外，T 本身不能是指针，比如不能是 *int。） 例如，这里为 *Vertex 定义了 Scale 方法。 指针类型入参的方法可以修改入参指针指向的值（如这里的 Scale 所示）。 由于方法经常需要修改它的入参对象，指针入参比值入参更常用。 试着移除 Scale 函数声明中的 *，观察此程序的行为如何变化。 若使用值入参，那么 Scale2 方法会对原始 Vertex 值的副本进行操作。（对于函数的其它参数也是如此。） package mainimport (\tfmt\tmath)type Vertex struct X, Y float64func (v Vertex) Abs() float64 // 25\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)func (v *Vertex) Scale(f float64) v.X = v.X * f\tv.Y = v.Y * ffunc (v Vertex) Scale2(f float64) v.X = v.X * f\tv.Y = v.Y * ffunc main() v := Vertex3, 4\t// 使用指针直接修改原始值\tv.Scale(10)\tfmt.Println(v.Abs())\tv2 := Vertex3, 4\t// 使用值接收，修改原始值的副本\tv2.Scale2(10)\tfmt.Println(v2.Abs()) 指针与函数 现在我们要把 Abs 和 Scale 方法重写为函数。 同样，先试着移除掉 Scale函数的*，你能看出程序行为改变的原因吗？ 要怎样做才能让该示例顺利通过编译？ package mainimport (\tfmt\tmath)type Vertex struct X, Y float64func Abs(v Vertex) float64 return math.Sqrt(v.X*v.X + v.Y*v.Y)func Scale(v *Vertex, f float64) v.X = v.X * f\tv.Y = v.Y * ffunc main() v := Vertex3, 4\tScale(v, 10)\tfmt.Println(Abs(v)) package mainimport fmttype Vertex struct X, Y float64func (v *Vertex) Scale(f float64) v.X = v.X * f\tv.Y = v.Y * ffunc ScaleFunc(v *Vertex, f float64) v.X = v.X * f\tv.Y = v.Y * ffunc main() v := Vertex3, 4\tv.Scale(2)\tScaleFunc(v, 10)\tp := Vertex4, 3\tp.Scale(3)\tScaleFunc(p, 8)\tfmt.Println(v, p) 比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针： var v VertexScaleFunc(v, 5) // 编译错误！ScaleFunc(v, 5) // OK 而入参为指针的的方法被调用时，入参既能是值又能是指针： var v Vertexv.Scale(5) // OKp := vp.Scale(10) // OK 对于语句 v.Scale(5) 来说，即便 v 是一个值而非指针，带指针入参的方法也能被直接调用。 也就是说，由于 Scale 方法有一个指针入参，为方便起见，Go 会将语句 v.Scale(5) 解释为 (v).Scale(5)。 反之也一样： 接受一个值作为参数的函数必须接受一个指定类型的值： var v Vertexfmt.Println(AbsFunc(v)) // OKfmt.Println(AbsFunc(v)) // 编译错误！ 而以值为入参的方法被调用时，入参既能为值又能为指针： var v Vertexfmt.Println(v.Abs()) // OKp := vfmt.Println(p.Abs()) // OK 这种情况下，方法调用 p.Abs() 会被解释为 (*p).Abs()。 package mainimport (\tfmt\tmath)type Vertex struct X, Y float64func (v Vertex) Abs() float64 return math.Sqrt(v.X*v.X + v.Y*v.Y)func AbsFunc(v Vertex) float64 return math.Sqrt(v.X*v.X + v.Y*v.Y)func main() v := Vertex3, 4\tfmt.Println(v.Abs()) fmt.Println((v).Abs())\tfmt.Println(AbsFunc(v)) // fmt.Println(AbsFunc(v)) 编译报错\tp := Vertex4, 3\tfmt.Println(p.Abs()) fmt.Println((*p).Abs())\tfmt.Println(AbsFunc(*p)) // fmt.Println(AbsFunc(p)) 编译报错 选择值或指针作为入参 使用指针入参的原因有二： 首先，方法能够修改其入参指针指向的值。 其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样会更加高效。 在本例中，Scale 和 Abs 入参的类型为 *Vertex，即便 Abs 并不需要修改其入参。 通常来说，所有给定类型的方法都应该有值或指针入参，但并不应该二者混用。 package mainimport (\tfmt\tmath)type Vertex struct X, Y float64func (v *Vertex) Scale(f float64) v.X = v.X * f\tv.Y = v.Y * ffunc (v *Vertex) Abs() float64 return math.Sqrt(v.X*v.X + v.Y*v.Y)func main() v := Vertex3, 4\tfmt.Printf(缩放前：%+v，绝对值：%v , v, v.Abs())\tv.Scale(5)\tfmt.Printf(缩放后：%+v，绝对值：%v , v, v.Abs())缩放前：X:3 Y:4，绝对值：5缩放后：X:15 Y:20，绝对值：25 11. 接口11.1 定义接口类型 的定义为一组方法签名。 接口可以让我们将不同的类型绑定到一组公共的方法上，从而实现多态和灵活的设计。 接口类型的变量可以持有任何实现了这些方法的值。 注意: 示例代码 a = v 存在一个错误。由于 Abs 方法只为 *Vertex （指针类型）定义，因此 Vertex（值类型）并未实现 Abser。 package mainimport (\tfmt\tmath)type Abser interface Abs() float64func main() var a Abser\tf := MyFloat(-math.Sqrt2)\tv := Vertex3, 4\ta = f // MyFloat实现了 Abser\ta = v // *Vertex实现了 Abser\t// 下面一行，v 是一个 Vertex（而不是 *Vertex）\t// 所以没有实现 Abser。\ta = v\tfmt.Println(a.Abs())type MyFloat float64func (f MyFloat) Abs() float64 if f 0 return float64(-f) return float64(f)type Vertex struct X, Y float64func (v *Vertex) Abs() float64 return math.Sqrt(v.X*v.X + v.Y*v.Y) 11.2 接口与隐式实现Go 语言中的接口是隐式实现的，也就是说，如果一个类型实现了一个接口定义的所有方法，那么它就自动地实现了该接口。 因此，我们可以通过将接口作为参数来实现对不同类型的调用，从而实现多态。 类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。 隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。 因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。 package mainimport ( fmt)type Phone interface call()type NokiaPhone struct func (nokiaPhone NokiaPhone) call() fmt.Println(I am Nokia, I can call you!)type IPhone struct func (iPhone IPhone) call() fmt.Println(I am iPhone, I can call you!)func main() var phone Phone phone = new(NokiaPhone) phone.call() phone = new(IPhone) phone.call() 11.3 接口值接口也是值。它们可以像其它值一样传递。 接口值可以用作函数的参数或返回值。 在内部，接口值可以看做包含值和具体类型的元组： (value, type) 接口值保存了一个具体底层类型的具体值。 接口值调用方法时会执行其底层类型的同名方法。 package mainimport (\tfmt\tmath)type I interface M()type T struct S stringfunc (t *T) M() fmt.Println(t.S)type F float64func (f F) M() fmt.Println(f)func main() var i I\ti = Thello\tdescribe(i)\ti.M()\ti = F(math.Pi)\tdescribe(i)\ti.M()func describe(i I) fmt.Printf((%v, %T) , i, i)(hello, *main.T)hello(3.141592653589793, main.F)3.141592653589793 底层值为 nil 的接口值 即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。 在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 M 方法）。 注意: 保存了 nil 具体值的接口其自身并不为 nil。 package mainimport fmttype I interface M()type T struct S stringfunc (t *T) M() if t == nil fmt.Println(nil) return fmt.Println(t.S)func main() var i I\tvar t *T\ti = t\tdescribe(i) // 这里不会触发一个空指针异常\ti.M()\ti = Thello\tdescribe(i)\ti.M()func describe(i I) fmt.Printf((%v, %T) , i, i)(nil, *main.T)nil(hello, *main.T)hello nil 接口值 nil 接口值既不保存值也不保存具体类型。 为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 具体 方法的类型。 package mainimport fmttype I interface M()func main() var i I\tdescribe(i) // 没有指定具体类型的方法 // (nil, nil)\t// panic: runtime error: invalid memory address or nil pointer dereference\ti.M()func describe(i I) fmt.Printf((%v, %T) , i, i) 11.4 空接口指定了零个方法的接口值被称为 空接口： interface 空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。） 空接口被用来处理未知类型的值。例如，fmt.Print 可接受类型为 interface 的任意数量的参数。 package mainimport fmttype I interfacefunc main() var i I\tdescribe(i)\ti = 42\tdescribe(i)\ti = hello\tdescribe(i)func describe(i I) fmt.Printf((%v, %T) , i, i) 11.5 类型断言类型断言 提供了访问接口值底层具体值的方式。 t := i.(T) 该语句断言接口值 i 保存了具体类型 T，并将其底层类型为 T 的值赋予变量 t。 若 i 并未保存 T 类型的值，该语句就会触发一个 panic。 为了 判断 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。 t, ok := i.(T) 若 i 保存了一个 T，那么 t 将会是其底层值，而 ok 为 true。 否则，ok 将为 false 而 t 将为 T 类型的零值，程序并不会产生 panic。 请注意这种语法和读取一个映射时的相同之处。 package mainimport fmtfunc main() var i interface = hello\ts := i.(string)\tfmt.Println(s)\ts, ok := i.(string)\tfmt.Println(ok)\tf, ok := i.(float64)\tfmt.Println(f, ok)\t// panic: interface conversion: interface is string, not float64\tf = i.(float64) // panic\tfmt.Println(f) 11.6 类型选择类型选择 是一种按顺序从几个类型断言中选择分支的结构。 类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。 switch v := i.(type) case T: // v 的类型为 Tcase S: // v 的类型为 Sdefault: // 没有匹配，v 与 i 的类型相同 类型选择中的声明与类型断言 i.(T) 的语法相同，只是具体类型 T 被替换成了关键字 type。 此选择语句判断接口值 i 保存的值类型是 T 还是 S。在 T 或 S 的情况下，变量 v 会分别按 T 或 S 类型保存 i 拥有的值。在默认（即没有匹配）的情况下，变量 v 与 i 的接口类型和值相同。 package mainimport fmtfunc do(i interface) switch v := i.(type) case int: fmt.Printf(二倍的 %v 是 %v , v, v*2)\tcase string: fmt.Printf(%q 长度为 %v 字节 , v, len(v))\tdefault: fmt.Printf(我不知道类型 %T! , v)\tfunc main() do(21)\tdo(hello)\tdo(true) 11.7 衍生类型基本语法：type TypeA TypeB 使用场景：例如使用第三方库时，没有办法修改源码，又想扩展这个库的方法就可以使用这个。 衍生类型是一个全新的类型 衍生类型可以互相转换 () 注意：TypeB 实现了某个接口不等于 TypeA 也实现了这个接口 type Dog struct Name stringfunc (d Dog) run() string return d.Nametype FlyDog Dogfunc main() dog := Dog\tdog.run()\tflyDog := FlyDog\t// flyDog 不能调用 Dog 上的方法，因为 flyDog 是一个全新的类型\t//flyDog.run()\tflyDog2 := Dog(flyDog)\tflyDog2.run() 11.8 类型别名基础语法：type TypeA = TypeB 別名，除了换了一个名字，没有任何区别 他和衍生类型的区别就是用了 = 类型别名一般用在导出类型、兼容性修改里 11.9 组合组合是 Go 中独有的语法概念。基本语法形态是： type A struct B 组合可以是以下几种情况： 接口组合接口 结构体组合结构体 结构体组合结构体指针 结构体组合接口 都可以组合多个。 特性 当 A 组合 B 之后 可以直接在 A 上调用 B 的方法。 B 实现的所有接口，都认为 A 已经实现了。 A 组合 B 之后，在初始化 A 的时候将 B 看作普通字段来初始化 组合不是继承，没有多态 12. 错误Go 程序使用 error 值来表示错误状态。 error 类型是一个内置的接口： type error interface Error() string （与 fmt.Stringer 类似，fmt 包也会根据对 error 的实现来打印值。） 通常函数会返回一个 error 值，调用它的代码应当判断这个错误是否等于 nil 来进行错误处理。 i, err := strconv.Atoi(42)if err != nil fmt.Printf(couldnt convert number: %v , err) returnfmt.Println(Converted integer:, i) error 为 nil 时表示成功；非 nil 的 error 表示失败。 package mainimport (\tfmt\tmath\ttime)type MyError struct When time.Time\tWhat string// 实现error接口的Error()方法func (e MyError) Error() string return fmt.Sprintf(at %v, %s, e.When, e.What)func Sqrt(f float64) (float64, error) if f 0 return 0, MyError time.Now(), square root of negative number, return math.Abs(f), nilfunc main() fmt.Println(Sqrt(1))\t_, err := Sqrt(-1)\tif err != nil fmt.Println(err)\t1 nilat 2024-08-07 15:35:34.2402027 +0800 CST m=+0.001527601, square root of negative number 12. Panic 异常Go 的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起 painc 异常。 一般而言，当 panic 异常发生时，程序会中断运行，并立即执行在该 goroutine 中被延迟的函数（defer 机制）。随后，程序崩溃并输出日志信息。日志信息包括 panic value 和函数调用的堆栈跟踪信息。panic value 通常是某种错误信息。对于每个 goroutine，日志信息中都会有与之相对的，发生 panic 时的函数调用堆栈跟踪信息。 switch s := suit(drawCard()); s case Spades: // ... case Hearts: // ... case Diamonds: // ... case Clubs: // ... default: panic(fmt.Sprintf(invalid suit %q, s)) // Joker? 12. Recover r 捕获异常通常来说，不应该对 panic 异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作。举个例子，当 web 服务器遇到不可预料的严重问题时，在崩溃前应该将所有的连接关闭；如果不做任何处理，会使得客户端一直处于等待状态。如果 web 服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试。 如果在 deferred 函数中调用了内置函数 recover，并且定义该 defer 语句的函数发生了 panic 异常，recover 会使程序从 panic 中恢复，并返回 panic value。导致 panic 异常的函数不会继续运行，但能正常返回。在未发生 panic 时调用 recover，recover 会返回 nil。 让我们以语言解析器为例，说明 recover 的使用场景。考虑到语言解析器的复杂性，即使某个语言解析器目前工作正常，也无法肯定它没有漏洞。因此，当某个异常出现时，我们不会选择让解析器崩溃，而是会将 panic 异常当作普通的解析错误，并附加额外信息提醒用户报告此错误。 func Parse(input string) (s *Syntax, err error) defer func() if p := recover(); p != nil err = fmt.Errorf(internal error: %v, p) () // ...parser... 不加区分的恢复所有的 panic 异常，不是可取的做法；安全的做法是有选择性的 recover。换句话说，只恢复应该被恢复的 panic 异常，此外，这些异常所占的比例应该尽可能的低。为了标识某个 panic 是否应该被恢复，我们可以将 panic value 设置成特殊类型。在 recover 时对 panic value 进行检查，如果发现 panic value 是特殊类型，就将这个 panic 作为 errror 处理，如果不是，则按照正常的 panic 进行处理。 13. 泛型13.1 类型参数可以使用类型参数编写 Go 函数来处理多种类型。 泛型接口 type List[T any] interface 泛型结构体 type ArrayList[T any] struct 泛型函数 func Index[T comparable](s []T, x T) int 此声明意味着 s 是满足内置约束 comparable 的任何类型 T 的切片。 x 也是相同类型的值。 comparable 是一个有用的约束，它能让我们对任意满足该类型的值使用 == 和 != 运算符。在此示例中，我们使用它将值与所有切片元素进行比较，直到找到匹配项。 该 Index 函数适用于任何支持比较的类型。 package mainimport fmt// Index 返回 x 在 s 中的下标，未找到则返回 -1。func Index[T comparable](s []T, x T) int for i, v := range s // v 和 x 的类型为 T，它拥有 comparable 可比较的约束， // 因此我们可以使用 ==。 if v == x return i return -1func Index2[T int](s []T, x T) int for i, v := range s // v 和 x 的类型为 T，它拥有 comparable 可比较的约束， // 因此我们可以使用 ==。 if v == x return i return -1func main() // Index 可以在整数切片上使用\tsi := []int10, 20, 15, -10\tfmt.Println(Index(si, 15)) si2 := []int10, 20, 15, -10 // Index2的参数约束为int，此时如果传入string类型编译会报错 fmt.Println(Index2(si2, 15))\t// Index 也可以在字符串切片上使用\tss := []stringfoo, bar, baz\tfmt.Println(Index(ss, hello)) 13.2 泛型约束func Sum[T any](vals ...T) T var res T\tfor _, val := range vals // any类型不支持 + 运算，需要限定泛型类型 res += val return res func Sum[T Number](vals ...T) T var res T\tfor _, val := range vals res += val return restype Number interface // 波浪线是支持衍生类型\t~int | float64type Integer intfunc main() println(Sum[int](1, 2, 3))\tprintln(Sum[float64](1.1, 2, 3))\tprintln(Sum[Integer](1, 2, 3)) 14. 并发14.1 Go 协程Go 程（goroutine）是由 Go 运行时管理的轻量级线程。 go f(x, y, z) 会启动一个新的 Go 协程并执行 f 函数 f(x, y, z) f, x, y 和 z 的求值发生在当前的 Go 协程中，而 f 的执行发生在新的 Go 协程中。 Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。sync 包提供了这种能力，不过在 Go 中并不经常用到，因为还有其它的办法。 package mainimport (\tfmt\ttime)func say(s string) for i := 0; i 5; i++ time.Sleep(100 * time.Millisecond) fmt.Println(s)\tfunc main() go say(world)\tsay(hello) 14.2 信道信道是带有类型的管道，你可以通过它用信道操作符 - 来发送或者接收值。 ch - v // 将 v 发送至信道 ch。v := -ch // 从 ch 接收值并赋予 v。 （“箭头”就是数据流的方向。） 和映射与切片一样，信道在使用前必须创建： ch := make(chan int) 默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。 以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。 package mainimport fmtfunc sum(s []int, c chan int) sum := 0\tfor _, v := range s sum += v c - sum // 发送 sum 到 cfunc main() s := []int7, 2, 8, -9, 4, 0\tc := make(chan int)\tgo sum(s[:len(s)/2], c)\tgo sum(s[len(s)/2:], c)\tx, y := -c, -c // 从 c 接收\tfmt.Println(x, y, x+y) 带缓冲的信道 信道可以是 带缓冲的。将缓冲长度作为第二个参数提供给 make 来初始化一个带缓冲的信道： ch := make(chan int, 100) 仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。 package mainimport fmtfunc main() ch := make(chan int, 2)\tch - 1\tch - 2 // 缓冲区满后再写会报下列错误 // fatal error: all goroutines are asleep - deadlock! // ch - 3\tfmt.Println(-ch)\tfmt.Println(-ch) 信道关闭 发送者可通过 close 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完 v, ok := -ch 此时 ok 会被设置为 false。 循环 for i := range c 会不断从信道接收值，直到它被关闭。 注意： 只应由发送者关闭信道，而不应油接收者关闭。向一个已经关闭的信道发送数据会引发程序 panic。 还要注意： 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 range 循环。 package mainimport (\tfmt)func fibonacci(n int, c chan int) x, y := 0, 1\tfor i := 0; i n; i++ c - x x, y = y, x+y close(c)func main() c := make(chan int, 10)\tgo fibonacci(cap(c), c)\tfor i := range c fmt.Println(i) 14.3 select 语句select 语句使一个 Go 程可以等待多个通信操作。 select 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。 package mainimport fmtfunc fibonacci(c, quit chan int) x, y := 0, 1\tfor select // 将当前的x值发送到通道c，然后计算下一个Fibonacci数列的值（x, y = y, x+y） case c - x: x, y = y, x+y // 从通道quit接收值，当接收到值时，打印quit并返回，结束函数执行 case -quit: fmt.Println(quit) return func main() c := make(chan int)\tquit := make(chan int) // 启动一个新的goroutine，在这个goroutine中，从通道c接收并打印10个Fibonacci数列的值，然后向quit通道发送一个值。\tgo func() for i := 0; i 10; i++ fmt.Println(-c) quit - 0\t()\tfibonacci(c, quit) default 分支 当 select 中的其它分支都没有准备好时，default 分支就会执行。 为了在尝试发送或者接收时不发生阻塞，可使用 default 分支： select case i := -c: // 使用 idefault: // 从 c 中接收会阻塞时执行 package mainimport (\tfmt\ttime)func main() tick := time.Tick(2000 * time.Millisecond)\tboom := time.After(5000 * time.Millisecond)\tfor select case -tick: fmt.Println(tick.) case -boom: fmt.Println(boom) return default: fmt.Println( .) time.Sleep(1000 * time.Millisecond) . .tick. . .tick. .boom","tags":[null],"categories":[null]},{"title":"Go","path":"/wiki/Go/用Go搭建Web服务器.html","content":"1. 安装https://go.dev/dl/ 下载安装版的，直接安装 安装完成后可以输入go version查看安装版本，输出对应版本表示安装成功。 3. 基础语法3.1 包每个 Go 程序都由包构成。程序从 main 包开始运行。本程序通过导入路径 fmt 和 math/rand 来使用这两个包。按照约定，包名与导入路径的最后一个元素一致。例如，math/rand 包中的源码均以 package rand 语句开始。 package mainimport (\tfmt\tmath/rand)func main() fmt.Println(Hello World!) go run . 3.2 导入代码用圆括号将导入的包分成一组，这是“分组”形式的导入语句。 当然也可以编写多个导入语句，例如： import fmtimport math 不过使用分组导入语句要更好。 import (\tfmt\tmath) 3.3 导出名在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，math包中Pi。 pi 并未以大写字母开头，所以是未导出的。 在导入一个包时，只能引用其中已导出的名字。 任何「未导出」的名字在该包外均无法访问。 package mainimport (\tfmt\tmath)func main() fmt.Println(math.Pi) 3.4 函数函数可接受零个或多个参数。 在本例中，add 接受两个 int 类型的参数。 注意类型在变量名的 后面。（参考这篇关于 Go 声明语法 的文章，了解为何使用这种类型声明的形式。） package mainimport fmtfunc add(x int, y int) int return x + yfunc main() fmt.Println(add(1, 2)) 当两个或多个参数类型重复时可以在最后申明类型 func add(x, y int) int return x + y 函数可以返回任意数量的返回值。 package mainimport fmtfunc swap(x, y string) (string, string) return y, xfunc main() a, b := swap(hello, world)\tfmt.Println(a, b) 函数中的返回值可以被命名，可以被视为定义在函数顶部的变量。 这些变量名称应该标识返回值的含义。 不带参数的 return 语句返回指定的返回值。这就是所谓的“裸”返回。 裸返回只建议在较短的函数中使用。 package mainimport fmtfunc split(sum int) (x, y int) x = sum * 4 / 9\ty = sum - x\treturnfunc main() fmt.Println(split(17)) 3.5 varvar 语句声明一个变量列表; 与函数参数列表一样，类型放后面。 package mainimport fmtvar c, python, java boolfunc main() var i int\tfmt.Println(i, c, python, java) var可以放在包级别或者函数级别。 var类型定义变量可以设定初始值，如果设定了初始值可以省略变量类型。变量将采用初始值设定的类型。 package mainimport fmtvar i, j int = 1, 2func main() var c, python, java = true, false, no\tfmt.Println(i, j, c, python, java) 在函数内部，可以使用: = short 赋值语句代替隐式类型的 var 声明。 在函数之外，每个语句都以关键字(var、 func 等)开头，因此: 结构不可用。 package mainimport fmtfunc main() var i, j int = 1, 2\tk := 3\tc, python, java := true, false, no!\tfmt.Println(i, j, k, c, python, java) 3.6 基本变量Go 语言按类别有以下几种数据类型： 序号 类型和描述 1 布尔型 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool true。 2 数字类型 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。 3 字符串类型: 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。 4 派生类型: 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型 数字类型Go 也有基于架构的类型，例如：int、uint 和 uintptr。 序号 类型和描述 1 uint8 无符号 8 位整型 (0 到 255) 2 uint16 无符号 16 位整型 (0 到 65535) 3 uint32 无符号 32 位整型 (0 到 4294967295) 4 uint64 无符号 64 位整型 (0 到 18446744073709551615) 5 int8 有符号 8 位整型 (-128 到 127) 6 int16 有符号 16 位整型 (-32768 到 32767) 7 int32 有符号 32 位整型 (-2147483648 到 2147483647) 8 int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) 浮点型 序号 类型和描述 1 float32 IEEE-754 32位浮点型数 2 float64 IEEE-754 64位浮点型数 3 complex64 32 位实数和虚数 4 complex128 64 位实数和虚数 其他数字类型以下列出了其他更多的数字类型： 序号 类型和描述 1 byte 类似 uint8 2 rune 类似 int32 3 uint 32 或 64 位 4 int 与 uint 一样大小 5 uintptr 无符号整型，用于存放一个指针 零值没有显式初始值的变量声明给出了它们的零值。 零值是: ​\t0表示数字类型, ​\t布尔类型为 false，并且 ​\t“”(空字符串)表示字符串。 package mainimport fmtfunc main() var i int\tvar f float64\tvar b bool\tvar s string // 0 0 false fmt.Printf(%v %v %v %q , i, f, b, s) 3.7 类型转换表达式 T(v) 将值 v 转换为类型 T。 一些数值类型的转换： var i int = 42var f float64 = float64(i)var u uint = uint(f) 或者，更加简短的形式： i := 42f := float64(i)u := uint(f) 与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换。 i := 42var f float64f = icannot use i (variable of type int) as float64 value in assignment 3.8 类型推断在声明一个变量而不指定其类型时（即使用不带类型的 := 语法 或 var = 表达式语法），变量的类型会通过右值推断出来。 当声明的右值确定了类型时，新变量的类型与其相同： var i intj := i // j 也是一个 int 不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 int、float64 或 complex128 了，这取决于常量的精度： i := 42 // intf := 3.142 // float64g := 0.867 + 0.5i // complex128 package mainimport fmtfunc main() v := 42 // v is of type int\tfmt.Printf(v is of type %T , v) 3.9 常量常量的声明与变量类似，只不过使用 const 关键字。 常量可以是字符、字符串、布尔值或数值。 常量不能用 := 语法声明。 package mainimport fmtconst Pi = 3.14func main() const World = 世界\tfmt.Println(Hello, World)\tfmt.Println(Happy, Pi, Day)\tconst Truth = true\tfmt.Println(Go rules?, Truth) 4. 流程控制语句4.1 for循环Go 只有一种循环结构：for 循环。 基本的 for 循环由三部分组成，它们用分号隔开： 初始化语句：在第一次迭代前执行 条件表达式：在每次迭代前求值 后置语句：在每次迭代的结尾执行 初始化语句通常为一句短变量声明，该变量声明仅在 for 语句的作用域中可见。 一旦条件表达式求值为 false，循环迭代就会终止。 注意：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面的三个构成部分外没有小括号， 大括号 则是必须的。 package mainimport fmtfunc main() sum := 0\tfor i := 0; i 10; i++ sum += i fmt.Println(sum) sum2 := 1\tfor sum2 100 sum2 += sum2 fmt.Println(sum2) 初始化语句和后置语句都是可选的，如果去掉;for还可以做while的语义。 package mainimport fmtfunc main() sum2 := 1\tfor sum2 100 sum2 += sum2 fmt.Println(sum2) 无限循环 package mainimport fmtfunc main() for 4.2 ifGo 的 if 语句与 for 循环类似，表达式外无需小括号 ( )，而大括号 则是必须的。 package mainimport (\tfmt\tmath)func sqrt(x float64) string if x 0 return sqrt(-x) + i return fmt.Sprint(math.Sqrt(x))func main() fmt.Println(sqrt(2), sqrt(-4)) 和 for 一样，if 语句可以在条件表达式前执行一个简短语句。 该语句声明的变量作用域仅在 if 之内。 package mainimport (\tfmt\tmath)func pow(x, n, lim float64) float64 if v := math.Pow(x, n); v lim return v return limfunc main() fmt.Println( pow(3, 2, 10), pow(3, 3, 20),\t) 在 if 的简短语句中声明的变量同样可以在对应的任何 else 块中使用。 package mainimport (\tfmt\tmath)func pow(x, n, lim float64) float64 if v := math.Pow(x, n); v lim return v else fmt.Printf(%g = %g , v, lim) // cant use v here, though\treturn limfunc main() fmt.Println( pow(3, 2, 10), pow(3, 3, 20),\t) 4.3 switch分支switch 语句是编写一连串 if - else 语句的简便方法。它运行第一个 case 值 值等于条件表达式的子句。 Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只会运行选定的 case，而非之后所有的 case。 在效果上，Go 的做法相当于这些语言中为每个 case 后面自动添加了所需的 break 语句。在 Go 中，除非以 fallthrough 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不限于整数。 package mainimport (\tfmt\truntime)func main() fmt.Print(Go 运行的系统环境)\tswitch os := runtime.GOOS; os case darwin: fmt.Println(mac.Os)\tcase linux: fmt.Println(Linux)\tdefault: fmt.Printf(%s , os) switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。 例如， switch i case 0:case f(): 在 i==0 时，f 不会被调用。 无条件的 switch 同 switch true 一样。 这种形式能将一长串 if-then-else 写得更加清晰。 package mainimport (\tfmt\ttime)func main() t := time.Now()\tswitch case t.Hour() 12: fmt.Println(早上好！)\tcase t.Hour() 17: fmt.Println(下午好！)\tdefault: fmt.Println(晚上好！) 4.4 defer推迟defer 语句会将函数推迟到外层函数返回之后执行。 推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。 package mainimport fmtfunc main() defer fmt.Println(world)\tfmt.Println(hello) 4.5 defer栈推迟调用的函数调用会被压入一个栈中。 当外层函数返回时，被推迟的调用会按照后进先出的顺序调用。 package mainimport fmtfunc main() fmt.Println(counting)\tfor i := 0; i 10; i++ defer fmt.Println(i) fmt.Println(done)countingdone9876543210 5. 结构体5.1 指针Go 拥有指针。指针保存了值的内存地址。 // 类型 *T 是指向 T 类型值的指针，其零值为 nil。// 变量p是指向int类型的指针var p *inti := 42// 操作符会生成一个指向其操作数的指针。// i 生成一个指针并赋值给pp = i * 操作符表示指针指向的底层值。 fmt.Println(*p) // 通过指针 p 读取 i*p = 21 // 通过指针 p 设置 i 这也就是通常所说的「解引用」或「间接引用」。 与 C 不同，Go 没有指针运算。 package mainimport fmtfunc main() i, j := 42, 2701 // 生成指向i的指针赋值给p\tp := i\tfmt.Println(*p) //42\t*p = 21\tfmt.Println(i) //21\tp = j\t*p = *p / 37\tfmt.Println(j) //73 5.2 结构体一个 结构体（struct）就是一组 字段（field）。 package mainimport fmttype Vertex struct X int\tY inttype V float64func main() fmt.Println(Vertex1, 2) fmt.Println(V(1)) 结构体中的字段可通过点号 . 来访问。 package mainimport fmttype Vertex struct X int\tY intfunc main() v := Vertex1, 2\tv.X = 4\tfmt.Println(v.X) 5.3 结构体指针结构体字段可通过结构体指针来访问。 如果我们有一个指向结构体的指针 p 那么可以通过 (*p).X 来访问其字段 X。 不过这么写太啰嗦了，所以语言也允许我们使用隐式解引用，直接写 p.X 就可以。 package mainimport fmttype Vertex struct X int\tY intfunc main() v := Vertex1, 2\tp := v\tp.X = 1e9\tfmt.Println(v) 5.4 结构体字面量使用 Name: 语法可以仅列出部分字段（字段名的顺序无关）。 特殊的前缀 返回一个指向结构体的指针。 package mainimport fmttype Vertex struct X, Y intvar (\tv1 = Vertex1, 2 // 创建一个 Vertex 类型的结构体\tv2 = VertexX: 1 // Y:0 被隐式地赋予零值 // v = Vertex1 // 这种会报错 v3 = Vertex // X:0 Y:0\tp = Vertex1, 2 // 创建一个 *Vertex 类型的结构体（指针）)func main() fmt.Println(v1, p, v2, v3) 6. 数组类型 [n]T 表示一个数组，它拥有 n 个类型为 T 的值。 表达式：var a [10]int 会将变量 a 声明为拥有 10 个整数的数组。 数组的长度是其类型的一部分，因此数组不能改变大小。 这看起来是个限制，不过没关系，Go 拥有更加方便的使用数组的方式。 package mainimport fmtfunc main() var a [2]string\ta[0] = hello\ta[1] = world\tfmt.Println(a[0], a[1])\tfmt.Println(a)\tprimes := [6]int2, 3, 4, 5, 6, 7\tfmt.Println(primes) 6.1 切片每个数组的大小都是固定的。而切片则为数组元素提供了动态大小的、灵活的视角。 在实践中，切片比数组更常用。 类型 []T 表示一个元素类型为 T 的切片。 切片通过两个下标来界定，一个下界和一个上界，二者以冒号分隔： a[low : high] 它会选出一个半闭半开区间，包括第一个元素，但排除最后一个元素。 以下表达式创建了一个切片，它包含 a 中下标从 1 到 3 的元素： a[1:4] package mainimport fmtfunc main() // 创建一个数组\tprimes := [6]int2, 3, 4, 5, 6, 7\t// 创建一个切片\tvar s []int = primes[1:4]\tfmt.Println(s) 切片就像数组的引用 切片并不存储任何数据，它只是描述了底层数组中的一段。更改切片的元素会修改其底层数组中对应的元素（原始数组中的数据不会改变，改的只是切片），和它共享底层数组的切片都会观测到这些修改。 package mainimport fmtfunc main() names := [4]string lala, dd, dx, po, fmt.Println(names)\ta := names[0:2]\tb := names[1:3]\tfmt.Println(a, b)\t// 修改切片数据，共享底层数组的切片中数据会修改，但底层数组数据不变\tb[0] = XX\tfmt.Println(a, b) //[lala XX] [XX dx]\tfmt.Println(names) //[lala XX dx po] 6.2 切片字面量切片字面量类似于没有长度的数组字面量。 这是一个数组字面量： [3]booltrue, true, false 下面这样则会先创建一个和上面相同的数组，然后再构建一个引用了它的切片： []booltrue, true, false package mainimport fmtfunc main() q := []int2, 3, 4, 5, 6\tfmt.Println(q)\tr := []booltrue, false, true\tfmt.Println(r)\ts := []struct i int b bool 2, true, 3, false, 4, true, fmt.Println(s) 6.3 切片默认行为在进行切片时，可以利用它的默认行为来忽略上下界。 切片下界的默认值为 0，上界则是该切片的长度。 对于数组 var a [10]int 来说，以下切片表达式和它是等价的： a[0:10]a[:10]a[0:]a[:] package mainimport fmtfunc main() s := []int2, 3, 4, 5, 6\ts = s[0:4]\tfmt.Println(s)\ts = s[:4]\tfmt.Println(s)\ts = s[0:]\tfmt.Println(s) 6.4 切片的长度与容量切片拥有 长度 和 容量。 切片的长度就是它所包含的元素个数。 切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。 切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。 可以通过重新切片来扩展一个切片，给它提供足够的容量。 package mainimport fmtfunc main() s := []int2, 3, 5, 7, 11, 13\tprintSlice(s)\t// 截取切片使其长度为 0\ts = s[:0]\tprintSlice(s)\t// 扩展其长度\ts = s[:4]\tprintSlice(s)\t// 舍弃前两个值\ts = s[2:]\tprintSlice(s)func printSlice(s []int) fmt.Printf(len=%d cap=%d %v , len(s), cap(s), s)len=6 cap=6 [2 3 5 7 11 13]len=0 cap=6 []len=4 cap=6 [2 3 5 7]len=2 cap=4 [5 7] s s[2:]的容量为什么是4？ 可以理解为切片是一种引用类型，在这指向数组s的指针。s[2:]将指针移动到了元素5的位置，此时计算容量就是4了。 6.5 nil切片切片的零值是 nil。 nil 切片的长度和容量为 0 且没有底层数组。 package mainimport fmtfunc main() var s []int\tfmt.Println(s, len(s), cap(s))\tif s == nil fmt.Println(nil!) 6.6 使用make创建切片切片可以用内置函数 make 来创建，这也是创建动态数组的方式。 make 函数会分配一个元素为零值的数组并返回一个引用了它的切片： a := make([]int, 5) // len(a)=5 要指定它的容量，需向 make 传入第三个参数： b := make([]int, 0, 5) // len(b)=0, cap(b)=5b = b[:cap(b)] // len(b)=5, cap(b)=5b = b[1:] // len(b)=4, cap(b)=4 package mainimport fmtfunc main() a := make([]int, 5)\tprintSlice(a, a)\tb := make([]int, 0, 5)\tprintSlice(b, b)\tc := b[:2]\tprintSlice(c, c)\td := c[2:5]\tprintSlice(d, d)func printSlice(s string, x []int) fmt.Printf(%s len=%d cap=%d %v , s, len(x), cap(x), x)a len=5 cap=5 [0 0 0 0 0]b len=0 cap=5 []c len=2 cap=5 [0 0]d len=3 cap=3 [0 0 0] 6.7 切片的切片切片可以包含任何类型，当然也包括其他切片。 package mainimport (\tfmt\tstrings)func main() // 创建一个井字棋（经典游戏）\tboard := [][]string []string_, _, _, []string_, _, _, []string_, _, _, // 两个玩家轮流打上 X 和 O\tboard[0][0] = X\tboard[2][2] = O\tboard[1][2] = X\tboard[1][0] = O\tboard[0][2] = X\tfor i := 0; i len(board); i++ fmt.Printf(%s , strings.Join(board[i], )) 6.8 向切片添加元素为切片追加新的元素是种常见的操作，为此 Go 提供了内置的 append 函数。内置函数的文档对该函数有详细的介绍。 func append(s []T, vs ...T) []T append 的第一个参数 s 是一个元素类型为 T 的切片，其余类型为 T 的值将会追加到该切片的末尾。 append 的结果是一个包含原切片所有元素加上新添加元素的切片。 当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。 返回的切片会指向这个新分配的数组。 （要了解关于切片的更多内容，请阅读文章 Go 切片：用法和本质。） package mainimport fmtfunc main() var s []int\tprintSlice(s)\ts = append(s, 0)\tprintSlice(s)\ts = append(s, 1)\tprintSlice(s)\ts = append(s, 3, 4, 5)\tprintSlice(s)func printSlice(s []int) fmt.Printf(len=%d cap=%d %v , len(s), cap(s), s)len=0 cap=0 []len=1 cap=1 [0]len=2 cap=2 [0 1]len=5 cap=6 [0 1 3 4 5] 7. range遍历for 循环的 range 形式可遍历切片或映射。 当使用 for 循环遍历切片时，每次迭代都会返回两个值。 第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。 package mainimport fmtvar pow = []int1, 2, 3, 4, 5, 6, 7, 8func main() for i, v := range pow fmt.Printf(i=%d v=%d , i, v)\ti=0 v=1i=1 v=2i=2 v=3i=3 v=4i=4 v=5i=5 v=6i=6 v=7i=7 v=8 可以将下标或值赋予 _ 来忽略它。 for i, _ := range powfor _, value := range pow 若只需要索引，忽略第二个变量即可。 for i := range pow package mainimport fmtfunc main() pow := make([]int, 5)\tfor i := range pow pow[i] = 1 uint(i) // 2^i for _, v := range pow fmt.Printf(%d , v)\t124816 8. map8.1 创建映射map 映射将键映射到值。 映射的零值为 nil 。nil 映射既没有键，也不能添加键。(使用var定义) make 函数会返回给定类型的映射，并将其初始化备用。 package mainimport fmttype Vertex struct Lat, Long float64var m map[string]Vertexfunc main() m = make(map[string]Vertex)\tm[gege] = Vertex 3.14, 15926.1, fmt.Println(m[gege]) 8.2 映射字面量映射的字面量和结构体类似，只不过必须有键名。 package mainimport fmttype Vertex struct Lat, Long float64var m = map[string]Vertex\tBell Labs: Vertex 40.68433, -74.39967,\t,\tGoogle: Vertex 37.42202, -122.08408,\t,func main() fmt.Println(m 若顶层类型只有一个类型名，那么你可以在字面量的元素中省略它。 package mainimport fmttype Vertex struct Lat, Long float64var m = map[string]Vertex\tBell Labs: 40.68433, -74.39967,\t,\tGoogle: 37.42202, -122.08408,\t,func main() fmt.Println(m 8.3 修改映射在映射 m 中插入或修改元素： m[key] = elem 获取元素： elem = m[key] 删除元素： delete(m, key) 通过双赋值检测某个键是否存在： elem, ok = m[key] 若 key 在 m 中，ok 为 true ；否则，ok 为 false。 若 key 不在映射中，则 elem 是该映射元素类型的零值。 注：若 elem 或 ok 还未声明，你可以使用短变量声明： elem, ok := m[key] package mainimport fmtfunc main() m := make(map[string]int)\tm[答案] = 42\tfmt.Println(值：, m[答案])\tm[答案] = 48\tfmt.Println(值：, m[答案])\tdelete(m, 答案)\tfmt.Println(值：, m[答案])\tv, ok := m[答案]\tfmt.Println(值：, v, 是否存在？, ok)值： 42值： 48值： 0值： 0 是否存在？ false 9. 函数9.1 函数值函数也是值。它们可以像其他值一样传递。 函数值可以用作函数的参数或返回值。 package mainimport (\tfmt\tmath)// 入参为函数fn(float64, float64) float64func compute(fn func(float64, float64) float64) float64 return fn(3, 4)func main() hypot := func(x, y float64) float64 return math.Sqrt(x*x + y*y) fmt.Println(hypot(5, 12)) // hypot(3,4)，把函数传入compute，执行hypot(3,4)\tfmt.Println(compute((hypot))) // math.pow(3,4)\tfmt.Println(compute(math.Pow)) 9.2 函数闭包Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。 该函数可以访问并赋予其引用的变量值，换句话说，该函数被“绑定”到了这些变量。 以下实例中，我们创建了函数 getSequence() ，返回另外一个函数。该函数的目的是在闭包中递增 i 变量，代码如下： package mainimport fmtfunc getSequence() func() int i:=0 return func() int i+=1 return i func main() /* nextNumber 为一个函数，函数 i 为 0 */ nextNumber := getSequence() /* 调用 nextNumber 函数，i 变量自增 1 并返回 */ fmt.Println(nextNumber()) fmt.Println(nextNumber()) fmt.Println(nextNumber()) /* 创建新的函数 nextNumber1，并查看结果 */ nextNumber1 := getSequence() fmt.Println(nextNumber1()) fmt.Println(nextNumber1())12312 10. 方法10.1 定义Go 没有类。不过你可以为类型定义方法。 方法就是一类带特殊的 **入参 **的函数。 方法入参在它自己的参数列表内，位于 func 关键字和方法名之间。 方法一般是面向对象编程(OOP)的一个特性，在 C++ 语言中方法对应一个类对象的成员函数，是关联到具体对象上的虚表中的。但是 Go 语言的方法却是关联到类型的，这样可以在编译阶段完成方法的静态绑定。一个面向对象的程序会用方法来表达其属性对应的操作，这样使用这个对象的用户就不需要直接去操作对象，而是借助方法来做这些事情。面向对象编程进入主流开发领域一般认为是从 C++ 开始的，C++ 就是在兼容 C 语言的基础之上支持了 class 等面向对象的特性。然后 Java 编程则号称是纯粹的面向对象语言，因为 Java 中函数是不能独立存在的，每个函数都必然是属于某个类的。 面向对象编程更多的只是一种思想，很多号称支持面向对象编程的语言只是将经常用到的特性内置到语言中了而已。Go 语言的祖先 C 语言虽然不是一个支持面向对象的语言，但是 C 语言的标准库中的 File 相关的函数也用到了的面向对象编程的思想。下面我们实现一组 C 语言风格的 File 函数： // 文件对象type File struct fd int// 打开文件func OpenFile(name string) (f *File, err error) // ...// 关闭文件func CloseFile(f *File) error // ...// 读文件数据func ReadFile(f *File, offset int64, data []byte) int // ... 其中 OpenFile 类似构造函数用于打开文件对象，CloseFile 类似析构函数用于关闭文件对象，ReadFile 则类似普通的成员函数，这三个函数都是普通的函数。CloseFile 和 ReadFile 作为普通函数，需要占用包级空间中的名字资源。不过 CloseFile 和 ReadFile 函数只是针对 File 类型对象的操作，这时候我们更希望这类函数和操作对象的类型紧密绑定在一起。 Go 语言中的做法是，将 CloseFile 和 ReadFile 函数的第一个参数移动到函数名的开头： // 关闭文件func (f *File) CloseFile() error // ...// 读文件数据func (f *File) ReadFile(offset int64, data []byte) int // ... 这样的话，CloseFile 和 ReadFile 函数就成了 File 类型独有的方法了（而不是 File 对象方法）。它们也不再占用包级空间中的名字资源，同时 File 类型已经明确了它们操作对象，因此方法名字一般简化为 Close 和 Read： // 关闭文件func (f *File) Close() error // ...// 读文件数据func (f *File) Read(offset int64, data []byte) int // ... 将第一个函数参数移动到函数前面，从代码角度看虽然只是一个小的改动，但是从编程哲学角度来看，Go 语言已经是进入面向对象语言的行列了。我们可以给任何自定义类型添加一个或多个方法。每种类型对应的方法必须和类型的定义在同一个包中，因此是无法给 int 这类内置类型添加方法的（因为方法的定义和类型的定义不在一个包中）。对于给定的类型，每个方法的名字必须是唯一的，同时方法和函数一样也不支持重载。 方法即函数 package mainimport (\tfmt\tmath)type Vertex struct X, Y float64// Abs 方法拥有一个名字为 v，类型为 Vertex 的入参。func (v Vertex) Abs() float64 return math.Sqrt(v.X*v.X + v.Y*v.Y)// 现在这个 Abs 的写法就是个正常的函数，功能并没有什么变化。func Abs2(v Vertex) float64 return math.Sqrt(v.X*v.X + v.Y*v.Y)func main() v := Vertex3, 4 // 函数与操作对象类型绑定\tfmt.Println(v.Abs()) fmt.Println(Abs2(v)) 你也可以为非结构体类型声明方法。 在此例中，我们看到了一个带 Abs 方法的数值类型 MyFloat。 你只能为在同一个包中定义的入参类型声明方法，而不能为其它别的包中定义的类型 （包括 int 之类的内置类型）声明方法。（就是入参的类型定义和方法声明必须在同一包内） package mainimport (\tfmt\tmath)type MyFloat float64func (f MyFloat) Abs() float64 if f 0 return float64(-f) return float64(f)func main() f := MyFloat(-math.Sqrt2)\tfmt.Println(f.Abs()) 10.2 指针类型入参你可以为指针类型的入参声明方法。 这意味着对于某类型 T，入参的类型可以用 *T 的文法。 （此外，T 本身不能是指针，比如不能是 *int。） 例如，这里为 *Vertex 定义了 Scale 方法。 指针类型入参的方法可以修改入参指针指向的值（如这里的 Scale 所示）。 由于方法经常需要修改它的入参对象，指针入参比值入参更常用。 试着移除 Scale 函数声明中的 *，观察此程序的行为如何变化。 若使用值入参，那么 Scale2 方法会对原始 Vertex 值的副本进行操作。（对于函数的其它参数也是如此。） package mainimport (\tfmt\tmath)type Vertex struct X, Y float64func (v Vertex) Abs() float64 // 25\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)func (v *Vertex) Scale(f float64) v.X = v.X * f\tv.Y = v.Y * ffunc (v Vertex) Scale2(f float64) v.X = v.X * f\tv.Y = v.Y * ffunc main() v := Vertex3, 4\t// 使用指针直接修改原始值\tv.Scale(10)\tfmt.Println(v.Abs())\tv2 := Vertex3, 4\t// 使用值接收，修改原始值的副本\tv2.Scale2(10)\tfmt.Println(v2.Abs()) 指针与函数 现在我们要把 Abs 和 Scale 方法重写为函数。 同样，先试着移除掉 Scale函数的*，你能看出程序行为改变的原因吗？ 要怎样做才能让该示例顺利通过编译？ package mainimport (\tfmt\tmath)type Vertex struct X, Y float64func Abs(v Vertex) float64 return math.Sqrt(v.X*v.X + v.Y*v.Y)func Scale(v *Vertex, f float64) v.X = v.X * f\tv.Y = v.Y * ffunc main() v := Vertex3, 4\tScale(v, 10)\tfmt.Println(Abs(v)) package mainimport fmttype Vertex struct X, Y float64func (v *Vertex) Scale(f float64) v.X = v.X * f\tv.Y = v.Y * ffunc ScaleFunc(v *Vertex, f float64) v.X = v.X * f\tv.Y = v.Y * ffunc main() v := Vertex3, 4\tv.Scale(2)\tScaleFunc(v, 10)\tp := Vertex4, 3\tp.Scale(3)\tScaleFunc(p, 8)\tfmt.Println(v, p) 比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针： var v VertexScaleFunc(v, 5) // 编译错误！ScaleFunc(v, 5) // OK 而入参为指针的的方法被调用时，入参既能是值又能是指针： var v Vertexv.Scale(5) // OKp := vp.Scale(10) // OK 对于语句 v.Scale(5) 来说，即便 v 是一个值而非指针，带指针入参的方法也能被直接调用。 也就是说，由于 Scale 方法有一个指针入参，为方便起见，Go 会将语句 v.Scale(5) 解释为 (v).Scale(5)。 反之也一样： 接受一个值作为参数的函数必须接受一个指定类型的值： var v Vertexfmt.Println(AbsFunc(v)) // OKfmt.Println(AbsFunc(v)) // 编译错误！ 而以值为入参的方法被调用时，入参既能为值又能为指针： var v Vertexfmt.Println(v.Abs()) // OKp := vfmt.Println(p.Abs()) // OK 这种情况下，方法调用 p.Abs() 会被解释为 (*p).Abs()。 package mainimport (\tfmt\tmath)type Vertex struct X, Y float64func (v Vertex) Abs() float64 return math.Sqrt(v.X*v.X + v.Y*v.Y)func AbsFunc(v Vertex) float64 return math.Sqrt(v.X*v.X + v.Y*v.Y)func main() v := Vertex3, 4\tfmt.Println(v.Abs()) fmt.Println((v).Abs())\tfmt.Println(AbsFunc(v)) // fmt.Println(AbsFunc(v)) 编译报错\tp := Vertex4, 3\tfmt.Println(p.Abs()) fmt.Println((*p).Abs())\tfmt.Println(AbsFunc(*p)) // fmt.Println(AbsFunc(p)) 编译报错 选择值或指针作为入参 使用指针入参的原因有二： 首先，方法能够修改其入参指针指向的值。 其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样会更加高效。 在本例中，Scale 和 Abs 入参的类型为 *Vertex，即便 Abs 并不需要修改其入参。 通常来说，所有给定类型的方法都应该有值或指针入参，但并不应该二者混用。 package mainimport (\tfmt\tmath)type Vertex struct X, Y float64func (v *Vertex) Scale(f float64) v.X = v.X * f\tv.Y = v.Y * ffunc (v *Vertex) Abs() float64 return math.Sqrt(v.X*v.X + v.Y*v.Y)func main() v := Vertex3, 4\tfmt.Printf(缩放前：%+v，绝对值：%v , v, v.Abs())\tv.Scale(5)\tfmt.Printf(缩放后：%+v，绝对值：%v , v, v.Abs())缩放前：X:3 Y:4，绝对值：5缩放后：X:15 Y:20，绝对值：25 11. 接口11.1 定义接口类型 的定义为一组方法签名。 接口可以让我们将不同的类型绑定到一组公共的方法上，从而实现多态和灵活的设计。 接口类型的变量可以持有任何实现了这些方法的值。 注意: 示例代码 a = v 存在一个错误。由于 Abs 方法只为 *Vertex （指针类型）定义，因此 Vertex（值类型）并未实现 Abser。 package mainimport (\tfmt\tmath)type Abser interface Abs() float64func main() var a Abser\tf := MyFloat(-math.Sqrt2)\tv := Vertex3, 4\ta = f // MyFloat实现了 Abser\ta = v // *Vertex实现了 Abser\t// 下面一行，v 是一个 Vertex（而不是 *Vertex）\t// 所以没有实现 Abser。\ta = v\tfmt.Println(a.Abs())type MyFloat float64func (f MyFloat) Abs() float64 if f 0 return float64(-f) return float64(f)type Vertex struct X, Y float64func (v *Vertex) Abs() float64 return math.Sqrt(v.X*v.X + v.Y*v.Y) 11.2 接口与隐式实现Go 语言中的接口是隐式实现的，也就是说，如果一个类型实现了一个接口定义的所有方法，那么它就自动地实现了该接口。因此，我们可以通过将接口作为参数来实现对不同类型的调用，从而实现多态。 类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。 隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。 因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。 package mainimport ( fmt)type Phone interface call()type NokiaPhone struct func (nokiaPhone NokiaPhone) call() fmt.Println(I am Nokia, I can call you!)type IPhone struct func (iPhone IPhone) call() fmt.Println(I am iPhone, I can call you!)func main() var phone Phone phone = new(NokiaPhone) phone.call() phone = new(IPhone) phone.call() 11.3 接口值接口也是值。它们可以像其它值一样传递。 接口值可以用作函数的参数或返回值。 在内部，接口值可以看做包含值和具体类型的元组： (value, type) 接口值保存了一个具体底层类型的具体值。 接口值调用方法时会执行其底层类型的同名方法。 package mainimport (\tfmt\tmath)type I interface M()type T struct S stringfunc (t *T) M() fmt.Println(t.S)type F float64func (f F) M() fmt.Println(f)func main() var i I\ti = Thello\tdescribe(i)\ti.M()\ti = F(math.Pi)\tdescribe(i)\ti.M()func describe(i I) fmt.Printf((%v, %T) , i, i)(hello, *main.T)hello(3.141592653589793, main.F)3.141592653589793 底层值为 nil 的接口值 即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。 在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 M 方法）。 注意: 保存了 nil 具体值的接口其自身并不为 nil。 package mainimport fmttype I interface M()type T struct S stringfunc (t *T) M() if t == nil fmt.Println(nil) return fmt.Println(t.S)func main() var i I\tvar t *T\ti = t\tdescribe(i) // 这里不会触发一个空指针异常\ti.M()\ti = Thello\tdescribe(i)\ti.M()func describe(i I) fmt.Printf((%v, %T) , i, i)(nil, *main.T)nil(hello, *main.T)hello nil接口值 nil 接口值既不保存值也不保存具体类型。 为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 具体 方法的类型。 package mainimport fmttype I interface M()func main() var i I\tdescribe(i) // 没有指定具体类型的方法 // (nil, nil)\t// panic: runtime error: invalid memory address or nil pointer dereference\ti.M()func describe(i I) fmt.Printf((%v, %T) , i, i) 11.4 空接口指定了零个方法的接口值被称为 空接口： interface 空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。） 空接口被用来处理未知类型的值。例如，fmt.Print 可接受类型为 interface 的任意数量的参数。 package mainimport fmttype I interfacefunc main() var i I\tdescribe(i)\ti = 42\tdescribe(i)\ti = hello\tdescribe(i)func describe(i I) fmt.Printf((%v, %T) , i, i) 11.5 类型断言类型断言 提供了访问接口值底层具体值的方式。 t := i.(T) 该语句断言接口值 i 保存了具体类型 T，并将其底层类型为 T 的值赋予变量 t。 若 i 并未保存 T 类型的值，该语句就会触发一个 panic。 为了 判断 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。 t, ok := i.(T) 若 i 保存了一个 T，那么 t 将会是其底层值，而 ok 为 true。 否则，ok 将为 false 而 t 将为 T 类型的零值，程序并不会产生 panic。 请注意这种语法和读取一个映射时的相同之处。 package mainimport fmtfunc main() var i interface = hello\ts := i.(string)\tfmt.Println(s)\ts, ok := i.(string)\tfmt.Println(ok)\tf, ok := i.(float64)\tfmt.Println(f, ok)\t// panic: interface conversion: interface is string, not float64\tf = i.(float64) // panic\tfmt.Println(f) 11.6 类型选择类型选择 是一种按顺序从几个类型断言中选择分支的结构。 类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。 switch v := i.(type) case T: // v 的类型为 Tcase S: // v 的类型为 Sdefault: // 没有匹配，v 与 i 的类型相同 类型选择中的声明与类型断言 i.(T) 的语法相同，只是具体类型 T 被替换成了关键字 type。 此选择语句判断接口值 i 保存的值类型是 T 还是 S。在 T 或 S 的情况下，变量 v 会分别按 T 或 S 类型保存 i 拥有的值。在默认（即没有匹配）的情况下，变量 v 与 i 的接口类型和值相同。 package mainimport fmtfunc do(i interface) switch v := i.(type) case int: fmt.Printf(二倍的 %v 是 %v , v, v*2)\tcase string: fmt.Printf(%q 长度为 %v 字节 , v, len(v))\tdefault: fmt.Printf(我不知道类型 %T! , v)\tfunc main() do(21)\tdo(hello)\tdo(true) 12. 错误Go 程序使用 error 值来表示错误状态。 error 类型是一个内置的接口： type error interface Error() string （与 fmt.Stringer 类似，fmt 包也会根据对 error 的实现来打印值。） 通常函数会返回一个 error 值，调用它的代码应当判断这个错误是否等于 nil 来进行错误处理。 i, err := strconv.Atoi(42)if err != nil fmt.Printf(couldnt convert number: %v , err) returnfmt.Println(Converted integer:, i) error 为 nil 时表示成功；非 nil 的 error 表示失败。 package mainimport (\tfmt\tmath\ttime)type MyError struct When time.Time\tWhat string// 实现error接口的Error()方法func (e MyError) Error() string return fmt.Sprintf(at %v, %s, e.When, e.What)func Sqrt(f float64) (float64, error) if f 0 return 0, MyError time.Now(), square root of negative number, return math.Abs(f), nilfunc main() fmt.Println(Sqrt(1))\t_, err := Sqrt(-1)\tif err != nil fmt.Println(err)\t1 nilat 2024-08-07 15:35:34.2402027 +0800 CST m=+0.001527601, square root of negative number 13. 泛型13.1 类型参数可以使用类型参数编写 Go 函数来处理多种类型。 函数的类型参数出现在函数参数之前的方括号之间。 func Index[T comparable](s []T, x T) int 此声明意味着 s 是满足内置约束 comparable 的任何类型 T 的切片。 x 也是相同类型的值。 comparable 是一个有用的约束，它能让我们对任意满足该类型的值使用 == 和 != 运算符。在此示例中，我们使用它将值与所有切片元素进行比较，直到找到匹配项。 该 Index 函数适用于任何支持比较的类型。 package mainimport fmt// Index 返回 x 在 s 中的下标，未找到则返回 -1。func Index[T comparable](s []T, x T) int for i, v := range s // v 和 x 的类型为 T，它拥有 comparable 可比较的约束， // 因此我们可以使用 ==。 if v == x return i return -1func Index2[T int](s []T, x T) int for i, v := range s // v 和 x 的类型为 T，它拥有 comparable 可比较的约束， // 因此我们可以使用 ==。 if v == x return i return -1func main() // Index 可以在整数切片上使用\tsi := []int10, 20, 15, -10\tfmt.Println(Index(si, 15)) si2 := []int10, 20, 15, -10 // Index2的参数约束为int，此时如果传入string类型编译会报错 fmt.Println(Index2(si2, 15))\t// Index 也可以在字符串切片上使用\tss := []stringfoo, bar, baz\tfmt.Println(Index(ss, hello)) 14. 并发14.1 Go协程Go 程（goroutine）是由 Go 运行时管理的轻量级线程。 go f(x, y, z) 会启动一个新的 Go 协程并执行f函数 f(x, y, z) f, x, y 和 z 的求值发生在当前的 Go 协程中，而 f 的执行发生在新的 Go 协程中。 Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。sync 包提供了这种能力，不过在 Go 中并不经常用到，因为还有其它的办法。 package mainimport (\tfmt\ttime)func say(s string) for i := 0; i 5; i++ time.Sleep(100 * time.Millisecond) fmt.Println(s)\tfunc main() go say(world)\tsay(hello) 14.2 信道信道是带有类型的管道，你可以通过它用信道操作符 - 来发送或者接收值。 ch - v // 将 v 发送至信道 ch。v := -ch // 从 ch 接收值并赋予 v。 （“箭头”就是数据流的方向。） 和映射与切片一样，信道在使用前必须创建： ch := make(chan int) 默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。 以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。 package mainimport fmtfunc sum(s []int, c chan int) sum := 0\tfor _, v := range s sum += v c - sum // 发送 sum 到 cfunc main() s := []int7, 2, 8, -9, 4, 0\tc := make(chan int)\tgo sum(s[:len(s)/2], c)\tgo sum(s[len(s)/2:], c)\tx, y := -c, -c // 从 c 接收\tfmt.Println(x, y, x+y) 带缓冲的信道 信道可以是 带缓冲的。将缓冲长度作为第二个参数提供给 make 来初始化一个带缓冲的信道： ch := make(chan int, 100) 仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。 package mainimport fmtfunc main() ch := make(chan int, 2)\tch - 1\tch - 2 // 缓冲区满后再写会报下列错误 // fatal error: all goroutines are asleep - deadlock! // ch - 3\tfmt.Println(-ch)\tfmt.Println(-ch) 信道关闭 发送者可通过 close 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完 v, ok := -ch 此时 ok 会被设置为 false。 循环 for i := range c 会不断从信道接收值，直到它被关闭。 注意： 只应由发送者关闭信道，而不应油接收者关闭。向一个已经关闭的信道发送数据会引发程序 panic。 还要注意： 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 range 循环。 package mainimport (\tfmt)func fibonacci(n int, c chan int) x, y := 0, 1\tfor i := 0; i n; i++ c - x x, y = y, x+y close(c)func main() c := make(chan int, 10)\tgo fibonacci(cap(c), c)\tfor i := range c fmt.Println(i) 14.3 select语句select 语句使一个 Go 程可以等待多个通信操作。 select 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。 package mainimport fmtfunc fibonacci(c, quit chan int) x, y := 0, 1\tfor select // 将当前的x值发送到通道c，然后计算下一个Fibonacci数列的值（x, y = y, x+y） case c - x: x, y = y, x+y // 从通道quit接收值，当接收到值时，打印quit并返回，结束函数执行 case -quit: fmt.Println(quit) return func main() c := make(chan int)\tquit := make(chan int) // 启动一个新的goroutine，在这个goroutine中，从通道c接收并打印10个Fibonacci数列的值，然后向quit通道发送一个值。\tgo func() for i := 0; i 10; i++ fmt.Println(-c) quit - 0\t()\tfibonacci(c, quit) default分支 当 select 中的其它分支都没有准备好时，default 分支就会执行。 为了在尝试发送或者接收时不发生阻塞，可使用 default 分支： select case i := -c: // 使用 idefault: // 从 c 中接收会阻塞时执行 package mainimport (\tfmt\ttime)func main() tick := time.Tick(2000 * time.Millisecond)\tboom := time.After(5000 * time.Millisecond)\tfor select case -tick: fmt.Println(tick.) case -boom: fmt.Println(boom) return default: fmt.Println( .) time.Sleep(1000 * time.Millisecond) . .tick. . .tick. .boom","tags":[null],"categories":[null]},{"title":"Gitlab安装","path":"/wiki/Kubernetes/Gitlab安装.html","content":"概念‌GitLab‌ 是一个 ‌DevOps 平台‌，集成了 ‌代码托管（Git）、CICD（持续集成持续交付）、项目管理、安全扫描、容器注册表‌ 等功能，适用于 ‌软件开发的整个生命周期‌（从代码编写到部署和维护）。 GitLab 的核心功能1.‌代码托管（类似 GitHub） 支持 ‌Git 版本控制‌，允许开发团队协作开发代码。 提供 ‌分支管理、代码审查（Merge Requests）、权限控制‌ 等功能。 2.CICD（持续集成持续交付） 内置 ‌GitLab CICD‌，可以自动化构建、测试和部署代码。 支持 ‌Docker、Kubernetes‌ 集成，方便云原生开发。 3.项目管理 敏捷开发 提供 ‌看板（Kanban）、问题跟踪（Issues）、里程碑（Milestones）等功能。 支持 ‌敏捷开发（Scrum）、DevOps 流程‌。 4.安全 合规性 ‌静态代码分析（SAST）（检查代码漏洞） ‌依赖扫描（SCA）（检查第三方库漏洞） ‌容器扫描‌（检查 DockerK8s 镜像安全） ‌合规性检查‌（确保代码符合安全标准） 5.容器注册表 Artifact 存储 内置 ‌Docker 镜像仓库‌（类似 Docker Hub） 支持 ‌二进制文件（Artifacts）存储‌（如编译后的二进制文件） 安装helm添加chartshelm repo add gitlab-jh https://charts.gitlab.cn helm pull gitlab-jh/gitlab 创建命名空间kubectl create ns gitlab chart改造# 全局主机配置global: hosts: domain: dev.com # 域名后缀，GitLab URL 将为 gitlab.dev.com https: true # 启用 HTTPS ingress: enabled: true # 启用 Ingress configureCertmanager: false # 禁用自动 cert-manager（使用现有 TLS Secret） tls: enabled: true # 启用 TLS secretName: ingress-nginx-tls # 使用现有 TLS Secret class: nginx # 假设使用 NGINX Ingress Class（根据您的集群调整） edition: ce # 安装 Enterprise Edition（如果需要 Community Edition，改为 ce）gitlab: gitaly: persistence: storageClass: nfs-client-retain size: 2Gipostgresql: auth: secretKeys: userPasswordKey: postgresql-postgres-password primary: persistence: storageClass: nfs-client-retain size: 2Gi readReplicas: persistence: storageClass: nfs-client-retain size: 2Giredis: auth: usePasswordFiles: false master: persistence: storageClass: nfs-client size: 2Giminio: persistence: storageClass: nfs-client size: 2Gi # 可选：禁用不必要的组件以节省资源（例如 Prometheus）prometheus: install: false # 如果不需要监控，禁用 installCertmanager: falsenginx-ingress: enabled: false helm upgrade --install gitlab gitlab-jh/gitlab -n gitlab --version 9.2.1 -f values.yaml # root初始密码kubectl get secret --namespace gitlab gitlab-gitlab-initial-root-password -o jsonpath=.data.password | base64 --decode ; echo 配置 glagent-TNvvTkH-AdiyiMstQRaqKJnfHF8GsgGuF61o57RsNj4CWiLxYg helm repo add gitlab https://charts.gitlab.iohelm repo updatehelm upgrade –install gtilab-agent gitlabgitlab-agent –namespace gitlab-agent-gtilab-agent –create-namespace –set image.tagv18.2.0 –set config.tokenglagent-TNvvTkH-AdiyiMstQRaqKJnfHF8GsgGuF61o57RsNj4CWiLxYg –set config.kasAddresswss:kas.dev.com","tags":[null],"categories":[null]},{"title":"Habor安装","path":"/wiki/Kubernetes/Habor安装.html","content":"Habor概念Harbor 的目标是帮助用户迅速搭建一个企业级的 Docker registry 服务。它以 Docker 公司开源的 registry 为基础，额外提供了如下功能: 基于角色的访问控制(Role Based Access Control) 基于策略的镜像复制(Policy based image replication) 镜像的漏洞扫描(Vulnerability Scanning) ADLDAP 集成(LDAPAD support) 镜像的删除和空间清理(Image deletion garbage collection) 友好的管理 UI(Graphical user portal) 审计日志(Audit logging) RESTful API 部署简单(Easy deployment) NFS 安装nfs-client-provisioner是Kubernetes中的一个供应商，其主要功能是‌动态提供由NFS（Network File System）共享支持的持久卷‌。在Kubernetes集群中，持久卷是独立于Pod存在的存储资源，用于持久地存储数据。nfs-client-provisioner通过以下方式发挥作用： ‌自动化创建持久卷‌：它根据需要自动化创建持久卷，无需手动操作。 ‌与NFS服务器交互‌：通过与NFS服务器进行交互，实现存储的动态分配。 ‌简化管理‌：使得在Kubernetes集群中为应用程序动态分配存储变得更加简单，无需手动管理NFS共享和持久卷的创建过程。 1.添加共享目录 # 每个节点执行yum install -y nfs-utils rpcbind# 以node1节点为nfs服务，在node1节点执行下列命令mkdir /nfsdatachmod 666 /nfsdatachown nobody /nfsdatacd /nfsdata/echo /nfsdata *(rw,no_root_squash,no_all_squash,sync) /etc/exportssystemctl start rpcbindsystemctl start nfs-serversystemctl restart rpcbind# 查看挂载目录showmount -e 10.37.129.10echo /nfsdata/share *(rw,no_root_squash,no_all_squash,sync) /etc/exportsmkdir -p /nfsdata/sharechown -R nobody /nfsdata/sharesystemctl enable nfs-server systemctl restart nfs-server systemctl restart rpcbindshowmount -e 10.37.129.10 2.创建命名空间 kubectl create ns nfs-storageclass 3.部署 nfs-client-provisioner apiVersion: apps/v1kind: Deploymentmetadata: name: nfs-client-provisioner namespace: nfs-storageclassspec: replicas: 1 selector: matchLabels: app: nfs-client-provisioner strategy: type: Recreate template: metadata: labels: app: nfs-client-provisioner spec: serviceAccountName: nfs-client-provisioner containers: - name: nfs-client-provisioner image: k8s.dockerproxy.com/sig-storage/nfs-subdir-external-provisioner:v4.0.2 volumeMounts: - name: nfs-client-root mountPath: /persistentvolumes env: - name: PROVISIONER_NAME value: k8s-sigs.io/nfs-subdir-external-provisioner - name: NFS_SERVER # value: YOUR NFS SERVER HOSTNAME value: 10.37.129.10 - name: NFS_PATH value: /nfsdata/share volumes: - name: nfs-client-root nfs: # value: YOUR NFS SERVER HOSTNAME server: 10.37.129.10 path: /nfsdata/share---apiVersion: v1kind: ServiceAccountmetadata: name: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: nfs-storageclass---kind: ClusterRoleapiVersion: rbac.authorization.k8s.io/v1metadata: name: nfs-client-provisioner-runnerrules:- apiGroups: [] resources: [nodes] verbs: [get, list, watch]- apiGroups: [] resources: [persistentvolumes] verbs: [get, list, watch, create, delete]- apiGroups: [] resources: [persistentvolumeclaims] verbs: [get, list, watch, update]- apiGroups: [storage.k8s.io] resources: [storageclasses] verbs: [get, list, watch]- apiGroups: [] resources: [events] verbs: [create, update, patch]---kind: ClusterRoleBindingapiVersion: rbac.authorization.k8s.io/v1metadata: name: run-nfs-client-provisionersubjects:- kind: ServiceAccount name: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: nfs-storageclassroleRef: kind: ClusterRole name: nfs-client-provisioner-runner apiGroup: rbac.authorization.k8s.io---kind: RoleapiVersion: rbac.authorization.k8s.io/v1metadata: name: leader-locking-nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: nfs-storageclassrules:- apiGroups: [] resources: [endpoints] verbs: [get, list, watch, create, update, patch]---kind: RoleBindingapiVersion: rbac.authorization.k8s.io/v1metadata: name: leader-locking-nfs-client-provisioner namespace: nfs-storageclasssubjects:- kind: ServiceAccount name: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: nfs-storageclassroleRef: kind: Role name: leader-locking-nfs-client-provisioner apiGroup: rbac.authorization.k8s.io 4.创建StorageClass apiVersion: storage.k8s.io/v1kind: StorageClassmetadata: name: nfs-client namespace: nfs-storageclassprovisioner: k8s-sigs.io/nfs-subdir-external-provisionerparameters: pathPattern: $.PVC.namespace/$.PVC.name onDelete: delete Ingress-Nginx 安装# 添加 ingress-controllerhelm repo add ingress-nginx https://kubernetes.github.io/ingress-nginxhelm pull ingress-nginx/ingress-nginxtar -zxvf ingress-nginx-*tgzcd ingress-nginx# 修改 values.yaml 文件修改 hostNetwork 的值为 truereplicaCount的值修改为：2dnsPolicy的值改为: ClusterFirstWithHostNetkind类型更改为：DaemonSet关闭所有镜像的 digest修改admissionWebhooks:port:8444ingressClassResource.default=truekubectl create ns ingresshelm install ingress-nginx -n ingress . -f values.yaml # tls配置cd ~openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj /CN=nginxsvc/O=nginxsvckubectl create secret tls ingress-nginx-tls --key tls.key --cert tls.crt Habor 安装1.创建名空间 cat namespace-harbor.yamlapiVersion: v1kind: Namespacemetadata: name: harborkubectl apply -f namespace-harbor.yaml 2.添加 helm repo cd /home/chahelm repo add harbor https://helm.goharbor.iohelm search repohelm pull harbor/harbortar zxf harbor-*.tgz # 修改 skipUpdate: true，添加存储类 storageClass: nfs-client(所有都要修改)，添加 tsl: tls.secret:secretName:ingress-nginx-tlshelm install harbor . -f values.yaml -n harbor# 添加域名到host文件(ingress 运行的node的IP)10.37.129.11 core.harbor.domain# 默认账号/密码adminHarbor12345","tags":[null],"categories":[null]},{"title":"Helm","path":"/wiki/Kubernetes/Helm.html","content":"HELMHELM 作用 ‌简化部署流程‌：在使用Helm之前，部署Kubernetes应用需要手动创建deployment、svc等资源，步骤繁琐。Helm通过打包方式，简化了这一过程。 ‌版本管理‌：Helm支持应用的版本管理，方便追踪和控制不同版本的发布。 ‌动态生成资源清单‌：Helm能动态生成Kubernetes资源清单文件，如‌deployment.yaml‌和‌service.yaml‌，并自动执行部署，提升了管理效率。 ‌可配置性‌：Helm让Kubernetes的应用管理变得可配置，适应不同环境和需求。 HELM重要概念 ‌Chart‌：是应用部署的自包含单元，包含了应用的配置模板、参数定义、依赖关系和文档说明等，可以将其想象成apt或yum中的软件包。 ‌Release‌：是Chart的运行实例，代表了一个正在Kubernetes集群中运行的应用。同一个Chart可以多次安装到集群中，每次安装都会生成一个新的Release。 ‌Helm CLI‌：是Helm的客户端组件，负责与Kubernetes API进行通信，用于管理Chart和Release。 ‌Repository‌：用于发布和存储Chart的仓库，方便用户查找和下载所需的Chart。 HELM常用命令HELM 安装curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3chmod 700 get_helm.sh./get_helm.sh 初始化# 查看仓库helm repo ls# 添加仓库helm repo add bitnami https://charts.bitnami.com/bitnami# 查看仓库中有哪些 charthelm search repo bitnami# 更新仓库helm repo update# 移除仓库 helm repo remove chart安装# 更新Helm仓库索引，确定我们可以拿到最新的 charts 列表helm repo update# 显示bitnami/apache chart的默认配置值helm show values bitnami/apache# 安装bitnami/apache chart并自动生成发布名称helm install bitnami/apache --generate-name# 列出在 Kubernetes 集群中 default 命名空间下安装的所有 Helm release（发布版本）。helm list -n default# 显示bitnami/apache Chart的基本信息和元数据helm show chart bitnami/apache# 显示该Chart的所有详细信息，包括Chart定义、values配置、README文档等完整内容helm show all bitnami/apache 可以看到在k8s集群中成功部署了一个 pod。 更多安装方法： helm install 命令可以从多个来源进行安装。 chart 的仓库（如上所述） 本地 chart 压缩包（ helm install foo foo-0.1.1.tgz） 解压后的 chart 目录（ helm install foo pathtofoo） 完整的 URL（ helm install foo https://example.com/charts/foo-1.2.3.tgz） release删除# 该命令会从Kubernetes卸载 apache-1753340573 它将删除和该版本相关的所有相关资源（service、deployment、 pod等等）甚至版本历史helm uninstall apache-1753340573 --keep-history # 选项， Helm 将会保存版本历史# 查看该版本的当前状态信息helm status apache-1753340573 helm v2 版本中，当一个 release 被删除，会保留一条删除记录。而在 Helm 3 中，删除也会移除 release 的记录。 如果想保留删除记录，使用 helm uninstall --keep-history。使用 helm list --uninstalled 只会展示使用了 --keep-history 删除的 release。 helm list --all 会展示 Helm 保留的所有 release 记录，包括失败或删除的条目（指定了 –keep-history）。 自定义chart安装# 显示bitnami/apache chart的默认配置值helm show values bitnami/apachevi values.yamlhelm install -f values.yaml bitnami/apache --generate-name 安装过程中有两种方式传递配置数据： --values (或 -f)：使用 YAML 文件覆盖配置。可以指定多次，优先使用最右边的文件。 --set：通过命令行的方式对指定项进行覆盖。 如果同时使用两种方式，则 --set 中的值会被合并到 --values 中，但是 --set 中的值优先级更高。 在 --set 中覆盖的内容会被被保存在 ConfigMap 中。可以通过 helm get values release-name 来查看指定 release 中 --set 设置的值。也可以通过运行 helm upgrade 并指定 --reset-values 字段来清除 --set 中设置的值。 --set 的格式和限制： --set 选项使用 0 或多个 name/value 对。最简单的用法类似于：--set name=value，等价于如下YAML 格式： name: value 多个值使用逗号分割，因此 --set a=b,c=d 的 YAML 表示是： a: bc: d 支持更复杂的表达式。 例如，--set outer.inner=value 被转换成了： outer: inner: value 列表使用花括号 来表示。 例如，--set name=a, b, c 被转换成了： name: - a - b - c 某些 name/key 可以设置为 null 或者空数组。 例如 --set name=[],a=null name: []a: null 从 2.5.0 版本开始，可以使用数组下标的语法来访问列表中的元素。 例如 --set servers[0].port=80 servers: - port: 80 多个值也可以通过这种方式来设置。 --set servers[0].port=80,servers[0].host=example servers: - port: 80 host: example 如果需要在 --set 中使用特殊字符，你可以使用反斜线来进行转义； --set name=value1\\,value2 name: value1,value2 --set nodeSelector.kubernetes.io/role=master nodeSelector: kubernetes.io/role: master release 升级helm upgrade [RELEASE] [CHART] [flags]功能说明：- helm upgrade 用于升级已安装的 Helm release（发布版本）- 将现有的 chart（图表）升级到新版本- 可以更新配置值、升级到新的 chart 版本- 通常需要指定 release 名称和 chart 路径或名称 helm upgrade -f 2-values.yaml apache-1753344736 bitnami/apache# 用于检索指定 Release 的 values 值helm get values apache-1753344736 release 回滚helm rollback [RELEASE] [REVISION]功能解释：helm rollback 用于将已部署的Helm release回滚到之前的版本。当前部署的应用出现问题时，可以使用此命令快速恢复到历史版本。需要指定release名称和目标版本号来执行回滚操作。 # 查看历史版本helm history apache-1753344736# 回滚版本helm rollback apache-1753344736 1 上面这条命令将我们的 apache-1753344736 回滚到了它最初的版本。release 版本其实是一个增量修订（revision）。 每当发生了一次安装、升级或回滚操作，revision 的值就会加1。第一次 revision 的值永远是1。我们可以使用 helm history [RELEASE] 命令来查看一个特定 release 的修订版本号。 升级回滚额外选项--timeout：一个 Go duration 类型的值， 用来表示等待 Kubernetes 命令完成的超时时间，默认值为 5m0s。such as “300ms”, “-1.5h” or “2h45m”. Validtime units are “ns”, “us” (or “µs”),”ms”, “s”, “m”, “h”。 --wait：表示必须要等到所有的 Pods 都处于 ready 状态，PVC 都被绑定，Deployments 都至少拥有最小 ready 状态 Pods 个数（Desired减去 maxUnavailable），并且 Services 都具有 IP 地址（如果是LoadBalancer， 则为 Ingress），才会标记该 release 为成功。最长等待时间由 –timeout 值指定。如果达到超时时间，release 将被标记为 FAILED。注意：当 Deployment 的replicas 被设置为1，但其滚动升级策略中的 maxUnavailable 没有被设置为0时，–wait 将返回就绪，因为已经满足了最小 ready Pod 数。 --no-hooks：不运行当前命令的钩子，即为安装此 chart 时的已定义的安装前或者安装后的动作。 创建charthttps://helm.sh/zh/docs/chart_template_guide/getting_started/ helm create myapp ‌Chart.yaml‌：定义了Helm Chart的元数据，包括Chart的名称、版本、描述等基本信息。 ‌values.yaml‌：包含了Chart的默认配置值和用户可自定义的参数，用于配置部署时的各种选项。 charts: 包含了该 chart 依赖的 chart。 ‌templates目录‌： NOTEX.txt：chart 说明文件。 ‌deployment.yaml‌：定义了Kubernetes的部署资源，用于指定Pod的模板、副本数等。 ‌service.yaml‌：定义了服务资源，用于暴露Pod的访问方式。 ‌ingress.yaml‌：定义了Ingress资源，用于管理外部访问服务的规则。 ‌hpa.yaml‌：定义了水平Pod自动扩展（HPA）规则，根据资源利用率自动调整Pod数量。 ‌serviceaccount.yaml‌：定义了服务账户，用于Pod的身份验证和授权。 ‌tests目录‌：包含测试文件，如‌test-connection.yaml‌，用于验证部署后的服务连接是否正常。 rm -rf values.yamlrm -rf templates/* cd templatesvi NOTES.txtvi deployment.yamlvi service.yamlcd ..vi values.yamlhelm install myapp-chart myapp/ NOTES.txt 1、这是一个测试的 myapp chart2、myapp release 名字：myapp-test- now | date 20060102030405 -deploy3、service 名字：myapp-test- now | date 20060102030405 -svc deployment.yaml apiVersion: apps/v1kind: Deploymentmetadata: labels: app: myapp-test name: myapp-test- now | date 20060102030405 -deployspec: replicas: .Values.replicaCount selector: matchLabels: app: myapp-test template: metadata: labels: app: myapp-test spec: containers: - image: .Values.image.repository : .Values.image.tag name: myapp service.yaml apiVersion: v1kind: Servicemetadata: labels: app: myapp-test name: myapp-test- now | date 20060102030405 -svcspec: ports: - name: 80-80 port: 80 protocol: TCP targetPort: 80 - if eq .Values.service.type NodePort nodePort: .Values.service.nodeport - end selector: app: myapp-test type: .Values.service.type | quote values.yaml # Default values for myapp.# This is a YAML-formatted file.# Declare variables to be passed into your templates.replicaCount: 5image: repository: wangyanglinux/myapp tag: v1.0service: type: NodePort nodeport: 32321","tags":[null],"categories":[null]},{"title":"Ingress","path":"/wiki/Kubernetes/Ingress.html","content":"IngressIngress 的定义Ingress 是 Kubernetes 中的一种 ‌API 资源对象‌，用于管理集群外部对内部服务的 HTTPHTTPS 访问。它通过定义路由规则，将外部请求定向到集群内不同的 Service，充当集群的“智能入口网关”‌。 ‌词源‌：源自拉丁语“ingressus”，意为“进入权”或“准入机制”‌。 ‌定位‌：属于 OSI 七层（应用层）代理，专注于 HTTPHTTPS 流量的路由与控制‌。 Ingress 核心功能 ‌路由规则‌ 基于 ‌域名‌（如 example.com）或 ‌路径‌（如 /api）将请求分发到不同后端服务‌。 支持多路径映射到同一 Service 的不同端口‌。 ‌负载均衡‌ 自动将流量均衡分配到后端 Pod，支持轮询、最小连接数等策略‌。 ‌SSLTLS 终止‌ 在代理层解密 HTTPS 流量，减轻后端服务压力‌。 ‌统一入口管理‌ 替代多个 NodePortLoadBalancer，降低云服务成本‌。 Ingress 架构与工作原理 ‌组成组件‌ ‌Ingress 资源‌：YAML 定义的规则（如路由、TLS 配置）‌。 ‌Ingress Controller‌：实际执行规则的组件（如 Nginx、Envoy），监听规则变化并动态更新代理配置‌。 ‌工作流程‌ 用户创建 Ingress 资源后，Controller 监听 API Server 的变更。 Controller 根据规则生成代理配置（如 Nginx 的 nginx.conf）并应用‌。 流量经 Controller 转发至后端 Service 对应的 Pod‌。 Ingress 典型应用场景 ‌多服务统一入口‌ 通过不同域名或路径暴露多个微服务（如 api.example.com 和 admin.example.com）。 ‌HTTPS 安全接入‌ 集中管理 TLS 证书，实现全站 HTTPS‌。 ‌灰度发布‌ 基于 Header 或 Cookie 将部分流量导流到新版本服务‌。 与 Service 组件的对比 ‌特性‌ ‌Ingress ‌Service (NodePortLB) ‌协议支持‌ HTTPHTTPS（七层）‌ TCPUDP（四层）‌ ‌路由能力‌ 支持域名、路径等高级路由‌ 仅支持端口映射‌ ‌适用场景‌ Web 应用、API 网关‌ 数据库、非 HTTP 服务‌ Ingress 注意事项 ‌Ingress Controller 非内置‌：需额外部署（如 Nginx Ingress Controller）‌。 ‌性能瓶颈‌：高并发场景需优化 Controller 资源配置（如 CPU内存）‌。 ‌未来演进‌：Kubernetes 正逐步将功能迁移至 ‌Gateway API‌‌。 实现七层负载手动实现 基于 ingress Ingress-Nginx架构原理图 安装helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginxhelm pull ingress-nginx/ingress-nginx# 修改 values.yaml 文件修改 hostNetwork 的值为 truereplicaCount的值修改为：2dnsPolicy的值改为: ClusterFirstWithHostNetkind类型更改为：DaemonSet关闭所有镜像的 digestingressClassResource.default=truekubectl create ns ingresshelm install ingress-nginx -n ingress . -f values.yaml # 添加域名到host文件(ingress 运行的node的IP)10.37.129.11 www1.k8s.com HTTP 代理apiVersion: apps/v1kind: Deploymentmetadata: name: ingress-httpproxy-www1spec: replicas: 2 selector: matchLabels: hostname: www1 template: metadata: labels: hostname: www1 spec: containers: - name: nginx image: wangyanglinux/myapp:v1.0 imagePullPolicy: IfNotPresent ports: - containerPort: 80---apiVersion: v1kind: Servicemetadata: name: ingress-httpproxy-www1spec: ports: - port: 80 targetPort: 80 protocol: TCP selector: hostname: www1---apiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: ingress-httpproxy-www1spec: ingressClassName: nginx rules: - host: www1.k8s.com http: paths: - path: / pathType: Prefix backend: service: name: ingress-httpproxy-www1 port: number: 80 ‌依赖前提‌： 集群已部署 Nginx Ingress Controller域名已正确解析到 Ingress Controller 的 IP 地址镜像仓库可访问（或本地已有该镜像） ‌Deployment 配置‌： 部署名为 ingress-httpproxy-www1 的应用运行 2 个副本的 Nginx 容器（镜像 wangyanglinuxmyapp:v1.0）每个容器暴露 80 端口，使用标签 hostname: www1 进行管理 ‌Service 配置‌： 创建同名 Service 作为集群内访问入口将外部 80 端口流量转发到容器 80 端口通过标签选择器关联到 Deployment 管理的 Pod ‌Ingress 配置‌： 使用 Nginx Ingress Controller 处理外部流量定义域名 www1.k8s.com 的路由规则将所有路径（）的 HTTP 请求转发到对应的 Service ‌完整工作流程‌： 外部用户访问 www1.k8s.com → 请求到达 Ingress Controller → 根据规则转发到 Service → 最终由 Deployment 管理的 Pod 处理 HTTPS 代理openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj /CN=nginxsvc/O=nginxsvckubectl create secret tls ingress-nginx-tls --key tls.key --cert tls.crt apiVersion: apps/v1kind: Deploymentmetadata: name: ingress-httpproxy-sslspec: replicas: 2 selector: matchLabels: hostname: ssl template: metadata: labels: hostname: ssl spec: containers: - name: nginx image: wangyanglinux/myapp:v3.0 imagePullPolicy: IfNotPresent ports: - containerPort: 80---apiVersion: v1kind: Servicemetadata: name: ingress-httpproxy-sslspec: ports: - port: 80 targetPort: 80 protocol: TCP selector: hostname: ssl---apiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: ingress-httpproxy-ssl namespace: default annotations: nginx.ingress.kubernetes.io/ssl-redirect: truespec: ingressClassName: nginx rules: - host: ssl.k8s.com http: paths: - path: / pathType: Prefix backend: service: name: ingress-httpproxy-ssl port: number: 80 tls: - hosts: - ssl.k8s.com secretName: ingress-nginx-tls 该配置包含三个核心组件： ‌Deployment‌：部署 2 个副本的 Nginx 容器（v3.0 版本），通过标签 hostname: ssl 管理‌。 ‌Service‌：提供稳定的集群内访问入口，将 80 端口流量转发到 Pod‌。 ‌Ingress： 强制 HTTPS 重定向（通过 ssl-redirect: true 注解）。 使用预创建的 TLS 证书 Secret（ingress-nginx-tls）为域名 ssl.xinxianghf.com 提供 HTTPS 支持‌。 通过 Nginx Ingress Controller 处理七层路由‌。 ‌部署前提‌： 需提前创建包含有效证书的 Secret：kubectl create secret tls ingress-nginx-tls --cert=tls.crt --key=tls.key。 确保域名解析指向 Ingress Controller 的外部 IP‌。 集群已安装 Nginx Ingress Controller。","tags":[null],"categories":[null]},{"title":"Jenkins安装","path":"/wiki/Kubernetes/Jenkins安装.html","content":"Jenkins 是一款开源的 ‌持续集成与持续交付（CICD） 工具，用于自动化软件开发流程中的构建、测试、部署等任务。 简介核心功能与定位 ‌自动化流水线‌：通过监听代码仓库（如 Git）的变更，自动触发构建、测试、打包和部署流程，实现代码提交后的全自动化处理‌。 ‌多环境支持‌：支持通过系统包、Docker 或 Java 独立程序运行，适配不同操作系统和开发环境‌。 ‌插件生态‌：拥有超过 1500 个插件，扩展性强，可集成 SonarQube、Docker、Kubernetes 等工具链‌。 架构与设计特点 ‌主从架构‌：支持分布式构建，主节点（Master）调度任务，从节点（Slave）执行实际构建，提升并行处理能力‌。 ‌数据存储‌：所有配置和数据以 XML 格式存储在 JENKINS_HOME 目录（默认 /var/lib/jenkins），需注意备份 config.xml 文件‌。 典型应用场景 ‌CICD 流程‌： ‌构建阶段‌：编译代码、生成可执行文件。 ‌测试阶段‌：自动化单元测试、集成测试。 ‌部署阶段‌：通过脚本或工具（如 Ansible）发布到生产环境‌。 ‌运维扩展‌：支持定时任务、日志收集、服务监控等非开发场景‌。 安装helm repo add jenkinsci https://charts.jenkins.iohelm repo updatecd chartshelm pull jenkinsci/jenkins controller: # -- Used for label app.kubernetes.io/component componentName: jenkins-controller image: pullPolicy: IfNotPresent serviceType: NodePortinstallPlugins: []persistence: storageClass: nfs-client size: 8Gi kubectl create ns cicdhelm upgrade --install jenkins jenkinsci/jenkins \\ --namespace cicd \\ -f my-values.yaml 1. Get your admin user password by running: kubectl exec --namespace cicd -it svc/jenkins -c jenkins -- /bin/cat /run/secrets/additional/chart-admin-password echo2. Get the Jenkins URL to visit by running these commands in the same shell: export NODE_PORT=$(kubectl get --namespace cicd -o jsonpath=.spec.ports[0].nodePort services jenkins) export NODE_IP=$(kubectl get nodes --namespace cicd -o jsonpath=.items[0].status.addresses[0].address) echo http://$NODE_IP:$NODE_PORT","tags":[null],"categories":[null]},{"title":"Kubernetes安装","path":"/wiki/Kubernetes/Kubernetes安装.html","content":"Kubernetes 安装Minikube 安装 Kubernetes安装 Minikube 下载 windows 版本 https://minikube.sigs.k8s.io/docs/start/?arch=%2Fwindows%2Fx86-64%2Fstable%2F.exe+download 安装 Minikube 打开安装目录，使用管理员打开 PowerShell 界面运行 Minikube 安装失败 启用 hyper-v https://blog.csdn.net/Destinyzhoujunyu/article/details/131610508 set HTTP_PROXY=http://127.0.0.1:17890set HTTPS_PROXY=https://127.0.0.1:17890set NO_PROXY=localhost,127.0.0.1,10.96.0.0/12,192.168.59.0/24,192.168.49.0/24,192.168.39.0/24 虚拟机安装ikuai安装 下载 ikuai iso镜像 https://www.ikuai8.com/component/download 安装镜像 选择镜像 选择操作系统 设置用户名密码 选择安装位置创建虚拟机 安装系统 添加网卡2 配置 lan 口查看 pd 偏好设置中虚拟网段进入 ikuai 配置为虚拟机所在网段 设置外网 k8s node 安装系统安装 系统配置 修改网络配置 cd /etc/NetworkManager/system-connections [ipv4]# 修改为手动method=manual# 网关为ikuai网关address1=10.37.129.10/24,10.37.129.200dns=114.114.114.114;8.8.8.8 systemctl restart NetworkManager 替换 yum 源 sed -e s|^mirrorlist=|#mirrorlist=|g \\ -e s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g \\ -i.bak \\ /etc/yum.repos.d/[Rr]ocky-*.repodnf makecache 修改防火墙 # 防火墙修改 firewalld 为 iptablessystemctl stop firewalldsystemctl disable firewalldyum -y install iptables-servicessystemctl start iptablesiptables -Fsystemctl enable iptables 禁用 Selinux setenforce 0sed -i s/SELINUX=enforcing/SELINUX=disabled/g /etc/selinux/configgrubby --update-kernel ALL --args selinux=0# 查看是否禁用，grubby --info DEFAULT# 回滚内核层禁用操作，grubby --update-kernel ALL --remove-args selinux 同步系统时间 timedatectl set-timezone Asia/Shanghai# 安装并启动服务yum install chrony # CentOS/RHELapt install chrony # Debian/Ubuntusystemctl enable --now chronyd# 配置服务器（编辑 /etc/chrony.conf）echo server ntp.aliyun.com iburst /etc/chrony.conf# 重启服务并验证systemctl restart chronydchronyc tracking # 查看同步状态 关闭 swap 分区 swapoff -ased -i s:/dev/mapper/rl-swap:#/dev/mapper/rl-swap:g /etc/fstab 修改主机名 hostnamectl set-hostname k8s-node01 安装 ipvs yum install -y ipvsadm# 开启路由转发echo net.ipv4.ip_forward=1 /etc/sysctl.confsysctl -p# 加载 bridgeyum install -y epel-releaseyum install -y bridge-utilsmodprobe br_netfilterecho br_netfilter /etc/modules-load.d/bridge.confecho net.bridge.bridge-nf-call-iptables=1 /etc/sysctl.confecho net.bridge.bridge-nf-call-ip6tables=1 /etc/sysctl.confsysctl -p 修改 host vi /etc/hosts 10.37.129.10 k8s-node01 n110.37.129.11 k8s-node02 n210.37.129.12 k8s-node03 n310.37.129.13 harbor docker 安装 添加 docker-ce yum 源 # 官方源sudo dnf config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repocd /etc/yum.repos.d# 保留官方源mv docker-ce.repo docker-ce.repo.backcp docker-ce.repo.back docker-ce.repo# 清华大学源sed -i s+https://download.docker.com+https://mirrors.tuna.tsinghua.edu.cn/docker-ce+ /etc/yum.repos.d/docker-ce.repo 安装 docker-ce yum -y install docker-ce# 配置 daemon.cat /etc/docker/daemon.json EOF data-root: /data/docker, exec-opts: [native.cgroupdriver=systemd], log-driver: json-file, log-opts: max-size: 100m, max-file: 100 , insecure-registries: [harbor.xinxainghf.com], registry-mirrors: [https://kfp63jaj.mirror.aliyuncs.com]EOFmkdir -p /etc/systemd/system/docker.service.d# 重启docker服务systemctl daemon-reload systemctl restart docker systemctl enable dockerreboot 安装 cri-docker # 安装yum -y install wgetwget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.9/cri-dockerd-0.3.9.amd64.tgztar -xf cri-dockerd-0.3.9.amd64.tgzcp cri-dockerd/cri-dockerd /usr/bin/chmod +x /usr/bin/cri-dockerd# 配置cat EOF /usr/lib/systemd/system/cri-docker.service[Unit]Description=CRI Interface for Docker Application Container Engine Documentation=https://docs.mirantis.comAfter=network-online.target firewalld.service docker.serviceWants=network-online.targetRequires=cri-docker.socket[Service]Type=notifyExecStart=/usr/bin/cri-dockerd --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.8ExecReload=/bin/kill -s HUP $MAINPIDTimeoutSec=0RestartSec=2Restart=alwaysStartLimitBurst=3StartLimitInterval=60sLimitNOFILE=infinityLimitNPROC=infinityLimitCORE=infinityTasksMax=infinityDelegate=yesKillMode=process[Install]WantedBy=multi-user.targetEOF# 添加套接字cat EOF /usr/lib/systemd/system/cri-docker.socket[Unit]Description=CRI Docker Socket for the APIPartOf=cri-docker.service[Socket]ListenStream=%t/cri-dockerd.sockSocketMode=0660SocketUser=rootSocketGroup=docker[Install]WantedBy=sockets.targetEOF# 启动systemctl daemon-reload systemctl enable cri-dockersystemctl start cri-dockersystemctl is-active cri-docker k8s安装 添加 kubeadm yum 源 cat EOF /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://pkgs.k8s.io/core:/stable:/v1.29/rpm/enabled=1gpgcheck=1gpgkey=https://pkgs.k8s.io/core:/stable:/v1.29/rpm/repodata/repomd.xml.keyexclude=kubelet kubeadm kubectl cri-tools kubernetes-cniEOF 安装 kubeadm 1.29 版本 yum install -y kubelet-1.29.0 kubectl-1.29.0 kubeadm-1.29.0# 开机自启systemctl enable kubelet.service# 启动kubectlsystemctl start kubelet # 通过安装包安装tar -zxvf kubernetes-1.29.2-150500.1.1.tar.gz cd kubernetes-1.29.2-150500.1.1yum -y install *# 开机自启systemctl enable kubelet.service 初始化主节点 kubeadm init --token-ttl 0 --apiserver-advertise-address=10.37.129.10 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version 1.29.2 --service-cidr=10.10.0.0/12 --pod-network-cidr=10.244.0.0/16 --ignore-preflight-errors=all --cri-socket unix:///var/run/cri-dockerd.sock 初始化失败尝试重启swapoff -asystemctl restart kubelet #work token 过期后，重新申请kubeadm token create –print-join-command # 主节点执行mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config# 从节点执行kubeadm join 10.37.129.10:6443 --token ej812q.x2a3orlgqotbrixn --discovery-token-ca-cert-hash sha256:36edaf40ae66ab2c1a87f47ee212209c239377f8f879a9e24522750eb0a05083 --cri-socket unix:///var/run/cri-dockerd.sock 添加参数 -v2 可以查看执行情况报如下错误检查防火墙 安装网络插件 # 三个节点都要执行yum install -y unzipunzip calico.zip cd calicotar -zxvf calico-images.tar.gz cd calico-imagesdocker load -i calico-cni-v3.26.3.tardocker load -i calico-kube-controllers-v3.26.3.tar docker load -i calico-node-v3.26.3.tar docker load -i calico-typha-v3.26.3.tar # 主节点执行kubectl apply -f calico-typha.yaml","tags":[null],"categories":[null]},{"title":"Kubernetes简介","path":"/wiki/Kubernetes/Kubernetes简介.html","content":"基础设施的变革单机场景传统方式部署早期，各个组织是在物理服务器上运行应用程序。 由于无法限制在物理服务器中运行的应用程序资源使用，因此会导致资源分配问题。 例如，如果在同一台物理服务器上运行多个应用程序， 则可能会出现一个应用程序占用大部分资源的情况，而导致其他应用程序的性能下降。 一种解决方案是将每个应用程序都运行在不同的物理服务器上， 但是当某个应用程序资源利用率不高时，剩余资源无法被分配给其他应用程序， 而且维护许多物理服务器的成本很高。 机器硬件- 操作系统- 应用服务（n） 虚拟部署因此，虚拟化技术被引入了。虚拟化技术允许你在单个物理服务器的 CPU 上运行多台虚拟机（VM）。 虚拟化能使应用程序在不同 VM 之间被彼此隔离，且能提供一定程度的安全性， 因为一个应用程序的信息不能被另一应用程序随意访问。虚拟化技术能够更好地利用物理服务器的资源，并且因为可轻松地添加或更新应用程序， 而因此可以具有更高的可扩缩性，以及降低硬件成本等等的好处。 通过虚拟化，你可以将一组物理资源呈现为可丢弃的虚拟机集群。每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。 机器硬件- 操作系统- 虚拟机（n）- 应用服务（n） 容器部署容器类似于 VM，但是更宽松的隔离特性，使容器之间可以共享操作系统（OS）。 因此，容器比起 VM 被认为是更轻量级的。且与 VM 类似，每个容器都具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。 容器因具有许多优势而变得流行起来，例如： 敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。 持续开发、集成和部署：通过快速简单的回滚（由于镜像不可变性）， 提供可靠且频繁的容器镜像构建和部署。 关注开发与运维的分离：在构建、发布时创建应用程序容器镜像，而不是在部署时， 从而将应用程序与基础架构分离。 可观察性：不仅可以显示 OS 级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。 跨开发、测试和生产的环境一致性：在笔记本计算机上也可以和在云中运行一样的应用程序。 跨云和操作系统发行版本的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。 以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。 松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。 资源隔离：可预测的应用程序性能。 资源利用：高效率和高密度。 机器硬件- 操作系统- 容器- 应用服务（n） 优势： 资源效率： 轻量级：容器共享宿主操作系统的内核，不需要完整的操作系统，每个容器仅包含应用和其依赖。这使得容器比虚拟机更轻量，启动速度更快，资源占用更少。 资源利用率：由于容器更轻量，通常可以在同一台物理机器上运行更多的容器实例，而虚拟机则需要更多的计算资源和内存。 启动时间： 快速启动：容器的启动速度通常比虚拟机快得多。这是因为容器只需启动应用程序及其依赖，而虚拟机需要启动一个完整的操作系统。 部署一致性： 环境一致性：容器封装了应用及其所有依赖，确保在不同环境中（开发、测试、生产）具有一致的行为。这减少了因环境差异导致的问题。 管理和运维： 简化管理：容器可以通过容器编排工具（如 Kubernetes）来管理和部署，支持自动扩展、负载均衡和故障恢复。虚拟机的管理则相对复杂一些。 更好的开发体验：容器支持持续集成和持续交付（CICD），有助于提高开发效率和减少发布周期。 可移植性： 跨平台：容器可以在任何支持容器引擎的环境中运行，如不同的操作系统或云平台。这使得应用程序在不同环境之间的迁移变得更加容易。 版本控制： 镜像版本管理：容器镜像可以被版本控制和存储在镜像仓库中，这使得回滚到某个特定版本或使用不同版本的镜像变得简单。 缺点： 安全性： 内核共享：容器共享宿主操作系统的内核，这意味着如果容器化应用中存在漏洞，攻击者可能会利用这些漏洞获取宿主操作系统的控制权。这种共享内核的机制使得容器的隔离性相对较弱。 攻击面增大：容器技术的流行增加了攻击者对容器环境的兴趣。容器漏洞或配置错误可能会导致安全问题，如容器逃逸（container escape）等。 隔离性： 资源隔离：虽然容器在大多数情况下提供了足够的资源隔离，但与虚拟机相比，容器在资源隔离方面仍然有限。虚拟机通过完全虚拟化提供了更强的隔离性和安全性。 网络和存储隔离：容器在网络和存储方面的隔离可能不如虚拟机那样强，尤其是在复杂的网络设置或多租户环境中。 复杂性： 管理和编排：虽然容器编排工具（如 Kubernetes）可以提供强大的管理功能，但它们也引入了额外的复杂性。学习和配置这些工具需要额外的时间和资源。 持久化存储：容器本身是短暂的，虽然可以通过卷（volumes）来管理数据持久性，但容器的临时性和动态性使得持久化存储和数据管理更为复杂。 兼容性： 操作系统和内核版本：容器依赖宿主操作系统和内核的特性，某些操作系统或内核版本可能不完全支持容器的特定功能。这可能会限制某些应用程序的容器化能力。 应用兼容性：某些应用程序可能不适合在容器中运行，特别是那些需要对操作系统有特殊要求的应用程序。 调试和监控： 调试难度：容器的动态特性（如快速启动和销毁）可能使得调试和排错更加复杂。容器化环境中的故障排除可能需要额外的工具和技巧。 监控挑战：虽然现代工具可以监控容器，但容器环境的动态性和分布式特性可能使得监控和日志管理更加复杂。 集群场景-IAASIAAS（Infrastructure as a Service，基础设施即服务）是一种云计算服务模型，它提供了对计算资源、存储、网络和其他基础设施组件的虚拟化访问。这些资源可以通过互联网按需进行访问和管理，而无需用户购买和维护物理硬件。例如各种云服务提供厂商：阿里云、腾讯云、华为云。 集群场景-PAASPAAS（Platform as a Service，平台即服务）是一种云计算服务模型，提供了一个完整的平台，允许开发者在其上构建、测试、部署和维护应用程序，而无需管理底层的基础设施（如服务器、存储、网络和操作系统）。PAAS 简化了应用程序开发和管理的过程，使得开发者能够专注于应用逻辑和功能，而不是基础设施的管理。例如：Swarm、MESOS、Kubernetes Kubernetes 简介Kubernetes 是一个可移植、可扩展的开源平台，用于 管理容器化的工作负载和服务，方便进行声明式配置和自动化。 为什么需要 Kubernetes？容器是打包和运行应用程序的好方式。在生产环境中， 需要管理运行着应用程序的容器，并确保服务不会下线。 例如，如果一个容器发生故障，则需要启动另一个容器。 如果此行为交由给系统处理，是不是会更容易一些？ 这就是 Kubernetes 要来做的事情！ Kubernetes 提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移你的应用、提供部署模式等。 Kubernetes 功能 服务发现和负载均衡 Kubernetes 可以使用 DNS 名称或自己的 IP 地址来暴露容器。 如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。 存储编排 Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。 自动部署和回滚 你可以使用 Kubernetes 描述已部署容器的所需状态， 它可以以受控的速率将实际状态更改为期望状态。 例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。 自动分配 CPU内存资源 - 弹性伸缩 你为 Kubernetes 提供许多节点组成的集群，在这个集群上运行容器化的任务。 你告诉 Kubernetes 每个容器需要多少 CPU 和内存 (RAM)。 Kubernetes 可以将这些容器按实际情况调度到你的节点上，以最佳方式利用你的资源。 自我修复 Kubernetes 将重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器， 并且在准备好服务之前不将其通告给客户端。 密钥与配置管理 Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 SSH 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。 批处理执行 除了服务外，Kubernetes 还可以管理你的批处理和 CI（持续集成）工作负载，如有需要，可以替换失败的容器。 水平扩缩 使用简单的命令、用户界面或根据 CPU 使用率自动对你的应用进行扩缩。 IPv4IPv6 双栈 为 Pod（容器组）和 Service（服务）分配 IPv4 和 IPv6 地址。 为可扩展性设计 在不改变上游源代码的情况下为你的 Kubernetes 集群添加功能。 Kubernetes 组件Kubernetes 集群由 控制平面 和一个或多个 工作节点 组成。 Control Plane Components（控制平面）管理集群的整体状态 API Server：公开 Kubernetes HTTP API 的核心组件服务器。 Controller Manager：负责处理集群的常规任务和控制逻辑，如副本控制、节点控制、端点控制等。 Scheduler：负责将 Pod 分配到合适的节点上，基于资源需求、策略和其他约束条件。 etcd：一个分布式键值存储，用于保存和复制集群状态数据。 **cloud-controller-manager (可选)**：与底层云驱动集成 Node（工作节点）在每个节点上运行，维护运行的 Pod 并提供 Kubernetes 运行时环境 kubelet：一个在每个节点上运行的代理，负责管理 Pod 的生命周期和节点的健康状态。 Container Runtime：负责运行容器的组件（如 Docker、containerd 或 CRI-O）。 kube-proxy（可选）：实现服务代理和负载均衡，为 Pod 提供网络服务。 插件（Addons）插件扩展了 Kubernetes 的功能。一些重要的例子包括： DNS 集群范围内的 DNS 解析 Web 界面（Dashboard） 通过 Web 界面进行集群管理 容器资源监控 用于收集和存储容器指标 集群层面日志 用于将容器日志保存到中央日志存储 容器和Pod概念容器打包应用及其运行依赖环境的技术。容器将应用程序从底层的主机设施中解耦。 这使得在不同的云或 OS 环境中部署更加容易。 Kubernetes 集群中的每个 节点 都会运行容器， 这些容器构成分配给该节点的 Pod。 单个 Pod 中的容器会在共同调度下，于同一位置运行在相同的节点上。 Pause 容器‌Pause概念 ‌Pause 容器‌（又称 Infra 容器）是每个 Pod 最先启动的隐藏容器，负责创建并维持 Pod 级别的 Linux 命名空间（如网络、IPC 等）。 它不运行业务逻辑，仅执行 /pause 命令保持阻塞状态，占用资源极低（约 300KB 镜像）‌。 核心功能 ‌共享网络IPC 命名空间‌：确保同 Pod 内容器共享相同 IP、端口范围，可通过 localhost 直接通信‌（如 Nginx 容器与日志收集器通过本地端口直接交互）。 ‌僵尸进程回收‌：作为 PID 1 进程，负责回收子进程避免僵尸进程堆积‌。 ‌稳定性保障‌：即使业务容器崩溃，Pause 容器仍保持运行，维持 Pod 网络身份不变‌。 典型行为特征 特性 说明 镜像体积 仅约 300KB，仅运行阻塞式 /pause 命令‌ 资源占用 内存占用约 700KB，CPU 几乎无消耗‌ 生命周期 与 Pod 完全绑定，Pod 删除后自动终止 PodPod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。 Pod（就像在鲸鱼荚或者豌豆荚中）是一组（一个或多个） 容器； 这些容器共享存储、网络、以及怎样运行这些容器的规约。 Pod 中的内容总是并置的并且一同调度，在共享的上下文中运行。 Pod 所建模的是特定于应用的 “逻辑主机”，其中包含一个或多个应用容器， 这些容器相对紧密地耦合在一起。 用大白话给你解释 Kubernetes（k8s）里的容器和 Pod： ‌容器‌ —— 就像一个个 “小罐头” 每个罐头里打包了一个完整的应用（比如一个网站后台） 自带所有需要的配料（代码、环境、依赖库） 和冰箱其他罐头相互隔离（不会互相干扰） 轻巧便携，可以快速复制很多份 ‌Pod‌ —— 相当于 “罐头礼盒” 最小的可部署单元（k8s 不直接管单个罐头，只管礼盒） 一个礼盒里可以放： 单个主罐头（最常见） 多个需要紧密配合的罐头（比如主程序+日志收集器） 礼盒里的罐头们： 共用同一个收件地址（IP 地址） 可以互相访问 localhost 共享同一块临时存储空间 举个栗子 🌰： 你想部署一个网站，需要： 主程序容器（比如 Nginx） 日志收集容器（比如 Filebeat） 这俩容器就会被打包在同一个 Pod 里 它们可以共用日志文件，通过本地网络通信 关键区别： 容器是技术单元（实际运行的东西） Pod 是管理单元（k8s 调度的最小单位） 就像你不会单独邮寄一个罐头，总是整盒寄送 Pod 的设计让紧密协作的多个容器能像 “一个应用” 一样被管理。","tags":[null],"categories":[null]},{"path":"/wiki/Kubernetes/MySql.html","content":"namespaceOverride: devarchitecture: replicationauth: createDatabase: true database: dev_db rootPassword: 123456primary: service: type: NodePort persistence: storageClass: nfs-client size: 5Gi accessModes: - ReadWriteMany extraEnvVars: - name: TZ value: Asia/Shanghaisecondary: name: slave extraEnvVars: - name: TZ value: Asia/Shanghai service: type: NodePort replicaCount: 1 persistence: storageClass: nfs-client size: 5Gi accessModes: - ReadWriteMany helm repo add bitnami https://charts.bitnami.com/bitnami helm upgrade –install mysql bitnamimysql –namespace dev -f my-values.yaml docker run –name nacos-standalone -e MODEstandalone -p 8080:8080 -p 8848:8848 -p 9848:9848 -d nacosnacos-server:v2.3.2"},{"title":"Kubernetes Pod","path":"/wiki/Kubernetes/Pod的生命周期.html","content":"Pod的生命周期 init容器init容器概念Init 容器是一种特殊容器，在 Pod 内的应用容器启动之前运行。Init 容器可以包括一些应用镜像中不存在的实用工具和安装脚本。 每个 Pod 中可以包含多个容器， 应用运行在这些容器里面，同时 Pod 也可以有一个或多个先于应用容器启动的 Init 容器。 Init 容器与普通的容器非常像，除了如下两点： Init 容器总是运行到完成为止(返回码为0)。 每个 Init 容器都必须在下一个 Init 启动之前成功完成（如果有10个 Init 容器，第10个初始化失败则必须再从第一个重新开始初始化）。 如果 Pod 的 Init 容器失败，kubelet 会不断地重启该 Init 容器直到该容器成功为止。然而，如果 Pod 对应的 restartPolicy 值为 “Never”，并且 Pod 的 Init 容器失败， 则 Kubernetes 会将整个 Pod 状态设置为失败。 与普通容器区别 常规的 Init 容器（即不包括边车容器）不支持 lifecycle、livenessProbe、readinessProbe 或 startupProbe 字段。 Init 容器必须在 Pod 准备就绪之前完成运行；而边车容器在 Pod 的生命周期内继续运行， 它支持一些探针。 如果为一个 Pod 指定了多个 Init 容器，这些容器会按顺序逐个运行。 每个 Init 容器必须运行成功，下一个才能够运行。当所有的 Init 容器运行完成时， Kubernetes 才会为 Pod 初始化应用容器并像平常一样运行。 Init 容器与应用容器具备不同的镜像，可以把一些危险工具放在 Init 容器中。 Init 容器多个之间是线性启动的，可以执行一些延迟性的操作。 init容器阻塞示例apiVersion: v1kind: Podmetadata: name: initc-1 labels: app.kubernetes.io/name: initcspec: containers: - name: myapp-container image: busybox:1.28 command: [sh, -c, echo The app is running! sleep 3600] initContainers: - name: init-myservice image: busybox:1.28 command: [sh, -c, until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done] - name: init-mydb image: busybox:1.28 command: [sh, -c, until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done] 通过运行下面的命令启动 Pod： vi inti-1-pod.yamlkubectl apply -f inti-1-pod.yaml 使用下面的命令检查其状态： kubectl get pod 可以看到 myapp-pod 容器还未就绪。 查看 myapp-pod 状态。 kubectl describe pod myapp-pod 可以看到启动事件卡在启动 Init 容器，init-myservice 上。 查看 init-myservice 容器日志。 kubectl logs myapp-pod -c init-myservice 可以看到 init-myservice 容器一直在等待 myservice。 # 创建 servicekubectl create svc clusterip myservice --tcp=80:80# 查看 svckubectl get svc 可以看到 init-myservie 容器创建成功，现在在等待 init-mydb 容器创建。 kubectl create svc clusterip mydb --tcp=80:80 初始化容器都创建成功后，应用容器才开始创建。 init 容器返回示例apiVersion: v1kind: Podmetadata: name: myapp-pod labels: app.kubernetes.io/name: MyAppspec: containers: - name: myapp image: wangyanglinux/myapp:v1.0 initContainers: - name: randexit image: wangyanglinux/tools:randexitv1 args: [--exitcode=1] Init 容器返回码不为 0 时，会重新创建 Init 容器。 修改容器部署文件。 apiVersion: v1kind: Podmetadata: name: myapp-pod labels: app.kubernetes.io/name: MyAppspec: containers: - name: myapp image: wangyanglinux/myapp:v1.0 initContainers: - name: randexit image: wangyanglinux/tools:randexitv1 args: [--exitcode=0] 重新部署pod。 kubectl delete pod myapp-podkubectl apply -f inti-2-pod.yaml 探针诊断探针是由 kubelet 对容器进行的周期性检查。要执行诊断，kubelet 既可以在容器内执行代码，也可以发出一个网络请求。 exec在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。 grpc使用 gRPC 执行一个远程过程调用。目标应该实现 gRPC 健康检查。如果响应的状态是 “SERVING”，则认为诊断成功。 httpGet对容器的 IP 地址上指定端口和路径执行 HTTP GET 请求。如果响应的状态码大于等于 200 且小于 400，则诊断被认为是成功的。 tcpSocket对容器的 IP 地址上的指定端口执行 TCP 检查。如果端口打开，则诊断被认为是成功的。如果远程系统（容器）在打开连接后立即将其关闭，这算作是健康的。 注意：和其他机制不同，exec 探针的实现涉及每次执行时创建复制多个进程。因此，在集群中具有较高 pod 密度、较低的 initialDelaySeconds 和 periodSeconds 时长的时候，配置任何使用 exec 机制的探针可能会增加节点的 CPU 负载。这种场景下，请考虑使用其他探针机制以避免额外的开销。 每次探测结果会是以下三种之一： 成功：表示容器通过了检查。 失败：表示容器未通过检查。 未知：检查失败，因此不会执行任何操作。 探针类型针对运行中的容器，kubelet 可以选择是否执行以下三种探针，以及如何针对探测结果作出反应： livenessProbe指示容器是否正在运行。如果存活态探测失败，则 kubelet 会杀死容器，并且容器将根据其重启策略决定未来。如果容器不提供存活探针，则默认状态为 Success 成功：静默 失败：根据重启的策略进行重启的动作 未知：静默 readinessProbe指示容器是否准备好为请求提供服务。如果就绪态探测失败， EndpointSlice 控制器将从与该 Pod 匹配的所有 Service 的 EndpointSlice 中删除该 Pod 的 IP 地址。初始延迟之前的就绪态的状态值默认为 Failure。如果容器不提供就绪态探针，则默认状态为 Success。（如果 pod 内部的容器不添加就绪探测，则状态默认就绪。如果添加了就绪探测，只有就绪通过后，才标记修改为就绪状态。当前 pod 内所有的容器都就绪，才标记当前的 pod 就绪） 成功：将当前容器标记为就绪 失败：静默 未知：静默 startupProbe指示容器中的应用是否已经启动。如果提供了启动探针，则所有其他探针都会被禁用，直到此探针成功为止。如果启动探测失败，kubelet 将杀死容器，而容器依其重启策略进行重启。 如果容器没有提供启动探测，则默认状态为 Success。 成功：就绪探测开始执行 失败：超出探测时间会进行重启。 未知：静默 探针选项选项说明： initialDelaySeconds：容器启动后要等待多少秒后探针就开始工作，单位’秒’，默认是 0 秒， 最小值也是 0。 periodSeconds：执行探测的时间间隔（单位是秒），默认为 10 秒，最小值是 1。 timeoutSeconds：探针执行检测请求后，等待响应的超时时间（单位秒），默认为 1 秒，最小值是 1 秒。 successThreshold：探针检测后认为成功的最小连接成功次数，默认值为 1。必须为 1 才能激活和启动。最小值为 1。 failureThreshold：探测失败的重试次数，重试一定次数后将认为失败，默认值为 3，最小值为 1。 就绪探针测试# 创建两个 pod # 1-pod-demo.yamlapiVersion: v1kind: Podmetadata: name: pod-1 namespace: default labels: app: myappspec: containers: - name: myapp-1 image: wangyanglinux/myapp:v1.0# 2-pod-demo.yamlapiVersion: v1kind: Podmetadata: name: pod-2 namespace: default labels: app: myappspec: containers: - name: myapp-1 image: wangyanglinux/myapp:v1.0 # 创建 podkubectl apply -f 1-pod-demo.yaml kubectl apply -f 2-pod-demo.yaml # 创建 svc (service名称为 myapp 时默认绑定到中 labels 为 myapp 的 pod)kubectl create svc clusterip myapp --tcp=80:80kubectl get svc 可以看到请求被负载均衡到了 pod1 和 pod2, 此时创建 pod3。 apiVersion: v1kind: Podmetadata: name: readiness-httpget-pod namespace: default labels: app: myapp env: testspec: containers: - name: readiness-httpget-container image: wangyanglinux/myapp:v1.0 imagePullPolicy: IfNotPresent # 这里回去访问 index1.html 成功才会标记为就绪状态 readinessProbe: httpGet: port: 80 path: /index1.html initialDelaySeconds: 1 periodSeconds: 3 kubectl apply -f readiness-httpget-pod.yaml kubectl describe pod readiness-httpget-podcd /usr/local/nginx/htmlecho dao ci yi you index1.html 可以看到 pod 一直处于为就绪状态，请求也不会走到 pod3。 kubectl exec -it readiness-httpget-pod -c readiness-httpget-container -- /bin/bashcd /usr/local/nginx/htmlecho dao ci yi you index1.html 创建 index1.html 后 pod 就绪状态改为成功状态，请求也能够走到 pod3。就绪探测保证了提供给用户的服务时可用的。 其他检查方式： 基于 exec 方式 apiVersion: v1kind: Podmetadata: name: readiness-exec-pod namespace: defaultspec: containers: - name: readiness-exec-container image: wangyanglinux/tools:busybox imagePullPolicy: IfNotPresent command: [/bin/sh,-c,touch /tmp/live ; sleep 60; rm -rf /tmp/live;sleep 3600] readinessProbe: exec: command: [test,-e,/tmp/live] initialDelaySeconds: 1 periodSeconds: 3 基于 Tcp check 方式 apiVersion: v1kind: Podmetadata: name: readiness-tcp-podspec: containers: - name: readiness-exec-container image: wangyanglinux/myapp:v1.0 readinessProbe: initialDelaySeconds: 5 timeoutSeconds: 1 tcpSocket: port: 80 存活探针测试apiVersion: v1kind: Podmetadata: name: liveness-exec-pod namespace: defaultspec: containers: - name: liveness-exec-container image: wangyanglinux/tools:busybox imagePullPolicy: IfNotPresent # 启动时创建 /tmp/live 目录，睡眠 60s 删除 /tmp/live 再睡眠 3600 command: [/bin/sh,-c,touch /tmp/live ; sleep 60; rm -rf /tmp/live;sleep 3600] livenessProbe: exec: # 查看 /tmp/live 目录是否存在，不存在存活探测失败 command: [test,-e,/tmp/live] initialDelaySeconds: 1 periodSeconds: 3 可以看到 pod 重建了两次，当存活探针探测 pod 存活状态失败时，会将 pod 删除重建已达到自愈的目的，所以这里显示重启次数增加。 其他检查方式： 基于 HTTP Get 方式 apiVersion: v1kind: Podmetadata: name: liveness-httpget-pod namespace: defaultspec: containers: - name: liveness-httpget-container image: wangyanglinux/myapp:v1.0 imagePullPolicy: IfNotPresent ports: - name: http containerPort: 80 livenessProbe: httpGet: port: 80 path: /index.html initialDelaySeconds: 1 periodSeconds: 3 timeoutSeconds: 3 基于 TCP Check 方式 apiVersion: v1kind: Podmetadata: name: liveness-tcp-podspec: containers: - name: liveness-tcp-container image: wangyanglinux/myapp:v1.0 livenessProbe: initialDelaySeconds: 5 timeoutSeconds: 1 tcpSocket: port: 80 启动探针测试apiVersion: v1kind: Podmetadata: name: startupprobe-1 namespace: defaultspec: containers: - name: myapp-container image: wangyanglinux/myapp:v1.0 imagePullPolicy: IfNotPresent ports: - name: http containerPort: 80 readinessProbe: httpGet: port: 80 path: /index2.html initialDelaySeconds: 1 periodSeconds: 3 startupProbe: httpGet: path: /index1.html port: 80 failureThreshold: 30 periodSeconds: 10 应用程序将会有最多 5 分钟 failureThreshold periodSeconds（30 10 300s）的时间来完成其启动过程。如果在这个时间内还未探测成功，那么 k8s 会重建该 pod。 可以看到当前启动探测失败。 # 创建 /index1.html 文件kubectl exec -it startupprobe-1 /bin/bashcd /usr/local/nginx/html/echo hahaha index1.html 此时还处于未就绪状态，因为 index2.html 文件未创建。 kubectl exec -it startupprobe-1 /bin/bashcd /usr/local/nginx/html/echo gagaga index2.html 当 index2.html 文件创建成功后，就绪探测也成功了。 钩子Pod hook(钩子) 是由 Kubernetes 管理的 kubelet 发起的，当容器中的进程启动后或容器中的进程终止之前运行，这是包含在容器的生命周期之中。可以同时为 Pod 中的所有容器都配置 hook。 Hook 的类型包括两种： exec：执行一段命令 HTTP: 发送 HTTP 请求 apiVersion: v1kind: Podmetadata: name: lifecycle-httpget-pod labels: name: lifecycle-httpget-podspec: containers: - name: lifecycle-httpget-container image: wangyanglinux/myapp:v1.0 ports: - containerPort: 80 lifecycle: postStart: httpGet: # 替换自身IP host: 10.37.129.10 path: index.html port: 1234 preStop: httpGet: host: 10.37.129.10 path: hostname.html port: 1234 # 开启一个测试 webServerdocker run -it --rm -p 1234:80 wangyanglinux/myapp:v1.0kubectl apply -f lifecycle-httpget-pod.yaml 可以看到启动后钩子被执行： kubectl delete pod lifecycle-httpget-pod 可以看到停止前钩子被执行： exec Hook 示例： apiVersion: v1kind: Podmetadata: name: lifecycle-exec-podspec: containers: - name: lifecycle-exec-container image: wangyanglinux/myapp:v1 lifecycle: postStart: exec: command: [/bin/sh, -c, echo postStart /usr/share/message] preStop: exec: command: [/bin/sh, -c, echo preStop /usr/share/message] 整个生命周期示例目标：完成 pod 启动成功 apiVersion: v1kind: Podmetadata: name: lifecycle-pod labels: app: lifecycle-podspec: containers: - name: busybox-container image: wangyanglinux/tools:busybox command: [/bin/sh,-c,touch /tmp/live ; sleep 600; rm -rf / tmp/live; sleep 3600] # 存活探针 livenessProbe: exec: command: [test, -e, /tmp/live] initialDelaySeconds: 1 periodSeconds: 3 # 钩子 lifecycle: postStart: httpGet: # 替换自身IP host: 10.37.129.10 path: index.html port: 1234 preStop: httpGet: host: 10.37.129.10 path: hostname.html port: 1234 - name: myapp-container image: wangyanglinux/myapp:v1.0 livenessProbe: httpGet: port: 80 path: /index.html initialDelaySeconds: 1 periodSeconds: 3 timeoutSeconds: 3 # 就绪探针 readinessProbe: httpGet: port: 80 path: /index1.html initialDelaySeconds: 1 periodSeconds: 3 # 初始化容器 initContainers: - name: init-myservice image: wangyanglinux/tools:busybox command: [sh, -c, until nslookup myservice; do echo waiting for myservice; sleep 2; done;] - name: init-mydb image: wangyanglinux/tools:busybox command: [sh, -c, until nslookup mydb; do echo waiting for mydb; sleep 2; done;] kubectl apply -f lifecycle-httpget-pod.yaml kubectl create svc clusterip myservice --tcp=80:80kubectl create svc clusterip mydb --tcp=80:80docker run -it --rm -p 1234:80 wangyanglinux/myapp:v1.0kubectl exec -it lifecycle-pod -c myapp-container /bin/bashecho hahah index1.htmlexit Pod 调度流程","tags":[null],"categories":[null]},{"title":"Rancher安装","path":"/wiki/Kubernetes/Rancher安装.html","content":"Ingress-Nginx 安装# 添加 ingress-controllerhelm repo add ingress-nginx https://kubernetes.github.io/ingress-nginxhelm pull ingress-nginx/ingress-nginxtar -zxvf ingress-nginx-*tgzcd ingress-nginx# 修改 values.yaml 文件修改 hostNetwork 的值为 truereplicaCount的值修改为：2dnsPolicy的值改为: ClusterFirstWithHostNetkind类型更改为：DaemonSet关闭所有镜像的 digest修改admissionWebhooks:port:8444ingressClassResource.default=truekubectl create ns ingresshelm install ingress-nginx -n ingress . -f values.yaml # tls配置cd ~openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj /CN=nginxsvc/O=nginxsvckubectl create secret tls ingress-nginx-tls --key tls.key --cert tls.crt Rancher安装添加 Helm Chart 仓库执行 helm repo add 命令，以添加包含安装 Rancher 的 Chart 的 Helm Chart 仓库。有关如何选择仓库，以及哪个仓库最适合你的用例，请参见选择 Rancher 版本。 Latest：建议用于试用最新功能 helm repo add rancher-latest https://releases.rancher.com/server-charts/latest Stable：建议用于生产环境 helm repo add rancher-stable https://releases.rancher.com/server-charts/stable Alpha：即将发布的实验性预览。 helm repo add rancher-alpha https://releases.rancher.com/server-charts/alpha 注意：不支持升级到 Alpha 版、从 Alpha 版升级或在 Alpha 版之间升级。 为 Rancher 创建命名空间你需要定义一个 Kubernetes 命名空间，用于安装由 Chart 创建的资源。这个命名空间的名称为 cattle-system： kubectl create namespace cattle-system 选择 SSL 配置Rancher Management Server 默认需要 SSLTLS 配置来保证访问的安全性。 如果你想在外部终止 SSLTLS，请参见外部负载均衡器的 TLS 终止。 你可以从以下三种证书来源中选择一种，用于在 Rancher Server 中终止 TLS： Rancher 生成的 TLS 证书：要求你在集群中安装 cert-manager。Rancher 使用 cert-manager 签发并维护证书。Rancher 会生成自己的 CA 证书，并使用该 CA 签署证书。然后 cert-manager负责管理该证书。 Let’s Encrypt：Let’s Encrypt 选项也需要使用 cert-manager。但是，在这种情况下，cert-manager 与 Let’s Encrypt 的特殊颁发者相结合，该颁发者执行获取 Let’s Encrypt 颁发的证书所需的所有操作（包括请求和验证）。此配置使用 HTTP 验证（HTTP-01），因此负载均衡器必须具有可以从互联网访问的公共 DNS 记录。 你已有的证书：使用已有的 CA 颁发的公有或私有证书。Rancher 将使用该证书来保护 WebSocket 和 HTTPS 流量。在这种情况下，你必须上传名称分别为 tls.crt 和 tls.key的 PEM 格式的证书以及相关的密钥。如果你使用私有 CA，则还必须上传该 CA 证书。这是由于你的节点可能不信任此私有 CA。Rancher 将获取该 CA 证书，并从中生成一个校验和，各种 Rancher 组件将使用该校验和来验证其与 Rancher 的连接。 配置 Helm Chart 选项 是否需要 cert-manager Rancher 生成的证书（默认） ingress.tls.source=rancher 是 Let’s Encrypt ingress.tls.source=letsEncrypt 是 你已有的证书 ingress.tls.source=secret 否 安装 cert-manager 如果你使用自己的证书文件（ingress.tls.source=secret）或使用外部负载均衡器的 TLS 终止，你可以跳过此步骤。 仅在使用 Rancher 生成的证书（ingress.tls.source=rancher）或 Let’s Encrypt 颁发的证书（ingress.tls.source=letsEncrypt）时，才需要安装 cert-manager。 # 如果你手动安装了CRD，而不是在 Helm 安装命令中添加了 `--set installCRDs=true` 选项，你应该在升级 Helm Chart 之前升级 CRD 资源。#kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.18.2/cert-manager.crds.yaml# 添加 Jetstack Helm 仓库helm repo add jetstack https://charts.jetstack.io# 更新本地 Helm Chart 仓库缓存helm repo updatekubectl create namespace cert-managerhelm install cert-manager --namespace cert-manager --version v1.18.2 --set crds.enabled=true jetstack/cert-manager 根据你选择的证书选项，通过 Helm 安装 Rancher不同的证书配置需要使用不同的 Rancher 安装命令。 默认情况是使用 Rancher 生成 CA，并使用 cert-manager 颁发用于访问 Rancher Server 接口的证书。 由于 rancher 是 ingress.tls.source 的默认选项，因此在执行 helm install 命令时，我们不需要指定 ingress.tls.source。 将 hostname 设置为解析到你的负载均衡器的 DNS 名称。 将 bootstrapPassword 设置为 admin 用户独有的值。 如果你需要安装指定的 Rancher 版本，使用 --version 标志，例如 --version 2.7.0。 # 添加 ingress-controllerhelm repo add ingress-nginx https://kubernetes.github.io/ingress-nginxhelm pull ingress-nginx/ingress-nginxcd ingress-nginx# 修改 values.yaml 文件修改 hostNetwork 的值为 truereplicaCount的值修改为：2dnsPolicy的值改为: ClusterFirstWithHostNetkind类型更改为：DaemonSet关闭所有镜像的 digestingressClassResource.default=truekubectl create ns ingresshelm install ingress-nginx -n ingress . -f values.yaml # 添加域名到host文件10.37.129.11 www1.k8s.com # ‌如上报错需要重新创建 Webhook 证书‌kubectl delete secret -n ingress-nginx ingress-nginx-admissionkubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/cloud/deploy.yaml# ‌验证 Webhook 服务‌kubectl get validatingwebhookconfigurations ingress-nginx-admission -o yaml确认配置中存在有效的 clientConfig 和服务端点# 安装 rancherhelm install rancher rancher-stable/rancher \\ --namespace cattle-system \\ --set hostname=rancher.dev.com \\ --set bootstrapPassword=admin \\ --set ingress.tls.source=letsEncrypt \\ --set letsEncrypt.email=me@example.org \\ --set letsEncrypt.ingress.class=nginx \\ --set ingress.ingressClassName=nginx 验证 Rancher Server 是否部署成功添加密文后，检查 Rancher 是否已成功运行： kubectl -n cattle-system rollout status deploy/rancherWaiting for deployment rancher rollout to finish: 0 of 3 updated replicas are available...deployment rancher successfully rolled out 如果你看到 error: deployment rancher exceeded its progress deadline 这个错误，可运行以下命令来检查 deployment 的状态： kubectl -n cattle-system get deploy rancherNAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGErancher 3 3 3 3 3mecho 10.37.129.10 rancher.my.org /etc/hosts DESIRED 和 AVAILABLE的个数应该相同。 kubectl -n cattle-system exec $(kubectl -n cattle-system get pods -l app=rancher | grep 1/1 | head -1 | awk print $1 ) -- reset-password helm repo add harbor https://helm.goharbor.io","tags":[null],"categories":[null]},{"title":"Kubernetes Service","path":"/wiki/Kubernetes/Service.html","content":"ServiceService概念Kubernetes 中 Service 是 将运行在一个或一组 Pod 上的网络应用程序公开为网络服务的方法。 Kubernetes 中 Service 的一个关键目标是让你无需修改现有应用以使用某种不熟悉的服务发现机制。 你可以在 Pod 集合中运行代码，无论该代码是为云原生环境设计的，还是被容器化的老应用。 你可以使用 Service 让一组 Pod 可在网络上访问，这样客户端就能与之交互。 如果你使用 Deployment 来运行你的应用， Deployment 可以动态地创建和销毁 Pod。 在任何时刻，你都不知道有多少个这样的 Pod 正在工作以及它们健康与否； 你可能甚至不知道如何辨别健康的 Pod。 Kubernetes Pod 的创建和销毁是为了匹配集群的预期状态。 Pod 是临时资源（你不应该期待单个 Pod 既可靠又耐用）。 每个 Pod 会获得属于自己的 IP 地址（Kubernetes 期待网络插件来保证这一点）。 对于集群中给定的某个 Deployment，这一刻运行的 Pod 集合可能不同于下一刻运行该应用的 Pod 集合。 这就带来了一个问题：如果某组 Pod（称为“后端”）为集群内的其他 Pod（称为“前端”） 集合提供功能，前端要如何发现并跟踪要连接的 IP 地址，以便其使用负载的后端组件呢？ Service API 是 Kubernetes 的组成部分，它是一种抽象，帮助你将 Pod 集合在网络上公开出去。 每个 Service 对象定义端点的一个逻辑集合（通常这些端点就是 Pod）以及如何访问到这些 Pod 的策略。 核心工作原理kube-proxy: 监听 apiServer 将 Service 变化修改本地 iptables 规则iptablesipvs: 负责转发用户请求流量 Iptables Ipvs # 修改为ipvs# 注意系统要支持 ipvskubectl edit configmap kube-proxy -n kube-systemkubectl delete pod -n kube-system -l k8s-app=kube-proxy ‌编辑kube-proxy配置‌： 命令：kubectl edit configmap kube-proxy -n kube-system 解释：此命令用于编辑kube-system命名空间中的kube-proxy ConfigMap，通常用于更改kube-proxy的工作模式。 ‌设置kube-proxy模式为ipvs‌： 在编辑界面中，将mode字段设置为ipvs。 解释：ipvs模式是高性能的IP负载均衡模式，适用于大规模集群。 ‌删除kube-proxy Pod‌： 命令：kubectl delete pod -n kube-system -l k8s-app=kube-proxy 解释：此命令用于删除kube-system命名空间中所有标签为k8s-app=kube-proxy的Pod，以便应用新的配置。 Service类型Kubernetes Service 的类型主要包括以下几种： ‌ClusterIP‌：这是默认类型，仅集群内部可以访问，通过自动分配的虚拟IP进行通信。 ‌NodePort‌：在 ClusterIP 的基础上，为每台机器绑定一个端口，可以通过 NodeIP:NodePort 的方式访问服务。 ‌LoadBalancer‌：在 NodePort 的基础上，借助云提供商创建一个外部负载均衡器，将外部请求转发到 NodeIP:NodePort。 ‌ExternalName‌：此类型将集群外部的服务引入到集群内部，集群内部可以直接使用这些服务，但需 Kubernetes 1.7 或更高版本的 kube-dns 支持。 Service类型模式详解以下是Kubernetes Service的四种核心模式详解及其应用场景： ClusterIP（默认类型）‌核心机制‌ 分配集群内部虚拟IP（VIP），仅允许‌集群内访问‌。 通过kube-proxy维护动态路由规则（iptablesIPVS实现）。 自动负载均衡到关联Pod（通过Label Selector匹配）‌。 ‌典型场景‌ 微服务间内部通信（如前端调用后端API）。 数据库服务暴露给应用层。 优势：安全隔离，无需暴露外部端口‌ NodePort‌三层扩展架构‌ graph LRA[外部请求] -- B(NodeIP:30000-32767端口)B -- C[ClusterIP虚拟IP]C -- D[后端Pod] ‌核心特性‌ 在ClusterIP基础上，‌每个Node开放静态端口‌（默认30000-32767）。 外部通过任意NodeIP:NodePort访问服务。 需手动管理防火墙规则‌。 ‌运维场景‌ 开发测试环境临时访问。 不支持LoadBalancer的本地集群。 LoadBalancer（云服务增强）‌工作流程‌ 创建Service时自动申请云平台负载均衡器。 负载均衡器将流量导向所有Node的NodePort。 NodePort转发至ClusterIP再到Pod‌。 ‌云服务差异‌ 云平台 实现特性 AWS 自动创建NLB并配置安全组 GCP 集成健康检查与全球负载均衡 Azure 支持公网内网负载均衡器双模式 局限：依赖云厂商，本地集群无法直接使用‌ 本地使用 keepaliveipvs: 云服务： ExternalName（跨集群服务接入）‌特殊实现机制‌ 创建CNAME记录指向外部域名（无IP分配） 依赖kube-dns 1.7+版本解析 示例配置： kind: Servicespec: type: ExternalName externalName: external-api.example.com ‌典型用例‌ 安全访问云数据库服务（如RDS） 集成遗留系统无需服务发现改造 注意：不提供负载均衡与代理功能‌ Service 实验clusterIpmyapp-clusterip-deploy.yaml apiVersion: apps/v1kind: Deploymentmetadata: name: myapp-clusterip-deploy namespace: defaultspec: replicas: 3 selector: matchLabels: app: myapp release: stabel svc: clusterip template: metadata: labels: app: myapp release: stabel env: test svc: clusterip spec: containers: - name: myapp-container image: wangyanglinux/myapp:v1.0 imagePullPolicy: IfNotPresent ports: - name: http containerPort: 80 readinessProbe: httpGet: port: 80 path: /index1.html initialDelaySeconds: 1 periodSeconds: 3 myapp-service.yaml apiVersion: v1kind: Servicemetadata: name: myapp-clusterip namespace: defaultspec: type: ClusterIP selector: app: myapp release: stabel svc: clusterip ports: - name: http port: 80 targetPort: 80 当开始创建 pod 和 Service 时，可以看到 pod 未就绪的状态下是不会加入 Service, 当创建 index1.html 后 pod 就绪，Service 可以转发到就绪的 pod 下。 在 myapp-clusterip-deploy-5c9cc9b64-hk69z 容器中添加 index1.html 并修改 index.html 为 v2。 使用域名访问Service#在集群k8s内部使用DNS解析域名svcName.nameSpaceName.svc.domainname.domainName集群默认域名是：cluster.local.示例：myapp-clusterip.default.svc.cluster.local. 持久化链接在Kubernetes中，service.spec.sessionAffinity: ClientIP 参数用于配置服务的会话保持机制。以下是详细说明和操作方法： 作用与原理 核心功能 ‌会话保持‌：将来自同一客户端IP的请求‌持续路由到同一个后端Pod‌ ‌解决有状态服务问题‌：适用于需要保持会话的应用（如登录会话、文件上传等场景） ‌工作流程‌ sequenceDiagram participant Client participant Service participant Pod1 participant Pod2 Client-Service: 请求1 (IP:192.168.1.10) Service-Pod1: 转发请求1 → 记录IP与Pod映射 Client-Service: 请求2 (IP:192.168.1.10) Service-Pod1: 再次转发到相同Pod Note right of Service: 同一IP的后续请求br/固定路由到Pod1 Client-Service: 新客户端请求 (IP:192.168.1.20) Service-Pod2: 首次请求分配新Pod ‌与默认模式对比‌ 模式 请求分发策略 适用场景 sessionAffinity: None (默认) 轮询随机负载均衡 无状态服务 sessionAffinity: ClientIP 基于源IP固定路由 有状态会话需求 配置参数详解 ‌核心参数‌ spec: sessionAffinity: ClientIP # 必需参数 sessionAffinityConfig: clientIP: timeoutSeconds: 10800 # 会话保持时间（秒） ‌超时机制‌ ‌timeoutSeconds‌：会话保持的有效期（默认值10800秒 3小时） 超过该时间未收到相同IP的请求，映射关系自动清除 设置为0表示永不过期（不推荐） 注意事项 ‌网络层依赖‌： 客户端真实IP必须能传递到Service（配置externalTrafficPolicy: Local） NodePortLoadBalancer类型需配置云厂商的保留客户端IP选项 ‌局限性‌： 不支持基于Cookie的会话保持 NAT网络下多个客户端可能共享相同公网IP（导致流量集中） ‌性能影响‌： 大规模集群中IP映射表可能占用内存 建议配合sessionAffinityConfig.timeoutSeconds设置合理超时 💡 ‌最佳实践‌：需要精确会话保持时，建议在应用层实现（如JWTCookie），该参数仅作为网络层辅助方案。 sessionAffinity 实验kubectl edit svc myapp-clusterip 再通过 Service 访问时，会一直转发到一个 pod。 internalTrafficPolicy 实验 ‌命令功能‌：该命令用于解释 Kubernetes 服务（Service）资源规格（spec）中的 internalTrafficPolicy 字段。 ‌字段含义‌：internalTrafficPolicy 描述了节点如何分发它们在 ClusterIP 上接收到的服务流量。 ‌枚举值‌： ‌Cluster：默认值，流量会均匀路由到服务的所有端点，可能受拓扑和其他功能的影响。 ‌Local：流量仅路由到与客户端 Pod 在同一节点上的服务端点，若无本地端点则丢弃流量。 ‌应用场景‌：根据实际需求选择合适的策略，以优化服务访问效率和资源利用。 kubectl edit svc myapp-clusterip 就绪的 pod 运行在 node02和node03节点上。 此时在node01节点访问 Service 此流量会被丢弃。 在 node02和node03上访问 Service 时也只会到本地节点的 pod 上。 NodePort实验apiVersion: apps/v1kind: Deploymentmetadata: name: myapp-nodeport-deploy namespace: defaultspec: replicas: 3 selector: matchLabels: app: myapp release: stabel svc: nodeport template: metadata: labels: app: myapp release: stabel env: test svc: nodeport spec: containers: - name: myapp-container image: wangyanglinux/myapp:v1.0 imagePullPolicy: IfNotPresent ports: - name: http containerPort: 80 apiVersion: v1kind: Servicemetadata: name: myapp-nodeport namespace: defaultspec: type: NodePort selector: app: myapp release: stabel svc: nodeport ports: - name: http port: 80 targetPort: 80 nodePort: 30010 #可以不指定由k8s集群配置 kubectl apply -f myapp-nodeport-deploy.yaml kubectl apply -f myapp-nodeport-service.yaml 使用 Service 能够正常调用。 在外部使用节点ip+端口也能正常访问。 externalTrafficPolicy 实验 ‌作用‌：该命令用于解释 Kubernetes 服务（Service）规格（spec）中的 externalTrafficPolicy 字段。 ‌字段含义‌：externalTrafficPolicy 描述了节点如何分发它们接收到的服务流量，这些流量来自服务的“外部面向”地址（如 NodePorts、ExternalIPs 和 LoadBalancer IPs）。 ‌可选值‌： ‌Cluster‌：默认值，表示流量会均匀路由到服务的所有端点。 ‌Local‌：流量仅路由到接收流量的节点上的本地端点，不伪装客户端源 IP。若发送到没有端点的节点，流量将被丢弃。 ‌注意事项‌： 集群内部发送到 External IP 或 LoadBalancer IP 的流量始终遵循 “Cluster” 语义。 集群内部发送到 NodePort 的客户端在选择节点时可能需要考虑流量策略。 kubectl edit svc myapp-nodeport 此时外部流量只能访问到本节点上的 pod。 ExternalName 实验 ‌核心功能‌ 创建一种特殊类型的 Service，通过 ‌DNS CNAME 记录‌将 Kubernetes 集群内部的服务名称映射到外部域名（如第三方 API、数据库等），实现跨集群访问外部服务的透明代理。 ‌工作原理‌ ‌DNS 重定向‌：当集群内应用访问该 Service 时，Kubernetes DNS 返回 externalName 字段指定的外部域名（如 external-service.example.com）的 CNAME 记录，而非 ClusterIP。 ‌无代理负载均衡‌：不同于其他 Service 类型，ExternalName 不创建代理、负载均衡器或 Endpoints，仅通过 DNS 机制转发请求。 ‌主要用途‌ ‌集成外部服务‌：将集群内应用与外部服务（如云数据库、第三方 API）解耦，避免硬编码外部地址。 ‌简化地址迁移‌：若外部服务地址变更，只需更新 externalName 字段，无需重启应用。 ‌跨命名空间环境‌：访问其他 Namespace 的服务（需目标服务支持）或混合云环境的外部资源。 ‌关键特性‌ ‌特性‌ ‌说明‌ ‌无负载均衡‌ 不提供流量分发或健康检查，依赖外部服务的可用性。 ‌配置简化‌ 仅需声明 type: ExternalName 和 externalName: 目标域名。 ‌集群内部访问‌ 只能通过 Kubernetes 集群内部的 DNS 名称访问该服务。 ‌注意事项‌ ‌协议限制‌：不指定端口或协议，需确保外部服务兼容 DNS 解析机制。 ‌安全性‌：依赖外部服务的安全策略（如 TLS防火墙），不提供 Kubernetes 网络策略支持。 ‌总结‌：ExternalName 本质是 DNS 别名，适用于透明桥接集群内外服务，但需明确其无代理、无负载均衡的特性限制。 kind: ServiceapiVersion: v1metadata: name: my-service-1 namespace: defaultspec: type: ExternalName externalName: www.baidu.com kubectl apply -f my-ExternalName.yaml kubectl get svckubectl exec -it myapp-nodeport-deploy-685dcc6ddf-fzjcf bin/bashping my-service-1.default.svc.cluster.local. EndpointsKubernetes 中的 Service 定义了一组 Pods 的逻辑集合及一个用户访问它们的策略。一个 Service 的目标 Pod 集合通常由 Label Selector 决定。 Endpoints是一组实际服务的端点集合，每个 Endpoint 代表一个可访问的服务端点，即状态为 running 的 Pod 的可访问端点。 一般 Pod 都不是一个独立的存在，所以一组 Pod 的端点合在一起称为 EndPoints。只有被 Service Selector 匹配且状态为 Running 的 Pod，才会被加入到与 Service 同名的Endpoints中，形成一组 Pod 的端点集合。 Endpoint 的工作机制graph LRA[Service] -- B(Endpoint)B -- C[Pod 1br192.168.1.2:80]B -- D[Pod 2br192.168.1.3:80]B -- E[Pod 3br192.168.1.4:80] 自动创建‌：当 Service 定义了 selector（如app: nginx）时，Kubernetes 自动。 监控匹配该标签的 Pod 将 Pod 的 IP 和端口填充到 Endpoint 对象 ‌流量转发‌：Service 接收到请求后，根据负载均衡策略（如轮询）将流量分发到 Endpoint 中的 Pod。 Endpoint 的核心价值 ‌服务发现‌Pod 可通过 Service 名称访问后端，无需感知具体 IP 变化。 ‌动态更新‌当 Pod 扩缩容或重启时，Endpoint 自动更新地址列表（例如新 Pod IP 自动加入）。 ‌解耦架构‌应用只需访问 Service 名称，流量路由由 Endpoint 机制透明处理。 ‌混合云集成‌通过手动配置 Endpoint，可将集群内服务与外部系统（如传统数据库）无缝连接。 与 ExternalName 的区别 ‌特性‌ ‌Endpoint‌ ‌ExternalName Service‌ ‌目标类型‌ Pod 或外部 IP 外部域名 (CNAME 记录) ‌DNS 解析‌ 返回 Service 的 ClusterIP 直接返回外部域名 ‌配置方式‌ 自动生成或手动定义 Endpoint 对象 仅需在 Service 中设置 externalName ‌流量路径‌ 经过 kube-proxy 转发 纯 DNS 重定向，无代理 ‌适用场景‌ 集群内 Pod 或混合云环境 简单域名映射 Endpoint实验自动关联（配置 selector）apiVersion: apps/v1kind: Deploymentmetadata: name: myapp-clusterip-deploy namespace: defaultspec: replicas: 3 selector: matchLabels: app: myapp release: stabel svc: clusterip template: metadata: labels: app: myapp release: stabel env: test svc: clusterip spec: containers: - name: myapp-container image: wangyanglinux/myapp:v1.0 imagePullPolicy: IfNotPresent ports: - name: http containerPort: 80 readinessProbe: httpGet: port: 80 path: /index1.html initialDelaySeconds: 1 periodSeconds: 3 apiVersion: v1kind: Servicemetadata: name: myapp-clusterip namespace: defaultspec: type: ClusterIP selector: app: myapp release: stabel svc: clusterip ports: - name: http port: 80 targetPort: 80 kubectl apply -f myapp-clusterip-deploy.yaml kubectl apply -f myapp-service.yaml 可以看到创建 Service 时，自动创建了同名的 Endpoint。因为 Pod 未就绪所以 Pod ip 还未计入到该端点下。 kubectl exec -it myapp-clusterip-deploy-5c9cc9b64-5jg56 bin/bashecho haha /usr/local/nginx/html/index1.htmlkubectl exec -it myapp-clusterip-deploy-5c9cc9b64-67kbq bin/bashecho haha /usr/local/nginx/html/index1.html 可以看到当 Pod 就绪后，Pod IP 自动加入到了 Endpoint 中。 手动关联（无配置 selector）apiVersion: v1kind: Servicemetadata: name: nginx-noselectspec: ports: - protocol: TCP port: 6666 targetPort: 80 apiVersion: v1kind: Endpointsmetadata: # 这个名字要与创建的 Service 命名相同 name: nginx-noselectsubsets: - addresses: # node2 节点 IP - ip: 10.37.129.11 ports: - port: 80 如果 Endpoint 需要跟踪多个 ip (多个 pod 或者容器或者应用)，可以使用: - addresses: - ip: 172.17.0.2 - ip: 172.17.0.3 - ip: 172.17.0.4 ... ... kubectl apply -f service-noselect.yaml kubectl apply -f endpoints-noselect.yaml # 在 node2 节点执行docker run -itd -p 80:80 --net host wangyanglinux/myapp:v1 将 nginx 在 node2 节点启动后，此时可以访问。 访问未就绪的 PodapiVersion: v1kind: Podmetadata: name: readiness-httpget-pod namespace: default labels: app: myapp env: testspec: containers: - name: readiness-httpget-container image: wangyanglinux/myapp:v1.0 imagePullPolicy: IfNotPresent readinessProbe: httpGet: port: 80 path: /index1.html initialDelaySeconds: 1 periodSeconds: 3 apiVersion: v1kind: Servicemetadata: labels: app: myapp name: myappspec: ports: - name: 80-80 port: 80 protocol: TCP targetPort: 80 selector: app: myapp type: ClusterIP 此时无法访问。 kubectl patch service myapp -p spec:publishNotReadyAddresses: true 添加 publishNotReadyAddresses:ture 配置后。该配置使得 Service 能够抓取到为就绪的 Pod。","tags":[null],"categories":[null]},{"title":"Loki安装","path":"/wiki/Kubernetes/loki安装.html","content":"Loki简介Loki是由Grafana Labs开发的开源日志聚合系统，专为云原生环境设计。它的核心特点包括： ‌轻量高效‌：不对日志内容进行全文索引，而是通过标签(与Prometheus相同的标签系统)来索引日志流，大幅降低存储需求。 ‌云原生优化‌：特别适合 Kubernetes 环境，能自动处理 Pod 标签等元数据。 ‌经济实惠‌：相比传统日志系统(如ELK)，存储成本显著降低。 ‌与Grafana深度集成‌：可直接在Grafana中查询日志，无需切换工具。 Loki主要由三个组件构成： ‌Loki‌：主服务器，负责日志存储和查询。 ‌Promtail‌：日志收集代理，负责采集日志并发送给Loki。 ‌Grafana‌：用于日志查询和展示的UI界面。 安装tar -zxvf loki-stack-2.9.11-wangyang.xinxianghf.tgzcd loki-stack/ # 查看 docker 数据存储路径cat /etc/docker/daemon.json values-pre.yaml # 这部分配置启用了Loki的持久化存储功能，使用NFS作为后端存储，分配2GB空间。ReadWriteOnce模式适合Loki的单节点读写场景。loki: enabled: true # 启用Loki组件 persistence: enabled: true # 启用持久化存储 accessModes: - ReadWriteOnce # 单节点读写访问模式 size: 5Gi # 分配5GB存储空间 storageClassName: nfs-client # 使用NFS存储类# Promtail配置了从主机收集容器日志的路径，包括Docker容器日志(/var/lib/docker/containers)和Kubernetes Pod日志(/var/log/pods)promtail: enabled: true # 启用Promtail日志收集器 defaultVolumes: # 定义主机路径卷 - name: run hostPath: path: /run/promtail - name: containers hostPath: path: /var/lib/docker/containers - name: pods hostPath: path: /var/log/pods defaultVolumeMounts: # 定义容器挂载点 - name: run mountPath: /run/promtail - name: containers mountPath: /var/lib/docker/containers readOnly: true # 只读模式挂载 - name: pods mountPath: /var/log/pods readOnly: true# Grafana同样配置了持久化存储，确保仪表板配置和用户数据不会丢失。与Loki使用相同的NFS存储类便于统一管理grafana: enabled: true # 启用Grafana persistence: enabled: true # 启用持久化存储 accessModes: - ReadWriteOnce # 单节点读写访问模式 size: 5Gi # 分配5GB存储空间 storageClassName: nfs-client # 使用NFS存储类 # 安装kubectl create namespace lokihelm install loki -n loki -f values-pre.yaml . loki-ingress.yaml apiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: grafana namespace: lokispec: ingressClassName: nginx rules: - host: grafana.dev.com http: paths: - path: / pathType: Prefix backend: service: name: loki-grafana port: number: 80 # 安装 ingresskubectl apply -f loki-ingress.yaml -n loki# 添加域名到 hosts# 查询密码kubectl get secret loki-grafana -n loki -o yamlecho VUVNZ1BJU2hVeDdsOXBRR0U2MDVqTE5KTVMyZFp5Y0FzRkR2TEdtNg== | base64 -d","tags":[null],"categories":[null]},{"title":"Kubernetes 二进制安装","path":"/wiki/Kubernetes/二进制安装.html","content":"k8s二进制安装节点环境初始化系统安装参考 Kubernetes 安装 - 虚拟机安装 镜像下载# 官方下载地址https://rockylinux.org/download# 阿里云镜像下载地址https://mirrors.aliyun.com/rockylinux/9/isos/x86_64/?spm=a2c6h.25603864.0.0.29696621VzJej5 环境配置(所有节点)# 网卡配置# cat /etc/NetworkManager/system-connections/enp0s5.nmconnection[ipv4]method=manualaddress1=10.37.129.10/24,10.37.129.200dns=114.114.114.114;8.8.8.8# 重启网络配置systemctl restart NetworkManagerreboot # 修改主机名和解析hostnamectl set-hostname k8s-master01hostnamectl set-hostname k8s-node01# cat /etc/hosts10.37.129.10 k8s-master01 m110.37.129.11 k8s-master02 m210.37.129.12 k8s-master03 m310.37.129.13 k8s-node01 n110.37.129.14 k8s-node02 n2# Rocky 系统软件源更换sed -e s|^mirrorlist=|#mirrorlist=|g \\ -e s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g \\ -i.bak \\ /etc/yum.repos.d/[Rr]ocky*.repodnf makecache# 防火墙修改 firewalld 为 iptablessystemctl stop firewalldsystemctl disable firewalldyum -y install iptables-servicessystemctl start iptablesiptables -Fsystemctl enable iptables# 禁用 Selinuxsetenforce 0sed -i s/SELINUX=enforcing/SELINUX=disabled/g /etc/selinux/configgrubby --update-kernel ALL --args selinux=0# 查看是否禁用，grubby --info DEFAULT# 回滚内核层禁用操作，grubby --update-kernel ALL --remove-args selinux# 设置时区timedatectl set-timezone Asia/Shanghai# 关闭 swap 分区swapoff -ased -i s:/dev/mapper/rl-swap:#/dev/mapper/rl-swap:g /etc/fstabfree -m # 查看内存信息# 安装 ipvsyum install -y ipvsadm# 开启路由转发echo net.ipv4.ip_forward=1 /etc/sysctl.confsysctl -p# 安装必备的工具包yum update -y yum -y install wget psmisc vim net-tools nfs-utils telnet yum-utils device-mapper-persistent-data lvm2 git tar curl # 排除 calico 网卡被 NetworkManager 所管理cat /etc/NetworkManager/conf.d/calico.conf EOF [keyfile]unmanaged-devices=interface-name:cali*;interface-name:tunl*EOFsystemctl restart NetworkManager#这个参数用于指定不由 NetworkManager 管理的设备。它由以下两个部分组成:#interface-name:cali*#表示以 cali 开头的接口名称被排除在 NetworkManager 管理之外。例如，cali0, cali1 等接口不受 NetworkManager 管理#interface-name:tunl*#表示以 tunl 开头的接口名称被排除在 NetworkManager 管理之外。例如，tunl0, tunl1 等接口不受 NetworkManager 管理#通过使用这个参数，可以将特定的接口排除在 NetworkManager 的管理范围之外，以便其他工具或进程可以独立地管理和配置这些接口 # 时间同步配置# 服务端(m1、m2、m3节点)yum install chrony -ycat /etc/chrony.conf EOF pool ntp.aliyun.com iburstdriftfile /var/lib/chrony/driftmakestep 1.0 3rtcsyncallow 10.37.129.0/24local stratum 10keyfile /etc/chrony.keysleapsectz right/UTClogdir /var/log/chronyEOFsystemctl restart chronydsystemctl enable chronyd# 客户端(n1、n2节点)yum install chrony -ycat /etc/chrony.conf EOF pool 10.37.129.10 iburstpool 10.37.129.11 iburstpool 10.37.129.12 iburstdriftfile /var/lib/chrony/driftmakestep 1.0 3rtcsynckeyfile /etc/chrony.keysleapsectz right/UTClogdir /var/log/chronyEOFsystemctl restart chronyd systemctl enable chronyd#使用客户端进行验证chronyc sources -v # 配置 ulimitulimit -SHn 65535cat /etc/security/limits.conf EOF* soft nofile 655360* hard nofile 131072* soft nproc 655350* hard nproc 655350* seft memlock unlimited* hard memlock unlimiteddEOF # 安装 ipvsyum install ipvsadm ipset sysstat conntrack libseccomp -ycat /etc/modules-load.d/ipvs.conf EOF ip_vsip_vs_rrip_vs_wrrip_vs_shnf_conntrackip_tablesip_setxt_setipt_setipt_rpfilteript_REJECTipipEOFsystemctl restart systemd-modules-load.servicelsmod | grep -e ip_vs -e nf_conntrack# 修改内核参数cat EOF /etc/sysctl.d/k8s.confnet.ipv4.ip_forward = 1net.bridge.bridge-nf-call-iptables = 1fs.may_detach_mounts = 1vm.overcommit_memory=1vm.panic_on_oom=0fs.inotify.max_user_watches=89100fs.file-max=52706963fs.nr_open=52706963net.netfilter.nf_conntrack_max=2310720net.ipv4.tcp_keepalive_time = 600net.ipv4.tcp_keepalive_probes = 3net.ipv4.tcp_keepalive_intvl =15net.ipv4.tcp_max_tw_buckets = 36000net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_max_orphans = 327680net.ipv4.tcp_orphan_retries = 3net.ipv4.tcp_syncookies = 1net.ipv4.tcp_max_syn_backlog = 16384net.ipv4.ip_conntrack_max = 65536net.ipv4.tcp_max_syn_backlog = 16384net.ipv4.tcp_timestamps = 0net.core.somaxconn = 16384net.ipv6.conf.all.disable_ipv6 = 0net.ipv6.conf.default.disable_ipv6 = 0net.ipv6.conf.lo.disable_ipv6 = 0net.ipv6.conf.all.forwarding = 1EOFsysctl --system # 安装 Docker# 二进制包下载地址：https://download.docker.com/linux/static/stable/x86_64/# wget https://mirrors.ustc.edu.cn/docker-ce/linux/static/stable/x86_64/docker-25.0.3.tgztar -zxvf kubernetes-1.29.2.tar.gzcd kubernetes-1.29.2/soft/tar xf docker-*.tgz cp docker/* /usr/bin/# 创建 containerd 的 service 文件,并且启动cat /etc/systemd/system/containerd.service EOF[Unit]Description=containerd container runtimeDocumentation=https://containerd.ioAfter=network.target local-fs.target[Service]ExecStartPre=-/sbin/modprobe overlayExecStart=/usr/bin/containerdType=notifyDelegate=yesKillMode=processRestart=alwaysRestartSec=5LimitNPROC=infinityLimitCORE=infinityLimitNOFILE=1048576TasksMax=infinityOOMScoreAdjust=-999[Install]WantedBy=multi-user.targetEOFsystemctl enable --now containerd.service# 准备 docker 的 service 文件cat /etc/systemd/system/docker.service EOF[Unit]Description=Docker Application Container EngineDocumentation=https://docs.docker.comAfter=network-online.target firewalld.service cri-docker.service docker.socket containerd.serviceWants=network-online.targetRequires=docker.socket containerd.service[Service]Type=notifyExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sockExecReload=/bin/kill -s HUP $MAINPIDTimeoutSec=0RestartSec=2Restart=alwaysStartLimitBurst=3StartLimitInterval=60sLimitNOFILE=infinityLimitNPROC=infinityLimitCORE=infinityTasksMax=infinityDelegate=yesKillMode=processOOMScoreAdjust=-500[Install]WantedBy=multi-user.targetEOF#准备 docker 的 socket 文件cat /etc/systemd/system/docker.socket EOF[Unit]Description=Docker Socket for the API[Socket]ListenStream=/var/run/docker.sockSocketMode=0660SocketUser=rootSocketGroup=docker[Install]WantedBy=sockets.targetEOF# 配置加速器mkdir -p /etc/docker/cat /etc/docker/daemon.json EOF exec-opts: [native.cgroupdriver=systemd], registry-mirrors: [ https://docker.mirrors.ustc.edu.cn ], max-concurrent-downloads: 10, log-driver: json-file, log-level: warn, log-opts: max-size: 10m, max-file: 3 , data-root: /var/lib/dockerEOF# 启动 Dockergroupadd dockersystemctl daemon-reloadsystemctl enable --now docker.socketsystemctl enable --now docker.servicesystemctl enable --now cri-docker.servicesystemctl status docker.servicedocker info # 解压 cri-docker# https://github.com/Mirantis/cri-dockerd/releases/# wget https://mirrors.chenby.cn/https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.10/cri-dockerd-0.3.10.amd64.tgztar xvf cri-dockerd-*.amd64.tgz cd cri-dockerdcp cri-dockerd /usr/bin/chmod +x /usr/bin/cri-dockerd# 写入启动 cri-docker 配置文件cat /usr/lib/systemd/system/cri-docker.service EOF[Unit]Description=CRI Interface for Docker Application Container EngineDocumentation=https://docs.mirantis.comAfter=network-online.target firewalld.service docker.serviceWants=network-online.targetRequires=cri-docker.socket[Service]Type=notifyExecStart=/usr/bin/cri-dockerd --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.7ExecReload=/bin/kill -s HUP $MAINPIDTimeoutSec=0RestartSec=2Restart=alwaysStartLimitBurst=3StartLimitInterval=60sLimitNOFILE=infinityLimitNPROC=infinityLimitCORE=infinityTasksMax=infinityDelegate=yesKillMode=process[Install]WantedBy=multi-user.targetEOF# 写入 cri-docker 的 socket 配置文件cat /usr/lib/systemd/system/cri-docker.socket EOF[Unit]Description=CRI Docker Socket for the APIPartOf=cri-docker.service[Socket]ListenStream=%t/cri-dockerd.sockSocketMode=0660SocketUser=rootSocketGroup=docker[Install]WantedBy=sockets.targetEOF# 启动 cri-dockersystemctl daemon-reloadsystemctl enable --now cri-docker.servicesystemctl status cri-docker.service k8s 与 ETCD 配置（m1节点操作）# 下载安装包#wget https://mirrors.chenby.cn/https://github.com/etcd-io/etcd/releases/download/v3.5.12/etcd-v3.5.12-linux-amd64.tar.gz#wget https://dl.k8s.io/v1.29.2/kubernetes-server-linux-amd64.tar.gzcd kubernetes-1.29.2/soft# 解压k8s安装文件tar -xf kubernetes-server-linux-amd64.tar.gz --strip-components=3 -C /usr/local/bin kubernetes/server/bin/kubelet,ctl,-apiserver,-controller-manager,-scheduler,-proxy# 解压etcd安装文件tar -xf etcd*.tar.gz mv etcd-*/etcd /usr/local/bin/ mv etcd-*/etcdctl /usr/local/bin/# 查看/usr/local/bin下内容ls /usr/local/bin/# 查看版本kubelet --version Kubernetes v1.29.2etcdctl version etcdctl version: 3.5.12 API version: 3.5# scp免密配置cd ~ssh-keygen -t rsassh-copy-id root@m2ssh-copy-id root@m3ssh-copy-id root@n1ssh-copy-id root@n2# 将组件发送至其它 k8s 节点Master=k8s-master02 k8s-master03Work=k8s-node01 k8s-node02# 拷贝 master 组件for NODE in $Master; do echo $NODE; scp /usr/local/bin/kubelet,ctl,-apiserver,-controller-manager,-scheduler,-proxy $NODE:/usr/local/bin/; scp /usr/local/bin/etcd* $NODE:/usr/local/bin/; done# 拷贝 work 组件for NODE in $Work; do echo $NODE; scp /usr/local/bin/kubelet,-proxy $NODE:/usr/local/bin/ ; done# 所有节点执行mkdir -p /opt/cni/bin # CA 证书配置cd kubernetes-1.29.2/softcp -a cfssl* /usr/local/bin# master01 节点下载证书生成工具#wget https://mirrors.chenby.cn/https://github.com/cloudflare/cfssl/releases/download/v1.6.4/cfssl_1.6.4_linux_amd64 -O /usr/local/bin/cfssl#wget https://mirrors.chenby.cn/https://github.com/cloudflare/cfssl/releases/download/v1.6.4/cfssljson_1.6.4_linux_amd64 -O /usr/local/bin/cfssljsonchmod +x /usr/local/bin/cfssl /usr/local/bin/cfssljson# 生成 ETCD 证书mkdir /etc/etcd/ssl -pcd /etc/etcd/ssl# 写入生成证书所需的配置文件,master01 节点生成 etcd 证书cat ca-config.json EOF signing: default: expiry: 876000h , profiles: kubernetes: usages: [ signing, key encipherment, server auth, client auth ], expiry: 876000h EOFcat etcd-ca-csr.json EOF CN: etcd, key: algo: rsa, size: 2048 , names: [ C: CN, ST: Beijing, L: Beijing, O: etcd, OU: Etcd Security ], ca: expiry: 876000h EOFcfssl gencert -initca etcd-ca-csr.json | cfssljson -bare /etc/etcd/ssl/etcd-cacat etcd-csr.json EOF CN: etcd, key: algo: rsa, size: 2048 , names: [ C: CN, ST: Beijing, L: Beijing, O: etcd, OU: Etcd Security ]EOFcfssl gencert -ca=/etc/etcd/ssl/etcd-ca.pem -ca-key=/etc/etcd/ssl/etcd-ca-key.pem -config=ca-config.json -hostname=127.0.0.1,k8s-master01,k8s-master02,k8s-master03,10.37.129.10,10.37.129.11,10.37.129.12,fc00:43f4:1eea:1::10,fc00:43f4:1eea:1::20,fc00:43f4:1eea:1::30,::1 -profile=kubernetes etcd-csr.json | cfssljson -bare /etc/etcd/ssl/etcd# 将证书复制到其他节点Master=k8s-master02 k8s-master03for NODE in $Master; do ssh $NODE mkdir -p /etc/etcd/ssl; for FILE in etcd-ca-key.pem etcd-ca.pem etcd-key.pem etcd.pem; do scp /etc/etcd/ssl/$FILE $NODE:/etc/etcd/ssl/$FILE; done; done # 生成 K8S 相关证书mkdir -p /etc/kubernetes/pkicd /etc/kubernetes/pki# master01 节点生成 k8s 证书, 写入生成证书所需的配置文件cat ca-csr.json EOF CN: kubernetes, key: algo: rsa, size: 2048 , names: [ C: CN, ST: Beijing, L: Beijing, O: Kubernetes, OU: Kubernetes-manual ], ca: expiry: 876000h EOFcfssl gencert -initca ca-csr.json | cfssljson -bare /etc/kubernetes/pki/cacat apiserver-csr.json EOF CN: kube-apiserver, key: algo: rsa, size: 2048 , names: [ C: CN, ST: Beijing, L: Beijing, O: Kubernetes, OU: Kubernetes-manual ]EOFcat ca-config.json EOF signing: default: expiry: 876000h , profiles: kubernetes: usages: [ signing, key encipherment, server auth, client auth ], expiry: 876000h EOFcfssl gencert -ca=/etc/kubernetes/pki/ca.pem -ca-key=/etc/kubernetes/pki/ca-key.pem -config=ca-config.json -hostname=10.96.0.1,10.37.129.16,127.0.0.1,kubernetes,kubernetes.default,kubernetes.default.svc,kubernetes.default.svc.cluster,kubernetes.default.svc.cluster.local,k8s.com,k8s.cn,10.37.129.10,10.37.129.11,10.37.129.12,10.37.129.13,10.37.129.14,10.37.129.15,10.37.129.16,10.37.129.17,10.37.129.18,10.37.129.19,10.37.129.20,fc00:43f4:1eea:1::10,fc00:43f4:1eea:1::20,fc00:43f4:1eea:1::30,fc00:43f4:1eea:1::40,fc00:43f4:1eea:1::50,fc00:43f4:1eea:1::60,fc00:43f4:1eea:1::70,fc00:43f4:1eea:1::80,fc00:43f4:1eea:1::90,fc00:43f4:1eea:1::100,::1 -profile=kubernetes apiserver-csr.json | cfssljson -bare /etc/kubernetes/pki/apiserver# 生成 apiserver 聚合证书cat front-proxy-ca-csr.json EOF CN: kubernetes, key: algo: rsa, size: 2048 , ca: expiry: 876000h EOFcfssl gencert -initca front-proxy-ca-csr.json | cfssljson -bare /etc/kubernetes/pki/front-proxy-ca cat front-proxy-client-csr.json EOF CN: front-proxy-client, key: algo: rsa, size: 2048 EOFcfssl gencert \\-ca=/etc/kubernetes/pki/front-proxy-ca.pem \\-ca-key=/etc/kubernetes/pki/front-proxy-ca-key.pem \\-config=ca-config.json \\-profile=kubernetes \\front-proxy-client-csr.json | cfssljson -bare /etc/kubernetes/pki/front-proxy-client# 生成 controller-manage 的证书cat manager-csr.json EOF CN: system:kube-controller-manager, key: algo: rsa, size: 2048 , names: [ C: CN, ST: Beijing, L: Beijing, O: system:kube-controller-manager, OU: Kubernetes-manual ]EOFcfssl gencert \\ -ca=/etc/kubernetes/pki/ca.pem \\ -ca-key=/etc/kubernetes/pki/ca-key.pem \\ -config=ca-config.json \\ -profile=kubernetes \\ manager-csr.json | cfssljson -bare /etc/kubernetes/pki/controller-managerkubectl config set-cluster kubernetes \\ --certificate-authority=/etc/kubernetes/pki/ca.pem \\ --embed-certs=true \\ --server=https://127.0.0.1:8443 \\ --kubeconfig=/etc/kubernetes/controller-manager.kubeconfig kubectl config set-context system:kube-controller-manager@kubernetes \\ --cluster=kubernetes \\ --user=system:kube-controller-manager \\ --kubeconfig=/etc/kubernetes/controller-manager.kubeconfig kubectl config set-credentials system:kube-controller-manager \\ --client-certificate=/etc/kubernetes/pki/controller-manager.pem \\ --client-key=/etc/kubernetes/pki/controller-manager-key.pem \\ --embed-certs=true \\ --kubeconfig=/etc/kubernetes/controller-manager.kubeconfigkubectl config use-context system:kube-controller-manager@kubernetes \\ --kubeconfig=/etc/kubernetes/controller-manager.kubeconfig# 生成 kube-scheduler 的证书cat scheduler-csr.json EOF CN: system:kube-scheduler, key: algo: rsa, size: 2048 , names: [ C: CN, ST: Beijing, L: Beijing, O: system:kube-scheduler, OU: Kubernetes-manual ]EOFcfssl gencert \\ -ca=/etc/kubernetes/pki/ca.pem \\ -ca-key=/etc/kubernetes/pki/ca-key.pem \\ -config=ca-config.json \\ -profile=kubernetes \\ scheduler-csr.json | cfssljson -bare /etc/kubernetes/pki/scheduler kubectl config set-cluster kubernetes \\ --certificate-authority=/etc/kubernetes/pki/ca.pem \\ --embed-certs=true \\ --server=https://127.0.0.1:8443 \\ --kubeconfig=/etc/kubernetes/scheduler.kubeconfig kubectl config set-credentials system:kube-scheduler \\ --client-certificate=/etc/kubernetes/pki/scheduler.pem \\ --client-key=/etc/kubernetes/pki/scheduler-key.pem \\ --embed-certs=true \\ --kubeconfig=/etc/kubernetes/scheduler.kubeconfig kubectl config set-context system:kube-scheduler@kubernetes \\ --cluster=kubernetes \\ --user=system:kube-scheduler \\ --kubeconfig=/etc/kubernetes/scheduler.kubeconfig kubectl config use-context system:kube-scheduler@kubernetes \\ --kubeconfig=/etc/kubernetes/scheduler.kubeconfig # 生成 admin 的证书配置cat admin-csr.json EOF CN: admin, key: algo: rsa, size: 2048 , names: [ C: CN, ST: Beijing, L: Beijing, O: system:masters, OU: Kubernetes-manual ]EOFcfssl gencert \\ -ca=/etc/kubernetes/pki/ca.pem \\ -ca-key=/etc/kubernetes/pki/ca-key.pem \\ -config=ca-config.json \\ -profile=kubernetes \\ admin-csr.json | cfssljson -bare /etc/kubernetes/pki/admin kubectl config set-cluster kubernetes \\ --certificate-authority=/etc/kubernetes/pki/ca.pem \\ --embed-certs=true \\ --server=https://127.0.0.1:8443 \\ --kubeconfig=/etc/kubernetes/admin.kubeconfig kubectl config set-credentials kubernetes-admin \\ --client-certificate=/etc/kubernetes/pki/admin.pem \\ --client-key=/etc/kubernetes/pki/admin-key.pem \\ --embed-certs=true \\ --kubeconfig=/etc/kubernetes/admin.kubeconfig kubectl config set-context kubernetes-admin@kubernetes \\ --cluster=kubernetes \\ --user=kubernetes-admin \\ --kubeconfig=/etc/kubernetes/admin.kubeconfig kubectl config use-context kubernetes-admin@kubernetes --kubeconfig=/etc/kubernetes/admin.kubeconfig# 创建 kube-proxy 证书cat kube-proxy-csr.json EOF CN: system:kube-proxy, key: algo: rsa, size: 2048 , names: [ C: CN, ST: Beijing, L: Beijing, O: system:kube-proxy, OU: Kubernetes-manual ]EOFcfssl gencert \\ -ca=/etc/kubernetes/pki/ca.pem \\ -ca-key=/etc/kubernetes/pki/ca-key.pem \\ -config=ca-config.json \\ -profile=kubernetes \\ kube-proxy-csr.json | cfssljson -bare /etc/kubernetes/pki/kube-proxy kubectl config set-cluster kubernetes \\ --certificate-authority=/etc/kubernetes/pki/ca.pem \\ --embed-certs=true \\ --server=https://127.0.0.1:8443 \\ --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig kubectl config set-credentials kube-proxy \\ --client-certificate=/etc/kubernetes/pki/kube-proxy.pem \\ --client-key=/etc/kubernetes/pki/kube-proxy-key.pem \\ --embed-certs=true \\ --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig kubectl config set-context kube-proxy@kubernetes \\ --cluster=kubernetes \\ --user=kube-proxy \\ --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig kubectl config use-context kube-proxy@kubernetes --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig# 创建 ServiceAccount Key ——secretopenssl genrsa -out /etc/kubernetes/pki/sa.key 2048openssl rsa -in /etc/kubernetes/pki/sa.key -pubout -out /etc/kubernetes/pki/sa.pub# 将证书发送到其他 master 节点# 其他两个主节点创建目录mkdir /etc/kubernetes/pki/ -pNODE=k8s-master02 k8s-master03for NODE in k8s-master02 k8s-master03; do for FILE in $(ls /etc/kubernetes/pki | grep -v etcd); do scp /etc/kubernetes/pki/$FILE $NODE:/etc/kubernetes/pki/$FILE; done; for FILE in admin.kubeconfig controller-manager.kubeconfig scheduler.kubeconfig; do scp /etc/kubernetes/$FILE $NODE:/etc/kubernetes/$FILE; done; done# 查看证书ls /etc/kubernetes/pki/ | wc -l k8s 系统组件配置ETCD# ETCD 配置# m1节点执行# 如果要用IPv6那么把IPv4地址修改为IPv6即可cat /etc/etcd/etcd.config.yml EOF name: k8s-master01data-dir: /var/lib/etcdwal-dir: /var/lib/etcd/walsnapshot-count: 5000heartbeat-interval: 100election-timeout: 1000quota-backend-bytes: 0listen-peer-urls: https://10.37.129.10:2380listen-client-urls: https://10.37.129.10:2379,http://127.0.0.1:2379max-snapshots: 3max-wals: 5cors:initial-advertise-peer-urls: https://10.37.129.10:2380advertise-client-urls: https://10.37.129.10:2379discovery:discovery-fallback: proxydiscovery-proxy:discovery-srv:initial-cluster: k8s-master01=https://10.37.129.10:2380,k8s-master02=https://10.37.129.11:2380,k8s-master03=https://10.37.129.12:2380initial-cluster-token: etcd-k8s-clusterinitial-cluster-state: newstrict-reconfig-check: falseenable-v2: trueenable-pprof: trueproxy: offproxy-failure-wait: 5000proxy-refresh-interval: 30000proxy-dial-timeout: 1000proxy-write-timeout: 5000proxy-read-timeout: 0client-transport-security: cert-file: /etc/kubernetes/pki/etcd/etcd.pem key-file: /etc/kubernetes/pki/etcd/etcd-key.pem client-cert-auth: true trusted-ca-file: /etc/kubernetes/pki/etcd/etcd-ca.pem auto-tls: truepeer-transport-security: cert-file: /etc/kubernetes/pki/etcd/etcd.pem key-file: /etc/kubernetes/pki/etcd/etcd-key.pem peer-client-cert-auth: true trusted-ca-file: /etc/kubernetes/pki/etcd/etcd-ca.pem auto-tls: truedebug: falselog-package-levels:log-outputs: [default]force-new-cluster: falseEOF# m2节点执行# 如果要用IPv6那么把IPv4地址修改为IPv6即可cat /etc/etcd/etcd.config.yml EOF name: k8s-master02data-dir: /var/lib/etcdwal-dir: /var/lib/etcd/walsnapshot-count: 5000heartbeat-interval: 100election-timeout: 1000quota-backend-bytes: 0listen-peer-urls: https://10.37.129.11:2380listen-client-urls: https://10.37.129.11:2379,http://127.0.0.1:2379max-snapshots: 3max-wals: 5cors:initial-advertise-peer-urls: https://10.37.129.11:2380advertise-client-urls: https://10.37.129.11:2379discovery:discovery-fallback: proxydiscovery-proxy:discovery-srv:initial-cluster: k8s-master01=https://10.37.129.10:2380,k8s-master02=https://10.37.129.11:2380,k8s-master03=https://10.37.129.12:2380initial-cluster-token: etcd-k8s-clusterinitial-cluster-state: newstrict-reconfig-check: falseenable-v2: trueenable-pprof: trueproxy: offproxy-failure-wait: 5000proxy-refresh-interval: 30000proxy-dial-timeout: 1000proxy-write-timeout: 5000proxy-read-timeout: 0client-transport-security: cert-file: /etc/kubernetes/pki/etcd/etcd.pem key-file: /etc/kubernetes/pki/etcd/etcd-key.pem client-cert-auth: true trusted-ca-file: /etc/kubernetes/pki/etcd/etcd-ca.pem auto-tls: truepeer-transport-security: cert-file: /etc/kubernetes/pki/etcd/etcd.pem key-file: /etc/kubernetes/pki/etcd/etcd-key.pem peer-client-cert-auth: true trusted-ca-file: /etc/kubernetes/pki/etcd/etcd-ca.pem auto-tls: truedebug: falselog-package-levels:log-outputs: [default]force-new-cluster: falseEOF# m3节点执行# 如果要用IPv6那么把IPv4地址修改为IPv6即可cat /etc/etcd/etcd.config.yml EOF name: k8s-master03data-dir: /var/lib/etcdwal-dir: /var/lib/etcd/walsnapshot-count: 5000heartbeat-interval: 100election-timeout: 1000quota-backend-bytes: 0listen-peer-urls: https://10.37.129.12:2380listen-client-urls: https://10.37.129.12:2379,http://127.0.0.1:2379max-snapshots: 3max-wals: 5cors:initial-advertise-peer-urls: https://10.37.129.12:2380advertise-client-urls: https://10.37.129.12:2379discovery:discovery-fallback: proxydiscovery-proxy:discovery-srv:initial-cluster: k8s-master01=https://10.37.129.10:2380,k8s-master02=https://10.37.129.11:2380,k8s-master03=https://10.37.129.12:2380initial-cluster-token: etcd-k8s-clusterinitial-cluster-state: newstrict-reconfig-check: falseenable-v2: trueenable-pprof: trueproxy: offproxy-failure-wait: 5000proxy-refresh-interval: 30000proxy-dial-timeout: 1000proxy-write-timeout: 5000proxy-read-timeout: 0client-transport-security: cert-file: /etc/kubernetes/pki/etcd/etcd.pem key-file: /etc/kubernetes/pki/etcd/etcd-key.pem client-cert-auth: true trusted-ca-file: /etc/kubernetes/pki/etcd/etcd-ca.pem auto-tls: truepeer-transport-security: cert-file: /etc/kubernetes/pki/etcd/etcd.pem key-file: /etc/kubernetes/pki/etcd/etcd-key.pem peer-client-cert-auth: true trusted-ca-file: /etc/kubernetes/pki/etcd/etcd-ca.pem auto-tls: truedebug: falselog-package-levels:log-outputs: [default]force-new-cluster: falseEOF# 创建 service（ 所有 master 节点操作）cat /usr/lib/systemd/system/etcd.service EOF[Unit]Description=Etcd ServiceDocumentation=https://coreos.com/etcd/docs/latest/After=network.target[Service]Type=notifyExecStart=/usr/local/bin/etcd --config-file=/etc/etcd/etcd.config.ymlRestart=on-failureRestartSec=10LimitNOFILE=65536[Install]WantedBy=multi-user.targetAlias=etcd3.serviceEOF# 创建 etcd 证书目录（ 所有 master 节点操作）mkdir /etc/kubernetes/pki/etcdln -s /etc/etcd/ssl/* /etc/kubernetes/pki/etcd/systemctl daemon-reloadsystemctl enable --now etcd.servicesystemctl status etcd.service# 查看 etcd 状态# 如果要用 IPv6 那么把 IPv4 地址修改为 IPv6 即可export ETCDCTL_API=3etcdctl --endpoints=10.37.129.12:2379,10.37.129.11:2379,10.37.129.10:2379 --cacert=/etc/kubernetes/pki/etcd/etcd-ca.pem --cert=/etc/kubernetes/pki/etcd/etcd.pem --key=/etc/kubernetes/pki/etcd/etcd-key.pem endpoint status --write-out=tableetcdctl member list --endpoints=10.37.129.12:2379,10.37.129.11:2379,10.37.129.10:2379 --cacert=/etc/kubernetes/pki/etcd/etcd-ca.pem --cert=/etc/kubernetes/pki/etcd/etcd.pem --key=/etc/kubernetes/pki/etcd/etcd-key.pem Nginx(转发到ApiServer的请求)# Nginx 配置# 安装编译环境yum install gcc -y# 下载解压 nginx 二进制文件# wget http://nginx.org/download/nginx-1.25.3.tar.gzcd /kubernetes-1.29.2/softtar xvf nginx-*.tar.gzcd nginx-1.25.3# 进行编译./configure --with-stream --without-http --without-http_uwsgi_module --without-http_scgi_module --without-http_fastcgi_modulemake make install # 拷贝编译好的 nginxnode=k8s-master02 k8s-master03 k8s-node01 k8s-node02for NODE in $node; do scp -r /usr/local/nginx/ $NODE:/usr/local/nginx/; done# 写入配置文件（在所有主机上执行）cat /usr/local/nginx/conf/kube-nginx.conf EOFworker_processes 1;events worker_connections 1024;stream upstream backend least_conn; hash $remote_addr consistent; server 10.37.129.10:6443 max_fails=3 fail_timeout=30s; server 10.37.129.11:6443 max_fails=3 fail_timeout=30s; server 10.37.129.12:6443 max_fails=3 fail_timeout=30s; server listen 127.0.0.1:8443; proxy_connect_timeout 1s; proxy_pass backend; EOFcat /etc/systemd/system/kube-nginx.service EOF[Unit]Description=kube-apiserver nginx proxyAfter=network.targetAfter=network-online.targetWants=network-online.target[Service]Type=forkingExecStartPre=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/kube-nginx.conf -p /usr/local/nginx -tExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/kube-nginx.conf -p /usr/local/nginxExecReload=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/kube-nginx.conf -p /usr/local/nginx -s reloadPrivateTmp=trueRestart=alwaysRestartSec=5StartLimitInterval=0LimitNOFILE=65536 [Install]WantedBy=multi-user.targetEOFsystemctl daemon-reloadsystemctl enable --now kube-nginx.servicesystemctl status kube-nginx.service ApiServer# 所有 k8s 节点创建以下目录mkdir -p /etc/kubernetes/manifests/ /etc/systemd/system/kubelet.service.d /var/lib/kubelet /var/log/kubernetes# 创建 apiserver（所有 master 节点）# master01 节点配置cat /usr/lib/systemd/system/kube-apiserver.service EOF[Unit]Description=Kubernetes API ServerDocumentation=https://github.com/kubernetes/kubernetesAfter=network.target[Service]ExecStart=/usr/local/bin/kube-apiserver \\\\ --v=2 \\\\ --allow-privileged=true \\\\ --bind-address=0.0.0.0 \\\\ --secure-port=6443 \\\\ --advertise-address=10.37.129.10 \\\\ --service-cluster-ip-range=10.96.0.0/12,fd00:1111::/112 \\\\ --service-node-port-range=30000-32767 \\\\ --etcd-servers=https://10.37.129.11:2379,https://10.37.129.12:2379,https://10.37.129.10:2379 \\\\ --etcd-cafile=/etc/etcd/ssl/etcd-ca.pem \\\\ --etcd-certfile=/etc/etcd/ssl/etcd.pem \\\\ --etcd-keyfile=/etc/etcd/ssl/etcd-key.pem \\\\ --client-ca-file=/etc/kubernetes/pki/ca.pem \\\\ --tls-cert-file=/etc/kubernetes/pki/apiserver.pem \\\\ --tls-private-key-file=/etc/kubernetes/pki/apiserver-key.pem \\\\ --kubelet-client-certificate=/etc/kubernetes/pki/apiserver.pem \\\\ --kubelet-client-key=/etc/kubernetes/pki/apiserver-key.pem \\\\ --service-account-key-file=/etc/kubernetes/pki/sa.pub \\\\ --service-account-signing-key-file=/etc/kubernetes/pki/sa.key \\\\ --service-account-issuer=https://kubernetes.default.svc.cluster.local \\\\ --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname \\\\ --enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota \\ --authorization-mode=Node,RBAC \\\\ --enable-bootstrap-token-auth=true \\\\ --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.pem \\\\ --proxy-client-cert-file=/etc/kubernetes/pki/front-proxy-client.pem \\\\ --proxy-client-key-file=/etc/kubernetes/pki/front-proxy-client-key.pem \\\\ --requestheader-allowed-names=aggregator \\\\ --requestheader-group-headers=X-Remote-Group \\\\ --requestheader-extra-headers-prefix=X-Remote-Extra- \\\\ --requestheader-username-headers=X-Remote-User \\\\ --enable-aggregator-routing=trueRestart=on-failureRestartSec=10sLimitNOFILE=65535[Install]WantedBy=multi-user.targetEOF# master02 节点配置cat /usr/lib/systemd/system/kube-apiserver.service EOF[Unit]Description=Kubernetes API ServerDocumentation=https://github.com/kubernetes/kubernetesAfter=network.target[Service]ExecStart=/usr/local/bin/kube-apiserver \\\\ --v=2 \\\\ --allow-privileged=true \\\\ --bind-address=0.0.0.0 \\\\ --secure-port=6443 \\\\ --advertise-address=10.37.129.11 \\\\ --service-cluster-ip-range=10.96.0.0/12,fd00:1111::/112 \\\\ --service-node-port-range=30000-32767 \\\\ --etcd-servers=https://10.37.129.11:2379,https://10.37.129.12:2379,https://10.37.129.10:2379 \\\\ --etcd-cafile=/etc/etcd/ssl/etcd-ca.pem \\\\ --etcd-certfile=/etc/etcd/ssl/etcd.pem \\\\ --etcd-keyfile=/etc/etcd/ssl/etcd-key.pem \\\\ --client-ca-file=/etc/kubernetes/pki/ca.pem \\\\ --tls-cert-file=/etc/kubernetes/pki/apiserver.pem \\\\ --tls-private-key-file=/etc/kubernetes/pki/apiserver-key.pem \\\\ --kubelet-client-certificate=/etc/kubernetes/pki/apiserver.pem \\\\ --kubelet-client-key=/etc/kubernetes/pki/apiserver-key.pem \\\\ --service-account-key-file=/etc/kubernetes/pki/sa.pub \\\\ --service-account-signing-key-file=/etc/kubernetes/pki/sa.key \\\\ --service-account-issuer=https://kubernetes.default.svc.cluster.local \\\\ --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname \\\\ --enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota \\\\ --authorization-mode=Node,RBAC \\\\ --enable-bootstrap-token-auth=true \\\\ --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.pem \\\\ --proxy-client-cert-file=/etc/kubernetes/pki/front-proxy-client.pem \\\\ --proxy-client-key-file=/etc/kubernetes/pki/front-proxy-client-key.pem \\\\ --requestheader-allowed-names=aggregator \\\\ --requestheader-group-headers=X-Remote-Group \\\\ --requestheader-extra-headers-prefix=X-Remote-Extra- \\\\ --requestheader-username-headers=X-Remote-User \\\\ --enable-aggregator-routing=trueRestart=on-failureRestartSec=10sLimitNOFILE=65535[Install]WantedBy=multi-user.targetEOF# master03 配置cat /usr/lib/systemd/system/kube-apiserver.service EOF[Unit]Description=Kubernetes API ServerDocumentation=https://github.com/kubernetes/kubernetesAfter=network.target[Service]ExecStart=/usr/local/bin/kube-apiserver \\\\ --v=2 \\\\ --allow-privileged=true \\\\ --bind-address=0.0.0.0 \\\\ --secure-port=6443 \\\\ --advertise-address=10.37.129.12 \\\\ --service-cluster-ip-range=10.96.0.0/12,fd00:1111::/112 \\\\ --service-node-port-range=30000-32767 \\\\ --etcd-servers=https://10.37.129.11:2379,https://10.37.129.12:2379,https://10.37.129.10:2379 \\\\ --etcd-cafile=/etc/etcd/ssl/etcd-ca.pem \\\\ --etcd-certfile=/etc/etcd/ssl/etcd.pem \\\\ --etcd-keyfile=/etc/etcd/ssl/etcd-key.pem \\\\ --client-ca-file=/etc/kubernetes/pki/ca.pem \\\\ --tls-cert-file=/etc/kubernetes/pki/apiserver.pem \\\\ --tls-private-key-file=/etc/kubernetes/pki/apiserver-key.pem \\\\ --kubelet-client-certificate=/etc/kubernetes/pki/apiserver.pem \\\\ --kubelet-client-key=/etc/kubernetes/pki/apiserver-key.pem \\\\ --service-account-key-file=/etc/kubernetes/pki/sa.pub \\\\ --service-account-signing-key-file=/etc/kubernetes/pki/sa.key \\\\ --service-account-issuer=https://kubernetes.default.svc.cluster.local \\\\ --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname \\\\ --enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota \\\\ --authorization-mode=Node,RBAC \\\\ --enable-bootstrap-token-auth=true \\\\ --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.pem \\\\ --proxy-client-cert-file=/etc/kubernetes/pki/front-proxy-client.pem \\\\ --proxy-client-key-file=/etc/kubernetes/pki/front-proxy-client-key.pem \\\\ --requestheader-allowed-names=aggregator \\\\ --requestheader-group-headers=X-Remote-Group \\\\ --requestheader-extra-headers-prefix=X-Remote-Extra- \\\\ --requestheader-username-headers=X-Remote-User \\\\ --enable-aggregator-routing=trueRestart=on-failureRestartSec=10sLimitNOFILE=65535[Install]WantedBy=multi-user.targetEOF# 启动 apiServer(master节点)systemctl daemon-reloadsystemctl enable --now kube-apiserver.servicesystemctl status kube-apiserver.service ControllerManager# 配置 kube-controller-manager service# 所有master节点配置，且配置相同# 172.16.0.0/12为pod网段，按需求设置你自己的网段cat /usr/lib/systemd/system/kube-controller-manager.service EOF[Unit]Description=Kubernetes Controller ManagerDocumentation=https://github.com/kubernetes/kubernetesAfter=network.target[Service]ExecStart=/usr/local/bin/kube-controller-manager \\\\ --v=2 \\\\ --bind-address=0.0.0.0 \\\\ --root-ca-file=/etc/kubernetes/pki/ca.pem \\\\ --cluster-signing-cert-file=/etc/kubernetes/pki/ca.pem \\\\ --cluster-signing-key-file=/etc/kubernetes/pki/ca-key.pem \\\\ --service-account-private-key-file=/etc/kubernetes/pki/sa.key \\\\ --kubeconfig=/etc/kubernetes/controller-manager.kubeconfig \\\\ --leader-elect=true \\\\ --use-service-account-credentials=true \\\\ --node-monitor-grace-period=40s \\\\ --node-monitor-period=5s \\\\ --controllers=*,bootstrapsigner,tokencleaner \\\\ --allocate-node-cidrs=true \\\\ --service-cluster-ip-range=10.96.0.0/12,fd00:1111::/112 \\\\ --cluster-cidr=172.16.0.0/12,fc00:2222::/112 \\\\ --node-cidr-mask-size-ipv4=24 \\\\ --node-cidr-mask-size-ipv6=120 \\\\ --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.pemRestart=alwaysRestartSec=10s[Install]WantedBy=multi-user.targetEOF# 启动 kube-controller-managersystemctl daemon-reloadsystemctl enable --now kube-controller-manager.servicesystemctl status kube-controller-manager.service Scheduler# 配置 kube-scheduler service# 所有 master 节点配置，且配置相同cat /usr/lib/systemd/system/kube-scheduler.service EOF[Unit]Description=Kubernetes SchedulerDocumentation=https://github.com/kubernetes/kubernetesAfter=network.target[Service]ExecStart=/usr/local/bin/kube-scheduler \\\\ --v=2 \\\\ --bind-address=0.0.0.0 \\\\ --leader-elect=true \\\\ --kubeconfig=/etc/kubernetes/scheduler.kubeconfigRestart=alwaysRestartSec=10s[Install]WantedBy=multi-user.targetEOF# 启动 kube-schedulersystemctl daemon-reloadsystemctl enable --now kube-scheduler.servicesystemctl status kube-scheduler.service TLS Bootstrapping 配置# 在 master01 上配置kubectl config set-cluster kubernetes \\--certificate-authority=/etc/kubernetes/pki/ca.pem \\--embed-certs=true --server=https://127.0.0.1:8443 \\--kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfigkubectl config set-credentials tls-bootstrap-token-user \\--token=c8ad9c.2e4d610cf3e7426e \\--kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfigkubectl config set-context tls-bootstrap-token-user@kubernetes \\--cluster=kubernetes \\--user=tls-bootstrap-token-user \\--kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfigkubectl config use-context tls-bootstrap-token-user@kubernetes \\--kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig# master节点执行mkdir -p /root/.kube ; cp /etc/kubernetes/admin.kubeconfig /root/.kube/config# 查看集群状态kubectl get cscd ~cat bootstrap.secret.yaml EOFapiVersion: v1kind: Secretmetadata: name: bootstrap-token-c8ad9c namespace: kube-systemtype: bootstrap.kubernetes.io/tokenstringData: description: The default bootstrap token generated by kubelet . token-id: c8ad9c token-secret: 2e4d610cf3e7426e usage-bootstrap-authentication: true usage-bootstrap-signing: true auth-extra-groups: system:bootstrappers:default-node-token,system:bootstrappers:worker,system:bootstrappers:ingress ---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata: name: kubelet-bootstraproleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: system:node-bootstrappersubjects:- apiGroup: rbac.authorization.k8s.io kind: Group name: system:bootstrappers:default-node-token---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata: name: node-autoapprove-bootstraproleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: system:certificates.k8s.io:certificatesigningrequests:nodeclientsubjects:- apiGroup: rbac.authorization.k8s.io kind: Group name: system:bootstrappers:default-node-token---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata: name: node-autoapprove-certificate-rotationroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: system:certificates.k8s.io:certificatesigningrequests:selfnodeclientsubjects:- apiGroup: rbac.authorization.k8s.io kind: Group name: system:nodes---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata: annotations: rbac.authorization.kubernetes.io/autoupdate: true labels: kubernetes.io/bootstrapping: rbac-defaults name: system:kube-apiserver-to-kubeletrules: - apiGroups: - resources: - nodes/proxy - nodes/stats - nodes/log - nodes/spec - nodes/metrics verbs: - *---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata: name: system:kube-apiserver namespace: roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: system:kube-apiserver-to-kubeletsubjects: - apiGroup: rbac.authorization.k8s.io kind: User name: kube-apiserverEOF kubectl apply -f bootstrap.secret.yaml Node 配置复制相关证书至 node# 在 master01 上将证书复制到 node 节点cd /etc/kubernetes/ for NODE in k8s-master02 k8s-master03 k8s-node01 k8s-node02; do ssh $NODE mkdir -p /etc/kubernetes/pki; for FILE in pki/ca.pem pki/ca-key.pem pki/front-proxy-ca.pem bootstrap-kubelet.kubeconfig kube-proxy.kubeconfig; do scp /etc/kubernetes/$FILE $NODE:/etc/kubernetes/$FILE; done; done 配置 kubelet（所有节点）# kubelet 配置# 当使用 docker 作为 Runtimecat /usr/lib/systemd/system/kubelet.service EOF[Unit]Description=Kubernetes KubeletDocumentation=https://github.com/kubernetes/kubernetesAfter=network-online.target firewalld.service cri-docker.service docker.socket containerd.serviceWants=network-online.targetRequires=docker.socket containerd.service[Service]ExecStart=/usr/local/bin/kubelet \\\\ --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig \\\\ --kubeconfig=/etc/kubernetes/kubelet.kubeconfig \\\\ --config=/etc/kubernetes/kubelet-conf.yml \\\\ --container-runtime-endpoint=unix:///run/cri-dockerd.sock \\\\ --node-labels=node.kubernetes.io/node= [Install]WantedBy=multi-user.targetEOFcat /etc/kubernetes/kubelet-conf.yml EOFapiVersion: kubelet.config.k8s.io/v1beta1kind: KubeletConfigurationaddress: 0.0.0.0port: 10250readOnlyPort: 10255authentication: anonymous: enabled: false webhook: cacheTTL: 2m0s enabled: true x509: clientCAFile: /etc/kubernetes/pki/ca.pemauthorization: mode: Webhook webhook: cacheAuthorizedTTL: 5m0s cacheUnauthorizedTTL: 30scgroupDriver: systemdcgroupsPerQOS: trueclusterDNS:- 10.96.0.10clusterDomain: cluster.localcontainerLogMaxFiles: 5containerLogMaxSize: 10MicontentType: application/vnd.kubernetes.protobufcpuCFSQuota: truecpuManagerPolicy: nonecpuManagerReconcilePeriod: 10senableControllerAttachDetach: trueenableDebuggingHandlers: trueenforceNodeAllocatable:- podseventBurst: 10eventRecordQPS: 5evictionHard: imagefs.available: 15% memory.available: 100Mi nodefs.available: 10% nodefs.inodesFree: 5%evictionPressureTransitionPeriod: 5m0sfailSwapOn: truefileCheckFrequency: 20shairpinMode: promiscuous-bridgehealthzBindAddress: 127.0.0.1healthzPort: 10248httpCheckFrequency: 20simageGCHighThresholdPercent: 85imageGCLowThresholdPercent: 80imageMinimumGCAge: 2m0siptablesDropBit: 15iptablesMasqueradeBit: 14kubeAPIBurst: 10kubeAPIQPS: 5makeIPTablesUtilChains: truemaxOpenFiles: 1000000maxPods: 110nodeStatusUpdateFrequency: 10soomScoreAdj: -999podPidsLimit: -1registryBurst: 10registryPullQPS: 5resolvConf: /etc/resolv.confrotateCertificates: trueruntimeRequestTimeout: 2m0sserializeImagePulls: truestaticPodPath: /etc/kubernetes/manifestsstreamingConnectionIdleTimeout: 4h0m0ssyncFrequency: 1m0svolumeStatsAggPeriod: 1m0sEOFsystemctl daemon-reloadsystemctl enable --now kubelet.servicesystemctl status kubelet.service kube-proxy 配置（所有节点）# 将 kubeconfig 发送至其他节点# master-1 执行for NODE in k8s-master02 k8s-master03 k8s-node01 k8s-node02; do scp /etc/kubernetes/kube-proxy.kubeconfig $NODE:/etc/kubernetes/kube-proxy.kubeconfig; done# 所有 k8s 节点添加 kube-proxy 的 service 文件cat /usr/lib/systemd/system/kube-proxy.service EOF[Unit]Description=Kubernetes Kube ProxyDocumentation=https://github.com/kubernetes/kubernetesAfter=network.target[Service]ExecStart=/usr/local/bin/kube-proxy \\\\ --config=/etc/kubernetes/kube-proxy.yaml \\\\ --cluster-cidr=172.16.0.0/12,fc00:2222::/112 \\\\ --v=2Restart=alwaysRestartSec=10s[Install]WantedBy=multi-user.targetEOF# 所有 k8s节点添加 kube-proxy 的配置cat /etc/kubernetes/kube-proxy.yaml EOFapiVersion: kubeproxy.config.k8s.io/v1alpha1bindAddress: 0.0.0.0clientConnection: acceptContentTypes: burst: 10 contentType: application/vnd.kubernetes.protobuf kubeconfig: /etc/kubernetes/kube-proxy.kubeconfig qps: 5clusterCIDR: 172.16.0.0/12,fc00:2222::/112configSyncPeriod: 15m0sconntrack: max: null maxPerCore: 32768 min: 131072 tcpCloseWaitTimeout: 1h0m0s tcpEstablishedTimeout: 24h0m0senableProfiling: falsehealthzBindAddress: 0.0.0.0:10256hostnameOverride: iptables: masqueradeAll: false masqueradeBit: 14 minSyncPeriod: 0s syncPeriod: 30sipvs: masqueradeAll: true minSyncPeriod: 5s scheduler: rr syncPeriod: 30skind: KubeProxyConfigurationmetricsBindAddress: 127.0.0.1:10249mode: ipvsnodePortAddresses: nulloomScoreAdj: -999portRange: udpIdleTimeout: 250msEOFsystemctl daemon-reloadsystemctl enable --now kube-proxy.servicesystemctl status kube-proxy.service 安装网络插件(m1节点操作)#wget https://mirrors.chenby.cn/https://github.com/projectcalico/calico/blob/master/manifests/calico-typha.yaml#cp calico-typha.yaml calico.yaml#vim calico.yaml# calico-config ConfigMap处 #ipam: # type: calico-ipam, #, #- name: IP # value: autodetect# #- name: CALICO_IPV4POOL_CIDR # value: 172.16.0.0/12# vim calico-ipv6.yaml# calico-config ConfigMap处# ipam: # type: calico-ipam,# assign_ipv4: true,# assign_ipv6: true# ,# - name: IP# value: autodetect# # - name: IP6# value: autodetect# # - name: CALICO_IPV4POOL_CIDR# value: 172.16.0.0/12# # - name: CALICO_IPV6POOL_CIDR# value: fc00:2222::/112# # - name: FELIX_IPV6SUPPORT# value: true# 若docker镜像拉不下来，可以使用国内的仓库#sed -i s#docker.io/calico/#m.daocloud.io/docker.io/calico/#g calico.yaml #sed -i s#docker.io/calico/#m.daocloud.io/docker.io/calico/#g calico-ipv6.yaml#sed -i s#m.daocloud.io/docker.io/calico/#docker.io/calico/#g calico.yaml #sed -i s#m.daocloud.io/docker.io/calico/#docker.io/calico/#g calico-ipv6.yaml# 修改为国内源 docker源可选#sed -i s#coredns/#m.daocloud.io/docker.io/coredns/#g values.yaml#sed -i s#registry.k8s.io/#m.daocloud.io/registry.k8s.io/#g values.yamlcd kubernetes-1.29.2/softmv dockertools /usr/local/binscp /usr/local/bin/dockertools root@m2:/usr/local/bin/scp /usr/local/bin/dockertools root@m3:/usr/local/bin/scp /usr/local/bin/dockertools root@n1:/usr/local/bin/scp /usr/local/bin/dockertools root@n2:/usr/local/bin/cd kubernetes-1.29.2dockertools load -l images/scp -r images root@m2:/root/scp -r images root@m3:/root/scp -r images root@n1:/root/scp -r images root@n2:/root/# 其他节点执行cd /root/dockertools load -l images/# 本地没有公网 IPv6 使用 calico.yamlcd /home/k8s/soft/kubernetes-1.29.2/manifestskubectl apply -f calico-typha.yaml#删除#kubectl delete -f calico-typha.yaml 安装 CoreDNS（m1节点操作）# 安装 helmcd kubernetes-1.29.2/softtar -zxvf helm-v3.14.4-linux-amd64.tar.gz mv linux-amd64/helm /usr/local/bin/helm version# 下载tgz包#helm repo add coredns https://coredns.github.io/helm#helm pull coredns/coredns#tar xvf coredns-*.tgzhelm install coredns ./coredns/ -n kube-system#删除#helm uninstall coredns -n kube-system# 修改IP地址#vim values.yaml#cat values.yaml | grep clusterIP:#clusterIP: 10.96.0.10 安装 Metrics Server# 下载 #wget https://mirrors.chenby.cn/https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml# 修改配置#vim components.yaml---## 1# - args:# - --cert-dir=/tmp# - --secure-port=10250# - --kubelet-preferred-address-types=InternalIP,#ExternalIP,Hostname# - --kubelet-use-node-status-port# - --metric-resolution=15s# - --kubelet-insecure-tls# - --requestheader-client-ca-file=/etc/kubernetes/#pki/front-proxy-ca.pem# - --requestheader-username-headers=X-Remote-User# - --requestheader-group-headers=X-Remote-Group# - #--requestheader-extra-headers-prefix=X-Remote-Ext#ra-#### 2# volumeMounts:# - mountPath: /tmp# name: tmp-dir# - name: ca-ssl# mountPath: /etc/kubernetes/pki### 3# volumes:# - emptyDir: # name: tmp-dir# - name: ca-ssl# hostPath:# path: /etc/kubernetes/pki---# 修改为国内源 docker源可选#sed -i s#registry.k8s.io/#m.daocloud.io/registry.k8s.io/#g *.yaml# m1节点执行部署cd kubernetes-1.29.2/manifestskubectl apply -f components.yamlkubectl top pod -n kube-system 安装命令补全# master节点执行yum install bash-completion -ysource /usr/share/bash-completion/bash_completionsource (kubectl completion bash)echo source (kubectl completion bash) ~/.bashrc# 设置 master 节点污点kubectl taint nodes k8s-node01 node-role.kubernetes.io/control-plane=:NoSchedule","tags":[null],"categories":[null]},{"title":"Kubernetes存储","path":"/wiki/Kubernetes/存储.html","content":"存储存储分类 ‌元数据‌： ‌configMap‌：用于保存配置数据，这些数据是明文存储的。 ‌Secret‌：用于保存敏感性数据，这些数据是经过编码的，以确保安全性。 ‌Downward API‌：容器在运行时可以从Kubernetes API服务器获取有关它们自身的信息。 ‌真实数据‌： ‌Volume‌：用于存储临时或持久性数据，满足容器运行时的数据存储需求。 ‌PersistentVolume‌：申请制的持久化存储，用于长期保存数据。 ConfigMapConfigMap 是 Kubernetes 中用于‌管理非敏感配置数据‌的核心资源对象，它将配置信息与容器镜像解耦，实现应用配置的集中化、动态化管理。 核心功能与特性 ‌分离配置与代码‌将环境变量、配置文件（如 nginx.conf）等从容器镜像中剥离，避免因配置变更需重新构建镜像的问题。‌ ‌支持多种数据格式 键值对（key: value） 完整配置文件（如 JSON、XML、YAML） 环境变量文件（.env 格式）‌ ‌动态更新能力‌修改 ConfigMap 后，部分挂载方式（如 Volume 挂载）可实时同步到 Pod 内，无需重启容器（需应用支持配置热加载）。‌ ‌注意事项‌1.ConfigMap 必须与 Pod 同命名空间‌。2.单 ConfigMap 数据量建议不超过 1 MiB，大文件建议使用持久化存储‌。 创建方式 文件 vi config.filekubectl create configmap game-config --from-file=config.file 命令行 kubectl create configmap literal-config --from-literal=name=zhangsan --from-literal=password=321 yaml声明式配置 apiVersion: v1kind: ConfigMapmetadata: name: timezone-configdata: timezone: Asia/Shanghai # 键值对 profile.properties: | # 完整配置文件 app.log.level=INFO app.thread.count=4 ConfigMap实验配置环境变量apiVersion: v1kind: ConfigMapmetadata: name: literal-config namespace: defaultdata: name: dave password: pass---apiVersion: v1kind: ConfigMapmetadata: name: env-config namespace: defaultdata: log_level: INFO---apiVersion: v1kind: Podmetadata: name: cm-env-podspec: containers: - name: myapp-container image: wangyanglinux/myapp:v1.0 command: [ /bin/sh, -c, env ] env: - name: USERNAME valueFrom: configMapKeyRef: name: literal-config key: name - name: PASSWORD valueFrom: configMapKeyRef: name: literal-config key: password envFrom: - configMapRef: name: env-config restartPolicy: Never 在同一个 yaml 内多个资源文件可以使用 — 隔离 kubectl create -f config-pod-env.yaml 启动命令apiVersion: v1kind: ConfigMapmetadata: name: literal-config namespace: defaultdata: name: dave password: pass---apiVersion: v1kind: Podmetadata: name: cm-command-podspec: containers: - name: myapp-container image: wangyanglinux/myapp:v1.0 command: [ /bin/sh, -c, echo $(USERNAME) $(PASSWORD) ] env: - name: USERNAME valueFrom: configMapKeyRef: name: literal-config key: name - name: PASSWORD valueFrom: configMapKeyRef: name: literal-config key: password restartPolicy: Never 输出配置到文件apiVersion: v1kind: ConfigMapmetadata: name: literal-config namespace: defaultdata: name: dave password: pass---apiVersion: v1kind: Podmetadata: name: cm-volume-podspec: containers: - name: myapp-container image: wangyanglinux/myapp:v1.0 volumeMounts: - name: config-volume mountPath: /etc/config volumes: - name: config-volume configMap: name: literal-config restartPolicy: Never 作用： ‌ConfigMap 挂载‌ 名为 literal-config 的 ConfigMap 被挂载为名为 config-volume 的卷，其所有键值对将自动生成文件（键名作为文件名，值作为文件内容）‌。 挂载路径为容器内的 /etc/config，容器可通过文件系统直接读取配置‌。 ‌动态更新特性‌ 若修改 literal-config 的内容，已挂载的文件会自动更新（需应用支持配置热加载），无需重启 Pod‌。 与 env 注入方式不同，Volume 挂载的配置更新是实时的‌。 配置说明： ‌Volume 声明‌ volumes 字段定义了一个名为 config-volume 的卷，其数据源来自 ConfigMap literal-config‌。 ConfigMap 中的每个键值对会生成独立文件（例如键 name 对应文件 /etc/config/name）‌。 ‌Volume 挂载‌ 容器通过 volumeMounts 将 config-volume 挂载到 /etc/config，该路径下的文件可直接被应用读取‌。 若挂载路径已存在文件，ConfigMap 内容会覆盖原有文件‌。 kubectl create -f cm-volume-pod.yamlkubectl exec -it cm-volume-pod /bin/bash kubectl edit cm literal-config 可以看到修改了 literal-config 中的值后对应 Pod 里的内容也被修改了。 Pod中文件是以链接的方式生成的，更新实际是生成新的文件然后修改链接。 热更新nginx.conf worker_processes 1;user nginx;daemon off;events worker_connections 1024;http default_type application/octet-stream; sendfile on; keepalive_timeout 65; server listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / root /usr/local/nginx/html; index index.html index.htm; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html root html; hotupdate-deploy.yaml apiVersion: apps/v1kind: Deploymentmetadata: labels: app: hotupdate-deploy name: hotupdate-deployspec: replicas: 5 selector: matchLabels: app: hotupdate-deploy template: metadata: labels: app: hotupdate-deploy spec: containers: - name: nginx image: wangyanglinux/myapp:v1.0 volumeMounts: - name: config-volume mountPath: /usr/local/nginx/conf/ volumes: - name: config-volume configMap: name: nginx.conf kubectl create cm nginx.conf --from-file=nginx.confkubectl create -f hotupdate-deploy.yaml Pod中也成功挂载了 default.con 文件。 kubectl edit cm default-nginx 等待一段时间后可以看到 Pod 中配置文件端口也修改为了 8080。 此时访问 8080 端口是不通的，因为 Pod 是没用重启使用新的配置。 kubectl patch deployment hotupdate-deploy --patch spec: template: metadata: annotations: version/config: 66666666 更新ConfigMap时，需注意以下几点： ‌滚动更新‌：默认情况下，更新ConfigMap不会触发Pod的滚动更新。如需强制触发，可通过修改 pod annotations 的方式强制触发滚动更新。 kubectl patch deployment hotupdate-deploy --patch spec: template: metadata: annotations: version/config: 66666666 ‌Volume数据同步‌：而挂载为Volume的数据则需要大约‌10秒‌的时间才能同步更新。 不可改变Kubernetes 提供了一种可选配置，允许将 ConfigMap 和 Secret 设置为不可变。这一功能带来以下好处： ‌防止意外更新‌：‌禁止变更 ConfigMap 和 Secret 的数据‌，可以避免非预期的更新导致应用程序中断。 ‌提升集群性能‌：通过将 ConfigMap 标记为不可变，可以关闭 kube-apiserver 对其的监视，从而‌显著降低 kube-apiserver 的负载‌。 ‌优化资源管理‌：对于大量使用 ConfigMap 的集群，这一配置有助于‌更好地管理资源‌，确保集群稳定运行。 kubectl edit cm nginx.conf 添加完该参数后再执行修改命令会拒绝保存修改。 如果修改为无可改变的状态，是不允许回退，不可逆的。只能删除此 cm，然后重新创建一个无不可改变标记的cm。 env与envFrom区别在 Kubernetes 中，env 和 envFrom 都是用于为容器设置环境变量的字段，但它们在功能和使用方式上有显著区别。 核心区别对比 ‌特性‌ ‌env‌ ‌envFrom‌ ‌数据来源‌ 直接定义或从 ConfigMapSecret 的‌单个键‌引用 从 ConfigMapSecret 的‌全部键值对‌批量引用 ‌更新行为‌ 修改后需重启 Pod 生效‌ 修改后需删除并重建 Pod 才能生效‌ ‌适用场景‌ 需要精确控制少量环境变量 需要批量导入整个配置文件的键值对 ‌语法示例‌ valueFrom.configMapKeyRef configMapRef 或 secretRef 具体差异解析 ‌env 的典型用法 ‌直接定义值‌： env: - name: LOG_LEVEL value: INFO ‌引用 ConfigMap 的单个键（如用户示例中的 USERNAME）： env: - name: USERNAME valueFrom: configMapKeyRef: name: literal-config key: name ‌特点‌：精准控制每个变量，适合敏感数据（如密码）或需命名的变量‌。 ‌envFrom 的典型用法 ‌批量导入 ConfigMap 所有键值对‌（如用户示例中的 env-config）： envFrom: - configMapRef: name: env-config ‌特点‌：自动将 ConfigMap 中的每个键值对转换为环境变量，键名直接作为变量名‌。‌ 注意‌：若需避免命名冲突，可通过 prefix 添加统一前缀‌。 行为差异详解 ‌更新后的生效方式‌ ‌env 修改：直接编辑 Pod YAML 中的 env 字段并应用后，Kubernetes 会自动重启 Pod 使新变量生效‌。 ‌envFrom 修改：更新引用的 ConfigMap 后，需手动删除 Pod 触发重建才能加载新变量（环境变量不会自动更新）‌。 ‌与 Volume 挂载的对比‌ 若通过 Volume 挂载 ConfigMap，文件内容会实时更新，但环境变量方式（无论 env 或 envFrom）均需重建 Pod‌。 最佳实践建议 ‌敏感数据‌：优先使用 env + secretKeyRef 而非 envFrom，避免意外暴露 Secret 的全部内容‌。 ‌批量配置‌：非敏感且需完整导入的配置（如地域列表），推荐使用 envFrom 简化管理‌。 ‌命名规范‌：通过 prefix 为 envFrom 导入的变量添加前缀（如 APP_），避免命名冲突‌。 总结：env 提供精细化控制，envFrom 简化批量导入，根据场景需求选择即可‌。 SecretSecret 的核心作用Secret 用于‌安全存储和分发敏感数据‌，例如： ‌认证信息‌：数据库密码、API 密钥、OAuth 令牌等。‌ ‌TLS 证书‌：为 HTTPS 通信提供加密证书和私钥。‌ ‌私有仓库凭据‌：拉取私有镜像时所需的 Docker 注册表用户名和密码。‌ ‌动态更新支持‌：在不重启 Pod 的前提下轮换敏感数据（如证书）。‌ 关键优势：通过 Base64 编码减少明文暴露风险，并依托 RBAC 机制控制访问权限。‌ Secret 的类型通过为 Secret 对象的 type 字段设置一个非空的字符串值，你也可以定义并使用自己 Secret 类型（如果 type 值为空字符串，则被视为 Opaque 类型）。 Kubernetes 并不对类型的名称作任何限制。不过，如果你要使用内置类型之一， 则你必须满足为该类型所定义的所有要求。 内置类型 用法 Opaque 用户定义的任意数据 kubernetes.io/service-account-token 服务账号令牌 kubernetes.io/dockercfg ~/.dockercfg 文件的序列化形式 kubernetes.io/dockerconfigjson ~/.docker/config.json 文件的序列化形式 kubernetes.io/basic-auth 用于基本身份认证的凭据 kubernetes.io/ssh-auth 用于 SSH 身份认证的凭据 kubernetes.io/tls 用于 TLS 客户端或者服务器端的数据 bootstrap.kubernetes.io/token 启动引导令牌数据 Opaque实验创建 secret[root@k8s-node01 ~]# echo -n admin | base64YWRtaW4=[root@k8s-node01 ~]# echo -n 1f2d1e2e67df | base64MWYyZDFlMmU2N2Rm[root@k8s-node01 ~]# apiVersion: v1kind: Secretmetadata: name: mysecrettype: Opaquedata: # 需要使用 base64 编码后的数据 password: MWYyZDFlMmU2N2Rm username: YWRtaW4= kubectl create -f mysecret.yaml kubectl describe secret mysecret secret环境变量apiVersion: apps/v1kind: Deploymentmetadata: labels: app: opaque-secret-env name: opaque-secret-env-deployspec: replicas: 5 selector: matchLabels: app: op-se-env-pod template: metadata: labels: app: op-se-env-pod spec: containers: - image: wangyanglinux/myapp:v1.0 name: myapp-continaer ports: - containerPort: 80 env: - name: TEST_USER valueFrom: secretKeyRef: name: mysecret key: username - name: TEST_PASSWORD valueFrom: secretKeyRef: name: mysecret key: password 容器中会将编码后的 mysecret 解码。 挂载 secretapiVersion: v1kind: Podmetadata: labels: name: secret-volume name: secret-volume-podspec: volumes: - name: volumes12 secret: secretName: mysecret containers: - image: wangyanglinux/myapp:v1.0 name: myapp-container volumeMounts: - name: volumes12 mountPath: /data 设置挂载目录权限apiVersion: v1kind: Podmetadata: labels: name: secret-volume name: secret-volume-podspec: volumes: - name: volumes12 secret: secretName: mysecret defaultMode: 256 containers: - image: wangyanglinux/myapp:v1.0 name: myapp-container volumeMounts: - name: volumes12 mountPath: /data 挂载单个keyapiVersion: v1kind: Podmetadata: labels: name: secret-volume name: secret-volume-podspec: volumes: - name: volumes12 secret: secretName: mysecret items: - key: username path: my-group/my-username containers: - image: wangyanglinux/myapp:v1.0 name: myapp-container volumeMounts: - name: volumes12 mountPath: /data 单独挂载部分 secret 数据不支持热更新 Secret 热更新当卷中存储并正在使用的 Secret 被更新时，‌映射的键也会随之更新‌。这一过程由组件 kubelet 负责监控，它会‌周期性同步并检查挂载的 Secret 是否为最新版本‌。但值得注意的是，kubelet 在检查过程中，‌会使用其本地缓存的数值作为 Secret 的当前值‌。此外，如果容器是通过 Secret 作为子路径卷挂载的，‌那么该容器将不会收到 Secret 更新的通知‌。 ❌ 子路径挂载（无自动更新）： volumeMounts: - name: secret-vol mountPath: /etc/ssl/private.key # 目标文件路径 subPath: private.key # 仅绑定此键值 更新 Secret 后，容器内文件保持不变。 ✅ 完整卷挂载（支持热更新）： volumeMounts: - name: secret-vol mountPath: /etc/ssl # 挂载整个卷 Secret 更新后，kubelet 会自动同步到 /etc/ssl 目录下。 apiVersion: v1kind: Secretmetadata: name: mysecrettype: Opaquedata: # 需要使用 base64 编码后的数据 password: MWYyZDFlMmU2N2Rm username: YWRtaW4=---apiVersion: v1kind: Podmetadata: labels: name: secret-volume name: secret-volume-podspec: volumes: - name: volumes12 secret: secretName: mysecret containers: - image: wangyanglinux/myapp:v1.0 name: myapp-container volumeMounts: - name: volumes12 mountPath: /data kubectl create -f secret-volume-pod-1.yaml kubectl exec -it secret-volume-pod bin/bashkubectl edit secret mysecret 不可变 apiVersion: v1kind: Secretmetadata: name: mysecret-1type: Opaqueimmutable: truedata: # 需要使用 base64 编码后的数据 password: MWYyZDFlMmU2N2Rm username: YWRtaW4= Downward APIDownward API 是 Kubernetes 提供的一种机制，允许容器在不直接调用 Kubernetes API 的情况下获取自身或集群的元数据。它通过两种方式将 Pod 和容器的字段暴露给运行中的容器：‌环境变量‌和‌文件挂载‌（通过特殊卷类型）。 ‌核心功能 ‌元数据注入‌ 支持注入 Pod 名称、命名空间、标签、注解、资源请求限制等字段。 例如，将 Pod 名称通过环境变量 POD_NAME 传递给容器，供应用程序使用。 ‌动态配置‌ 应用程序可根据运行时信息（如节点 CPU 数量或内存限制）调整行为。例如，Nginx 可通过 Downward API 获取真实 CPU 核心数，动态设置 worker_processes 参数。 ‌低耦合设计‌ 避免在容器内硬编码 Kubernetes 依赖，提升应用的可移植性。 ‌实现方式 ‌方式‌ ‌适用场景‌ ‌示例字段‌ ‌环境变量‌ 注入单个变量（如 Pod IP） metadata.name、status.podIP ‌文件挂载‌ 注入复杂数据（如标签或注解） metadata.labels、metadata.annotations ‌注意‌：并非所有字段都支持两种方式。例如，spec.nodeName 仅支持环境变量注入。 ‌典型应用场景 ‌资源感知‌容器通过 requests.cpu 或 limits.memory 获取资源限制，优化线程或内存分配。 ‌标识传递‌使用 metadata.uid 或 metadata.labels 作为应用唯一标识符。 ‌环境集成‌结合 ConfigMap 或 Secret，实现配置的动态加载。 ‌与 ConfigMapSecret 的区别 Downward API ‌直接暴露 Pod 自身元数据‌，而 ConfigMapSecret 用于外部配置管理。 无需预先定义资源，直接在 Pod 配置中引用即可。 通过 Downward API，Kubernetes 实现了容器与集群环境的无缝集成，同时保持了应用的轻量性和可移植性。 Downward API 实验Downward API 环境变量apiVersion: v1kind: Podmetadata: name: downward-api-env-examplespec: containers: - name: my-container image: wangyanglinux/myapp:v1.0 env: - name: POD_NAME valueFrom: fieldRef: fieldPath: metadata.name - name: POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace - name: POD_IP valueFrom: fieldRef: fieldPath: status.podIP - name: CPU_REQUEST valueFrom: resourceFieldRef: resource: requests.cpu - name: CPU_LIMIT valueFrom: resourceFieldRef: resource: limits.cpu - name: MEMORY_REQUEST valueFrom: resourceFieldRef: resource: requests.memory - name: MEMORY_LIMIT valueFrom: resourceFieldRef: resource: limits.memory restartPolicy: Never kubectl create -f downward-api-env-example.yaml kubectl get pod -o widekubectl exec -it downward-api-env-example bin/bash Downward API 挂载配置apiVersion: v1kind: Podmetadata: name: downward-api-volume-examplespec: containers: - name: my-container image: wangyanglinux/myapp:v1.0 resources: limits: cpu: 1 memory: 512Mi requests: cpu: 0.5 memory: 256Mi volumeMounts: - name: downward-api-volume mountPath: /etc/podinfo volumes: - name: downward-api-volume downwardAPI: items: - path: annotations fieldRef: fieldPath: metadata.annotations - path: labels fieldRef: fieldPath: metadata.labels - path: name fieldRef: fieldPath: metadata.name - path: namespace fieldRef: fieldPath: metadata.namespace - path: uid fieldRef: fieldPath: metadata.uid - path: cpuRequest resourceFieldRef: containerName: my-container resource: requests.cpu - path: memoryRequest resourceFieldRef: containerName: my-container resource: requests.memory - path: cpuLimit resourceFieldRef: containerName: my-container resource: limits.cpu - path: memoryLimit resourceFieldRef: containerName: my-container resource: limits.memory restartPolicy: Never # 支持热更新kubectl label pod downward-api-volume-example domain=www.gaga.com VolumeVolume 的核心作用 ‌数据持久化‌当 Pod 被销毁重建时，Volume 可保留容器产生的数据（如数据库文件），避免数据丢失‌。 ‌容器间数据共享‌同一 Pod 内的多个容器可通过 Volume 共享目录（如 web 服务与日志收集器共享日志路径）‌。 ‌配置注入‌将 ConfigMapSecret 以文件形式挂载到容器内，实现配置动态加载‌。 Volume 的主要类型及特性 类型 适用场景 生命周期 emptyDir 临时缓存、中间计算结果 与 Pod 共存亡‌ hostPath 宿主机目录映射（调试场景） 依赖节点持久化‌ emptyDir‌当Pod被分配给节点时，会创建emptyDir卷的相关信息如下‌： ‌创建与存在‌：Pod被分配至节点时，会首先创建emptyDir卷。只要Pod在该节点运行，该卷就会持续存在。 ‌数据交互‌：Pod中的容器可以读取和写入emptyDir卷中的文件，且该卷可以挂载到每个容器中的相同或不同路径。 ‌数据安全性‌：若容器崩溃，Pod不会被移除，因此emptyDir卷中的数据在容器崩溃时仍然是安全的。 ‌数据删除‌：当Pod从节点中删除时，emptyDir卷中的数据将被永久删除。 ‌应用场景‌：emptyDir可用作暂存空间，如基于磁盘的合并排序或长时间计算崩溃恢复时的检查点；也可在Web服务器容器提供数据时，保存内容管理器容器提取的文件。 apiVersion: v1kind: Podmetadata: name: volume-emptydir-disk-pod namespace: defaultspec: containers: - name: myapp image: wangyanglinux/myapp:v1.0 ports: - containerPort: 80 volumeMounts: - name: logs-volume mountPath: /usr/local/nginx/logs - name: busybox image: wangyanglinux/tools:busybox command: [/bin/sh,-c,touch /logs/access.log tail -f /logs/access.log] volumeMounts: - name: logs-volume mountPath: /logs volumes: - name: logs-volume emptyDir: - 这个 Pod 包含两个容器 (`myapp` 和 `busybox`)，它们共享同一个存储卷 `logs-volume`。- `busybox` 容器会在挂载路径 `/logs` 下创建一个日志文件 `access.log`，并持续输出该文件的内容。- `myapp` 容器则将 `logs-volume` 挂载到了 `/usr/local/nginx/logs`，可以访问 `busybox` 容器生成的日志文件。 ‌kubelet工作目录‌：kubelet的工作目录由root-dir参数控制，默认路径为varlibkubelet。 ‌emptyDir存储机制‌：对于每个使用了 emptyDir: 的pod，kubelet会在其工作目录下创建一个专属目录，格式如varlibkubeletpods{podid}volumeskubernetes.io~empty-dir。 ‌数据存储位置‌：所有放在emptyDir卷中的数据，最终都会存储在node节点的上述指定路径中。 kubectl get pod -o widekubectl get pod volume-emptydir-disk-pod -o yaml# 切换到 node2 节点yum install treecd /var/lib/kubelet/pods/5825bf00-5823-45ee-9490-b110b0520587/volumestree kubernetes.io~empty-dir/ 共享内存apiVersion: v1kind: Podmetadata: name: volume-emptydir-mem namespace: defaultspec: containers: - name: myapp image: wangyanglinux/myapp:v1.0 ports: - containerPort: 80 resources: limits: cpu: 1 memory: 1024Mi requests: cpu: 1 memory: 1024Mi volumeMounts: - name: mem-volume mountPath: /data volumes: - name: mem-volume emptyDir: medium: Memory sizeLimit: 500Mi 📌 实际用途 高速缓存 适用于需要快速读写的数据，如中间计算结果、缓存日志等。 因为使用内存，性能远高于磁盘卷。 跨容器共享数据 同一 Pod 中的多个容器可以通过挂载同一个 emptyDir 卷进行通信或数据共享。 示例中虽只有一个容器，但可扩展为多容器协作场景。 临时文件处理 如图片处理、压缩包解压等操作，完成后即可删除，无需持久化。 ⚠️ 注意事项 易失性：Pod 被删除或重启时，emptyDir 数据将永久丢失。 资源竞争：由于使用内存，需合理配置 sizeLimit 和容器内存请求限制，避免 OOM（Out of Memory）。 适合场景：仅适用于无状态、对性能要求高、不依赖持久化的任务。 hostPathhostPath是Kubernetes中一种特殊的存储卷类型，它允许将宿主机节点上的文件系统路径直接挂载到Pod中。 基本概念与核心特性hostPath卷的主要功能是将工作节点(宿主机)上的特定目录或文件挂载到Pod容器内部，使容器能够直接读写宿主机的文件系统‌。与emptyDir等临时存储不同，hostPath具有以下关键特性： ‌节点级持久化‌：数据生命周期与节点而非Pod绑定，即使Pod被删除，只要新Pod调度到同一节点，数据仍然可用‌。这种特性使其成为最简单的节点级持久化方案。 ‌直接文件系统访问‌：容器获得对宿主机指定路径的完全访问权限，可以读取或修改节点系统文件(取决于配置)‌。这种能力使其成为系统级工具的理想选择。 ‌节点亲和性依赖‌：由于数据存储在特定节点上，使用hostPath的Pod通常需要配置节点亲和性规则，确保总是调度到包含所需数据的节点‌。 典型应用场景hostPath特别适合以下特定需求： ‌系统监控与日志收集‌：监控代理Pod需要访问宿主机的系统日志目录(如varlog)来收集节点级日志信息‌。这是hostPath最常见的生产环境用途。 ‌开发调试工具‌：开发环境中，工具Pod可能需要访问宿主机的Docker套接字(varrundocker.sock)或调试接口，hostPath为此提供了便利‌。 ‌节点特定配置访问‌：当应用需要读取节点特有的配置或硬件信息时(如GPU节点配置)，hostPath是直接有效的解决方案‌。 ‌单节点数据持久化‌：在开发或测试环境中，单节点部署的数据库或缓存可以使用hostPath作为简单的持久化存储‌。但此用法不适合生产环境。 ⚠️ hostPath 注意事项 ‌Pod行为差异‌：由于每个节点上的文件不同，具有相同配置的Pod在不同节点上运行时，其行为可能会有所不同。 ‌Kubernetes调度问题‌：当Kubernetes按照计划添加资源感知调度时，它无法考虑hostPath使用的资源，这可能导致资源分配不均。 ‌hostPath写入权限：在底层主机上创建的文件或目录默认只能由root用户写入。若想在hostPath卷中写入数据，需在特权容器中以root身份运行进程，或修改主机上的文件权限。 hostPath 类型 ‌值‌ ‌行为描述‌ ‌DirectoryOrCreate‌ 若路径不存在，则创建空目录，权限设为0755 ‌Directory‌ 路径下必须已存在目录，否则操作将失败 ‌FileOrCreate‌ 若路径不存在，则创建空文件，权限设为0644 ‌File‌ 路径下必须已存在文件，否则操作将失败 ‌Socket‌ 路径下必须已存在UNIX套接字 ‌CharDevice‌ 路径下必须已存在字符设备 ‌BlockDevice‌ 路径下必须已存在块设备 hostPath 实验apiVersion: v1kind: Podmetadata: name: hostpath-podspec: containers: - image: wangyanglinux/myapp:v1.0 name: myapp volumeMounts: - mountPath: /test-pd name: test-volume volumes: - name: test-volume hostPath: # directory location on host path: /test # this field is optional type: Directory 当检测 /test 目录不存在时不会成功创建 pod。 在 pod 运行的节点2上创建 /test,此时 pod 能够成功创建。 # 在节点2上创建新文件，可以在容器中共享到此文件echo gaga /test/index.html# 在 pod 容器中写入数据到index.html中，节点2中此文件也会变动kubectl exec -it hostpath-pod /bin/bashcd test-pd/echo nihao index.html PVPVC‌PVPVC 基本概念 ‌PV（PersistentVolume）由集群管理员预先配置的存储资源，代表实际的存储设备（如NFS、云存储等），具有独立的生命周期‌。 ‌PVC（PersistentVolumeClaim）用户对存储资源的请求，通过 PVC 声明所需的存储大小和访问模式，Kubernetes会为其匹配符合条件的PV‌。 通过PVPVC的抽象层，Kubernetes实现了存储资源与应用的解耦，支持灵活的动态存储管理‌。 ‌核心特性对比 ‌特性‌ ‌PV‌ ‌PVC‌ ‌创建者‌ 管理员手动或动态制备（StorageClass）‌ 用户按需声明‌ ‌绑定关系‌ 与PVC一对一绑定‌ 绑定后独占PV资源‌ ‌生命周期‌ 独立于Pod存在‌ 随Pod删除可保留或释放（取决于回收策略）‌ 关键配置参数 ‌PVPVC的访问模式 ReadWriteOnce（单节点读写） ReadOnlyMany（多节点只读） ReadWriteMany（多节点读写）‌ ‌PV回收策略 Retain（保留，手动清理） Delete（自动删除存储） Recycle（已废弃，由动态制备替代）‌ PVPVC状态 Available（可用）：表示该资源当前处于空闲状态，未被任何声明所绑定，可供使用。 ‌Bound（已绑定）：意味着该卷已经被某个声明绑定，正在被使用中。 Released（已释放）：声明已被删除，但资源尚未被集群重新声明，处于中间状态，等待被重新分配。 ‌Failed（失败）：指该卷的自动回收过程失败，可能需要手动处理或检查错误原因。 PVC保护PVC保护的主要作用是‌确保正在被Pod使用的PVC不会被从系统中移除‌，从而防止可能因此导致的数据丢失。具体机制如下： ‌活动状态判定‌：当Pod状态为Pending（等待中）且已分配给节点，或Pod为Running（运行中）状态时，相关的PVC被视为处于活动状态。 ‌保护机制‌：一旦启用了PVC保护功能，若用户尝试删除一个正在被Pod使用的PVC，该PVC不会被立即删除。‌删除操作将被推迟‌，直至该PVC不再被任何Pod使用为止。 这样，PVC保护机制有效保障了数据的安全性和持续性。 PVC选择PV机制‌1. 基础匹配规则‌ ‌容量优先‌：PVC会优先选择‌容量≥请求值且差值最小‌的PV（如PVC请求1Gi，存在1Gi和2Gi的PV时优先绑定1Gi）‌。 ‌访问模式‌：PV必须支持PVC声明的访问模式（如ReadWriteOnceReadWriteMany）‌。 ‌StorageClass匹配‌：若PVC指定了storageClassName，则仅匹配同类的PV；未指定时仅匹配未设置StorageClass的PV‌。 ‌2. 高级选择机制‌ ‌标签选择器（Label Selector）PVC可通过 spec.selector 匹配PV的标签，实现精细化筛选（如选择特定性能的SSD存储）‌。 # PVC配置示例spec: selector: matchLabels: tier: ssd ‌静态绑定（volumeName）直接通过spec.volumeName指定PV名称，强制绑定特定PV（需确保PV未被占用）‌。 3. 动态匹配流程‌ ‌静态供应‌：管理员预先创建PV，PVC根据上述规则自动匹配‌。 ‌动态供应：通过StorageClass自动创建PV并绑定PVC，无需手动干预‌。 # StorageClass动态配置示例provisioner: kubernetes.io/aws-ebsparameters: type: gp2 4. 冲突处理与优先级‌ ‌唯一性‌：1个PV只能绑定1个PVC，绑定后状态变为Bound‌。 ‌多PV竞争‌：当多个PV满足条件时，Kubernetes调度器按‌容量最接近‌原则选择‌。 工作流程 ‌静态制备‌：管理员预先创建PV池，PVC通过匹配条件绑定可用PV‌。 ‌动态制备‌：通过StorageClass自动按需创建PV，无需手动干预‌。 ‌绑定与使用‌：PVC绑定PV后，Pod通过volumeMounts挂载PVC实现数据持久化‌。 ‌注意事项 ‌未绑定状态‌：若PVC需求无匹配PV，将无限期等待直至满足条件‌。 ‌安全限制‌：PV的hostPath类型需谨慎配置路径权限（如DirectoryOrCreateFileOrCreate）‌。 PVPVC实验1.安装NFS服务器 # 3个节点执行yum install -y nfs-utils rpcbind# 以node1节点为nfs服务，在node1节点执行下列命令mkdir /nfsdatachmod 666 /nfsdatachown nobody /nfsdatacd /nfsdata/mkdir 1..10echo 1 1/index.htmlecho 2 2/index.htmlecho 3 3/index.htmlecho 4 4/index.htmlecho 5 5/index.htmlecho 6 6/index.htmlecho 7 7/index.htmlecho 8 8/index.htmlecho 9 9/index.htmlecho 10 10/index.htmlecho /nfsdata/1 *(rw,no_root_squash,no_all_squash,sync) /etc/exportsecho /nfsdata/2 *(rw,no_root_squash,no_all_squash,sync) /etc/exportsecho /nfsdata/3 *(rw,no_root_squash,no_all_squash,sync) /etc/exportsecho /nfsdata/4 *(rw,no_root_squash,no_all_squash,sync) /etc/exportsecho /nfsdata/5 *(rw,no_root_squash,no_all_squash,sync) /etc/exportsecho /nfsdata/6 *(rw,no_root_squash,no_all_squash,sync) /etc/exportsecho /nfsdata/7 *(rw,no_root_squash,no_all_squash,sync) /etc/exportsecho /nfsdata/8 *(rw,no_root_squash,no_all_squash,sync) /etc/exportsecho /nfsdata/9 *(rw,no_root_squash,no_all_squash,sync) /etc/exportsecho /nfsdata/10 *(rw,no_root_squash,no_all_squash,sync) /etc/exportssystemctl start rpcbindsystemctl start nfs-serversystemctl restart rpcbindshowmount -e 10.37.129.10# 测试挂载# 在 node2 节点挂载nfsmkdir /nfstestmount -t nfs 10.37.129.10:/nfsdata/1 /nfstest/cd /nfstestumount /nfstest/ 2.部署 PV apiVersion: v1kind: PersistentVolumemetadata: name: nfspv1spec: capacity: storage: 1Gi accessModes: - ReadWriteOnce persistentVolumeReclaimPolicy: Recycle storageClassName: nfs nfs: path: /nfsdata/1 server: 10.37.129.10---apiVersion: v1kind: PersistentVolumemetadata: name: nfspv2spec: capacity: storage: 0.9Gi accessModes: - ReadWriteOnce persistentVolumeReclaimPolicy: Recycle storageClassName: nfs nfs: path: /nfsdata/2 server: 10.37.129.10---apiVersion: v1kind: PersistentVolumemetadata: name: nfspv3spec: capacity: storage: 1.2Gi accessModes: - ReadWriteOnce persistentVolumeReclaimPolicy: Recycle storageClassName: nfs nfs: path: /nfsdata/3 server: 10.37.129.10---apiVersion: v1kind: PersistentVolumemetadata: name: nfspv4spec: capacity: storage: 1Gi accessModes: - ReadWriteOnce persistentVolumeReclaimPolicy: Recycle storageClassName: nfs nfs: path: /nfsdata/4 server: 10.37.129.10---apiVersion: v1kind: PersistentVolumemetadata: name: nfspv5spec: capacity: storage: 1Gi accessModes: - ReadWriteMany persistentVolumeReclaimPolicy: Recycle storageClassName: nfs nfs: path: /nfsdata/5 server: 10.37.129.10---apiVersion: v1kind: PersistentVolumemetadata: name: nfspv6spec: capacity: storage: 1Gi accessModes: - ReadWriteOnce persistentVolumeReclaimPolicy: Recycle storageClassName: nfs1 nfs: path: /nfsdata/6 server: 10.37.129.10---apiVersion: v1kind: PersistentVolumemetadata: name: nfspv7spec: capacity: storage: 1Gi accessModes: - ReadWriteOnce persistentVolumeReclaimPolicy: Retain storageClassName: nfs nfs: path: /nfsdata/7 server: 10.37.129.10 kubectl create -f vp-demo.yaml kubectl get pv 3.创建服务使用PVC apiVersion: v1kind: Servicemetadata: name: nginx labels: app: nginxspec: ports: - port: 80 name: web clusterIP: None selector: app: nginx---apiVersion: apps/v1kind: StatefulSetmetadata: name: webspec: selector: matchLabels: app: nginx serviceName: nginx replicas: 3 template: metadata: labels: app: nginx spec: containers: - name: nginx image: wangyanglinux/myapp:v1.0 ports: - containerPort: 80 name: web volumeMounts: - name: www mountPath: /usr/local/nginx/html volumeClaimTemplates: - metadata: name: www spec: accessModes: [ ReadWriteOnce ] storageClassName: nfs resources: requests: storage: 1Gi 配置解析 Service部分（Headless Service）： apiVersion: v1kind: Servicemetadata: name: nginx labels: app: nginxspec: ports: - port: 80 name: web clusterIP: None # 关键配置：声明为无头服务 selector: app: nginx ‌核心作用‌：为StatefulSet提供稳定的网络标识，每个Pod会获得独立的DNS记录（格式：pod-name.service-name.namespace.svc.cluster.local）‌。 ‌关键特性： clusterIP: None：表示这是一个Headless Service，不分配集群IP，直接通过Pod IP通信‌。 selector：匹配标签为app: nginx的Pod，与StatefulSet的Pod模板一致‌。 StatefulSet部分： apiVersion: apps/v1kind: StatefulSetmetadata: name: webspec: serviceName: nginx # 绑定上述Headless Service replicas: 3 template: metadata: labels: app: nginx spec: containers: - name: nginx image: wangyanglinux/myapp:v1.0 ports: - containerPort: 80 name: web volumeMounts: - name: www mountPath: /usr/local/nginx/html volumeClaimTemplates: # 动态存储声明模板 - metadata: name: www spec: accessModes: [ ReadWriteOnce ] storageClassName: nfs resources: requests: storage: 1Gi ‌核心功能‌：管理有状态应用，确保Pod具有稳定的标识和持久化存储‌。 ‌关键配置： ‌有序部署‌：Pod按顺序创建（如web-0、web-1、web-2），重启后名称不变‌。 ‌存储卷模板： volumeClaimTemplates：为每个Pod动态创建PVC，绑定nfs存储类的1Gi卷‌。 volumeMounts：将卷挂载到容器内的/usr/local/nginx/html路径‌。 ‌服务绑定‌：通过serviceName: nginx关联Headless Service，实现Pod间直接通信‌。 整体协作机制： ‌网络标识‌：StatefulSet Pod通过Headless Service获得唯一DNS，如web-0.nginx.default.svc.cluster.local‌。 ‌数据持久化‌：每个Pod的PVC独立绑定PV，即使Pod重建数据仍保留‌。 kubectl apply -f pvc-demo.yamlkubectl get pod -o widekubectl get pvkubectl get svckubectl get endpointsyum install bind-utils # dig（Domain Information Groper）是一个用于‌DNS查询‌的常用命令行工具，主要用于诊断和调试域名解析问题‌dig -t A nginx.default.svc.cluster.local. @10.0.0.10 # 修改挂载的index.html，删除podkubectl get pod -o widekubectl exec -it web-0 /bin/bash # 修改副本数，此时满足条件的 pv 数不足，所以会卡住kubectl scale statefulset web --replicas 10 # 当我们删除pv对应绑定的pvc时，pv会被释放，此时创建其他pvc不会绑定释放的pvkubectl delete -f pvc-demo.yaml kubectl delete pvc --all # 可以删除pv中引用部分将pv状态修改为活跃 kubectl edit pv nfspv1 StorageClass‌StorageClass（存储类）是Kubernetes中用于动态管理持久化存储的核心对象‌，它定义了存储的类型、供给策略及后端配置，使管理员能够按需自动创建和管理持久卷（PV）‌。 StorageClass‌ 核心功能 ‌动态供给存储‌：根据用户提交的PVC（持久卷声明）自动创建匹配的PV，无需手动预配置存储资源‌。 ‌定义存储类型‌：支持配置不同存储后端（如SSD、HDD、云存储等）的参数（如性能、冗余策略）‌。 ‌生命周期管理‌：通过reclaimPolicy（如Delete或Retain）控制PV的回收行为‌。 ‌关键组成 ‌Provisioner（供应者）：指定存储后端的驱动（如AWS EBS、NFS、Ceph等），负责实际创建PV‌。 ‌Parameters（参数）：定义存储后端的配置（如云存储的区域、磁盘类型）‌。 ‌Binding模式‌：支持Immediate（立即绑定）或WaitForFirstConsumer（延迟绑定至Pod调度）‌。 ‌与PVPVC的关系 ‌PV（持久卷）：由StorageClass动态创建，或由管理员静态预配置‌。 ‌PVC（持久卷声明）：用户通过PVC申请存储资源，StorageClass自动匹配并生成PV‌。 StorageClass‌ 典型应用场景 ‌云原生环境‌：动态分配云存储（如AWS EBS、Azure Disk）以适应弹性扩展需求‌。 ‌混合存储管理‌：为不同业务定义多类StorageClass（如高性能SSD、低成本HDD）‌。 ‌自动化运维‌：减少手动维护PV的工作量，提升集群存储效率‌。 StorageClass‌ 实验nfs-client-provisioner是Kubernetes中的一个供应商，其主要功能是‌动态提供由NFS（Network File System）共享支持的持久卷‌。在Kubernetes集群中，持久卷是独立于Pod存在的存储资源，用于持久地存储数据。nfs-client-provisioner通过以下方式发挥作用： ‌自动化创建持久卷‌：它根据需要自动化创建持久卷，无需手动操作。 ‌与NFS服务器交互‌：通过与NFS服务器进行交互，实现存储的动态分配。 ‌简化管理‌：使得在Kubernetes集群中为应用程序动态分配存储变得更加简单，无需手动管理NFS共享和持久卷的创建过程。 1.添加共享目录 echo /nfsdata/share *(rw,no_root_squash,no_all_squash,sync) /etc/exportsmkdir /nfsdata/sharechown -R nobody /nfsdata/sharesystemctl enable nfs-server systemctl restart nfs-server systemctl restart rpcbindshowmount -e 10.37.129.10 2.创建命名空间 kubectl create ns nfs-storageclass 3.部署 nfs-client-provisioner apiVersion: apps/v1kind: Deploymentmetadata: name: nfs-client-provisioner namespace: nfs-storageclassspec: replicas: 1 selector: matchLabels: app: nfs-client-provisioner strategy: type: Recreate template: metadata: labels: app: nfs-client-provisioner spec: serviceAccountName: nfs-client-provisioner containers: - name: nfs-client-provisioner image: k8s.dockerproxy.com/sig-storage/nfs-subdir-external-provisioner:v4.0.2 volumeMounts: - name: nfs-client-root mountPath: /persistentvolumes env: - name: PROVISIONER_NAME value: k8s-sigs.io/nfs-subdir-external-provisioner - name: NFS_SERVER # value: YOUR NFS SERVER HOSTNAME value: 10.37.129.10 - name: NFS_PATH value: /nfsdata/share volumes: - name: nfs-client-root nfs: # value: YOUR NFS SERVER HOSTNAME server: 10.37.129.10 path: /nfsdata/share---apiVersion: v1kind: ServiceAccountmetadata: name: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: nfs-storageclass---kind: ClusterRoleapiVersion: rbac.authorization.k8s.io/v1metadata: name: nfs-client-provisioner-runnerrules:- apiGroups: [] resources: [nodes] verbs: [get, list, watch]- apiGroups: [] resources: [persistentvolumes] verbs: [get, list, watch, create, delete]- apiGroups: [] resources: [persistentvolumeclaims] verbs: [get, list, watch, update]- apiGroups: [storage.k8s.io] resources: [storageclasses] verbs: [get, list, watch]- apiGroups: [] resources: [events] verbs: [create, update, patch]---kind: ClusterRoleBindingapiVersion: rbac.authorization.k8s.io/v1metadata: name: run-nfs-client-provisionersubjects:- kind: ServiceAccount name: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: nfs-storageclassroleRef: kind: ClusterRole name: nfs-client-provisioner-runner apiGroup: rbac.authorization.k8s.io---kind: RoleapiVersion: rbac.authorization.k8s.io/v1metadata: name: leader-locking-nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: nfs-storageclassrules:- apiGroups: [] resources: [endpoints] verbs: [get, list, watch, create, update, patch]---kind: RoleBindingapiVersion: rbac.authorization.k8s.io/v1metadata: name: leader-locking-nfs-client-provisioner namespace: nfs-storageclasssubjects:- kind: ServiceAccount name: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: nfs-storageclassroleRef: kind: Role name: leader-locking-nfs-client-provisioner apiGroup: rbac.authorization.k8s.io 4.创建StorageClass apiVersion: storage.k8s.io/v1kind: StorageClassmetadata: name: nfs-client namespace: nfs-storageclassprovisioner: k8s-sigs.io/nfs-subdir-external-provisionerparameters: pathPattern: $.PVC.namespace/$.PVC.name onDelete: delete 5.测试 pod apiVersion: v1kind: PersistentVolumeClaimmetadata: name: test-claim annotations: volume.beta.kubernetes.io/storage-class: nfs-clientspec: accessModes: - ReadWriteMany resources: requests: storage: 1Mi storageClassName: nfs-client---apiVersion: v1kind: Podmetadata: name: test-podspec: containers: - name: test-pod image: wangyanglinux/myapp:v1.0 volumeMounts: - name: nfs-pvc mountPath: /usr/local/nginx/html restartPolicy: Never volumes: - name: nfs-pvc persistentVolumeClaim: claimName: test-claim","tags":[null],"categories":[null]},{"title":"Kubernetes常用命令","path":"/wiki/Kubernetes/常用命令.html","content":"常用命令# 获取当前的资源，pod$ kubectl get pod -A,--all-namespaces 查看当前所有名称空间的资源 -n 指定名称空间，默认值 default，kube-system 空间存放是当前组件资源 --show-labels 查看当前的标签 -l 筛选资源，key、key=value -o wide 详细信息包括 IP、分配的节点 -w 监视，打印当前的资源对象的变化部分# 添加标签kubectl label node k8s-node03 domain=xinxianghf# 进入 Pod 内部的容器执行命令$ kubectl exec -it podName -c cName -- command -c 可以省略，默认进入唯一的容器内部 # 查看资源的描述$ kubectl explain pod.spec# 查看 pod 内部容器的 日志$ kubectl logs podName -c cName# 查看资源对象的详细描述$ kubectl describe pod podName# 删除资源对象$ kubectl delete kindName objName --all 删除当前所有的资源对象# 查看 rc 控制器$ kubectl get rc# 查看 rc 控制器$ kubectl get rcDeployment‌ 常用命令#‌创建 Deployment‌：命令：kubectl create -f deployment.yaml --record解释：此命令用于根据 deployment.yaml 文件创建 Deployment。‌--record 参数会记录每次变更，便于后续查看每次修订的变化‌。#‌修改副本数 Deployment‌：命令：kubectl scale deployment nginx-deployment --replicas 10解释：此命令用于调整 nginx-deployment 的副本数为 10。‌通过增加或减少 Pod 数量，确保 Deployment 达到指定的副本规模‌。#‌设置自动缩放‌：命令：kubectl autoscale deployment nginx-deployment --min=10 --max=15 --cpu-percent=80解释：此命令为 nginx-deployment 设置自动缩放规则。‌当 CPU 使用率超过 80% 时，系统会自动增加副本数，最多增加到 15 个；当负载降低时，副本数会自动减少，但不少于 10 个‌。#‌更新 Deployment 镜像‌：命令：kubectl set image deployment/nginx-deployment nginx-deployment-container=wangyanglinux/myapp:v2.0解释：此命令用于更新 nginx-deployment 中的镜像。‌将指定容器的镜像替换为 wangyanglinux/myapp:v2.0，实现应用的版本升级‌。注意，这里的 nginx-deployment-container 应为容器名 。#‌回滚 Deployment‌：命令：kubectl rollout undo deployment/nginx-deployment解释：此命令用于回滚 nginx-deployment 到之前的版本。‌当新版本出现问题时，可以使用此命令快速恢复到之前的稳定版本‌。#删除 Deployment‌：命令：kubectl delete -f deploymentName解释：通过 deployment.yaml 文件去删除对应Deployment‌。#导出资源清单命令: --dry-run -o yaml解释：将命令生成的yaml导出?示例：kubectl create svc clusterip myapp --tcp=80:80 --dry-run -o yaml#命令补全yum install bash-completionsource (kubectl completion bash) 常见报错kubectl get ds -n kube-system calico-nodekubectl rollout restart ds -n kube-system calico-node","tags":[null],"categories":[null]},{"title":"Kubernetes控制器","path":"/wiki/Kubernetes/控制器.html","content":"控制器在 Kubernetes 中运行了一系列控制器来确保集群的当前状态与期望状态保持一致，它们就是 Kubernetes 集群内部的管理控制中心或者说是”中心大脑”。例如，ReplicaSet 控制器负责维护集群中运行的 Pod 数量；Node 控制器负责监控节点的状态，并在节点出现故障时，执行自动化修复流程，确保集群始终处于预期的工作状态。 Pod 控制器ReplicationController（RC）用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的 Pod 来替代；而如果异常多出来的容器也会自动回收； 在新版本的 Kubernetes 中建议使用 ReplicaSet 来取代 ReplicationController。ReplicaSet 跟 ReplicationController 没有本质区别，只是名字不一样，并且 ReplicaSet 支持集合式的 selector。 RC 控制器apiVersion: v1kind: ReplicationControllermetadata: # 设置控制器的名称，在命名空间内唯一 name: rc-testspec: replicas: 3 selector: # 通过标签选择器匹配要管理的Pod app: rc-demo template: metadata: labels: # 为创建的Pod设置标签，需与selector匹配 app: rc-demo spec: containers: - name: rc-demo-container image: wangyanglinux/myapp:v1.0 env: - name: GET_HOSTS_FROM value: dns name: zhangsan value: 123 ports: - containerPort: 80 kubectl apply -f 1-rc-demo.yamlkubectl get podkubectl get rc 可以看到成功运行了三个 pod。 kubectl delete pod rc-test-dln5b 当我们删除其中一个 pod 不满足期望时，会自动创建新的 pod。 kubectl get pod --show-labelskubectl label pod rc-test-4692h version=v1kubectl get pods -l app=rc-demo --show-labels 修改 pod 标签后，当还能通过 selector 选择器匹配到该 pod，则不会重新创建 pod。 kubectl label pod rc-test-lqtl8 app=hahaha --overwrite 当 selector 选择器匹配不到 pod 标签，则会重新创建 pod。 kubectl label pod rc-test-lqtl8 app=rc-demo --overwrite 将 pod 标签改回，可以发现最新创建的 pod 将被删除。 kubectl scale rc rc-test --replicas=10 修改 pod 副本数。 RS 控制器apiVersion: apps/v1kind: ReplicaSetmetadata: # 设置控制器的名称，在命名空间内唯一 name: rs-ml-testspec: replicas: 3 selector: matchLabels: # 通过标签选择器匹配要管理的Pod app: rs-ml-demo template: metadata: labels: # 为创建的Pod设置标签，需与selector匹配 app: rs-ml-demo spec: containers: - name: rs-ml-demo-container image: wangyanglinux/myapp:v1.0 env: - name: GET_HOSTS_FROM value: dns ports: - containerPort: 80 matchLabels 与 rc 功能类似。 selector.matchExpressions rs 在标签选择器上，除了可以定义键值对的选择形式，还支持 matchExpressions 字段，可以提供多种选择。 目前支持的操作包括： In：label 的值在某个列表中 NotIn：label 的值不在某个列表中 Exists：某个 label 存在 DoesNotExist：某个 label 不存在 apiVersion: apps/v1kind: ReplicaSetmetadata: # 设置控制器的名称，在命名空间内唯一 name: rs-me-exists-testspec: replicas: 3 selector: matchExpressions: # pod 存在 key 为 app 的标签就可以匹配上 - key: app operator: Exists template: metadata: labels: app: spring spec: containers: - name: rs-ml-exists-container image: wangyanglinux/myapp:v1.0 ports: - containerPort: 80 只需要 pod 中存在 key 为 app 的标签就能够匹配，修改 app 的值不影响。 apiVersion: apps/v1kind: ReplicaSetmetadata: # 设置控制器的名称，在命名空间内唯一 name: rs-me-in-testspec: replicas: 3 selector: matchExpressions: # pod 存在 app 值为 values 中的标签就可以匹配上 - key: app operator: In values: - spring - haha template: metadata: labels: # key 为 app app: spring2 spec: containers: - name: rs-ml-exists-container image: wangyanglinux/myapp:v1.0 ports: - containerPort: 80 新版 k8s 创建 pod 时会检测容器标签是否符合规则，匹配失败会直接创建失败。 把 spring2 改为 spring。 kubectl apply -f 4-rs-in-demo.yaml kubectl label pod rs-me-in-test-bxprv app=haha --overwritekubectl get pod --show-labels 修改 pod 标签存在列表中时，不会重新创建 pod。 kubectl label pod rs-me-in-test-bxprv app=haha1 --overwritekubectl get pod --show-labels 不存在列表中就会重新创建新的 pod。 DeploymentDeployment 为 Pod 和 ReplicaSet 提供了一个声明式定义 (declarative ) 方法，用来替代以前的 ReplicationController 来方便管理应用。典型的应用场景包括： 定义 Deployment 来创建 Pod 和 ReplicaSet 滚动升级和回滚应用 扩容和缩容 暂停和继续 Deployment 命令式和声明式在Kubernetes中，声明式与命令式是两种不同的操作方式。 ‌声明式‌是对最终结果的陈述，表明意图而非实现过程。例如，在 Kubernetes 中说“应该有一个包含三个 Pod 的 ReplicaSet”，这是一种声明式的表达，它描述了期望的状态，而不是如何达到这个状态。 ‌命令式‌则是主动且直接的命令。比如“创建一个包含三个 Pod 的 ReplicaSet”，这是一个命令式的操作，它直接指示系统执行具体的动作。 综上所述，声明式与命令式在 Kubernetes 中分别代表了描述期望状态和直接执行命令的两种方式。 kubectl replace 和 kubectl apply 区别在Kubernetes中，kubectl replace和kubectl apply是两个常用的命令，用于管理集群中的资源。以下是这两个命令在读取内容并进行操作时的详细区别： ‌一、命令功能‌kubectl replace‌ 功能：使用新的配置完全替换掉现有资源的配置。 特点：新配置将覆盖现有资源的所有字段和属性，包括未指定的字段，导致整个资源的替换。这类似于删除现有资源并重新创建。 ‌kubectl apply‌ 功能：使用新的配置部分地更新现有资源的配置。 特点：根据提供的配置文件或参数，只更新与新配置中不同的部分，而不会覆盖整个资源的配置。这保留了未指定字段的原有值。 ‌二、字段级别更新‌‌kubectl replace‌：完全替换所有字段和属性，无论是否在新配置中指定。 ‌kubectl apply‌：只更新与新配置中不同的字段和属性，保留未指定的字段不受影响。 ‌三、使用场景‌‌kubectl replace‌：适用于需要彻底替换资源配置的场景，如资源配置发生重大变更时。使用前需谨慎，因为替换操作是不可逆的。 ‌kubectl apply‌：适用于需要部分更新资源配置的场景，如仅修改部分配置参数时。它提供了更高的灵活性和并发处理能力，适合在多个用户或进程同时修改同一资源时使用。 四、部分更新‌kubectl replace‌：不支持部分更新。当你使用这个命令时，它会替换整个资源的配置，这意味着资源的所有字段都会被新的配置文件中的值所覆盖。 ‌kubectl apply‌：支持部分更新。这个命令只会更新新配置中发生变化的部分，而保留未指定的部分不受影响。这使得kubectl apply在进行配置更新时更加灵活和高效。 五‌、与其他配置的影响‌‌kubectl replace‌：在替换资源时，不考虑其他资源配置的状态。这意味着即使其他资源依赖于被替换的资源，kubectl replace也不会考虑这些依赖关系，直接进行替换操作。 ‌kubectl apply‌：能够结合使用 -f 或 -k 参数，从文件或目录中读取多个资源配置，并根据当前集群中的资源状态进行更新。这使得 kubectl apply 能够更智能地处理资源之间的依赖关系，确保更新的顺利进行。 ‌总结‌：‌kubectl apply‌更适合进行部分更新和结合多个配置文件进行更新，它能够保留未指定的部分不受影响，并根据当前集群状态进行智能更新。 ‌kubectl replace‌则更加直接和彻底，它会替换整个资源的配置，不考虑其他资源配置的状态。在使用时需要谨慎，以避免对集群造成不必要的影响。 测试apiVersion: apps/v1kind: Deploymentmetadata: labels: app: myapp-deploy name: myapp-deployspec: selector: matchLabels: app: myapp-deploy template: metadata: labels: app: myapp-deploy spec: containers: - image: wangyanglinux/myapp:v1.0 name: myapp # 执行kubectl apply -f 5-deployment-demo1.yaml 可以看到 pod 正常创建。这个时候 pod 个数为 1。 # 修改副本数kubectl scale deploy myapp-deploy --replicas=3 # 修改 pod 版本为 2.0 ... spec: containers: - image: wangyanglinux/myapp:v2.0 name: myapp kubectl apply -f 5-deployment-demo1.yaml 可以看到 pod 数未改变，且版本修改为2.0。 kubectl replace -f 5-deployment-demo1.yaml 使用 kubectl replace 运行时，按照最新的 deployment 文件描述全部重新创建。 Deployment‌ 常用命令 ‌创建 Deployment‌： 命令：kubectl create -f deployment.yaml –record 解释：此命令用于根据 deployment.yaml 文件创建 Deployment。‌--record 参数会记录每次变更，便于后续查看每次修订的变化‌。 缩放 Deployment‌： 命令：kubectl scale deployment nginx-deployment –replicas 10 解释：此命令用于调整 nginx-deployment 的副本数为 10。‌通过增加或减少 Pod 数量，确保 Deployment 达到指定的副本规模‌。 ‌设置自动缩放‌： 命令：kubectl autoscale deployment nginx-deployment –min10 –max15 –cpu-percent80 解释：此命令为 nginx-deployment 设置自动缩放规则。‌当 CPU 使用率超过 80% 时，系统会自动增加副本数，最多增加到 15 个；当负载降低时，副本数会自动减少，但不少于 10 个‌。 更新 Deployment 镜像‌： 命令：kubectl set image deploymentnginx-deployment nginx-deployment-containerwangyanglinuxmyapp:v2.0 解释：此命令用于更新 nginx-deployment 中的镜像。‌将指定容器的镜像替换为 wangyanglinuxmyapp:v2.0，实现应用的版本升级‌。注意，这里的 nginx-deployment-container 应为容器名。 ‌回滚 Deployment‌： 命令：kubectl rollout undo deploymentnginx-deployment 解释：此命令用于回滚 nginx-deployment 到之前的版本。‌当新版本出现问题时，可以使用此命令快速恢复到之前的稳定版本‌。 删除 Deployment‌: 命令：kubectl delete -f deploymentName 解释：通过 deployment.yaml 文件去删除对应Deployment‌。 查询 Deployment 资源文件： 命令：kubectl get deploy deployName -o yaml 解释：kubectl get deploy myapp-deploy -o yaml 查看myapp-deploy资源文件 ‌检查滚动更新状态‌： 命令：kubectl rollout status deployments nginx-deployment ‌功能：此命令用于检查 nginx-deployment 的滚动更新是否完成，以及当前的状态。 ‌查看历史记录‌： 命令：kubectl rollout history deployment/nginx-deployment ‌功能：列出 nginx-deployment 的所有历史版本，包括每个版本的详细信息，如创建时间和哈希值。 ‌回滚到特定版本‌： 命令：kubectl rollout undo deployment/nginx-deployment --to-revision=2 ‌功能：将 nginx-deployment 回滚到第 2 个版本。这对于修复错误或恢复到稳定状态非常有用。 ‌暂停滚动更新‌： 命令：kubectl rollout pause deployment/nginx-deployment ‌功能：暂停 nginx-deployment 的当前滚动更新。这可以在需要暂停更新以进行其他操作时使用。 更新策略在升级时，Deployment能确保只有一定数量的Pod处于down状态。默认情况下，它会保证至少有比期望Pod数量少一个的Pod处于up状态（即‌最多一个Pod不可用‌）。 同时，Deployment也能确保只创建出超过期望数量的一定数量的Pod。默认情况下，它会确保最多比期望Pod数量多一个的Pod处于up状态（即‌最多一个surge‌）。 在（apiVersion: apps/v1）版本的Kubernetes中，关于Pod数量控制的策略将从当前的1-1（即一个down，一个surge）变成25%-25%（即25%的Pod可能处于down状态，同时允许25%的额外Pod处于up状态）。 策略类型使用kubectl explain命令读取Kubernetes部署（Deployment）的spec.strategy.type字段内容时，可以了解到部署策略的相关信息，具体如下： ‌Recreate‌：重新创建方式，即先停止所有旧版本Pod，再创建新版本Pod。 ‌rollingUpdate‌：滚动更新方式，逐步替换旧版本Pod为新版本，以减少服务中断。 ‌maxSurge‌：指定滚动更新过程中允许超出期望副本数的数量，有两种指定方式： 指定数量‌：直接给出具体的超出副本数。 ‌百分比‌：以期望副本数的百分比形式给出。 ‌maxUnavailable‌：指定在滚动更新过程中允许的最大不可用Pod数量，确保服务的高可用性。 这些参数共同控制了 Kubernetes 部署的更新策略，使得管理员可以根据实际需求灵活配置更新方式，以减少对业务的影响。 清理策略可以通过设置 .spec.revisionHistoryLimit 项来控制 deployment 的 revision 历史记录数量。‌默认情况下‌，系统会保留所有的 revision 历史记录。如果将 .spec.revisionHistoryLimit 设置为 ‌0‌，则 Deployment 将不允许进行回退操作，即不会保留任何历史版本。 金丝雀部署金丝雀部署的名字来源于17世纪英国矿井的一个传统方法： ‌一、命名由来‌工人们使用金丝雀作为瓦斯检测指标，因为金丝雀对瓦斯气体十分敏感，微量瓦斯就能让其停止歌唱，高浓度时则会毒发身亡，从而提醒工人紧急撤离。 ‌二、核心思想‌在实际运行环境中，金丝雀部署仅针对一小部分用户或流量测试新版本软件，而大部分用户或流量继续使用旧版本。这种方法可以及早发现新版本中的潜在问题，减少对整个系统的冲击。 ‌三、实施效果‌通过对新版本进行有限范围的实时测试和监控，确保新版本在全面推广前已经过充分验证，提高了软件部署的安全性和稳定性。 kubectl patch deployment deployment-demo -p spec:strategy:rollingUpdate:maxSurge:1,maxUnavailable:0#‌更新滚动更新策略‌：#使用 kubectl patch 命令更新 deployment-demo Deployment 的滚动更新策略。# -maxSurge: 1 表示在更新过程中，允许最多比期望副本数多一个的副本存在。# -maxUnavailable: 0 表示在更新过程中，不允许有任何副本处于不可用状态。kubectl patch deployment deployment-demo --patch spec:template:spec:containers:[name:deployment-demo-container,image:wangyanglinux/myapp:v2.0] kubectl rollout pause deploy deployment-demo#更新容器镜像‌：#再次使用 kubectl patch 命令，这次是为了更新 deployment-demo Deployment 中容器的镜像。#将容器 deployment-demo-container 的镜像更新为 wangyanglinux/myapp:v2.0。#使用 连接了 kubectl rollout pause deploy deployment-demo 命令，用于在镜像更新后立即暂停 Deployment 的滚动更新，确保更新过程的安全性。‌kubectl rollout resume deploy deployment-demo#恢复滚动更新‌：#使用 kubectl rollout resume deploy deployment-demo 命令恢复 Deployment 的滚动更新。#这允许 Kubernetes 根据新的配置和镜像启动新的副本，完成整个更新过程。 DaemonSetDaemonSet 确保在全部或部分 Node 上运行一个 Pod 的副本。具体特性如下： ‌动态调整‌：当有新 Node 加入集群时，会自动为其新增一个 Pod；若 Node 从集群移除，相应的 Pod 也会被回收。 ‌删除机制‌：删除 DaemonSet 会导致其创建的所有 Pod 被删除。 ‌典型用法‌： ‌集群存储‌：在每个 Node 上运行如 glusterd、ceph 等存储 daemon。 ‌日志收集‌：利用 fluentd、logstash 等工具在每个 Node 上收集日志。 ‌系统监控‌：在每个 Node 部署 Prometheus Node Exporter、collectd、Datadog 代理、New Relic 代理或 Ganglia gmond 进行监控。 apiVersion: apps/v1kind: DaemonSetmetadata: name: daemonset-demo labels: app: daemonset-demospec: selector: matchLabels: name: daemonset-demo template: metadata: labels: name: daemonset-demo spec: containers: - name: daemonset-demo-container image: wangyanglinux/myapp:v1.0 kubectl apply -f 6-daemonset-demo.yaml 可以看到 pod 运行在了 node2, node3节点。 注意： master 节点默认是污点节点不参与调度 Job控制器Job负责批处理任务，确保任务的一次性成功执行，可管理一个或多个Pod。 ‌关键参数‌： ‌spec.template：格式与Pod相同，定义了Job中Pod的模板。 ‌RestartPolicy：仅支持Never（从不重启）或OnFailure（失败时重启），控制Pod的重启策略。 ‌Pod结束条件‌：单个Pod成功运行后，默认Job结束（默认返回码为 0 时才是成功）。 .spec.completions：‌标志Job完成所需成功运行的Pod数量‌，默认为1。 .spec.parallelism：‌标志并行运行的Pod数量‌，默认为1。 .spec.activeDeadlineSeconds：‌设置失败Pod的重试最大时长‌，超过则不再重试。 计算 P 的值# -*- coding: utf-8 -*-from __future__ import division# 导入时间模块import time# 计算当前时间time1=time.time()# 算法根据马青公式计算圆周率 #number = 1000# 多计算10位，防止尾数取舍的影响number1 = number+10# 算到小数点后number1位b = 10**number1# 求含4/5的首项x1 = b*4//5# 求含1/239的首项x2 = b // -239# 求第一大项he = x1+x2#设置下面循环的终点，即共计算n项number *= 2#循环初值=3，末值2n,步长=2for i in xrange(3,number,2):# 求每个含1/5的项及符号x1 //= -25# 求每个含1/239的项及符号x2 //= -57121# 求两项之和x = (x1+x2) // i# 求总和he += x# 求出πpai = he*4#舍掉后十位pai //= 10**10# 输出圆周率π的值paistring=str(pai)result=paistring[0]+str(.)+paistring[1:len(paistring)]print resulttime2=time.time()print uTotal time: + str(time2 - time1) + s apiVersion: batch/v1kind: Jobmetadata: name: job-demospec: template: metadata: name: job-demo-pod spec: containers: - name: job-demo-container image: wangyanglinux/tools:maqingpythonv1 restartPolicy: Never kubectl apply -f 6-daemonset-demo.yaml 控制错误码返回为 1apiVersion: batch/v1kind: Jobmetadata: name: randspec: template: metadata: name: rand spec: containers: - name: rand image: wangyanglinux/tools:randexitv1 args: [--exitcode=1] restartPolicy: Never 任务最终执行失败 随机生成返回码apiVersion: batch/v1kind: Jobmetadata: name: randspec: completions: 10 parallelism: 5 template: metadata: name: rand spec: containers: - name: rand image: wangyanglinux/tools:randexitv1 restartPolicy: Never Cron JobCron Job主要用于管理基于时间的任务，具体功能包括： ‌在特定时间点运行一次‌：适用于需要在某个具体时间点执行的任务。 ‌周期性运行‌：可设定在固定的时间点周期性地执行任务，如每天、每周等。 ‌典型用法： ‌调度任务‌：根据设定的时间点自动调度任务运行。 ‌周期性任务‌：如‌数据库备份‌、‌发送邮件‌等，可大大简化运维工作。 ‌使用条件‌：需确保Kubernetes集群版本‌大于等于1.8‌，以支持CronJob功能。 注意：创建 Job 的操作应该是幂等的。 常用参数： ‌.spec.schedule：调度，必需字段，用于指定任务的运行周期，格式与Cron相同。 ‌.spec.jobTemplate：Job模板，必需字段，用于指定需要运行的任务，格式与Job相同。 ‌.spec.startingDeadlineSeconds：启动Job的期限（以秒为单位），该字段可选。若因任何原因错过调度时间，则错过执行时间的Job将被视为失败。若未指定，则无期限限制。 ‌.spec.concurrencyPolicy：并发策略，该字段可选。用于指定如何处理由CronJob创建的Job的并发执行，策略包括： Allow（默认）：允许并发运行Job。 Forbid：禁止并发运行，若前一个Job未完成，则跳过下一个。 Replace：取消当前正在运行的Job，用新的Job替换。 注意‌：并发策略仅适用于由同一个 CronJob 创建的 Job。若存在多个 CronJob，它们创建的 Job 之间允许并发运行。 ‌.spec.suspend‌：此字段用于挂起Job的执行，是可选的。若设置为true，则后续所有计划中的Job执行都会被挂起。但请注意，它对已经开始执行的Job没有影响。默认情况下，该字段的值为false。 ‌spec.successfulJobsHistoryLimit‌ 和 ‌.spec.failedJobsHistoryLimit‌：这两个字段用于设置成功和失败Job的历史记录保留数量，同样是可选的。默认情况下，成功Job的历史记录保留数量为3，失败Job的保留数量为1。如果将这两个字段的值设置为0，则相关类型的Job完成后将不会被保留。 apiVersion: batch/v1kind: CronJobmetadata: name: cronjob-demospec: # 每隔一分钟调一次 schedule: */1 * * * * jobTemplate: spec: # 成功 3 个 pod 任务才算成功 completions: 3 template: spec: containers: - name: cronjob-demo-container image: busybox args: - /bin/sh - -c - date; echo Hello from the Kubernetes cluster restartPolicy: OnFailure","tags":[null],"categories":[null]},{"title":"Kubernetes资源清单","path":"/wiki/Kubernetes/资源清单.html","content":"资源清单什么是资源清单？资源：K8S 中所有的内容都抽象为 资源，资源实例化之后称为 对象‌。 资源清单的作用‌：是与 K8S 集群交互的机制，用于传递配置信息，创建符合预期的 Pod 或其他资源‌。 在 Kubernetes（K8S）中，‌资源‌、‌对象‌和‌资源清单‌是三个核心概念，它们的关系可以用日常生活中的例子来类比： 资源（Resource） ‌通俗解释：资源是 K8S 里的“工具”或“原材料”，每种工具都有特定功能。比如： Pod：像是一个“快递包裹”，里面装着一个或多个容器（比如 Nginx 服务）‌。 Deployment：像“流水线说明书”，告诉 K8S 如何批量管理相同的 Pod（比如始终保持 3 个 Nginx 副本运行）‌。 Service：相当于“电话号码簿”，让其他服务能找到你的 Pod‌。 ‌本质‌：K8S 将计算、存储、网络等能力抽象成不同类型的资源，用户通过操作这些资源来管理应用‌。 对象（Object） ‌通俗解释‌：对象是资源的“具体实例”。比如： 资源是“菜谱”，对象就是“按菜谱做出来的菜”。 你定义一个 Deployment 资源（菜谱），K8S 实际创建的就是一个 Deployment 对象（一盘菜）‌。 ‌关键点‌：对象是运行时存在的实体，持有当前状态（比如 Pod 是否运行正常）‌。 资源清单（Manifest） ‌通俗解释‌：资源清单是“需求说明书”，用 YAML 或 JSON 格式写下你的需求。例如： apiVersion: v1 # 用哪个版本的“工具”（API 版本）kind: Pod # 要创建什么（资源类型）metadata: name: nginx-pod # 实例名称spec: containers: - name: nginx # 容器名 image: nginx # 镜像地址 ‌作用‌：把这份清单提交给 K8S，它就会按你的要求创建并管理对应的对象‌。 三者的关系总结 ‌资源‌是抽象的功能分类（如 Pod、Service）。 ‌对象‌是资源的实际实例（如一个名为 nginx-pod 的 Pod）。 ‌资源清单‌是生成对象的“配方”（YAMLJSON 文件）‌。 ‌类比‌： 资源 乐高积木的类型（比如车轮、窗户）。 对象 拼好的乐高模型（比如一辆车）。 资源清单 拼装说明书（告诉你怎么拼）‌。 通过这种机制，K8S 实现了对应用的声明式管理（你只需描述“想要什么”，而非“如何做”）‌。 资源类型命名空间级别工作负载型资源 (Workload)用于管理容器化应用的生命周期： Pod：最基本的可调度单位，包含一个或多个容器‌。 Deployment：管理无状态应用，支持滚动更新和回滚‌。 StatefulSet：管理有状态应用，提供稳定的存储和唯一标识‌。 DaemonSet：确保每个节点运行一个 Pod 副本‌。 Job CronJob：用于一次性或定时任务‌。 服务发现及负载均衡型资源‌ Service：定义服务端点，实现内部或外部访问和负载均衡‌。 Ingress：管理外部访问的路由规则‌。 配置与存储型资源 Volume：提供持久化存储支持‌。 ConfigMap Secret：分别存储非敏感配置和敏感数据‌。 CSI：扩展第三方存储接口‌。 集群级资源‌ Namespace：逻辑隔离资源，支持多租户管理‌。 Node：代表集群中的物理或虚拟机‌。 元数据型资源 HPA (HorizontalPodAutoscaler)：基于指标自动扩缩容‌。 LimitRange：定义资源限制范围‌。 资源的编写结构资源清单必须包含以下核心字段‌： apiVersion: group/version # 资源所属的 API 组和版本kind: ResourceType # 资源类型（如 Deployment、Service）metadata: # 元数据 name: string # 资源名称 namespace: string # 所属命名空间（可选）默认是spec: # 资源的详细配置 containers: # 容器列表（以 Pod 为例） - name: string # 容器名称 image: string # 容器镜像 imagePullPolicy: Always|Never|IfNotPresent # 镜像拉取策略（可选） 资源清单的字段需严格遵循 K8S API 规范，可通过 kubectl explain 命令查询字段定义‌。 示例apiVersion: v1kind: Podmetadata: name: pod-demo namespace: default labels: app: myappspec: containers: - name: myapp-1 image: wangyanglinux/myapp:v1.0 - name: busybox-1 image: wangyanglinux/tools:busybox command: - /bin/sh - -c - sleep 3600 创建Pod kubectl create -f 1-pod-demo.yaml 查看pod详细信息 kubectl describe pod pod-demo(pod名称) 可以看到pod创建过程中的事件： 错误排查apiVersion: v1kind: Podmetadata: name: pod-demo-1 namespace: default labels: app: myappspec: containers: - name: myapp-1 image: wangyanglinux/myapp:v1.0 - name: myapp-2 image: wangyanglinux/myapp:v1.0 cp 1-pod-demo.yaml 2-pod-demo.yaml kubectl apply -f 2-pod-demo.yaml 可以看到 pod-demo-1 创建失败 排查错误： kubectl describe pod pod-demo-1 进入容器查看日志： kubectl logs pod-demo-1 -c myapp-2","tags":[null],"categories":[null]},{"title":"Kubernetes调度器","path":"/wiki/Kubernetes/调度器.html","content":"调度器调度器核心概念Kubernetes调度器(kube-scheduler)是集群控制平面的核心组件，负责将新创建的Pod分配到合适的节点(Node)上运行。 调度器核心作用 ‌资源匹配‌：根据Pod的资源请求(CPU内存等)和节点可用资源进行匹配‌。 ‌策略执行‌：通过预设规则(如节点亲和性、污点容忍等)优化Pod分布‌。 ‌高可用保障‌：确保Pod分散在多个节点，避免单点故障‌。 调度三阶段流程 ‌预选阶段(PredicatesFilter) 过滤不符合硬性条件的节点，检查项包括： 资源可用性(节点剩余资源 ≥ Pod请求)‌ 节点选择器(nodeSelector)匹配‌ 污点容忍(Taints Tolerations)‌ Pod亲和性规则(Pod Affinity)‌ ‌优选阶段(PrioritiesScore) 对通过预选的节点进行多维评分： 资源均衡(利用率越低得分越高)‌ 镜像本地化(已存在所需镜像的节点优先)‌ 拓扑分布(同可用区机架优先)‌ 最终选择综合得分最高的节点‌ ‌绑定阶段(Binding) 将Pod的nodeName字段设置为选中节点并写入etcd‌ 目标节点的kubelet监听到变化后启动Pod‌ 关键调度策略 ‌节点亲和性(Node Affinity) requiredDuringScheduling: 必须满足的硬性规则‌ preferredDuringScheduling: 优先满足的软性规则‌ ‌污点与容忍(Taints Tolerations) 通过污点标记节点特殊状态(如专用节点)‌ Pod需声明对应容忍才能调度‌ ‌优先级与抢占(Priority Preemption) 高优先级Pod可抢占低优先级Pod的资源‌ 需预先定义PriorityClass对象‌ 架构演进从Kubernetes 1.15开始，调度框架逐步从PredicatesPriorities两阶段模型转变为多阶段插件架构(FilterScore)，增强了扩展性和精细化控制能力‌。当前主流版本支持通过ComponentConfig灵活配置插件及其执行顺序‌。 典型调度过程示例：当创建需2核CPU的Pod时，调度器会先过滤出剩余CPU≥2核的节点，再根据资源均衡、亲和性等策略选择最优节点，最终完成绑定并触发Pod创建‌。 调度器实验# 在 kubernetes Master 节点开启 apiServer 的代理kubectl proxy --port=8001 # 基于 shell 编写一个自定义调度器# vi my-scheduler.sh# yum -y install epel-release# yum -y install jq#!/bin/bashSERVER=localhost:8001while true; do # 获取使用my-scheduler且未分配节点的Pod列表 for PODNAME in $(kubectl --server $SERVER get pods -o json | jq .items[] | select(.spec.schedulerName == my-scheduler) | select(.spec.nodeName == null) | .metadata.name | tr -d ) do # 获取所有节点列表 NODES=($(kubectl --server $SERVER get nodes -o json | jq .items[].metadata.name | tr -d )) NUMNODES=$#NODES[@] # 随机选择节点 CHOSEN=$NODES[$[ $RANDOM % $NUMNODES ]] # 创建绑定请求 curl --header Content-Type:application/json --request POST --data apiVersion:v1,kind:Binding,metadata: name:$PODNAME,target:apiVersion:v1,kind: Node, name: $CHOSEN http://$SERVER/api/v1/namespaces/default/pods/$PODNAME/binding/ echo Assigned $PODNAME to $CHOSEN done sleep 1done # 不指定调度器apiVersion: apps/v1kind: Deploymentmetadata: labels: app: myapp name: myappspec: replicas: 1 selector: matchLabels: app: myapp template: metadata: labels: app: myapp spec: containers: - image: wangyanglinux/myapp:v1.0 name: myapp vi 1-pod-demo.yamlkubectl create -f 1-pod-demo.yaml -o yaml 不指定调度器，默认使用 default-scheduler apiVersion: apps/v1kind: Deploymentmetadata: labels: app: myapp name: myappspec: replicas: 1 selector: matchLabels: app: myapp template: metadata: labels: app: myapp spec: schedulerName: my-scheduler containers: - image: wangyanglinux/myapp:v1.0 name: myapp chmod 777 my-scheduler.shsh my-scheduler.shkubectl apply -f 2-pod-my-scheduler.yaml 节点亲和性Kubernetes节点亲和性(Node Affinity)是通过节点标签控制Pod调度的核心机制，相比简单的nodeSelector提供更精细化的调度策略‌。 节点亲和性基本概念节点亲和性允许基于节点标签定义调度规则，决定Pod应该(或不应该)运行在哪些节点上‌。 ‌定向调度‌：如将GPU应用调度到带GPU标签的节点‌。 ‌拓扑约束‌：如将服务分散到不同可用区实现高可用‌。 节点亲和性核心类型硬亲和性(Required) ‌规则标识‌：requiredDuringSchedulingIgnoredDuringExecution ‌特点‌：必须满足的强制性规则，否则Pod保持Pending状态‌。 ‌典型场景： affinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: gpu-type operator: In values: [a100] 软亲和性(Preferred) ‌规则标识‌：preferredDuringSchedulingIgnoredDuringExecution ‌特点‌：优先但不强制满足，通过权重(weight)实现优先级区分 ‌软性要求‌：比如你希望对象「最好」会做饭（权重80），「其次」喜欢宠物（权重 50）。不会做饭也能接受，但会的话更优先考虑。 ‌权重作用‌：系统会给符合条件的节点打分： 会做饭的+80分 喜欢宠物的+50分 最终选总分最高的 ‌兜底机制‌：即使没有完全匹配的节点（比如没人会做饭），Pod也能被调度到其他节点， 不会卡住。 ‌典型场景： affinity: nodeAffinity: preferredDuringSchedulingIgnoredDuringExecution: - weight: 80 preference: matchExpressions: - key: zone operator: In values: [east-1] 关键操作符 操作符 作用 示例场景 InNotIn 标签值是否在集合内外 调度到特定可用区(zoneeast)‌ Exists 只需存在标签键(不校验值) 识别GPU节点(gpu标签存在)‌ DoesNotExist 标签键必须不存在 避开维护节点(maintenance标签)‌ GtLt 数值比较(适用于CPU内存等数值型标签) 要求节点剩余内存8Gi‌ 高级特性 ‌多条件组合‌： 同一nodeSelectorTerms内多个matchExpressions是AND关系‌ 不同nodeSelectorTerms之间是OR关系‌ nodeSelectorTerms:- matchExpressions: # 必须同时满足A和B - key: A operator: Exists - key: B operator: In values: [v1]- matchExpressions: # 或满足C - key: C operator: Exists ‌动态容忍‌： IgnoredDuringExecution表示节点标签变化不会驱逐已运行的Pod‌ 需配合requiredDuringSchedulingRequiredDuringExecution实现动态重调度(实验特性)‌ 对比其他机制 特性 nodeSelector 节点亲和性 污点容忍 表达能力 仅精确匹配 支持复杂逻辑运算‌ 基于排斥机制‌ 强制程度 强制 可硬软约束‌ 强制 典型应用场景 简单环境部署 精细化调度‌ 节点隔离专用‌ 最佳实践 ‌标签规划‌：提前设计节点标签体系(如env=prod、disk=ssd等)‌ ‌权重分配‌：软亲和性中合理设置weight(1-100)区分优先级‌ ‌拓扑约束‌：结合topologyKey实现机架可用区级别的分布‌ ‌性能考量‌：避免使用大量复杂规则增加调度器负载 节点亲和性实验软策略apiVersion: v1kind: Podmetadata: name: node-affinity-preferred labels: app: node-affinity-preferredspec: containers: - name: node-affinity-preferred-pod image: wangyanglinux/myapp:v1.0 affinity: nodeAffinity: preferredDuringSchedulingIgnoredDuringExecution: - weight: 1 preference: matchExpressions: - key: domain operator: In values: - xinxianghf 当前节点并没有匹配的标签，此时 pod 也能够成功部署。 # 给节点3添加标签kubectl label node k8s-node03 domain=xinxianghf 此时可以看到 pod 被调度到节点3了。 硬策略apiVersion: v1kind: Podmetadata: name: node-affinity-required labels: app: node-affinity-requiredspec: containers: - name: node-affinity-required-pod image: wangyanglinux/myapp:v1.0 affinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: kubernetes.io/hostname operator: In values: - k8s-node04 没有匹配上亲和性的节点 pod 不会部署成功。 Pod亲和性Kubernetes ‌Pod 亲和性（Pod Affinity）‌ 是一种调度策略，用于控制 Pod 如何与其他 Pod 共同调度在同一个节点（亲和）或避免调度在一起（反亲和）。它比节点亲和性更精细，因为它基于 ‌Pod 之间的关系‌ 而非节点标签来决策。 ‌Pod 亲和性的核心概念Pod 亲和性分为两种： ‌Pod 亲和（Pod Affinity）：让 Pod 尽量调度到某些 Pod 所在的节点（例如：前端 Pod 尽量和后端 Pod 在同一节点）。 ‌Pod 反亲和（Pod Anti-Affinity）：让 Pod 避免调度到某些 Pod 所在的节点（例如：同一服务的多个副本避免在同一节点，提高容灾能力）。 Pod 亲和性同样支持 ‌硬性（Required） 和 ‌软性（Preferred） 两种规则： ‌硬性（Required）：必须满足，否则 Pod 无法调度（Pending）。 ‌软性（Preferred）：尽量满足，但不强制，通过 weight（1-100）调整优先级。 Pod 亲和性的关键配置topologyKey：决定亲和性的作用范围Pod 亲和性依赖 topologyKey 来定义“拓扑域”，常见的 topologyKey 包括： kubernetes.io/hostname（同一节点） topology.kubernetes.io/zone（同一可用区） topology.kubernetes.io/region（同一区域） ‌示例‌： affinity: podAffinity: requiredDuringSchedulingIgnoredDuringExecution: - labelSelector: matchExpressions: - key: app operator: In values: [backend] topologyKey: kubernetes.io/hostname # 必须和 backend Pod 在同一节点 labelSelector：匹配目标 PodPod 亲和性通过 labelSelector 选择要亲和或反亲和的 Pod。 ‌示例‌： affinity: podAntiAffinity: requiredDuringSchedulingIgnoredDuringExecution: - labelSelector: matchExpressions: - key: app operator: In values: [frontend] topologyKey: kubernetes.io/hostname # 避免和 frontend Pod 在同一节点 亲和性匹配规则在 Kubernetes 中，Pod 亲和性反亲和性调度时，labelSelector 和 topologyKey 的匹配规则遵循以下逻辑顺序和交互关系。 ‌匹配流程的先后规则 ‌labelSelector 优先匹配 调度器首先根据 labelSelector 筛选出符合条件的 ‌目标 Pod‌（例如 app=backend 的 Pod）。 匹配逻辑支持 In、NotIn、Exists 等操作符，且同一 matchExpressions 内多个条件是 ‌AND 关系‌，不同 matchExpressions 之间是 ‌OR 关系‌。 ‌topologyKey 定义作用域 在找到目标 Pod 后，调度器根据 topologyKey（如 hostname、zone）确定这些 Pod 所在的 ‌拓扑域‌（如节点、可用区）。 节点必须拥有 topologyKey 指定的标签(是标签不是标签值)，否则会被排除（例如节点无 zone 标签时，无法参与基于 zone 的调度）。 ‌最终调度决策‌ 对于 ‌亲和性‌：新 Pod 会被调度到目标 Pod 所在的拓扑域（如相同节点或可用区）。 对于 ‌反亲和性‌：新 Pod 会避免调度到目标 Pod 所在的拓扑域。 关键交互规则 ‌依赖关系‌：labelSelector 的匹配结果是 topologyKey 计算的前提。若没有 Pod 匹配 labelSelector，则 topologyKey 规则不生效（硬性规则会导致调度失败，软性规则会被忽略）。 ‌作用域隔离‌：topologyKey 的值（标签）（如 hostname 或 zone）决定了亲和性反亲和性的影响范围。 hostname：确保 Pod 在同一节点或不同节点。 zone：确保 Pod 在同一可用区或跨可用区分布。 ‌动态调整‌：若目标 Pod 的拓扑分布变化（如节点标签更新），调度器会重新计算亲和性反亲和性约束。 ‌场景 1：Pod 亲和性‌affinity: podAffinity: requiredDuringSchedulingIgnoredDuringExecution: - labelSelector: matchExpressions: - key: app operator: In values: [backend] # 1. 先匹配 app=backend 的 Pod topologyKey: kubernetes.io/hostname # 2. 再确保新 Pod 与这些 Pod 在有 `kubernetes.io/hostname` 标签的节点上 ‌执行顺序‌： 找到所有 app=backend 的 Pod。 统计这些 Pod 所在的节点（根据 hostname 标签）。 将新 Pod 调度到这些节点之一。 ‌场景 2：Pod 反亲和性（高可用）affinity: podAntiAffinity: requiredDuringSchedulingIgnoredDuringExecution: - labelSelector: matchExpressions: - key: app operator: In values: [redis] # 1. 先匹配 app=redis 的 Pod topologyKey: topology.kubernetes.io/zone # 2. 再避免新 Pod 与这些 Pod 在同一可用区 ‌执行顺序‌： 找到所有 app=redis 的 Pod。 统计这些 Pod 所在的可用区（根据 zone 标签）。 将新 Pod 调度到其他可用区的节点。 ‌匹配注意事项 ‌硬性规则风险‌：若 labelSelector 无匹配项且规则为 requiredDuringScheduling，Pod 将无法调度。 ‌软性规则灵活性‌：preferredDuringScheduling 会尝试满足条件，但允许失败，并通过 weight 调整优先级。 ‌标签一致性‌：确保目标 Pod 和节点的标签正确，否则规则可能失效。 通过合理组合 labelSelector 和 topologyKey，可以实现精细化的 Pod 调度策略，优化资源利用和高可用性。 ‌Pod 亲和性 vs. 节点亲和性 特性 Pod 亲和性 节点亲和性 ‌决策依据‌ 基于其他 Pod 的标签 基于节点标签 ‌适用场景‌ 微服务共置、高可用 硬件环境调度（如 GPU 节点） ‌灵活性‌ 更精细（基于 Pod 关系） 较粗粒度（基于节点属性） ‌**典型 topologyKey**‌ hostname、zone、region 无（直接匹配节点标签） ‌Pod 亲和性总结 ‌Pod 亲和性‌ 适用于需要 Pod 紧密协作的场景（如微服务共置）。 ‌Pod 反亲和性‌ 适用于高可用和资源隔离场景（如避免单点故障）。 ‌topologyKey‌ 决定亲和性的作用范围（节点、可用区、区域）。 ‌硬性规则（Required） 确保严格调度，‌软性规则（Preferred） 提供灵活性。 通过合理使用 Pod 亲和性，可以优化 Kubernetes 集群的资源利用率和应用稳定性。 Pod 亲和性实验亲和性软策略apiVersion: v1kind: Podmetadata: name: pod-aff-prefer labels: app: pod-affspec: containers: - name: myapp image: wangyanglinux/myapp:v1.0 affinity: podAffinity: preferredDuringSchedulingIgnoredDuringExecution: - weight: 1 podAffinityTerm: labelSelector: matchExpressions: - key: app operator: In values: - pod-1 topologyKey: kubernetes.io/hostname apiVersion: v1kind: Podmetadata: name: node-affinity-preferred labels: app: node-affinity-preferredspec: containers: - name: node-affinity-preferred-pod image: wangyanglinux/myapp:v1.0 affinity: nodeAffinity: preferredDuringSchedulingIgnoredDuringExecution: - weight: 1 preference: matchExpressions: - key: domain operator: In values: - xinxianghf # 先部署一个 pod 到节点3kubectl apply -f node-affinity-preferred-pod.yaml # 添加 pod 标签kubectl label pod node-affinity-preferred app=pod-1 --overwritekubectl apply -f pod-aff-prefer.yaml 可以看到 pod-aff-prefer 也被部署到了节点3。 亲和性硬策略apiVersion: v1kind: Podmetadata: name: pod-aff-req labels: app: pod-aff-reqspec: containers: - name: pod-aff-req-c image: wangyanglinux/myapp:v1.0 affinity: podAffinity: requiredDuringSchedulingIgnoredDuringExecution: - labelSelector: matchExpressions: - key: app operator: In values: - pod-2 topologyKey: kubernetes.io/hostname kubectl delete pod --allkubectl apply -f pod-aff-req.yaml 没有匹配到亲和 Pod 不能够成功部署。 反亲和性软策略apiVersion: v1kind: Podmetadata: name: pod-antiaff-prefer labels: app: pod-affspec: containers: - name: myapp image: wangyanglinux/myapp:v1.0 affinity: podAntiAffinity: preferredDuringSchedulingIgnoredDuringExecution: - weight: 1 podAffinityTerm: labelSelector: matchExpressions: - key: app operator: In values: - pod-1 topologyKey: kubernetes.io/hostname apiVersion: v1kind: Podmetadata: name: node-affinity-preferred-1 labels: app: pod-1spec: containers: - name: node-affinity-preferred-pod-1 image: wangyanglinux/myapp:v1.0 affinity: nodeAffinity: preferredDuringSchedulingIgnoredDuringExecution: - weight: 1 preference: matchExpressions: - key: domain operator: In values: - xinxianghf-1 apiVersion: v1kind: Podmetadata: name: node-affinity-preferred labels: app: pod-1spec: containers: - name: node-affinity-preferred-pod image: wangyanglinux/myapp:v1.0 affinity: nodeAffinity: preferredDuringSchedulingIgnoredDuringExecution: - weight: 1 preference: matchExpressions: - key: domain operator: In values: - xinxianghf # 给节点2添加标签kubectl label node k8s-node02 domain=xinxianghf-1# 先部署2个 pod 到节点2、3kubectl apply -f node-affinity-preferred-pod.yaml kubectl apply -f node-affinity-preferred-pod-1.yaml # 部署反亲和 podkubectl apply -f pod-antiaff-prefer.yaml 可以看到即使有匹配的反亲和 pod 的节点，该 pod 也能部署成功。 反亲和性硬策略apiVersion: v1kind: Podmetadata: name: pod-antiaff-req labels: app: pod-antiaff-reqspec: containers: - name: pod-antiaff-req-c image: wangyanglinux/myapp:v1.0 affinity: podAntiAffinity: requiredDuringSchedulingIgnoredDuringExecution: - labelSelector: matchExpressions: - key: app operator: In values: - pod-1 topologyKey: kubernetes.io/hostname kubectl apply -f pod-antiaff-req.yaml kubectl get pod -o wide --show-labels 污点和容忍污点和容忍核心概念 ‌污点(Taints) 定义在节点(Node)上的标记，用于限制 Pod 的调度‌。 本质是键值对+效果(effect)的组合：key=value:effect‌。 被标记的节点不一定是故障节点，可能是特殊用途节点（如GPU节点、生产环境节点等）。‌ ‌容忍度(Tolerations) 定义在 Pod 上的属性，允许 Pod 调度到带有匹配污点的节点‌。 与污点成对出现，形成调度策略的互斥机制‌。 污点的组成参数 ‌key‌ 污点的分类标识（如 accelerator、env）‌。 示例：accelerator=gpu:NoSchedule 标识GPU节点‌。 ‌value‌ 污点的具体值（如 nvidia、prod）‌。 可为空但需保留等号（如 disk=:NoSchedule）‌。 ‌effect‌ 定义排斥等级，支持三种效果： NoSchedule：禁止调度新Pod（已运行的Pod不受影响）‌。 PreferNoSchedule：尽量不调度（柔性限制）‌。 NoExecute：驱逐不能容忍的已运行Pod‌。 容忍类型在 Kubernetes 中，容忍度(Tolerations)的 operator 字段定义了容忍规则与污点的匹配方式，支持以下两种主要类型： Equal（精确匹配）： ‌功能‌：要求 Pod 容忍度的 key、value 和 effect 必须与节点污点的对应字段完全一致。 ‌典型配置‌： tolerations:- key: gpu operator: Equal value: nvidia # 必须与污点的value完全匹配 effect: NoSchedule ‌适用场景‌：需要严格限制 Pod 只能容忍特定值的污点（如专用硬件节点）。 ‌Exists（存在性匹配）： ‌功能‌：仅需容忍度的 key 和 effect 与污点匹配，忽略 value 字段（即使污点有value）。 ‌典型配置： tolerations:- key: env operator: Exists # 无需指定value effect: NoExecute ‌适用场景‌：容忍某一类污点（如所有环境隔离标签）。 特殊规则： 当 operator 为 Exists 时，若未指定 key 则表示容忍所有污点（极端情况，慎用）。 若未显式定义 operator，默认行为等同于 Equal。 两种操作符的对比： 类型 匹配要求 灵活性 Equal 完全匹配keyvalueeffect 低 Exists 仅匹配keyeffect，忽略value 高 通过合理选择操作符，可以实现从精确控制到宽松匹配的调度策略。 污点和容忍的典型应用场景 ‌专用节点隔离‌ 例如：GPU节点仅允许机器学习任务 Pod 调度‌。 实现方式：节点添加污点 + 特定 Pod 配置容忍‌。 ‌节点维护‌ 维护前给节点打 NoExecute 污点，自动驱逐 Pod‌。 ‌环境区分‌ 生产测试环境节点通过不同污点隔离‌。 操作示例 ‌添加删除污点‌ # 添加污点kubectl taint nodes node1 env=prod:NoSchedule# 删除污点kubectl taint nodes node1 env=prod:NoSchedule- ‌Pod 容忍度配置‌ tolerations:- key: env operator: Equal value: prod effect: NoSchedule ‌容忍特殊类型当不指定 value 时，表示容忍所有的污点 value； tolerations:- key: key operator: Exists effect: NoSchedule 当不指定 key 值时，表示容忍所有的污点; tolerations:- operator: Exists 当不指定 effect 值时，表示容忍所有的污点作用; tolerations:- key: key operator: Exists 污点、容忍实验污点实验kubectl describe node k8s-node01 可以看到 master 节点设置了一个污点, 所以 pod 默认都会被调度到2、3节点。 # 去除污点kubectl taint nodes k8s-node01 node-role.kubernetes.io/control-plane=:NoSchedule-kubectl describe node k8s-node01# 完成实验修改回kubectl taint nodes k8s-node01 node-role.kubernetes.io/control-plane=:NoSchedule apiVersion: apps/v1kind: Deploymentmetadata: labels: app: myapp name: myappspec: replicas: 10 selector: matchLabels: app: myapp template: metadata: labels: app: myapp spec: containers: - image: wangyanglinux/myapp:v1.0 name: myapp 可以看到 pod 也部署到了 node1 节点。 容忍实验apiVersion: apps/v1kind: Deploymentmetadata: labels: app: myapp name: myappspec: replicas: 10 selector: matchLabels: app: myapp template: metadata: labels: app: myapp spec: tolerations: - operator: Exists containers: - image: wangyanglinux/myapp:v1.0 name: myapp 添加容忍污点后，pod 也可以被调度到 node1 节点。 固定调度固定节点调度是 Kubernetes 中强制将 Pod 分配到特定节点的机制，主要通过以下两种方式实现。 nodeName 强制调度 ‌原理‌：直接跳过默认调度器，将 Pod 绑定到指定节点名称‌。 ‌特点： 完全绕过调度器的过滤打分流程，无视节点资源状态和污点‌。 节点不存在或资源不足时，Pod 会持续处于 Pending 状态‌。 ‌示例配置： spec: nodeName: node01 # 精确指定节点名称 nodeSelector 标签选择调度 ‌原理‌：通过节点标签（Label）匹配选择目标节点‌。 ‌特点： 需预先给节点打标签（如 disktype=ssd）‌。 支持多标签组合匹配（AND 逻辑）‌。 仍受节点资源条件和污点限制‌。 ‌示例配置： spec: nodeSelector: disktype: ssd gpu: true 对比与适用场景 方式 灵活性 调度器干预 典型场景 nodeName 低 完全跳过 调试、特殊硬件依赖场景‌ nodeSelector 高 部分参与 常规固定节点需求‌ 固定调度注意事项 ‌nodeName 风险‌：节点故障会导致 Pod 不可用，需配合健康检查‌。 ‌标签管理‌：确保节点标签与调度需求严格匹配，避免误调度‌。 ‌资源冲突‌：固定调度可能加剧节点资源碎片化，建议设置资源限制。 固定调度实验nodeName 实验apiVersion: apps/v1kind: Deploymentmetadata: labels: app: myapp name: myappspec: selector: matchLabels: app: myapp template: metadata: labels: app: myapp spec: nodeName: k8s-node01 containers: - image: wangyanglinux/myapp:v1.0 name: myapp 无视了 node1 节点的污点。 nodeSelector 实验apiVersion: apps/v1kind: Deploymentmetadata: name: nodeselect-testspec: replicas: 2 selector: matchLabels: app: nodeselect template: metadata: labels: app: nodeselect spec: nodeSelector: type: nodeselect containers: - name: myweb image: wangyanglinux/myapp:v1.0 ports: - containerPort: 80 # 给 node1 节点添加 nodeselect 标签kubectl label node k8s-node01 type=nodeselectkubectl apply -f nodeselect-test.yaml 可以看到 pod 都处于 Pending 状态，因为只有 node1 节点有 typenodeselect 标签，但是该节点存在污点，所以 pod 调度不到该节点。 # 给 node2 节点添加 nodeselect 标签kubectl label node k8s-node02 type=nodeselect","tags":[null],"categories":[null]},{"title":"MySQL中一条select语句是如何执行的？","path":"/wiki/MySQL/MySQL1.html","content":"一条SQL查询语句的执行基础准备 我们先创建一张表 create table learnhub.user_test( id bigint null, name varchar(255) null, age int null);insert into user_test (id, name, age) values (1, 张三, 18); 执行查询 select * from user_test where id = 1; 执行完这条sql后我们能获取到一个结果。 这里就有个问题mysql内部是如何执行的呢？ 经过哪些步骤给我们返回了这样的一条数据？ 带着这两个问题我们先来认识MySQL的基础架构。 基础架构下面是MySQL的基本架构示意图，从中你可以清楚地看到SQL语句在MySQL的各个功能模块中的执行过程。 大体来说，MySQL分为Server层和引擎层两部分。 Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能。 而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。 连接器我们要执行sql语句，首先就要输入用户名、密码先连接上MySQL。这个连接MySQL的过程主要就是通过连接器。连接器会对输入的用户名和密码进行认证。 如果用户名或密码不对，你就会收到一个Access denied for user的错误，然后客户端程序结束执行。 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。 这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。 连接完成后我们可以使用show processlist来查看连接的状态。 如果连接后，没有后续操作连接就处于空闲状态此时Command列会显示为Sleep。如果客户端太长时间没有动静，此时连接器就会断开此连接。这个时间由wait_timeout默认为8小时，可以通过show global variables like wait_timeout;查看。 如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。 MySql最大支持的连接数默认为151，由max_connections控制。超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。 show variables like max_connections; 查询缓存MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。 解析SQL分析器建立完连接后，就可以执行查询操作了。MySQL接收到一条发送过来的SQL，首先需要解析这个SQL才能知道这个SQL要做些什么。 分析器先会做词法分析。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。 MySQL从你输入的select这个关键字识别出来，这是一个查询语句。它也要把字符串user_test识别成表名user_test，把字符串id识别成列id。 做完了这些识别以后，就要做语法分析。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。 如果你的语句不对，就会收到You have an error in your SQL syntax的错误提醒，比如下面这个语句select少打了开头的字母s。 执行SQL预处理器预处理器阶段主要做了两件事： 检查 SQL 查询语句中的表或者字段是否存在； 将 select * 中的 * 符号，扩展为表上的所有列； 下面这条查询语句，如果user_test 这张表是不存在的，这时 MySQL 就会在执行 SQL 查询语句的 prepare 阶段中报错。 select * from user_test where id = 1; 优化器经过分析器后，MySQL知道了你要做什么了。在真正开始执行前还要经过优化器的处理。 优化器主要作用是在执行复杂sql时选择一个最优方案，例如有表中多个索引，决定走哪个索引；或者语句中有多个表关联，决定表关联的顺序。比如执行下面这样的语句，这个语句是执行两个表的join： select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20; 既可以先从表t1里面取出c10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。 也可以先从表t2里面取出d20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。 这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。 优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。 执行器MySQL通过分析器知道了你想做什么，通过优化器知道了该怎么做，于是进入执行阶段，开始执行语句。 开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误。 mysql select * from T where ID=10;ERROR 1142 (42000): SELECT command denied to user b@localhost for table T 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。 比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的： 调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中； 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 至此，这个语句就执行完成了。 总结执行一条 SQL 查询语句，期间发生了什么？ 连接器：建立连接，管理连接、校验用户身份； 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块； 解析 SQL：通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型； 执行 SQL： 预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列； 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划； 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；","tags":[null],"categories":[null]},{"title":"MySQL中一行记录是怎么存储的？","path":"/wiki/MySQL/MySQL2.html","content":"MySQL中数据存放在哪?MySQL在机器掉电重启服务后仍能够查询到已存储的数据是因为数据存储在磁盘中，随着MySQL服务重启会加载磁盘中的数据，这样保证数据的持久性。那么有个问题，MySQL的数据存储在磁盘哪？ 通过SHOW VARIABLES LIKE datadir;命令可以查看MySQL的数据文件存放位置 在MySQL中，我们每创建一个数据库时都会在/var/lib/mysql/里创建一个以数据库名为名的目录，然后保存表数据文件在该目录下。 例如：创建一个Test数据库，在该库中创建一个test表。进入到Test目录可以看到以下内容 可以看到Test目录下有一个test.ibd文件，该文件中保存了test表的结构及数据。 表中数据存储结构是怎样的？ 我们可以看到表中的数据是按照一行一行组成的，实际整个表空间在 InnoDB 引擎中，是由段（segment）、区（extent）、页（page）、行（row）组成。 我们从下到上看。 行（row） 数据库表中的记录都是按行（row）来存放的。每行记录根据不同的格式，有不同的存储结构。 页（page） 数据库中记录是一行行记录的，但是读取数据的时候并不是按照一行一行来读取，否则一次读取（一次IO）只能处理一行数据，效率太低。因此，在InnoDB中的数据是以【页】为单位来读写的。当需要读取一行记录时，会将该行记录所在页一起读取整体放入内存中。默认每个页的大小是16KB，也就是说最多只能保证16KB的连续存储空间。页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。表中的记录存储在「数据页」里面。 区（extent） 在 InnoDB 存储引擎中是使用 B+ 树来组织数据的。 在存储数据的叶子节点上是通过双向链表连接起来的，如果以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机IO，随机 IO 是非常慢的。 所以在表中有大量数据时，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 IO 了。 段（segment） 表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。 索引段：存放 B + 树的非叶子节点的区的集合； 数据段：存放 B + 树的叶子节点的区的集合； 回滚段：存放的是回滚数据的区的集合，MVCC 就是利用了回滚段实现了多版本查询数据。 InnoDB行格式长啥样？行格式（row_format），就是一条记录在磁盘中的存储结构。 InnoDB提供了4中行格式，分别是Redundant、Compact、Dynamic和 Compressed 行格式。 Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。 由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。 Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。 Compact行格式长啥样？ 一条完整的记录分为【记录额外信息】和【记录真实数据】两部分。 记录额外信息记录的额外信息包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息。 变长字段长度列表在 MySql 中 char 是定长的，varchar 是变长的，varchar 字段实际存储的数据的长度（大小）不固定的。所以在存储的时候需要将数据的大小也存起来，存到 【变长字段长度列表】 中。读取时再根据字段长度列表中的长度去读取对应大小的数据。 为了展示【变长字段长度列表】具体是怎么保存【变长字段的真实数据占用的字节数】，我们先创建这样一张表，字符集是 ascii（所以每一个字符占用的 1 字节），行格式是 Compact，user 表中 name 和 phone 字段都是变长字段： CREATE TABLE `user` ( `id` int(20) NOT NULL, `name` VARCHAR(20) DEFAULT NULL, `phone` VARCHAR(20) DEFAULT NULL, `sex` int(1) DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT; 在 user 表中插入三行数据： 接下来，我们来看下这三行数据的【变长字段长度列表】是怎样存储的。 先看第一条记录： id和sex都是定长的不用管； name列值为a，真实占用字节数是 1 个字节，十六进制表示为 0x01； phone列值为155，真实占用字节数是 3 个字节，十六进制表示为 0x03; 这些变长字段的真实数据占用的字节数会按照列的顺序 逆序存放。 同理，第二条记录格式如下： 第三条记录中 phone 列的值是 NULL，NULL 是不会存放在行格式中记录的真实数据部分里的，所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度。 【变长字段字节数列表】不是必须的。 当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有【变长字段长度列表】了，因为没必要，不如去掉以节省空间。 所以【变长字段长度列表】只出现在数据表有变长字段的时候。 Null值列表在上述 user 表中，存在字段值为 Null 的列，在 Compact 行格式中会把这些值为 Null 的列存储到 Null 值列表中。 存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。 二进制位的值为1时，代表该列的值为NULL。 二进制位的值为0时，代表该列的值不为NULL。 另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 0。 以 user 表为例，以下展示user 表中三条记录 【Null值列表】的存储方式。 先来看第一条记录，第一条记录所有列都有值，不存在 NULL 值，所以用二进制来表示为： 但是 InnoDB 是用整数字节的二进制位来表示 NULL 值列表的，现在不足 8 位，所以要在高位补 0，最终用二进制来表示为： 所以，对于第一条数据，NULL 值列表用十六进制表示是 0x00。 同理，第二条记录 age 列是 NULL 值，所以，对于第二条数据，NULL值列表用十六进制表示是 0x04。 第三条记录 phone 列 和 age 列是 NULL 值，所以，对于第三条数据，NULL 值列表用十六进制表示是 0x06。 NULL 值列表也不是必须的。 当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了。 所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。 【NULL 值列表】的空间不是固定 1 字节的。 当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的【NULL 值列表】，以此类推。 记录头信息记录头信息中包含的内容很多，就不一一列举了，这里说几个比较重要的： delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。 next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。 record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录。 记录真实数据记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer，我们来看下这三个字段是什么。 row_id 如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。 trx_id 事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。 roll_pointer 这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。 varchar(n) 中 n 的最大值MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节。 也就是说，一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 字节，注意是一行的总长度，不是一列。 varchar(n) 字段类型的 n 代表的是最多存储的字符数量，并不是字节大小哦。 要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节，比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。 保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 65535。","tags":[null],"categories":[null]},{"title":"Pytest简介","path":"/wiki/Python/Pytest.html","content":"简介Pytest 是一个功能强大且易于使用的 Python 测试框架，用于编写和运行 单元测试 用例、集成测试和功能测试，对比 unittest 框架，Pytest 的优势非常明显： 简单易用：Pytest 的语法简单明了，学习曲线低，它采用了自然的测试用例编写方式，使得编写测试代码变得更加简单和直观。 灵活性：Pytest 支持多种测试样式，包括函数式、类式、模块级别的测试，甚至支持测试生成器，而且插件生态非常丰富，可以通过插件来扩展 Pytest 的功能，满足各种测试场景。 集成性：Pytest 可以很好地与其他测试工具和框架集成，比如与 Jenkins、Travis CI、Coverage.py 等。它还支持与其他测试框架（如 unittest 和 doctest）协同工作。 丰富的输出信息：Pytest 在测试运行过程中提供丰富的输出信息，包括测试结果、失败原因、详细的堆栈跟踪等，便于开发人员定位和修复问题。 https://docs.pytest.org/en/stable/getting-started.html pip install -U pytest 编写规则在 Pytest 中，测试用例的编写需要遵循以下规则： 测试文件以 test_开头或_test 结尾； 测试类以 Test 开头，并且不能带有 init 方法； 测试函数以 test_ 开头； 断言使用基本的 assert 即可； Pytest 会递归查找当前目录及子目录下的所有以 test_ 开始或者 _test 结尾的 Python 脚本，执行其中符合规则的函数和方法，不需要显示调用。 一些常见的运行命令： # 直接运行文件夹内符合规则的所有用例pytest folder_name# 执行某个 Python 文件中的用例pytest test_file.py# 执行某个 Python 文件内的某个函数pytest test_file.py::test_func# 执行某个 Python 文件内某个测试类的某个方法pytest test_file.py::TestClass::test_method# 运行测试时显示标准输出(stdout)，允许测试中的 print() 语句直接输出到终端pytest -s# 运行测试时显示详细的信息，包括每个测试用例的名称及结果(通过/失败/跳过等)，-v 代表 verbosepytest -v 基本测试 pytesttest_example.py import mathdef test_pow(): num = 25 res = math.pow(5, 2) assert res == numdef test_sqrt(): res = math.sqrt(4) assert res == 1 pytest 输出结果： (.venv) PS D:\\work\\example_workspace\\example_Python pytest test session starts platform win32 – Python 3.13.2, pytest-8.3.5, pluggy-1.5.0rootdir: D:\\work\\example_workspace\\example_Pythoncollected 2 items pytest\\test_example.py .F [100%] FAILURES ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ test_sqrt ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ def test_sqrt(): res = math.sqrt(4) assert res == 1 E assert 2.0 == 1 pytest\\test_example.py:18: AssertionError short test summary info FAILED pytesttest_example.py:: test_sqrt - assert 2.0 1 1 failed, 1 passed in 0.04s (.venv) PS D:\\work\\example_workspace\\example_Python 查看结果的第一行。它显示文件名和结果。F 代表测试失败，点 (.) 代表测试成功。 在此之下，我们可以看到失败测试的详细信息。它将显示测试失败的语句。 最后，我们可以看到测试执行摘要，1 个失败，1 个通过。 # -v 增加详细程度pytest -v (.venv) PS D:\\work\\example_workspace\\example_Python pytest -v test session starts platform win32 – Python 3.13.2, pytest-8.3.5, pluggy-1.5.0 – D:\\work\\example_workspace\\example_Python.venv\\Scripts\\Python.execachedir: .pytest_cacherootdir: D:\\work\\example_workspace\\example_Pythoncollected 2 items pytesttest_example.py:: test_pow PASSED [ 50%]pytesttest_example.py:: test_sqrt FAILED [100%] FAILURES ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ test_sqrt ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ def test_sqrt(): res = math.sqrt(4) assert res == 1 E assert 2.0 == 1 pytest\\test_example.py:18: AssertionError short test summary info FAILED pytesttest_example.py:: test_sqrt - assert 2.0 1 1 failed, 1 passed in 0.04s (.venv) PS D:\\work\\example_workspace\\example_Python 现在结果更能说明失败的测试和通过的测试。 注意： pytest 命令将执行所有格式的文件 test_* 要么***_test**在当前目录和子目录中。 执行文件 pytesttest_example.py import mathdef test_pow2(): num = 25 res = math.pow(5, 2) assert res == numdef test_sqrt2(): res = math.sqrt(4) assert res == 1 pytest (.venv) PS D:\\work\\example_workspace\\example_Python pytest test session starts platform win32 – Python 3.13.2, pytest-8.3.5, pluggy-1.5.0rootdir: D:\\work\\example_workspace\\example_Pythoncollected 4 items pytest\\test_example.py .F [ 50%]pytest\\test_example2.py .F [100%] FAILURES ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ test_sqrt ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ def test_sqrt(): res = math.sqrt(4) assert res == 1 E assert 2.0 == 1 pytest\\test_example.py:18: AssertionError____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ test_sqrt2 ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ _____ def test_sqrt2(): res = math.sqrt(4) assert res == 1 E assert 2.0 == 1 pytest\\test_example2.py:18: AssertionError short test summary info FAILED pytesttest_example.py:: test_sqrt - assert 2.0 1FAILED pytesttest_example2.py:: test_sqrt2 - assert 2.0 1 2 failed, 2 passed in 0.05s (.venv) PS D:\\work\\example_workspace\\example_Python 会输出两个文件的测试结果。 如果要指定执行某个文件测试。 # pytest filenamepytest .\\examples_pytest\\test_example.py 输出结果： (.venv) PS D:\\work\\example_workspace\\example_Python pytest .\\examples_pytest\\test_example.py test session starts platform win32 – Python 3.13.2, pytest-8.3.5, pluggy-1.5.0rootdir: D:\\work\\example_workspace\\example_Pythoncollected 2 items examples_pytest\\test_example.py .F [100%] FAILURES ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ test_sqrt ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ _____ def test_sqrt(): res = math.sqrt(4) assert res == 1 E assert 2.0 == 1 examples_pytest\\test_example.py:19: AssertionError short test summary info FAILED examples_pytesttest_example.py:: test_sqrt - assert 2.0 1 1 failed, 1 passed in 0.04s (.venv) PS D:\\work\\example_workspace\\example_Python 执行测试套件的子集在实际场景中，我们将有多个测试文件，每个文件都会有多个测试。测试将涵盖各种模块和功能。假设，我们只想运行一组特定的测试；我们该怎么做？ Pytest 提供了两种方法来运行测试套件的子集。 根据测试名称的子字符串匹配选择要运行的测试。 根据应用的标记选择要运行的测试组。 测试名称的子串匹配语法： pytest -k substring -v -k substring 表示要在测试名称中搜索的子字符串。 # 过滤出 math 文件测试pytest -k math -v (.venv) PS D:\\work\\example_workspace\\example_Python pytest -k math -v test session starts platform win32 – Python 3.13.2, pytest-8.3.5, pluggy-1.5.0 – D:\\work\\example_workspace\\example_Python.venv\\Scripts\\Python.execachedir: .pytest_cacherootdir: D:\\work\\example_workspace\\example_Pythoncollected 5 items 4 deselected 1 selected examples_pytesttest_math.py:: test_pow PASSED [100%] 1 passed, 4 deselected in 0.02s # 过滤出 test_example 的文件测试pytest -k test_example -v (.venv) PS D:\\work\\example_workspace\\example_Python pytest -k test_example -v test session starts platform win32 – Python 3.13.2, pytest-8.3.5, pluggy-1.5.0 – D:\\work\\example_workspace\\example_Python.venv\\Scripts\\Python.execachedir: .pytest_cacherootdir: D:\\work\\example_workspace\\example_Pythoncollected 5 items 1 deselected 4 selected examples_pytesttest_example.py:: test_pow PASSED [ 25%]examples_pytesttest_example.py:: test_sqrt FAILED [ 50%]examples_pytesttest_example2.py:: test_pow2 PASSED [ 75%]examples_pytesttest_example2.py:: test_sqrt2 FAILED [100%] FAILURES ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ test_sqrt ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ _____ def test_sqrt(): res = math.sqrt(4) assert res == 1 E assert 2.0 == 1 examples_pytest\\test_example.py:19: AssertionError____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ test_sqrt2 ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ def test_sqrt2(): res = math.sqrt(4) assert res == 1 E assert 2.0 == 1 examples_pytest\\test_example2.py:19: AssertionError short test summary info FAILED examples_pytesttest_example.py:: test_sqrt - assert 2.0 1FAILED examples_pytesttest_example2.py:: test_sqrt2 - assert 2.0 1 2 failed, 2 passed, 1 deselected in 0.05s (.venv) PS D:\\work\\example_workspace\\example_Python # 从 example 目录过滤pytest -k example -v (.venv) PS D:\\work\\example_workspace\\example_Python pytest -k example -v test session starts platform win32 – Python 3.13.2, pytest-8.3.5, pluggy-1.5.0 – D:\\work\\example_workspace\\example_Python.venv\\Scripts\\Python.execachedir: .pytest_cacherootdir: D:\\work\\example_workspace\\example_Pythoncollected 5 items examples_pytesttest_example.py:: test_pow PASSED [ 20%]examples_pytesttest_example.py:: test_sqrt FAILED [ 40%]examples_pytesttest_example2.py:: test_pow2 PASSED [ 60%]examples_pytesttest_example2.py:: test_sqrt2 FAILED [ 80%]examples_pytesttest_math.py:: test_pow PASSED [100%] FAILURES ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ test_sqrt ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ _____ def test_sqrt(): res = math.sqrt(4) assert res == 1 E assert 2.0 == 1 examples_pytest\\test_example.py:19: AssertionError____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ test_sqrt2 ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ def test_sqrt2(): res = math.sqrt(4) assert res == 1 E assert 2.0 == 1 examples_pytest\\test_example2.py:19: AssertionError short test summary info FAILED examples_pytesttest_example.py:: test_sqrt - assert 2.0 1FAILED examples_pytesttest_example2.py:: test_sqrt2 - assert 2.0 1 2 failed, 3 passed in 0.05s (.venv) PS D:\\work\\example_workspace\\example_Python 对测试进行分组Pytest 允许我们在测试函数上使用标记。标记用于设置各种特征属性来测试功能。Pytest 提供了许多内置标记，例如 xfail、skip 和 parametrize。除此之外，用户可以创建自己的标记名称。 @pytest.mark.markername 要使用标记，我们必须 import pytest 测试文件中的模块。我们可以为测试定义我们自己的标记名称并运行具有这些标记名称的测试。 要运行标记的测试，我们可以使用以下语法： pytest -m markername -v -m markername 表示要执行的测试的标记名称。 examples_pytesttest_compare.py import pytest@pytest.mark.greatdef test_greater(): num = 100 assert num 100 @pytest.mark.greatdef test_greater_equal(): num = 100 assert num = 100@pytest.mark.othersdef test_less(): num = 100 assert num 200 examples_pytesttest_square.py import mathimport pytest@pytest.mark.squaredef test_sqrt(): num = 25 assert math.sqrt(num) == 5@pytest.mark.squaredef testsquare(): num = 7 assert 7 * 7 == 40@pytest.mark.othersdef test_equality(): assert 10 == 11 # 运行标记为 others 的测试pytest -m others -v (.venv) PS D:\\work\\example_workspace\\example_Python pytest -m others -v test session starts platform win32 – Python 3.13.2, pytest-8.3.5, pluggy-1.5.0 – D:\\work\\example_workspace\\example_Python.venv\\Scripts\\Python.execachedir: .pytest_cacherootdir: D:\\work\\example_workspace\\example_Pythoncollected 11 items 9 deselected 2 selected examples_pytesttest_compare.py:: test_less PASSED [ 50%]examples_pytesttest_square.py:: test_equality FAILED [100%] FAILURES ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ _test_equality _ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ @pytest.mark.others def test_equality(): assert 10 == 11 E assert 10 == 11 examples_pytest\\test_square.py:28: AssertionError short test summary info FAILED examples_pytesttest_square.py:: test_equality - assert 10 11 1 failed, 1 passed, 9 deselected, 6 warnings in 0.05s (.venv) PS D:\\work\\example_workspace\\example_Python fixture在 Pytest 中，fixture 是一种用于为测试函数提供预设数据或设置测试环境的机制。简单来说，可以 使用 fixture 来为测试提供预设数据和设置测试环境的功能。 fixture 通常写在 conftest.py 文件中，并且对应的目录及子目录都可以使用 conftest.py 提供的 fixture，如果存在嵌套 conftest.py 文件，则使用的是最接近的 fixture。定义好 fixture 后，在测试函数中，可以使用同名的参数直接使用，Pytest 会自动注入。 标记一个函数为 fixture: @pytest.fixture 测试函数可以通过将 fixture 名称作为输入参数来使用 fixture。 examples_pytestfixturetest_div.py import pytest@pytest.fixturedef input_value(): input = 39 return inputdef test_divisible_by_3(input_value): assert input_value % 3 == 0def test_divisible_by_6(input_value): assert input_value % 6 == 0 在这里，我们有一个名为 input_value 的 fixture 标注函数，它为测试提供输入。要访问 fixture 功能，测试必须使用 fixture 标注的函数名称作为输入参数。 Pytest 在执行测试时，会将函数名称作为输入参数。然后它执行 fixture 函数并将返回值存储到输入参数中，供测试使用。 pytest -k divisible -v 输出结果： (.venv) PS D:\\work\\example_workspace\\example_Python pytest -k divisible -v test session starts platform win32 – Python 3.13.2, pytest-8.3.5, pluggy-1.5.0 – D:\\work\\example_workspace\\example_Python.venv\\Scripts\\Python.execachedir: .pytest_cacherootdir: D:\\work\\example_workspace\\example_Pythoncollected 13 items 11 deselected 2 selected examples_pytestfixturetest_div.py:: test_divisible_by_3 PASSED [ 50%]examples_pytestfixturetest_div.py:: test_divisible_by_6 FAILED [100%] FAILURES ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ test_divisible_by_6 ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ ____ input_value 39 def test_divisible_by_6(input_value): assert input_value % 6 == 0 E assert (39 % 6) == 0 examples_pytest\\fixture\\test_div.py:24: AssertionError short test summary info FAILED examples_pytestfixturetest_div.py:: test_divisible_by_6 - assert (39 % 6) 0 1 failed, 1 passed, 11 deselected, 6 warnings in 0.05s 然而，这种方法有其自身的局限性。在测试文件中定义的 fixture 函数仅在测试文件中具有范围。我们不能在另一个测试文件中使用该 fixture 函数。为了使一个 fixture 可用于多个测试文件，我们必须在一个名为 conftest.py 的文件中定义 fixture 函数。 examples_pytestfixtureconftest.py import pytest@pytest.fixturedef input_value(): input = 39 return input pytest -k divisible -v (.venv) PS D:\\work\\example_workspace\\example_Python pytest -k divisible -v test session starts platform win32 – Python 3.13.2, pytest-8.3.5, pluggy-1.5.0 – D:\\work\\example_workspace\\example_Python.venv\\Scripts\\Python.execachedir: .pytest_cacherootdir: D:\\work\\example_workspace\\example_Pythoncollected 15 items 11 deselected 4 selected examples_pytestfixturetest_div.py:: test_divisible_by_3 PASSED [ 25%]examples_pytestfixturetest_div.py:: test_divisible_by_6 FAILED [ 50%]examples_pytestfixturetest_div2.py:: test_divisible_by_3 PASSED [ 75%]examples_pytestfixturetest_div2.py:: test_divisible_by_6 FAILED [100%] 测试将在同一文件中查找 fixture。由于在文件中没有找到 fixture，它会在 conftest.py 文件中检查 fixture。找到它后，将调用 fixture 方法并将结果赋值给测试的输入参数。 参数化测试在 Pytest 中可以使用 @pytest.mark.parametrize 装饰测试函数，实现使用不同的参数值多次测试运行相同的代码，以覆盖多种测试场景，可以传递 2 个参数，分别是参数名和参数值： 参数名：可以为单个参数或多个参数 参数值：为单个参数对应的参数列表，多个参数对应的元组参数列表； import pytest# 重复测试两次第一次输入num = 1，第二次输入num = 2@pytest.mark.parametrize(num, [1, 2])def test_multiplication_1(num): assert num == 1 @pytest.mark.parametrize(username, password, [(zhangsan, 123), (lisi, 321)])def test_multiplication_username_password(username, password): assert username.__eq__(zhangsan) assert password.__eq__(123) pytest -k multiplication -v 输出结果： (.venv) PS D:\\work\\example_workspace\\example_Python pytest -k multiplication -v test session starts platform win32 – Python 3.13.2, pytest-8.3.5, pluggy-1.5.0 – D:\\work\\example_workspace\\example_Python.venv\\Scripts\\Python.execachedir: .pytest_cacherootdir: D:\\work\\example_workspace\\example_Pythoncollected 19 items 15 deselected 4 selected examples_pytestparametrizetest_multiplication.py:: test_multiplication_1 [1] PASSED [25%]examples_pytestparametrizetest_multiplication.py:: test_multiplication_1 [2] FAILED [ 50%]examples_pytestparametrizetest_multiplication.py:: test_multiplication_username_password [zhangsan-123] PASSED [ 75%]examples_pytestparametrizetest_multiplication.py:: test_multiplication_username_password [lisi-321] FAILED [100%]","tags":[null],"categories":[null]},{"title":"Python环境搭建","path":"/wiki/Python/Python安装.html","content":"简介Python是由荷兰程序员吉多·范罗苏姆（Guido van Rossum）于1989年圣诞节期间设计并首发的编程语言，首个公开版本发布于1991年。其名称源自英国喜剧团体“蒙提·派森的飞行马戏团”（Monty Python’s Flying Circus），体现了语言设计的轻松理念。 核心特点 ‌语法简洁‌采用强制缩进和接近自然语言的表达方式，强调代码可读性，适合初学者快速入门。 ‌多范式支持‌同时支持面向对象、面向过程、函数式编程等多种编程范式，灵活性高。 ‌解释型语言‌无需编译即可直接运行，开发效率高，但执行速度通常慢于编译型语言。 ‌跨平台性‌可在Windows、Linux、MacOS等多种操作系统上运行，兼容性强。 ‌丰富的生态‌标准库涵盖网络、数据库、文本处理等领域，第三方库（如NumPy、Django）覆盖科学计算、Web开发等场景。 应用领域 ‌Web开发‌：Django、Flask等框架支持高效后端开发。 ‌数据分析与AI‌：Pandas、TensorFlow等库广泛应用于数据处理和机器学习。 ‌自动化运维‌：通过脚本实现系统管理和任务自动化。 ‌科学计算‌：NumPy、SciPy等工具支持复杂数学运算。 安装https://www.python.org/downloads/ Python 稳定版并没有一个固定的“标记”，而是指发布后经过充分测试，处于Bugfix（问题修复）或Security（安全运行）阶段的版本。用户可以根据项目需求和稳定性考虑，选择处于Security 阶段的版本使用，例如曾经的Python 3.8 和3.9。 查看版本生命周期状态： Bugfix 阶段：:指此版本仍有新的Bug（错误）被修复。 Security 阶段：:指此版本只接受安全相关的Bug 修复，此阶段后不再接受其他Bug 修复。 uvhttps://docs.astral.sh/uv/getting-started/ uv 是由 Astral 团队（Ruff 工具的开发者）使用 Rust 编写的高性能 Python 包管理工具，旨在替代传统工具链（如 pip、virtualenv 等），提供极速的依赖解析、虚拟环境管理和项目工具集成。 ‌性能优势‌ 无缓存时比 pip 快 8-10 倍，热缓存时快 80-115 倍； 依赖解析、下载和安装全程并行化，充分利用硬件资源。 ‌功能集成‌ 统一命令行接口，整合 pip（包管理）、pyenv（Python 版本控制）、pipx（工具安装）等功能； 支持静态分发，无需 Python 环境即可运行，避免版本冲突。 ‌兼容性与标准化‌ 虚拟环境符合标准，可与现有工具（如 Poetry、pipenv）互换使用； 支持现代 Python 打包功能（GitURL本地依赖、约束文件等）。 ‌跨平台支持‌ 支持 Windows、Linux 和 macOS，提供一致的使用体验。 安装方式通常通过命令行直接安装（如 curl -LsSf https://astral.sh/uv/install.sh | sh），具体可参考官方文档。 brew install uv 在 pycharm 中使用 uv","tags":[null],"categories":[null]},{"title":"Python依赖注入","path":"/wiki/Python/依赖注入.html","content":"依赖注入的核心概念‌ ‌目的‌：解耦组件，通过外部传递依赖项，而非在类内部创建。 ‌优势‌：提高可测试性、可维护性和灵活性。 手动依赖注入构造函数注入class Service: def do_something(self): return Real Serviceclass Client: def __init__(self, service: Service): # 依赖通过构造函数传入 self.service = service def execute(self): return self.service.do_something()# 使用service = Service()client = Client(service)print(client.execute()) # 输出: Real Service 方法注入class Service: def do_something(self): return Real Serviceclass Client: def execute(self, service: Service): # 依赖通过方法参数传入 return service.do_something()# 使用client = Client()service = Service()print(client.execute(service)) # 输出: Real Service 自动注入injectpip install injector 创建注入器与绑定依赖自动注入需要提供 __init__ 方法 from injector import Injector, injectclass Inner: def __init__(self): self.forty_two = 42class Outer: @inject def __init__(self, inner: Inner): self.inner = innerinjector = Injector()outer = injector.get(Outer)print(outer.inner.forty_two) 使用 dataclasses from dataclasses import dataclassfrom injector import Injector, injectclass Inner: def __init__(self): self.forty_two = 42@inject@dataclassclass Outer: inner: Innerinjector = Injector()outer = injector.get(Outer)print(outer.inner.forty_two) # Prints 42","tags":[null],"categories":[null]},{"title":"Python函数","path":"/wiki/Python/函数.html","content":"函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。 函数能提高应用的模块性，和代码的重复利用率。你已经知道 Python 提供了许多内建函数，比如 print()。但你也可以自己创建函数，这被叫做用户自定义函数。 定义函数你可以定义一个由自己想要功能的函数，以下是简单的规则： 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 函数内容以冒号 : 起始，并且缩进。 return [表达式] 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。 def 函数名（参数列表）: 函数体 默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。 #!/usr/bin/python3def hello() : print(Hello World!)hello() # 比较两个数，并返回较大的数: def max(a, b): if a b: return a else: return b a = 4b = 5print(max(a, b)) # 5 函数调用定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。 这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。 如下实例调用了 printme() 函数： #!/usr/bin/python3 # 定义函数def printme( str ): # 打印任何传入的字符串 print (str) return # 调用函数printme(我要调用用户自定义函数!) # 我要调用用户自定义函数!printme(再次调用同一函数) # 再次调用同一函数 参数传递在 Python 中，类型属于对象，对象有不同类型的区分，变量是没有类型的： a=[1,2,3]a=Runoob 以上代码中，**[1,2,3]** 是 List 类型，**”Runoob”** 是 String 类型，而变量 a 是没有类型，它仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。 可更改(mutable)与不可更改(immutable)对象： 在 Python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list, dict 等则是可以修改的对象。 不可变类型： 变量赋值 a 5 后再赋值 a 10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。 可变类型： 变量赋值 la = [1,2,3,4] 后再赋值 la [2] = 5 则是将 list la 的第三个元素值更改，本身 la 没有动，只是其内部的一部分值被修改了。 Python 函数的参数传递： 不可变类型： 类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。 可变类型： 类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响 Python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。 传不可变对象示例： 通过 id() 函数来查看内存地址变化。 def change(a): print(id(a)) # 指向的是同一个对象 a=10 print(id(a)) # 一个新对象 a = 1print(id(a))change(a) 输出结果： 4379369136 43793691364379369424 可以看见在调用函数前后，形参和实参指向的是同一个对象（对象 id 相同），在函数内部修改形参后，形参指向的是不同的 id。 传可变对象示例： 可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。 #!/usr/bin/python3 # 可写函数说明def changeme( mylist ): 修改传入的列表 mylist.append([1,2,3,4]) print (函数内取值: , mylist) return # 调用changeme函数mylist = [10,20,30]changeme( mylist )print (函数外取值: , mylist) 传入函数的和在末尾添加新内容的对象用的是同一个引用。 输出结果： 函数内取值: [10, 20, 30, [1, 2, 3, 4]]函数外取值: [10, 20, 30, [1, 2, 3, 4]] 参数以下是调用函数时可使用的正式参数类型： 必需参数 关键字参数 默认参数 不定长参数 必须参数必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。 调用 printme() 函数，你必须传入一个参数，不然会出现语法错误： #!/usr/bin/python3 #可写函数说明def printme( str ): 打印任何传入的字符串 print (str) return # 调用 printme 函数，不加参数会报错printme() 输出结果： Traceback (most recent call last):File “test.py”, line 10, in moduleprintme()TypeError: printme() missing 1 required positional argument: ‘str’ 关键字参数关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。 使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 以下在函数 printme() 调用时使用参数名： #!/usr/bin/python3 #可写函数说明def printme( str ): 打印任何传入的字符串 print (str) return #调用printme函数printme( str = 菜鸟教程) # 菜鸟教程 以下演示了函数参数的使用不需要使用指定顺序： #!/usr/bin/python3 #可写函数说明def printinfo( name, age ): 打印任何传入的字符串 print (名字: , name) print (年龄: , age) return #调用printinfo函数printinfo( age=50, name=runoob ) 输出结果： 名字: runoob年龄: 50 默认参数调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值： #!/usr/bin/python3 #可写函数说明def printinfo( name, age = 35 ): 打印任何传入的字符串 print (名字: , name) print (年龄: , age) return #调用printinfo函数printinfo( age=50, name=runoob )print (------------------------)printinfo( name=runoob ) 输出结果： 名字: runoob年龄: 50------------------------名字: runoob年龄: 35 带有默认值的参数需要放到参数列表最后面，不然会报错。 不定长参数你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。 def functionname([formal_args,] *var_args_tuple ): 函数_文档字符串 function_suite return [expression] 加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。 #!/usr/bin/python3 # 可写函数说明def printinfo( arg1, *vartuple ): 打印任何传入的参数 print (输出: ) print (arg1) print (vartuple) # 调用printinfo 函数printinfo( 70, 60, 50 ) 输出结果： 输出:70(60, 50) 如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。 #!/usr/bin/python3 # 可写函数说明def printinfo( arg1, *vartuple ): 打印任何传入的参数 print (输出: ) print (arg1) for var in vartuple: print (var) return # 调用printinfo 函数printinfo( 10 )printinfo( 70, 60, 50 ) 输出结果： 输出:10()输出:706050 还有一种就是参数带两个星号 ** ： def functionname([formal_args,] **var_args_dict ): 函数_文档字符串 function_suite return [expression] 加了两个星号 * 的参数会以字典的形式导入。 #!/usr/bin/python3 # 可写函数说明def printinfo( arg1, **vardict ): 打印任何传入的参数 print (输出: ) print (arg1) print (vardict) # 调用printinfo 函数printinfo(1, a=2,b=3) 输出结果： 输出:1{‘a’: 2, ‘b’: 3} 声明函数时，参数中星号 * 可以单独出现，例如： def f(a,b,*,c): return a+b+c 如果单独出现星号 *，则星号 * 后的参数必须用关键字传入： def f(a,b,*,c):... return a+b+c... f(1,2,3) # 报错Traceback (most recent call last): File stdin, line 1, in moduleTypeError: f() takes 2 positional arguments but 3 were given f(1,2,c=3) # 正常6 return 语句return [表达式] 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的 return 语句返回 None。 #!/usr/bin/python3 # 可写函数说明def sum( arg1, arg2 ): # 返回2个参数的和. total = arg1 + arg2 print (函数内 : , total) return total # 调用sum函数total = sum( 10, 20 )print (函数外 : , total) 输出结果： 函数内 : 30函数外 : 30 强制位置参数Python3.8 新增了一个函数形参语法 / 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。 在以下的例子中，形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 和 f 要求为关键字形参: def f(a, b, /, c, d, *, e, f): print(a, b, c, d, e, f) 以下使用方法是正确的： f(10, 20, 30, d=40, e=50, f=60) 以下使用方法会发生错误： f(10, b=20, c=30, d=40, e=50, f=60) # b 不能使用关键字参数的形式f(10, 20, 30, 40, 50, f=60) # e 必须使用关键字参数的形式 lambda(匿名函数)Python 使用 lambda 来创建匿名函数。 lambda 函数是一种小型、匿名的、内联函数，它可以具有任意数量的参数，但只能有一个表达式。 匿名函数不需要使用 def 关键字定义完整函数。 lambda 函数通常用于编写简单的、单行的函数，通常在需要函数作为参数传递的情况下使用，例如在 map()、filter()、reduce() 等函数中。 lambda 函数特点： lambda 函数是匿名的，它们没有函数名称，只能通过赋值给变量或作为参数传递给其他函数来使用。 lambda 函数通常只包含一行代码，这使得它们适用于编写简单的函数。 lambda 语法格式： lambda arguments: expression lambda 是 Python 的关键字，用于定义 lambda 函数。 arguments 是参数列表，可以包含零个或多个参数，但必须在冒号(:)前指定。 expression 是一个表达式，用于计算并返回函数的结果。 以下的 lambda 函数没有参数： f = lambda: Hello, world! print(f()) # 输出: Hello, world! 输出结果： Hello, world! 使用 lambda 创建匿名函数，设置一个函数参数 a，函数计算参数 a 加 10，并返回结果： x = lambda a : a + 10 print(x(5)) 输出结果： 15 lambda 函数也可以设置多个参数，参数使用逗号 , 隔开： x = lambda a, b : a * b print(x(5, 6)) 输出结果： 30 lambda 函数通常与内置函数如 map()、filter() 和 reduce() 一起使用，以便在集合上执行操作。例如： numbers = [1, 2, 3, 4, 5]squared = list(map(lambda x: x**2, numbers))print(squared) # 输出: [1, 4, 9, 16, 25] 输出结果： [1, 4, 9, 16, 25] 使用 lambda 函数与 filter() 一起，筛选偶数： numbers = [1, 2, 3, 4, 5, 6, 7, 8]even_numbers = list(filter(lambda x: x % 2 == 0, numbers))print(even_numbers) # 输出：[2, 4, 6, 8] 输出结果： [2, 4, 6, 8] 函数嵌套基本结构示例： def outer(): x = 10 def inner(): print(f访问外部变量: x) # inner可访问outer的变量 inner()outer() # 输出：访问外部变量: 10 核心特性： ‌作用域规则‌ 内部函数可访问外层作用域变量（non-local 作用域） 外部函数无法访问内部函数的局部变量 ‌闭包（Closure） def counter(): n = 0 def inc(): nonlocal n n += 1 return n return incc = counter()print(c(), c(), c()) # 输出：1 2 3 ‌装饰器应用： def logger(func): def wrapper(*args, **kwargs): print(f开始执行: func.__name__) result = func(*args, **kwargs) print(执行结束) return result return wrapper@loggerdef say_hello(): print(Hello World!)say_hello() 应用场景： ‌封装私有逻辑‌：隐藏不需要暴露的内部实现 ‌创建工厂函数‌：动态生成功能相似的函数 ‌实现装饰器‌：增强函数功能而不修改原函数 ‌延迟计算‌：通过闭包保存中间状态 注意事项： # 错误示例：循环中创建闭包def create_funcs(): return [lambda: i for i in range(3)]funcs = create_funcs()print([f() for f in funcs]) # 输出：[2, 2, 2] 而非预期[0,1,2]# 正确写法：使用默认参数捕获变量def create_funcs_fixed(): return [lambda x=i: x for i in range(3)]","tags":[null],"categories":[null]},{"title":"Python命名空间和作用域","path":"/wiki/Python/命名空间和作用域.html","content":"命名空间命名空间(Namespace)是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。 命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。 我们举一个计算机系统中的例子，一个文件夹(目录)中可以包含多个文件夹，每个文件夹中不能有相同的文件名，但不同文件夹中的文件可以重名。 一般有三种命名空间： 内置名称（built-in names）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。 全局名称（global names），模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。 局部名称（local names），函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是） 命名空间查找顺序: 假设我们要使用变量 runoob，则 Python 的查找顺序为：局部的命名空间 - 全局命名空间 - 内置命名空间。 如果找不到变量 runoob，它将放弃查找并引发一个 NameError 异常： NameError: name ‘runoob’ is not defined。 命名空间的生命周期： 命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。 因此，我们无法从外部命名空间访问内部命名空间的对象。 # var1 是全局名称var1 = 5def some_func(): # var2 是局部名称 var2 = 6 def some_inner_func(): # var3 是内嵌的局部名称 var3 = 7 作用域作用域就是一个 Python 程序可以直接访问命名空间的正文区域。 在一个 Python 程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。 Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。 变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。 Python 的作用域一共有 4 种，分别是： 有四种作用域： L（Local）：最内层，包含局部变量，比如一个函数方法内部。 E（Enclosing）：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的变量名称来说 A 中的作用域就为 nonlocal。 G（Global）：当前脚本的最外层，比如当前模块的全局变量。 B（Built-in）： 包含了内建的变量关键字等，最后被搜索。 LEGB 规则（Local, Enclosing, Global, Built-in）：Python 查找变量时的顺序是： L – E – G – B。 Local：当前函数的局部作用域。 Enclosing：包含当前函数的外部函数的作用域（如果有嵌套函数）。 Global：当前模块的全局作用域。 Built-in：Python 内置的作用域。 在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内置中找。 g_count = 0 # 全局作用域def outer(): o_count = 1 # 闭包函数外的函数中 def inner(): i_count = 2 # 局部作用域 内置作用域是通过一个名为 builtin 的标准模块来实现的，但是这个变量名自身并没有放入内置作用域内，所以必须导入这个文件才能够使用它。在 Python3.0 中，可以使用以下的代码来查看到底预定义了哪些变量： import builtins dir(builtins) Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while 等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码： if True:... msg = I am from Runoob... msgI am from Runoob 实例中 msg 变量定义在 if 语句块中，但外部还是可以访问的。 如果将 msg 定义在函数中，则它就是局部变量，外部不能访问： def test():... msg_inner = I am from Runoob... msg_innerTraceback (most recent call last): File stdin, line 1, in moduleNameError: name msg_inner is not defined 从报错的信息上看，说明了 msg_inner 未定义，无法使用，因为它是局部变量，只有在函数内可以使用。 全局变量和局部变量定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。 局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。 在函数内部声明的变量只在函数内部的作用域中有效，调用函数时，这些内部变量会被加入到函数内部的作用域中，并且不会影响到函数外部的同名变量，如下示例： #!/usr/bin/python3 total = 0 # 这是一个全局变量# 可写函数说明def sum( arg1, arg2 ): #返回2个参数的和. total = arg1 + arg2 # total在这里是局部变量. print (函数内是局部变量 : , total) return total #调用sum函数sum( 10, 20 )print (函数外是全局变量 : , total) 输出结果： 函数内是局部变量 : 30函数外是全局变量 : 0 1、全局变量：在函数外部定义的变量，可以在整个文件中被访问。在函数外部定义的变量对所有函数都是可见的，除非函数内部定义了同名的局部变量。 x = 10 # 全局变量def my_function(): print(x) # 可以访问全局变量 xmy_function() # 输出 10 2、局部变量：在函数内部定义的变量，仅在函数内有效，函数外无法访问。局部变量优先级高于全局变量，因此如果局部变量和全局变量同名，函数内部会使用局部变量。 def my_function(): x = 5 # 局部变量 print(x) # 访问局部变量 xmy_function() # 输出 5print(x) # 报错: NameError: name x is not defined global 和 nonlocal当内部作用域想修改外部作用域的变量时，就要用到 global 和 nonlocal 关键字了。 以下实例修改全局变量 num： #!/usr/bin/python3 num = 1def fun1(): global num # 需要使用 global 关键字声明 print(num) num = 123 print(num)fun1()print(num) 输出结果： 1123123 如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，如下示例： #!/usr/bin/python3 def outer(): num = 10 def inner(): nonlocal num # nonlocal关键字声明 num = 100 print(num) inner() print(num)outer() 输出结果： 100100 另外有一种特殊情况，假设下面这段代码被运行： #!/usr/bin/python3 a = 10def test(): a = a + 1 print(a)test() Traceback (most recent call last):File “test.py”, line 7, in test()File “test.py”, line 5, in testa a + 1UnboundLocalError: local variable ‘a’ referenced before assignment 错误信息为局部作用域引用错误，因为 test 函数中的 a 使用的是局部，未定义，无法修改。 修改 a 为全局变量： #!/usr/bin/python3 a = 10def test(): global a a = a + 1 print(a)test() # 11 也可以通过函数参数传递： #!/usr/bin/python3 a = 10def test(a): a = a + 1 print(a)test(a) # 11 总结: 全局变量 在函数外部定义，可以在整个文件中访问。 局部变量 在函数内部定义，只能在函数内访问。 使用 global 可以在函数中修改全局变量。 使用 nonlocal 可以在嵌套函数中修改外部函数的变量。","tags":[null],"categories":[null]},{"title":"Python基础语法","path":"/wiki/Python/基础语法.html","content":"编码默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码。 # -*- coding: cp-1252 -*- 标识符 第一个字符必须是字母表中 字母 或下划线 _ 。 标识符的其他的部分由 字母、数字 和 下划线 组成。 标识符对大小写敏感。 在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。 保留字Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字： import keyword keyword.kwlist[False, None, True, and, as, assert, async, await, break, class, continue, def, del, elif, else, except, finally, for, from, global, if, import, in, is, lambda, nonlocal, not, or, pass, raise, return, try, while, with, yield] 注释Python 中单行注释以 # 开头，示例如下： #!/usr/bin/python3 # 第一个注释print (Hello, Python!) # 第二个注释 多行注释可以用多个 # 号，或者 ‘’’ 和 **”” “**： #!/usr/bin/python3 # 第一个注释# 第二个注释 多行注释多行注释多行注释多行注释print (Hello, Python!) 代码缩进Python 最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。 缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。实例如下： if True: print(True)else: print(False) 以下代码最后一行语句缩进数的空格数不一致，会导致运行错误： if True: print(True)else: print(False) print(hello) # 缩进不一致，会导致运行错误 多行语句Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 \\ 来实现多行语句，例如： str = 你 + \\好 + \\啊print(str) # 你好啊 在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 \\，例如： str = [你,好,啊]print(str) # [你, 好, 啊]str1 = 你,好,啊print(str1) # 你, 好, 啊 空行函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。 空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分 隔两段不同功能或含义的代码，便于日后代码的维护或重构。 记住： 空行也是程序代码的一部分。 class MyClass: def __init__(self, name): self.name = name def greet(self): # 这一行空行用于分隔不同功能的代码 print(fHello, self.name!) # 类与函数之间插入空行来突出函数入口 def farewell(self): print(fGoodbye, self.name!) 等待用户输入执行下面的程序在按回车键后就会等待用户输入: #!/usr/bin/python3 input( 按下 enter 后退出) 以上代码中 ， 在结果输出前会输出两个新的空行。一旦用户按下 enter 键时，程序将退出。 同一行显示多条语句Python 可以在同一行中使用多条语句，语句之间使用分号 ; 分割，以下是一个简单的实例： #!/usr/bin/python3 import sys; str = zhangsan; sys.stdout.write(str + ) 多个语句构成代码组缩进相同 的一组语句构成一个代码块，我们称之代码组。 像 if、while、def 和 class 这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。 我们将首行及后面的代码组称为一个子句(clause)。 如下实例： if expression : suiteelif expression : suite else : suite import 与 from…import在 Python 用 import 或者 from…import 来导入相应的模块。 将整个模块(somemodule)导入，格式为： import somemodule 从某个模块中导入某个函数, 格式为： from somemodule import somefunction 从某个模块中导入多个函数, 格式为： from somemodule import firstfunc, secondfunc, thirdfunc 将某个模块中的全部函数导入，格式为： from somemodule import * # 导入整个模块import mathprint(math.sqrt(16)) # 计算平方根# 从某个模块中导入某个函数from random import randintprint(randint(1, 10)) # 生成 1 到 10 之间的随机整数# 从某个模块中导入多个函数from datetime import datetime, timedeltanow = datetime.now()print(Current time:, now)tomorrow = now + timedelta(days=1)print(Tomorrow:, tomorrow)# 从某个模块中导入所有函数（不推荐，可能导致命名冲突）from os import *print(getcwd()) # 获取当前工作目录 说明： import math 直接导入整个 math 模块，需要使用 math.sqrt() 访问其函数。 from random import randint 只导入 randint，可以直接使用 randint()。 from datetime import datetime, timedelta 只导入 datetime 和 timedelta，避免加载整个 datetime 模块。 from os import * 导入 os 模块的所有功能，可能会导致命名冲突，因此通常不推荐使用。","tags":[null],"categories":[null]},{"title":"Python推导式","path":"/wiki/Python/推导式.html","content":"Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。 Python 推导式是一种强大且简洁的语法，适用于生成列表、字典、集合和生成器。 在使用推导式时，需要注意可读性，尽量保持表达式简洁，以免影响代码的可读性和可维护性。 Python 支持各种数据结构的推导式： 列表(list)推导式 字典(dict)推导式 集合(set)推导式 元组(tuple)推导式 列表推导式[表达式 for 变量 in 列表] [out_exp_res for out_exp in input_list]或者 [表达式 for 变量 in 列表 if 条件][out_exp_res for out_exp in input_list if condition] out_exp_res：列表生成元素表达式，可以是有返回值的函数。 for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。 if condition：条件语句，可以过滤列表中不符合条件的值。 names = [Bob,Tom,alice,Jerry,Wendy,Smith]new_names = [name.upper() for name in names]print(new_names) # [BOB, TOM, ALICE, JERRY, WENDY, SMITH]lst = [1,2,3,4]new_lst = [i**2 for i in lst if i 2]print(new_lst) #[9, 16] 字典推导式 key_expr: value_expr for value in collection 或 key_expr: value_expr for value in collection if condition list_demo = [google, baidu,byte dance]new_dict = v:len(v) for v in list_demoprint(new_dict) # google: 6, baidu: 5, byte dance: 10 dic = x:x**2 for x in range(4)print(dic) # 0: 0, 1: 1, 2: 4, 3: 9 集合推导式 expression for item in Sequence 或 expression for item in Sequence if conditional set_new = i**2 for i in range(4)print(set_new) # 0, 1, 4, 9 a = x for x in abcdefgasdwe if x not in abcprint(a) # e, s, d, f, g, w 元组推导式元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。 元组推导式基本格式： (expression for item in Sequence )或(expression for item in Sequence if conditional ) 元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 () 圆括号将各部分括起来，而列表推导式用的是中括号 []，另外 元组推导式返回的结果是一个生成器对象。 a = (x for x in range(1,10))print(a) # generator object genexpr at 0x000001A18D0D5F00","tags":[null],"categories":[null]},{"title":"Python条件控制","path":"/wiki/Python/条件控制.html","content":"if 语句if condition_1: statement_block_1elif condition_2: statement_block_2else: statement_block_3 如果 “condition_1” 为 True 将执行 “statement_block_1” 块语句 如果 “condition_1” 为 False，将判断 “condition_2” 如果 “condition_2” 为 True 将执行 “statement_block_2” 块语句 如果 “condition_2” 为 False，将执行 “statement_block_3” 块语句 Python 中用 elif 代替了 else if，所以 if 语句的关键字为：if – elif – else。 注意： 1、每个条件后面要使用冒号 **:**，表示接下来是满足条件后要执行的语句块。 2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。 3、在 Python 中没有 switch…case 语句，但在 Python3.10 版本添加了 match…case，功能也类似。 #!/usr/bin/python3 var1 = 100if var1: print (1 - if 表达式条件为 true) print (var1) var2 = 0if var2: print (2 - if 表达式条件为 true) print (var2)print (Good bye!) 执行以上代码，输出结果为： 1 - if 表达式条件为 true100Good bye! 以下为 if 中常用的操作运算符: 操作符 描述 小于 = 小于或等于 大于 = 大于或等于 == 等于，比较两个值是否相等 != 不等于 #!/usr/bin/python3 # 程序演示了 == 操作符# 使用数字print(5 == 6) # False# 使用变量x = 5y = 8print(x == y) # False #!/usr/bin/python3 # 该实例演示了数字猜谜游戏number = 7guess = -1print(数字猜谜游戏!)while guess != number: guess = int(input(请输入你猜的数字：)) if guess == number: print(恭喜，你猜对了！) elif guess number: print(猜的数字小了...) elif guess number: print(猜的数字大了...) 数字猜谜游戏!请输入你猜的数字：1猜的数字小了…请输入你猜的数字：9猜的数字大了…请输入你猜的数字：7恭喜，你猜对了！ 三目运算语法格式： exp1 if contion else exp2# condition 是判断条件，exp1 和 exp2 是两个表达式。 如果 condition 成立（结果为真），就执行 exp1，并把 exp1 的结果作为整个表达式的结果； 如果 condition 不成立（结果为假），就执行 exp2，并把 exp2 的结果作为整个表达式的结果。 示例： if ab: max = aelse: max = b 更加简洁的写法，如下所示： max = a if ab else b max a if a b else b 的含义是： 如果 a b 成立，就把 a 作为整个表达式的值，并赋给变量 max； 如果 a b 不成立，就把 b 作为整个表达式的值，并赋给变量 max。 if 嵌套# !/usr/bin/python3 num=int(input(输入一个数字：))if num%2==0: if num%3==0: print (你输入的数字可以整除 2 和 3) else: print (你输入的数字可以整除 2，但不能整除 3)else: if num%3==0: print (你输入的数字可以整除 3，但不能整除 2) else: print (你输入的数字不能整除 2 和 3) mathc…casePython 3.10 增加了 match…case 的条件判断，不需要再使用一连串的 if-else 来判断了。 match 后的对象会依次与 case 后的内容进行匹配，如果匹配成功，则执行匹配到的表达式，否则直接跳过，_ 可以匹配一切。 match subject: case pattern_1: action_1 case pattern_2: action_2 case pattern_3: action_3 case _: action_wildcard case _: 类似于 C 和 Java 中的 default:，当其他 case 都无法匹配时，匹配这条，保证永远会匹配成功。 def http_error(status): match status: case 400: return Bad request case 404: return Not found case 418: return Im a teapot case _: return Somethings wrong with the internetmystatus=400print(http_error(400)) # Bad request 一个 case 也可以设置多个匹配条件，条件使用 ｜ 隔开，例如： ... case 401|403|404: return Not allowed 条件判断中的隐式转换Python 的 if 语句会自动执行布尔转换，以下值被视为 False： False | None | 0 | 0.0 | | [] | () | | set() | range(0) 类型判断最佳实践： def check_value(val): # 严格判断None类型 if val is None: print(未赋值) # 检查空字符串 elif isinstance(val, str) and not val: print(空字符串) # 检查数值零 elif isinstance(val, (int, float)) and val == 0: print(零值) # 检查空容器 elif hasattr(val, __len__) and not val: print(空容器) whilewhile 判断条件(condition)： 执行语句(statements)…… #!/usr/bin/env python3 n = 100 sum = 0counter = 1while counter = n: sum = sum + counter counter += 1 print(1 到 %d 之和为: %d % (n,sum)) # 1 到 100 之和为: 5050 无限循环可以将判断条件设置为 True 实现无限循环 #!/usr/bin/python3 var = 1while var == 1 : # 表达式永远为 true num = int(input(输入一个数字 :)) print (你输入的数字是: , num) print (Good bye!) 输出结果： 输入一个数字 :5你输入的数字是: 5输入一个数字 : 可以使用 CTRL+C 来退出当前的无限循环。 while…else如果 while 后面的条件语句为 false 时，则执行 else 的语句块。 while expr: statement(s)else: additional_statement(s) expr 条件语句为 true 则执行 statement(s) 语句块，如果为 false，则执行 additional_statement(s)。 循环输出数字，并判断大小： #!/usr/bin/python3 count = 0while count 5: print (count, 小于 5) count = count + 1else: print (count, 大于或等于 5) 输出结果： 0 小于 51 小于 52 小于 53 小于 54 小于 55 大于或等于 5 forPython for 循环可以遍历任何可迭代对象，如一个列表或者一个字符串。 for 循环的一般格式如下： for variable in sequence: statementselse: statements #!/usr/bin/python3 sites = [Baidu, Google,Runoob,Taobao]for site in sites: print(site) 输出结果： BaiduGoogleRunoobTaobao 也可用于打印字符串中的每个字符： #!/usr/bin/python3 word = runoob for letter in word: print(letter) 输出结果： runoob 整数范围值可以配合 range() 函数使用： # 1 到 5 的所有数字：for number in range(1, 6): print(number) 输出结果： 12345 for…else在 Python 中，for...else 语句用于在循环结束后执行一段代码。 for item in iterable: # 循环主体else: # 循环结束后执行的代码 当循环执行完毕（即遍历完 iterable 中的所有元素）后，会执行 else 子句中的代码，如果在循环过程中遇到了 break 语句，则会中断循环，此时不会执行 else 子句。 for x in range(6): print(x)else: print(Finally finished!) 输出结果： 012345Finally finished! 以下 for 实例中使用了 break 语句，break 语句用于跳出当前循环体，不会执行 else 子句： #!/usr/bin/python3 sites = [Baidu, Google,Runoob,Taobao]for site in sites: if site == Runoob: print(菜鸟教程!) break print(循环数据 + site)else: print(没有循环数据!)print(完成循环!) 输出结果： 循环数据 Baidu循环数据 Google菜鸟教程!完成循环! range()函数如果你需要遍历数字序列，可以使用内置 range() 函数。它会生成数列，例如: for i in range(5): print(i) 输出结果： 01234 可以使用 range() 指定区间的值： for i in range(1,5): print(i) 输出结果： 1234 以使 range() 以指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做’步长’)： for i in range(1,10,2): print(i) for i in range(1,-10,-2): print(i) 输出结果： 13579 1-1-3-5-7-9 可以结合 range() 和 len() 函数以遍历一个序列的索引, 如下所示： a = [Google, Baidu, Runoob, Taobao, QQ]for i in range(len(a)): print(i, a[i]) 输出结果： 0 Google1 Baidu2 Runoob3 Taobao4 QQ break 和 contiuebreak 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。 continue 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环。 n = 5while n 0: n -= 1 if n == 2: break print(n)print(循环结束。) 输出结果： 43循环结束。 n = 5while n 0: n -= 1 if n == 2: continue print(n)print(循环结束。) 输出结果： 4310循环结束。 循环语句可以有 else 子句，它在穷尽列表(以 for 循环)或条件变为 false (while 循环)导致循环终止时被执行，但 循环被 break 终止时不执行。 a = [Google, Baidu, Runoob, Taobao, QQ]for i in range(len(a)): print(i, a[i]) if i == 2: breakelse: print(end) 输出结果： 0 Google1 Baidu2 Runoob pass 语句Python pass 是空语句，是为了保持程序结构的完整性。 pass 不做任何事情，一般用做占位语句。 #!/usr/bin/python3 for letter in Runoob: if letter == o: pass print (执行 pass 块) print (当前字母 :, letter) print (Good bye!) 输出结果： 当前字母 : R当前字母 : u当前字母 : n执行 pass 块当前字母 : o执行 pass 块当前字母 : o当前字母 : bGood bye! end 关键字关键字 end 可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符。 #!/usr/bin/python3 # Fibonacci series: 斐波纳契数列# 两个元素的总和确定了下一个数a, b = 0, 1while b 1000: print(b, end=,) a, b = b, a+b 输出结果： 1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,","tags":[null],"categories":[null]},{"title":"Python枚举","path":"/wiki/Python/枚举.html","content":"基本概念Python通过 enum 模块实现枚举类型，需继承 Enum 基类： from enum import Enumclass Color(Enum): RED = 1 GREEN = 2 BLUE = 3 # 成员值可为任意数据类型‌ 核心特性状态表示： class OrderStatus(Enum): PENDING = 10 PAID = 20 SHIPPED = 30 # 代替魔法数字 类型安全验证： def process_color(color: Color): if not isinstance(color, Color): raise TypeError(必须传入Color枚举) 配置管理： class EnvConfig(Enum): DEV = dev.example.com PROD = api.example.com“ 常用方法from enum import Enum, autoclass Status(Enum): # 显式赋值 ACTIVE = 10 INACTIVE = 20 # 自动递增赋值（适用于整数） PENDING = auto() # 自动生成# 访问方式print(Status.ACTIVE) # 输出: Status.ACTIVEprint(Status[INACTIVE]) # 通过名称访问print(Status(20)) # 通过值获取成员 成员属性提取Status.ACTIVE.name # ACTIVEStatus.PENDING.value # 21（自动生成值)","tags":[null],"categories":[null]},{"title":"Python模块","path":"/wiki/Python/模块.html","content":"概念Python 中的模块（Module）是一个包含 Python 定义和语句的文件，文件名就是模块名加上 .py 后缀。 模块可以包含函数、类、变量以及可执行的代码。通过模块，我们可以将代码组织成可重用的单元，便于管理和维护。 模块的作用: 代码复用：将常用的功能封装到模块中，可以在多个程序中重复使用。 命名空间管理：模块可以避免命名冲突，不同模块中的同名函数或变量不会互相干扰。 代码组织：将代码按功能划分到不同的模块中，使程序结构更清晰。 这是一个使用 Python 标准库中模块的例子。 #!/usr/bin/python3# 文件名: using_sys.py import sys print(命令行参数如下:)for i in sys.argv: print(i) print( Python 路径为：, sys.path, ) 执行结果： $ Python using_sys.py 参数 1 参数 2命令行参数如下:using_sys.py参数 1参数 2 Python 路径为： [‘root’, ‘usrlibpython3.4’, ‘usrlibpython3.4plat-x86_64-linux-gnu’, ‘usrlibpython3.4lib-dynload’, ‘usrlocallibpython3.4dist-packages’, ‘usrlibpython3dist-packages’] 1、import sys 引入 Python 标准库中的 sys.py 模块；这是引入某一模块的方法。 2、sys.argv 是一个包含命令行参数的列表。 3、sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。 import想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下： import module1[, module2[,... moduleN] 当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。 搜索路径时一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support，需要把命令放在脚本的顶端： #!/usr/bin/python3# Filename: support.py def print_func( par ): print (Hello : , par) return test.py 引入 support 模块： #!/usr/bin/python3# Filename: test.py # 导入模块import support # 现在可以调用模块里包含的函数了support.print_func(Runoob) 输出结果： $ python3 test.pyHello : Runoob 一个模块只会被导入一次，不管你执行了多少次 import。这样可以防止导入模块被一遍又一遍地执行。 模块搜索路径当我们使用 import 语句的时候，Python 解释器是怎样找到对应的文件的呢？ 这就涉及到 Python 的搜索路径，搜索路径是由一系列目录名组成的，Python 解释器就依次从这些目录中去寻找所引入的模块。 当导入一个模块时，Python 会按照以下顺序查找模块： 当前目录。 环境变量 PYTHONPATH 指定的目录。 Python 标准库目录。 .pth 文件中指定的目录。 搜索路径是在 Python 编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在 sys 模块中的 path 变量，做一个简单的实验，在交互式解释器中，输入以下代码： import sys sys.path[, D:\\\\work\\\\tools\\\\python\\\\python313.zip, D:\\\\work\\\\tools\\\\python\\\\DLLs, D:\\\\work\\\\tools\\\\python\\\\Lib, D:\\\\work\\\\tools\\\\python, D:\\\\work\\\\tools\\\\python\\\\Lib\\\\site-packages] sys.path 输出是一个列表，其中第一项是空串 ‘’，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行 Python 解释器的目录（对于脚本的话就是运行的脚本所在的目录）。 因此若像我一样在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。 了解了搜索路径的概念，就可以在脚本中修改 sys.path 来引入一些不在搜索路径中的模块。 在当前目录新建 fibo.py fibo.py # 斐波那契(fibonacci)数列模块 def fib(n): # 定义到 n 的斐波那契数列 a, b = 0, 1 while b n: print(b, end= ) a, b = b, a+b print() 在同级目录新建 hello.py 导入 fibo.py hello.py import fibo# 可以使用模块名称来访问函数fibo.fib(10) # 1 1 2 3 5 8 如果经常使用一个函数，可以把它赋给一个本地的名称： import fibofib = fibo.fibfib(10) # 1 1 2 3 5 8 from … importPython 的 from 语句可以模块中导入一个指定的部分到当前命名空间中，语法如下： from modname import name1[, name2[, ... nameN]] 例如，要导入模块 fibo 的 fib 函数，使用如下语句： from fibo import fibfib(10) 这个声明不会把整个 fibo 模块导入到当前的命名空间中，它只会将 fibo 里的 fib 函数引入进来。 把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明： from modname import * 这提供了一个简单的方法来导入一个模块中的所有项目。 不推荐，容易引起命名冲突。 别名使用 as 关键字为模块或函数起别名： import numpy as np # 将 numpy 模块别名设置为 npfrom math import sqrt as square_root # 将 sqrt 函数别名设置为 square_root 深入模块模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。 每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。 所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞混。 从另一个方面，当你确实知道你在做什么的话，你也可以通过 modname.itemname 这样的表示法来访问模块内的函数。 模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用 import 来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。 还有一种导入的方法，可以使用 import 直接把模块内（函数，变量的）名称导入到当前操作模块。比如: from fibo import fib 这种导入的方法不会把被导入的模块的名称放在当前的字符表中（所以在这个例子里面，fibo 这个名称是没有定义的）。 还有一种方法，可以一次性的把模块中的所有（函数，变量）名称都导入到当前模块的字符表: from fibo import * 这将把所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例。大多数情况， Python 程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义。 _name_属性一个模块被另一个程序第一次引入时，其主程序将运行。 如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用 __name__ 属性来使该程序块仅在该模块自身运行时执行。 fibo.py # 斐波那契(fibonacci)数列模块 def fib(n): # 定义到 n 的斐波那契数列 a, b = 0, 1 while b n: print(b, end= ) a, b = b, a+b print() if __name__ == __main__: print(程序自身在运行)else: print(__name__) print(我来自另一模块) 直接运行 fibo.py 输出： D:worktoolsPythonPython.exe d:worksty_projectsty_Python01.basicfibo.py程序自身在运行 test.pyt from fibo import fibfib(10) 运行导入 fibo 的 hello.py 输出： D:worktoolsPythonPython.exe d:worksty_projectsty_Python01.basichello.pyfibo我来自另一模块1 1 2 3 5 8 说明：每个模块都有一个 __name__ 属性。 如果模块是被直接运行，__name__ 的值为 __main__。 如果模块是被导入的，__name__ 的值为模块名。 __name__ 与 __main__ 底下是双下划线， _ _ dir() 函数内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回： import fibo, sys dir(fibo)[__name__, fib] dir(sys) [__displayhook__, __doc__, __excepthook__, __loader__, __name__, __package__, __stderr__, __stdin__, __stdout__, _clear_type_cache, _current_frames, _debugmallocstats, _getframe, _home, _mercurial, _xoptions, abiflags, api_version, argv, base_exec_prefix, base_prefix, builtin_module_names, byteorder, call_tracing, callstats, copyright, displayhook, dont_write_bytecode, exc_info, excepthook, exec_prefix, executable, exit, flags, float_info, float_repr_style, getcheckinterval, getdefaultencoding, getdlopenflags, getfilesystemencoding, getobjects, getprofile, getrecursionlimit, getrefcount, getsizeof, getswitchinterval, gettotalrefcount, gettrace, hash_info, hexversion, implementation, int_info, intern, maxsize, maxunicode, meta_path, modules, path, path_hooks, path_importer_cache, platform, prefix, ps1, setcheckinterval, setdlopenflags, setprofile, setrecursionlimit, setswitchinterval, settrace, stderr, stdin, stdout, thread_info, version, version_info, warnoptions] 如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称： a = [1, 2, 3, 4, 5] import fibo fib = fibo.fib dir() # 得到一个当前模块中定义的属性列表[__builtins__, __name__, a, fib, fibo, sys] a = 5 # 建立一个新的变量 a dir()[__builtins__, __doc__, __name__, a, sys] del a # 删除变量名a dir()[__builtins__, __doc__, __name__, sys] 标准模块Python 本身带着一些标准的模块库，在 Python 库参考文档中将会介绍到（就是后面的 “库参考文档”）。 模块名 功能描述 math 数学运算（如平方根、三角函数等） os 操作系统相关功能（如文件、目录操作） sys 系统相关的参数和函数 random 生成随机数 datetime 处理日期和时间 json 处理 JSON 数据 re 正则表达式操作 collections 提供额外的数据结构（如 defaultdict、deque） itertools 提供迭代器工具 functools 高阶函数工具（如 reduce、lru_cache） 有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。 这些组件会根据不同的操作系统进行不同形式的配置，比如 winreg 这个模块就只会提供给 Windows 系统。 应该注意到这有一个特别的模块 sys ，它内置在每一个 Python 解析器中。变量 sys.ps1 和 sys.ps2 定义了主提示符和副提示符所对应的字符串: import sys sys.ps1 sys.ps2... sys.ps1 = C C print(Runoob!)Runoob!C 包包是一种管理 Python 模块命名空间的形式，采用 “点模块名称”。 比如一个模块的名称是 A.B， 那么他表示一个包 A 中的子模块 B 。 就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。 这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库。 不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个 “包”）。 现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如： .wav，:file:.aiff，:file:.au，），所以你需要有一组不断增加的模块，用来在不同的格式之间转换。 并且针对这些音频数据，还有很多不同的操作（比如混音，添加回声，增加均衡器功能，创建人造立体声效果），所以你还需要一组怎么也写不完的模块来处理这些操作。 这里给出了一种可能的包结构（在分层的文件系统中）: sound/ 顶层包 __init__.py 初始化 sound 包 formats/ 文件格式转换子包 __init__.py wavread.py wavwrite.py aiffread.py aiffwrite.py auread.py auwrite.py ... effects/ 声音效果子包 __init__.py echo.py surround.py reverse.py ... filters/ filters 子包 __init__.py equalizer.py vocoder.py karaoke.py ... 在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。 目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。 最简单的情况，放一个空的 :file:__init__.py 就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的） all 变量赋值。 用户可以每次只导入一个包里面的特定模块，比如： import sound.effects.echo 这将会导入子模块 : sound.effects.echo。 他必须使用全名去访问： sound.effects.echo.echofilter(input, output, delay=0.7, atten=4) 还有一种导入子模块的方法是： from sound.effects import echo 这同样会导入子模块: echo，并且他不需要那些冗长的前缀，所以可以这样使用： echo.echofilter(input, output, delay=0.7, atten=4) 还有一种变化就是直接导入一个函数或者变量： from sound.effects.echo import echofilter 同样的，这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数： echofilter(input, output, delay=0.7, atten=4) 注意当使用 from package import item 这种形式的时候，对应的 item 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。 import 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 :exc:ImportError 异常。 反之，如果使用形如 import item.subitem.subsubitem 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。 从包中导入 *如果我们使用 from sound.effects import * 会发生什么呢？ Python 会进入文件系统，找到这个包里面所有的子模块，然后一个一个的把它们都导入进来。 但这个方法在 Windows 平台上工作的就不是非常好，因为 Windows 是一个不区分大小写的系统。 在 Windows 平台上，我们无法确定一个叫做 ECHO.py 的文件导入为模块是 echo 还是 Echo，或者是 ECHO。 为了解决这个问题，我们只需要提供一个精确包的索引。 导入语句遵循如下规则：如果包定义文件 __init__.py 存在一个叫做 __all__ 的列表变量，那么在使用 from package import * 的时候就把这个列表中的所有名字作为包内容导入。 作为包的作者，可别忘了在更新包之后保证 __all__ 也更新了。 以下实例在 file:sounds/effects/__init__.py 中包含如下代码: __all__ = [echo, surround, reverse] 这表示当你使用 from sound.effects import 这种用法时，你只会导入包里面这三个子模块。 如果 __all__ 真的没有定义，那么使用 from sound.effects import * 这种语法的时候，就不会导入包 sound.effects 里的任何子模块。他只是把包 sound.effects 和它里面定义的所有内容导入进来（可能运行 __init__.py 里定义的初始化代码）。 这会把 __init__.py 里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码: import sound.effects.echoimport sound.effects.surroundfrom sound.effects import * 这个例子中，在执行 from...import 前，包 sound.effects 中的 echo 和 surround 模块都被导入到当前的命名空间中了。（当然如果定义了 __all__ 就更没问题了） 通常我们并不主张使用 * 这种方法来导入模块，因为这种方法经常会导致代码的可读性降低。不过这样倒的确是可以省去不少敲键的功夫，而且一些模块都设计成了只能通过特定的方法导入。 记住，使用 from Package import specific_submodule 这种方法永远不会有错。事实上，这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。 如果在结构中包是一个子包（比如这个例子中对于包 sound 来说），而你又想导入兄弟包（同级别的包）你就得使用导入绝对的路径来导入。比如，如果模块 sound.filters.vocoder 要使用包 sound.effects 中的模块 echo，你就要写成 from sound.effects import echo。 from . import echofrom .. import formatsfrom ..filters import equalizer 无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是 “__main__“，一个 Python 应用程序的主模块，应当总是使用绝对路径引用。 包还提供一个额外的属性 __path__。这是一个目录列表，里面每一个包含的目录都有为这个包服务的 __init__.py，你得在其他 __init__.py 被执行前定义哦。可以修改这个变量，用来影响包含在包里面的模块和子包。 这个功能并不常用，一般用来扩展包里面的模块。","tags":[null],"categories":[null]},{"title":"Python装饰器","path":"/wiki/Python/装饰器.html","content":"装饰器装饰器（decorators）是 Python 中的一种高级功能，它允许你动态地修改函数或类的行为。 装饰器是一种函数，它接受一个函数作为参数，并返回一个新的函数或修改原来的函数。 装饰器的语法使用 @decorator_name 来应用在函数或方法上。 Python 还提供了一些内置的装饰器，比如 @staticmethod 和 @classmethod，用于定义静态方法和类方法。 装饰器的应用场景： 日志记录: 装饰器可用于记录函数的调用信息、参数和返回值。 性能分析: 可以使用装饰器来测量函数的执行时间。 权限控制: 装饰器可用于限制对某些函数的访问权限。 缓存: 装饰器可用于实现函数结果的缓存，以提高性能。 基本语法Python 装饰允许在不修改原有函数代码的基础上，动态地增加或修改函数的功能，装饰器本质上是一个接收函数作为输入并返回一个新的包装过后的函数的对象。 def decorator_function(original_function): def wrapper(*args, **kwargs): # 这里是在调用原始函数前添加的新功能 # before_call_code() print(before_call_code) result = original_function(*args, **kwargs) # 这里是在调用原始函数后添加的新功能 #after_call_code() print(after_call_code) return result return wrapper# 使用装饰器@decorator_functiondef target_function(arg1, arg2): print(run code)target_function(1,2) 输出结果： before_call_coderun codeafter_call_code 解析： decorator 是一个装饰器函数，它接受一个函数 func 作为参数，并返回一个内部函数 wrapper，在 wrapper 函数内部，你可以执行一些额外的操作，然后调用原始函数 func，并返回其结果。 decorator_function 是装饰器，它接收一个函数 original_function 作为参数。 wrapper 是内部函数，它是实际会被调用的新函数，它包裹了原始函数的调用，并在其前后增加了额外的行为。 当我们使用 @decorator_function 前缀在 target_function 定义前，Python 会自动将 target_function 作为参数传递给 decorator_function，然后将返回的 wrapper 函数替换掉原来的 target_function。 装饰器通过 @ 符号应用在函数定义之前，例如： @time_loggerdef target_function(): pass 等同于： def target_function(): passtarget_function = time_logger(target_function) 这会将 target_function 函数传递给 decorator 装饰器，并将返回的函数重新赋值给 target_function。从而，每次调用 target_function 时，实际上是调用了经过装饰器处理后的函数。 通过装饰器，开发者可以在保持代码整洁的同时，灵活且高效地扩展程序的功能。 带参数的装饰器装饰器函数也可以接受参数，例如： def repeat(n): def decorator(func): def wrapper(*args, **kwargs): for _ in range(n): result = func(*args, **kwargs) return result return wrapper return decorator@repeat(3)def greet(name): print(fHello, name!)greet(Alice) 以上代码中 repeat 函数是一个带参数的装饰器，它接受一个整数参数 n，然后返回一个装饰器函数。该装饰器函数内部定义了 wrapper 函数，在调用原始函数之前重复执行 n 次。因此，greet 函数在被 @repeat(3) 装饰后，会打印三次问候语。 输出结果： Hello, Alice!Hello, Alice!Hello, Alice! dataclasses@dataclass 是 Python 3.7 引入的一个装饰器，用于自动生成类的特殊方法，如 init()、repr() 和 eq() 等。 使用 @dataclass 可以简化类的定义，使其更加简洁和易读。 导入 dataclass： from dataclasses import dataclass 定义类并使用 @dataclass 装饰： @dataclassclass MyClass: field1: type field2: type # 可以添加默认值 field3: type = default_value 自动生成的方法：__init__()：根据类定义的字段自动生成初始化方法。__repr__()：生成一个字符串表示，方便调试。__eq__()：生成比较方法，用于比较两个实例是否相等。 可选参数：init：是否自动生成 __init__() 方法，默认为 True。repr：是否自动生成 __repr__() 方法，默认为 True。eq：是否自动生成 __eq__() 方法，默认为 True。order：是否生成比较方法（__lt__, __le__, __gt__, __ge__），默认为 False。unsafe_hash：是否生成 __hash__() 方法，默认为 False。 示例： from dataclasses import dataclass@dataclassclass Product: name: str price: float quantity: int = 0 def total_cost(self) - float: return self.price * self.quantity# 使用示例product = Product(name=Laptop, price=1200.0, quantity=3)print(product) # 输出: Product(name=Laptop, price=1200.0, quantity=3)print(product.total_cost()) # 输出: 3600.0","tags":[null],"categories":[null]},{"title":"Python运算符","path":"/wiki/Python/运算符.html","content":"运算符类型Python 语言支持以下类型的运算符: 算术运算符 比较（关系）运算符 赋值运算符 逻辑运算符 位运算符 成员运算符 身份运算符 Python 算术运算符以下假设变量 a 10，变量 b 21： 运算符 描述 实例 + 加 - 两个对象相加 a + b 输出结果 31 - 减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -11 * 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 210 除 - x 除以 y b a 输出结果 2.1 % 取模 - 返回除法的余数 b % a 输出结果 1 ** 幂 - 返回 x 的 y 次幂 a** b 为 10 的 21 次方 取整除 - 往小的方向取整数 9//2 4 -9//2 -5 a = 21b = 10c = 0 c = a + bprint (1 - c 的值为：, c) c = a - bprint (2 - c 的值为：, c) c = a * bprint (3 - c 的值为：, c) c = a / bprint (4 - c 的值为：, c) c = a % bprint (5 - c 的值为：, c) # 修改变量 a 、b 、ca = 2b = 3c = a**b print (6 - c 的值为：, c) a = 10b = 5c = a//b print (7 - c 的值为：, c) 以上实例输出结果： 1 - c 的值为： 312 - c 的值为： 113 - c 的值为： 2104 - c 的值为： 2.15 - c 的值为： 16 - c 的值为： 87 - c 的值为： 2 Python 比较运算符以下假设变量 a 为 10，变量 b 为 20： 运算符 描述 实例 等于 - 比较对象是否相等 (a b) 返回 False。 ! 不等于 - 比较两个对象是否不相等 (a ! b) 返回 True。 大于 - 返回 x 是否大于 y (a b) 返回 False。 小于 - 返回 x 是否小于 y。所有比较运算符返回 1 表示真，返回 0 表示假。这分别与特殊的变量 True 和 False 等价。注意，这些变量名的大写。 (a b) 返回 True。 大于等于 - 返回 x 是否大于等于 y。 (a b) 返回 False。 小于等于 - 返回 x 是否小于等于 y。 (a b) 返回 True。 以下实例演示了 Python 所有比较运算符的操作： a = 21b = 10c = 0 if ( a == b ): print (1 - a 等于 b)else: print (1 - a 不等于 b) if ( a != b ): print (2 - a 不等于 b)else: print (2 - a 等于 b) if ( a b ): print (3 - a 小于 b)else: print (3 - a 大于等于 b) if ( a b ): print (4 - a 大于 b)else: print (4 - a 小于等于 b) # 修改变量 a 和 b 的值a = 5b = 20if ( a = b ): print (5 - a 小于等于 b)else: print (5 - a 大于 b) if ( b = a ): print (6 - b 大于等于 a)else: print (6 - b 小于 a) 以上实例输出结果： 1 - a 不等于 b2 - a 不等于 b3 - a 大于等于 b4 - a 大于 b5 - a 小于等于 b6 - b 大于等于 a Python 赋值运算符以下假设变量 a 为 10，变量 b 为 20： 运算符 描述 实例 简单的赋值运算符 c a + b 将 a + b 的运算结果赋值为 c + 加法赋值运算符 c + a 等效于 c c + a - 减法赋值运算符 c - a 等效于 c c - a * 乘法赋值运算符 c a 等效于 c c a 除法赋值运算符 c a 等效于 c c a % 取模赋值运算符 c % a 等效于 c c % a ** 幂赋值运算符 c a 等效于 c c a 取整除赋值运算符 c a 等效于 c c a : 海象运算符，这个运算符的主要目的是在表达式中同时进行赋值和返回赋值的值。Python3.8 版本新增运算符。 在这个示例中，赋值表达式可以避免调用 len() 两次: if (n := len(a)) 10: print(fList is too long (n elements, expected = 10)) 以下实例演示了 Python 所有赋值运算符的操作： #!/usr/bin/python3 a = 21b = 10c = 0 c = a + bprint (1 - c 的值为：, c) c += aprint (2 - c 的值为：, c) c *= aprint (3 - c 的值为：, c) c /= a print (4 - c 的值为：, c) c = 2c %= aprint (5 - c 的值为：, c) c **= aprint (6 - c 的值为：, c) c //= aprint (7 - c 的值为：, c) 以上示例输出结果： 1 - c 的值为： 312 - c 的值为： 523 - c 的值为： 10924 - c 的值为： 52.05 - c 的值为： 26 - c 的值为： 20971527 - c 的值为： 99864 在 Python 3.8 及更高版本中，引入了一种新的语法特性，称为 “海象运算符”（Walrus Operator），它使用 := 符号。这个运算符的主要目的是在表达式中同时进行赋值和返回赋值的值。 使用海象运算符可以在一些情况下简化代码，尤其是在需要在表达式中使用赋值结果的情况下。这对于简化循环条件或表达式中的重复计算很有用。 下面是一个简单的实例，演示了海象运算符的使用： # 传统写法n = 10if n 5: print(n)# 使用海象运算符if (n := 10) 5: print(n) 海象运算符的优点： 海象运算符（:=）允许在表达式内部进行赋值，这可以减少代码的重复，提高代码的可读性和简洁性。 在上述例子中，传统写法需要单独一行来赋值 n，然后在 if 语句中进行条件检查。而使用海象运算符的写法可以在 if 语句中直接进行赋值和条件检查。 Python 位运算符按位运算符是把数字看作二进制来进行计算的。Python 中的按位运算法则如下： 下表中变量 a 为 60，b 为 13 二进制格式如下： a = 0011 1100b = 0000 1101-----------------ab = 0000 1100a|b = 0011 1101a^b = 0011 0001~a = 1100 0011 运算符 描述 实例 按位与运算符：参与运算的两个值, 如果两个相应位都为 1, 则该位的结果为 1, 否则为 0 (a b) 输出结果 12 ，二进制解释： 0000 1100 | 按位或运算符：只要对应的二个二进位有一个为 1 时，结果位就为 1。 (a | b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为 1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反, 即把 1 变为 0, 把 0 变为 1。**~x** 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。 左移动运算符：运算数的各二进位全部左移若干位，由 “” 右边的数指定移动的位数，高位丢弃，低位补 0。 a 2 输出结果 240 ，二进制解释： 1111 0000 右移动运算符：把 “” 左边的运算数的各二进位全部右移若干位，”” 右边的数指定移动的位数 a 2 输出结果 15 ，二进制解释： 0000 1111 以下实例演示了 Python 所有位运算符的操作： #!/usr/bin/python3 a = 60 # 60 = 0011 1100 b = 13 # 13 = 0000 1101 c = 0 c = a b # 12 = 0000 1100print (1 - c 的值为：, c) c = a | b # 61 = 0011 1101 print (2 - c 的值为：, c) c = a ^ b # 49 = 0011 0001print (3 - c 的值为：, c) c = ~a # -61 = 1100 0011print (4 - c 的值为：, c) c = a 2 # 240 = 1111 0000print (5 - c 的值为：, c) c = a 2 # 15 = 0000 1111print (6 - c 的值为：, c) 以上实例输出结果： 1 - c 的值为： 122 - c 的值为： 613 - c 的值为： 494 - c 的值为： -615 - c 的值为： 2406 - c 的值为： 15 Python 逻辑运算符Python 语言支持逻辑运算符，以下假设变量 a 为 10, b 为 20: 运算符 逻辑表达式 描述 实例 and x and y 布尔 “与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔 “或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔 “非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 以上实例输出结果： #!/usr/bin/python3 a = 10b = 20 if ( a and b ): print (1 - 变量 a 和 b 都为 true) # 1 - 变量 a 和 b 都为 trueelse: print (1 - 变量 a 和 b 有一个不为 true) if ( a or b ): print (2 - 变量 a 和 b 都为 true，或其中一个变量为 true) # 2 - 变量 a 和 b 都为 true，或其中一个变量为 trueelse: print (2 - 变量 a 和 b 都不为 true) # 修改变量 a 的值a = 0if ( a and b ): print (3 - 变量 a 和 b 都为 true)else: print (3 - 变量 a 和 b 有一个不为 true) # 3 - 变量 a 和 b 有一个不为 true if ( a or b ): print (4 - 变量 a 和 b 都为 true，或其中一个变量为 true) # 4 - 变量 a 和 b 都为 true，或其中一个变量为 trueelse: print (4 - 变量 a 和 b 都不为 true) if not( a and b ): print (5 - 变量 a 和 b 都为 false，或其中一个变量为 false) # 5 - 变量 a 和 b 都为 false，或其中一个变量为 falseelse: print (5 - 变量 a 和 b 都为 true) Python 成员运算符除了以上的一些运算符之外，Python 还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 以下实例演示了 Python 所有成员运算符的操作： #!/usr/bin/python3 a = 10b = 20list = [1, 2, 3, 4, 5 ] if ( a in list ): print (1 - 变量 a 在给定的列表中 list 中)else: print (1 - 变量 a 不在给定的列表中 list 中) if ( b not in list ): print (2 - 变量 b 不在给定的列表中 list 中)else: print (2 - 变量 b 在给定的列表中 list 中) # 修改变量 a 的值a = 2if ( a in list ): print (3 - 变量 a 在给定的列表中 list 中)else: print (3 - 变量 a 不在给定的列表中 list 中) 以上示例输出结果： 1 - 变量 a 不在给定的列表中 list 中2 - 变量 b 不在给定的列表中 list 中3 - 变量 a 在给定的列表中 list 中 Python 身份运算符身份运算符用于比较两个对象的存储单元 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 **id(x) ! id(y)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。 注： id() 函数用于获取对象内存地址。 以下示例演示了 Python 所有身份运算符的操作： #!/usr/bin/python3 a = 20b = 20 if ( a is b ): print (1 - a 和 b 有相同的标识)else: print (1 - a 和 b 没有相同的标识) if ( id(a) == id(b) ): print (2 - a 和 b 有相同的标识)else: print (2 - a 和 b 没有相同的标识) # 修改变量 b 的值b = 30if ( a is b ): print (3 - a 和 b 有相同的标识)else: print (3 - a 和 b 没有相同的标识) if ( a is not b ): print (4 - a 和 b 没有相同的标识)else: print (4 - a 和 b 有相同的标识) 以上示例输出结果： 1 - a 和 b 有相同的标识2 - a 和 b 有相同的标识3 - a 和 b 没有相同的标识4 - a 和 b 没有相同的标识 #is 与 == 区别：#is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。a = [1, 2, 3] b = a b is a True b == aTrue b = a[:] b is aFalse b == aTrue Python 运算符优先级以下表格列出了从最高到最低优先级的所有运算符， 相同单元格内的运算符具有相同优先级。 运算符均指二元运算，除非特别指出。 相同单元格内的运算符从左至右分组（除了幂运算是从右至左分组）： 运算符 描述 (expressions...), [expressions...], key: value..., expressions... 圆括号的表达式 x[index], x[index:index], x(arguments...), x.attribute 读取，切片，调用，属性引用 await x await 表达式 ** 乘方(指数) +x, -x, ~x 正，负，按位非 NOT *, @, /, //, % 乘，矩阵乘，除，整除，取余 +, - 加和减 , 移位 按位与 AND ^ 按位异或 XOR | 按位或 OR in,not in, is,is not, , =, , =, !=, == 比较运算，包括成员检测和标识号检测 not x 逻辑非 NOT and 逻辑与 AND or 逻辑或 OR if -- else 条件表达式 lambda lambda 表达式 := 赋值表达式 以下实例演示了 Python 所有运算符优先级的操作： #!/usr/bin/python3 a = 20b = 10c = 15d = 5e = 0 e = (a + b) * c / d #( 30 * 15 ) / 5print ((a + b) * c / d 运算结果为：, e) e = ((a + b) * c) / d # (30 * 15 ) / 5print (((a + b) * c) / d 运算结果为：, e) e = (a + b) * (c / d) # (30) * (15/5)print ((a + b) * (c / d) 运算结果为：, e) e = a + (b * c) / d # 20 + (150/5)print (a + (b * c) / d 运算结果为：, e) 以上实例输出结果： (a + b) * c / d 运算结果为： 90.0((a + b) * c) / d 运算结果为： 90.0(a + b) * (c / d) 运算结果为： 90.0a + (b * c) / d 运算结果为： 50.0 and 拥有更高优先级: x = Truey = Falsez = False if x or y and z: print(yes)else: print(no) 以上实例先计算 y and z 并返回 False ，然后 x or False 返回 True，输出结果： yes 注意： Python3 已不支持 运算符，可以使用 ! 代替，如果你一定要使用这种比较运算符，可以使用以下的方式： from __future__ import barry_as_FLUFL 1 2 True python","tags":[null],"categories":[null]},{"title":"Python迭代器和生成器","path":"/wiki/Python/迭代器和生成器.html","content":"迭代器迭代是 Python 最强大的功能之一，是访问集合元素的一种方式。 迭代器是一个可以记住遍历的位置的对象。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法：iter() 和 next()。 字符串，列表或元组对象都可用于创建迭代器： str = abcdit1 = iter(str)print(it1) # str_ascii_iterator object at 0x000001E778C5F370list = [1,2,3,4]it2 = iter(list) print(it2) # list_iterator object at 0x000001E778C5F3D0tup = (1,2,3,4)it3 = iter(tup) print(it3) # tuple_iterator object at 0x000001E778C5F400set = 1,2,3,4it4 = iter(set)print(it4) # set_iterator object at 0x000001E778C7E080dic = a:1,b:2it5 = iter(dic)print(it5) # dict_keyiterator object at 0x000001E778BFB4C0 迭代器对象可以使用常规 for 语句进行遍历： #!/usr/bin/python3 list=[1,2,3,4]it = iter(list) # 创建迭代器对象for x in it: print (x, end= ) #1 2 3 4 也可以使用 next() 函数： #!/usr/bin/python3 import sys # 引入 sys 模块 list=[1,2,3,4]it = iter(list) # 创建迭代器对象 while True: try: print (next(it)) except StopIteration: # StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况， sys.exit() 输出结果： 1234 生成器(yield)在 Python 中，使用了 yield 的函数被称为生成器（generator）。 yield 是一个关键字，用于定义生成器函数，生成器函数是一种特殊的函数，可以在迭代过程中逐步产生值，而不是一次性返回所有结果。 跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。 当在生成器函数中使用 yield 语句时，函数的执行将会暂停，并将 yield 后面的表达式作为当前迭代的值返回。 然后，每次调用生成器的 next() 方法或使用 for 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 yield 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果。 调用一个生成器函数，返回的是一个迭代器对象。 下面是一个简单的示例，展示了生成器函数的使用： def countdown(n): while n 0: yield n n -= 1 # 创建生成器对象generator = countdown(5) # 通过迭代生成器获取值print(next(generator)) # 输出: 5print(next(generator)) # 输出: 4print(next(generator)) # 输出: 3 # 使用 for 循环迭代生成器for value in generator: print(value) # 输出: 2 1 以上实例中，countdown 函数是一个生成器函数。它使用 yield 语句逐步产生从 n 到 1 的倒数数字。在每次调用 yield 语句时，函数会返回当前的倒数值，并在下一次调用时从上次暂停的地方继续执行。 通过创建生成器对象并使用 next() 函数或 for 循环迭代生成器，我们可以逐步获取生成器函数产生的值。在这个例子中，我们首先使用 next() 函数获取前三个倒数值，然后通过 for 循环获取剩下的两个倒数值。 生成器函数的优势是它们可以按需生成值，避免一次性生成大量数据并占用大量内存。此外，生成器还可以与其他迭代工具（如 for 循环）无缝配合使用，提供简洁和高效的迭代方式。","tags":[null],"categories":[null]},{"title":"Python错误和异常","path":"/wiki/Python/错误和异常.html","content":"Python 有两种错误很容易辨认：语法错误和异常。 Python assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。 语法错误Python 的语法错误或者称之为解析错，是初学者经常碰到的，如下： while True print(Hello world) File stdin, line 1, in ? while True print(Hello world) ^SyntaxError: invalid syntax 这个例子中，函数 print() 被检查到有错误，是它前面缺少了一个冒号 : 。 语法分析器指出了出错的一行，并且在最先找到的错误的位置标记了一个小小的箭头。 异常即便 Python 程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。 大多数的异常都不会被程序处理，都以错误信息的形式展现在这里: 10 * (1/0) # 0 不能作为除数，触发异常Traceback (most recent call last): File stdin, line 1, in ?ZeroDivisionError: division by zero 4 + spam*3 # spam 未定义，触发异常Traceback (most recent call last): File stdin, line 1, in ?NameError: name spam is not defined 2 + 2 # int 不能与 str 相加，触发异常Traceback (most recent call last): File stdin, line 1, in moduleTypeError: can only concatenate str (not int) to str 异常以不同的类型出现，这些类型都作为信息的一部分打印出来: 例子中的类型有 ZeroDivisionError，NameError 和 TypeError。 错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。 异常处理异常捕捉可以使用 try/except 语句。 以下例子中，让用户输入一个合法的整数，但是允许用户中断这个程序（使用 Control-C 或者操作系统提供的方法）。用户中断的信息会引发一个 KeyboardInterrupt 异常。 while True: try: x = int(input(请输入一个数字: )) break except ValueError: print(您输入的不是数字，请再次尝试输入！) try 语句按照如下方式工作； 首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。 如果没有异常发生，忽略 except 子句，try 子句执行后结束。 如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。 如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。 一个 try 语句可能包含多个 except 子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。 处理程序将只针对对应的 try 子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。 一个 except 子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如： except (RuntimeError, TypeError, NameError): pass 最后一个except 子句可以忽略异常的名称，它将被当作通配符使用。你可以使用这种方法打印一个错误信息，然后再次把异常抛出。 import systry: f = open(myfile.txt) s = f.readline() i = int(s.strip())except OSError as err: print(OS error: 0.format(err))except ValueError: print(Could not convert data to an integer.)except: print(Unexpected error:, sys.exc_info()[0]) raise tryexcept…elsetry/except 语句还有一个可选的 else 子句，如果使用这个子句，那么必须放在所有的 except 子句之后。 else 子句将在 try 子句没有发生任何异常的时候执行。 以下实例在 try 语句中判断文件是否可以打开，如果打开文件时正常的没有发生异常则执行 else 部分的语句，读取文件内容： for arg in sys.argv[1:]: try: f = open(arg, r) except IOError: print(cannot open, arg) else: print(arg, has, len(f.readlines()), lines) f.close() 使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到，而 except 又无法捕获的异常。 异常处理并不仅仅处理那些直接发生在 try 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。 例如： def this_fails(): x = 1/0 try: this_fails() except ZeroDivisionError as err: print(Handling run-time error:, err) Handling run-time error: int division or modulo by zero try…finallytry-finally 语句无论是否发生异常都将执行最后的代码。 以下实例中 finally 语句无论异常是否发生都会执行： try: runoob()except AssertionError as error: print(error)else: try: with open(file.log) as file: read_data = file.read() except FileNotFoundError as fnf_error: print(fnf_error)finally: print(这句话，无论异常是否发生都会执行。) 抛出异常Python 使用 raise 语句抛出一个指定的异常。 raise 语法格式如下： raise [Exception [, args [, traceback]]] 以下实例如果 x 大于 5 就触发异常： x = 10if x 5: raise Exception(x 不能大于 5。x 的值为: .format(x)) 执行以上代码会触发异常： Traceback (most recent call last):File “test.py”, line 3, in moduleraise Exception(‘x 不能大于 5。x 的值为: {}’.format(x))Exception: x 不能大于 5。x 的值为: 10 raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。 如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。 try: raise NameError(HiThere) # 模拟一个异常。 except NameError: print(An exception flew by!) raise # 再次抛出 An exception flew by!Traceback (most recent call last): File stdin, line 2, in ?NameError: HiThere 用户自定义异常你可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承。 class MyError(Exception): def __init__(self, value): self.value = value def __str__(self): return repr(self.value) try: raise MyError(2*2) except MyError as e: print(My exception occurred, value:, e.value) My exception occurred, value: 4 raise MyError(oops!)Traceback (most recent call last): File stdin, line 1, in ?__main__.MyError: oops! 在这个例子中，类 Exception 默认的 __init__() 被覆盖。 当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类： class Error(Exception): Base class for exceptions in this module. passclass InputError(Error): Exception raised for errors in the input. Attributes: expression -- input expression in which the error occurred message -- explanation of the error def __init__(self, expression, message): self.expression = expression self.message = messageclass TransitionError(Error): Raised when an operation attempts a state transition thats not allowed. Attributes: previous -- state at beginning of transition next -- attempted new state message -- explanation of why the specific transition is not allowed def __init__(self, previous, next, message): self.previous = previous self.next = next self.message = message 大多数的异常的名字都以 “Error” 结尾，就跟标准的异常命名一样。 定义清理行为try 语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为。 try:... raise KeyboardInterrupt... finally:... print(Goodbye, world!)... Goodbye, world!Traceback (most recent call last): File stdin, line 2, in moduleKeyboardInterrupt 以上例子不管 try 子句里面有没有发生异常，finally 子句都会执行。 如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后被抛出。 下面是一个更加复杂的例子（在同一个 try 语句里包含 except 和 finally 子句）: def divide(x, y): try: result = x / y except ZeroDivisionError: print(division by zero!) else: print(result is, result) finally: print(executing finally clause) divide(2, 1)result is 2.0executing finally clause divide(2, 0)division by zero!executing finally clause divide(2, 1)executing finally clauseTraceback (most recent call last): File stdin, line 1, in ? File stdin, line 3, in divideTypeError: unsupported operand type(s) for /: str and str finally 子句始终都会执行。 预定义的清理行为(with)一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。 下面这个例子展示了尝试打开一个文件，然后把内容打印到屏幕上： for line in open(myfile.txt): print(line, end=) 以上这段代码的问题是，当执行完毕后，文件会保持打开状态，并没有被关闭。 关键词 with 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法： with open(myfile.txt) as f: for line in f: print(line, end=) 以上这段代码执行完毕后，就算在处理过程中出问题了，文件 f 总是会关闭。 Python 中的 with 语句用于异常处理，封装了 try…except…finally 编码范式，提高了易用性。 with 语句使代码更清晰、更具可读性， 它简化了文件流等公共资源的管理。 在处理文件对象时使用 with 关键字是一种很好的做法。 我们可以看下以下几种代码实例： 不使用 with，也不使用 try…except…finally。 file = open(./test_runoob.txt, w)file.write(hello world !)file.close() 以上代码如果在调用 write 的过程中，出现了异常，则 close 方法将无法被执行，因此资源就会一直被该程序占用而无法被释放。 接下来我们呢可以使用 try…except…finally 来改进代码： file = open(./test_runoob.txt, w)try: file.write(hello world)finally: file.close() 以上代码我们对可能发生异常的代码处进行 try 捕获，发生异常时执行 except 代码块，finally 代码块是无论什么情况都会执行，所以文件会被关闭，不会因为执行异常而占用资源。 使用 with 关键字： with open(./test_runoob.txt, w) as file: file.write(hello world !) 使用 with 关键字系统会自动调用 f.close() 方法， with 的作用等效于 try/finally 语句是一样的。 我们可以在执行 with 关键字后检验文件是否关闭： with open(./test_runoob.txt) as f:... read_data = f.read() # 查看文件是否关闭 f.closedTrue with 语句实现原理建立在上下文管理器之上。 上下文管理器是一个实现 __enter__ 和 __exit__ 方法的类。 使用 with 语句确保在嵌套块的末尾调用 exit 方法。 这个概念类似于 try...finally 块的使用。","tags":[null],"categories":[null]},{"title":"Python基本数据类型","path":"/wiki/Python/基本数据类型.html","content":"基本数据类型Python 中的变量 不需要声明。每个变量在 使用前都必须赋值，变量赋值以后该变量才会被创建。 在 Python 中，变量就是变量，它没有类型，我们所说的 “类型” 是变量所指的 内存中对象的类型。 等号（）用来给变量赋值。 等号（）运算符左边是一个变量名，等号（）运算符右边是存储在变量中的值。 #!/usr/bin/python3 count = 100 # 整形变量miles = 1.0 # 浮点型变量name = 张三 # 字符串print(count, miles, name) 多个变量赋值Python 允许你同时为多个变量赋值。例如： a = b = c = 张三print(a, b, c) 以上实例，创建一个整型对象，值为 ‘’张三’’，从后向前赋值，三个变量被赋予相同的数值。 也可以为多个对象指定多个变量。 #!/usr/bin/python3 a,b,c = 张三,1,2print(a) # 张三print(b) # 1print(c) # 2a,b,c = 张三,1 # 这种情况会报错 标准数据类型Python3 中常见的数据类型有： Number（数字） int float bool complex String（字符串） bool（布尔类型） True False List（列表） Tuple（元组） Set（集合） Dictionary（字典） Python3 的六个标准数据类型中： 不可变数据（3 个）： Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）： List（列表）、Dictionary（字典）、Set（集合）。 此外还有一些高级的数据类型，如: 字节数组类型(bytes)。 NumberNumber 基础Python3 支持 int、float、bool、complex（复数）。 在 Python 3 里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。 数据类型是不允许改变的，这就意味着如果改变数字数据类型的值，将重新分配内存空间。 像大多数语言一样，数值类型的赋值和计算都是很直观的。 内置的 type() 函数可以用来查询变量所指的对象类型。 a,b,c,d=20,5.5,True,4+3j # j 在 Python 中表示虚数单位，用于定义复数# 复数由实数部分和虚数部分构成，可以用 a + bj，或者 complex(a,b) 表示， 复数的实部 a 和虚部 b 都是浮点型。 print(type(a),type(b),type(c),type(d))class int class float class bool class complex 此外还可以用 isinstance 来判断： a = 111 isinstance(a, int)True isinstance 和 type 的区别在于： type()不会认为子类是一种父类类型。 isinstance()会认为子类是一种父类类型。 class A:... pass... class B(A):... pass... isinstance(A(), A)True type(A()) == A True isinstance(B(), A)True type(B()) == AFalse A 是一个基类。 B 继承自 A，即 B 是 A 的子类。 注意： Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加，True 1、False 0 会返回 True，但可以通过 is 来判断类型。 issubclass(bool, int) True True==1True False==0True True+12 False+11 1 is TrueFalse 0 is FalseFalse bool 继承自 int，但它是一个独立的类型。 True == 1 和 False == 0 结果为 True，因为它们的值相等。 True is 1 结果为 False，因为 is 比较的是对象身份，而它们的类型不同 在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。 当指定一个值时，Number 对象就会被创建： a = 1b = 2.2 数值运算： 5 + 4 # 加法9 4.3 - 2 # 减法2.3 3 * 7 # 乘法21 2 / 4 # 除法，得到一个浮点数0.5 2 // 4 # 除法，得到一个整数0 17 % 3 # 取余 2 2 ** 5 # 乘方32 1、Python 可以同时为多个变量赋值，如 a, b 1, 2。2、一个变量可以通过赋值指向不同类型的对象。3、数值的除法包含两个运算符：**** 返回一个浮点数，**** 返回一个整数。4、在混合计算时，Python 会把整型转换成为浮点数。 常用函数数学函数 函数 返回值 ( 描述 ) abs(x) 返回数字的绝对值，如 abs(-10) 返回 10 ceil(x) 返回数字的上入整数，如 math.ceil(4.1) 返回 5 cmp(x, y) 如果 x y 返回 -1, 如果 x y 返回 0, 如果 x y 返回 1。 Python 3 已废弃，使用 (x y)-(x y) 替换。 exp(x) 返回 e 的 x 次幂(ex), 如 math.exp(1) 返回 2.718281828459045 fabs(x) 以浮点数形式返回数字的绝对值，如 math.fabs(-10) 返回 10.0 floor(x) 返回数字的下舍整数，如 math.floor(4.9)返回 4 log(x) 如 math.log(math.e)返回 1.0, math.log(100,10)返回 2.0 log10(x) 返回以 10 为基数的 x 的对数，如 math.log10(100)返回 2.0 max(x1, x2,…) 返回给定参数的最大值，参数可以为序列。 min(x1, x2,…) 返回给定参数的最小值，参数可以为序列。 modf(x) 返回 x 的整数部分与小数部分，两部分的数值符号与 x 相同，整数部分以浮点型表示。 pow(x, y) x**y 运算后的值。 [round(x , n]) 返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。其实准确的说是保留值将保留到离上一位更近的一端。 sqrt(x) 返回数字 x 的平方根。 随机数函数随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。 Python 包含以下常用随机数函数： 函数 描述 choice(seq) 从序列的元素中随机挑选一个元素，比如 random.choice(range(10))，从 0 到 9 中随机挑选一个整数。 [randrange (start,] stop [, step]) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1 random() 随机生成下一个实数，它在[0,1)范围内。 [seed(x]) 改变随机数生成器的种子 seed。如果你不了解其原理，你不必特别去设定 seed，Python 会帮你选择 seed。 shuffle(lst) 将序列的所有元素随机排序 uniform(x, y) 随机生成下一个实数，它在 [x, y] 范围内。 三角函数Python 包括以下三角函数： 函数 描述 acos(x) 返回 x 的反余弦弧度值。 asin(x) 返回 x 的反正弦弧度值。 atan(x) 返回 x 的反正切弧度值。 atan2(y, x) 返回给定的 X 及 Y 坐标值的反正切值。 cos(x) 返回 x 的弧度的余弦值。 hypot(x, y) 返回欧几里德范数 sqrt(x x + y y)。 sin(x) 返回的 x 弧度的正弦值。 tan(x) 返回 x 弧度的正切值。 degrees(x) 将弧度转换为角度, 如 degrees(math.pi2) ， 返回 90.0 radians(x) 将角度转换为弧度 数学常量 常量 描述 pi 数学常量 pi（圆周率，一般以 π 来表示） e 数学常量 e，e 即自然常数（自然常数）。 StringString 基础Python 中的字符串用单引号 ‘ 或双引号 “ 括起来，同时使用反斜杠 \\ 转义特殊字符。 字符串的截取的语法格式如下： 变量[头下标:尾下标] 索引值以 0 为开始值，-1 为从末尾的开始位置。 [头下标:尾下标] 获取的子字符串包含头下标的字符，但不包含尾下标的字符。 + 是字符串的连接符， * 表示复制当前字符串，与之结合的数字为复制的次数。 #!/usr/bin/python3str = Runoob # 定义一个字符串变量print(str) # 打印整个字符串 Runoobprint(str[0:-1]) # 打印字符串第一个到倒数第二个字符（不包含倒数第一个字符）Runooprint(str[0]) # 打印字符串的第一个字符 Rprint(str[2:5]) # 打印字符串第三到第五个字符（包含第五个字符）nooprint(str[2:]) # 打印字符串从第三个字符开始到末尾 noobprint(str * 2) # 打印字符串两次 RunoobRunoobprint(str + TEST) # 打印字符串和TEST拼接在一起 RunoobTEST Python 使用反斜杠 \\ 转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串： print(hel lo)hello print(rhel lo)hel lo 另外，\\可以作为续行符，表示下一行是上一行的延续。也可以使用 ... 或者 ... 跨越多行。 注意，Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。 str = 张三 print(str[1])三 print(str[0])张 print(str[3]) Python 字符串不能被改变。向一个索引位置赋值，比如 word [0] ‘m’ 会导致错误。 str[0] = 李Traceback (most recent call last): File python-input-40, line 1, in module str[0] = 李 ~~~^^^TypeError: str object does not support item assignment 1、反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。2、字符串可以用 + 运算符连接在一起，用 * 运算符重复。3、Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。4、Python 中的字符串 不能改变。 Python 转义字符在需要在字符中使用特殊字符时，Python 用反斜杠 \\ 转义字符。如下表： 转义字符 描述 实例 (在行尾时) 续行符 print(line1 \\ line2 \\ line3) line1 line2 line3 \\ 反斜杠符号 print(\\\\) \\ 单引号 print(\\) 双引号 print(\\) \\a 响铃 print(\\a) 执行后电脑有响声。 \\b 退格(Backspace) print(Hello \\b World!) Hello World! \\000 空 print(\\000) 换行 print( ) \\v 纵向制表符 print(Hello \\v World!) Hello World! \\t 横向制表符 print(Hello \\t World!) Hello World! \\r 回车，将 \\r 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 \\r 后面的内容完全替换完成。 print(Hello\\rWorld!) World! print(google runoob taobao\\r123456) 123456 runoob taobao \\f 换页 print(Hello \\f World!) Hello World! \\yyy 八进制数，y 代表 0~7 的字符，例如：\\012 代表换行。 print(\\110\\145\\154\\154\\157\\40\\127\\157\\162\\154\\144\\41) Hello World! \\xyy 十六进制数，以 \\x 开头，y 代表的字符，例如：\\x0a 代表换行 print(\\x48\\x65\\x6c\\x6c\\x6f\\x20\\x57\\x6f\\x72\\x6c\\x64\\x21) Hello World! \\other 其它的字符以普通格式输出 Python 字符串运算符下表实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”： 操作符 描述 实例 + 字符串连接 a + b 输出结果： HelloPython * 重复输出字符串 a* 2 输出结果：HelloHello [] 通过索引获取字符串中字符 a [1] 输出结果 e [ : ] 截取字符串中的一部分，遵循 左闭右开 原则，str [0:2] 是不包含第 3 个字符的。 a [1:4] 输出结果 ell in 成员运算符 - 如果字符串中包含给定的字符返回 True ‘H’ in a 输出结果 True not in 成员运算符 - 如果字符串中不包含给定的字符返回 True ‘M’ not in a 输出结果 True rR 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 print( r ) print( R ) % 格式字符串 #!/usr/bin/python3 a = Hellob = Python print(a + b 输出结果：, a + b)print(a * 2 输出结果：, a * 2)print(a[1] 输出结果：, a[1])print(a[1:4] 输出结果：, a[1:4]) if( H in a) : print(H 在变量 a 中)else : print(H 不在变量 a 中) if( M not in a) : print(M 不在变量 a 中)else : print(M 在变量 a 中) print (r )print (R ) 以上实例输出结果为： a + b 输出结果： HelloPythona * 2 输出结果： HelloHelloa[1] 输出结果： ea[1:4] 输出结果： ellH 在变量 a 中M 不在变量 a 中 Python 字符串格式化Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。 在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。 #!/usr/bin/python3 print (我叫 %s 今年 %d 岁! % (小明, 10))# 我叫 小明 今年 10 岁！ Python 字符串格式化符号: 符 号 描述 %c 格式化字符及其 ASCII 码 %s 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同%e，用科学计数法格式化浮点数 %g %f 和%e 的简写 %G %f 和 %E 的简写 %p 用十六进制数格式化变量的地址 格式化操作符辅助指令: 符号 功能 * 定义宽度或者小数点精度 - 用做左对齐 + 在正数前面显示加号( + ) sp 在正数前面显示空格 # 在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’) 0 显示的数字前面填充’0’而不是默认的空格 % ‘%%’输出一个单一的’%’ (var) 映射变量(字典参数) m.n. m 是显示的最小总宽度, n 是小数点后的位数(如果可用的话) Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。 Python 三引号Python 三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。 #!/usr/bin/python3 para_str = 这是一个多行字符串的实例多行字符串可以使用制表符TAB ( \\t )。也可以使用换行符 [ ]。print (para_str) 这是一个多行字符串的实例多行字符串可以使用制表符TAB ( )。也可以使用换行符 [ ]。 三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的 WYSIWYG（所见即所得）格式的。 一个典型的用例是，当你需要一块 HTML 或者 SQL 时，这时用字符串组合，特殊字符串转义将会非常的繁琐。 errHTML = HTMLHEADTITLEFriends CGI Demo/TITLE/HEADBODYH3ERROR/H3B%s/BPFORMINPUT TYPE=button VALUE=BackONCLICK=window.history.back()/FORM/BODY/HTMLcursor.execute(CREATE TABLE users ( login VARCHAR(8), uid INTEGER,prid INTEGER)) f-stringf-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。 之前我们习惯用百分号 (%): name = Runoob Hello %s % nameHello Runoob f-string 格式化字符串以 f 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去，示例如下： name = Runoob fHello name # 替换变量Hello Runoob f1+2 # 使用表达式3 w = name: Runoob, url: www.runoob.com fw[name]: w[url]Runoob: www.runoob.com 用了这种方式明显更简单了，不用再去判断使用 %s，还是 %d。 在 Python 3.8 的版本中可以使用 符号来拼接运算表达式与结果。 x = 1 print(fx+1) # Python 3.62 x = 1 print(fx+1=) # Python 3.8x+1=2 Unicode 字符串在 Python2 中，普通字符串是以 8 位 ASCII 码进行存储的，而 Unicode 字符串则存储为 16 位 unicode 字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀 u。 在 Python3 中，所有的字符串都是 Unicode 字符串。 字符串内建函数Python 的字符串常用内建函数如下： 序号 方法及描述 1 capitalize() 将字符串的第一个字符转换为大写 2 center(width, fillchar) 返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。 3 count(str, beg 0, end len(string)) 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 4 bytes.decode(encoding “utf-8”, errors “strict”) Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。 5 encode(encoding ’UTF-8’, errors ’strict’) 以 encoding 指定的编码格式编码字符串，如果出错默认报一个 ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’ 6 endswith(suffix, beg 0, end len(string)) 检查字符串是否以 suffix 结束，如果 beg 或者 end 指定则检查指定的范围内是否以 suffix 结束，如果是，返回 True, 否则返回 False。 7 expandtabs(tabsize 8) 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。 8 find(str, beg 0, end len(string)) 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1 9 index(str, beg 0, end len(string)) 跟 find()方法一样，只不过如果 str 不在字符串中会报一个异常。 10 isalnum() 检查字符串是否由字母和数字组成，即字符串中的所有字符都是字母或数字。如果字符串至少有一个字符，并且所有字符都是字母或数字，则返回 True；否则返回 False。 11 isalpha() 如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False 12 isdigit() 如果字符串只包含数字则返回 True 否则返回 False.. 13 islower() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False 14 isnumeric() 如果字符串中只包含数字字符，则返回 True，否则返回 False 15 isspace() 如果字符串中只包含空白，则返回 True，否则返回 False. 16 istitle() 如果字符串是标题化的(见 title())则返回 True，否则返回 False 17 isupper() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False 18 join(seq) 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 19 len(string) 返回字符串长度 20 [ljust(width, fillchar]) 返回一个原字符串左对齐, 并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。 21 lower() 转换字符串中所有大写字符为小写. 22 lstrip() 截掉字符串左边的空格或指定字符。 23 maketrans() 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 24 max(str) 返回字符串 str 中最大的字母。 25 min(str) 返回字符串 str 中最小的字母。 26 [replace(old, new , max]) 把 将字符串中的 old 替换成 new, 如果 max 指定，则替换不超过 max 次。 27 rfind(str, beg 0, end len(string)) 类似于 find()函数，不过是从右边开始查找. 28 rindex( str, beg 0, end len(string)) 类似于 index()，不过是从右边开始. 29 [rjust(width,, fillchar]) 返回一个原字符串右对齐, 并使用 fillchar(默认空格）填充至长度 width 的新字符串 30 rstrip() 删除字符串末尾的空格或指定字符。 31 split(str “”, num string.count(str)) 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串 32 [splitlines(keepends]) 按照行(‘\\r’, ‘\\r ’, ’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 33 startswith(substr, beg 0, end len(string)) 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果 beg 和 end 指定值，则在指定范围内检查。 34 [strip(chars]) 在字符串上执行 lstrip()和 rstrip() 35 swapcase() 将字符串中大写转换为小写，小写转换为大写 36 title() 返回 “标题化” 的字符串, 就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) 37 translate(table, deletechars “”) 根据 table 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中 38 upper() 转换字符串中的小写字母为大写 39 zfill (width) 返回长度为 width 的字符串，原字符串右对齐，前面填充 0 40 isdecimal() 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。 bool布尔类型即 True 或 False。 在 Python 中，True 和 False 都是关键字，表示布尔值。 布尔类型可以用来控制程序的流程，比如判断某个条件是否成立，或者在某个条件满足时执行某段代码。 布尔类型特点： 布尔类型只有两个值：True 和 False。 bool 是 int 的子类，因此布尔值可以被看作整数来使用，其中 True 等价于 1。 布尔类型可以和其他数据类型进行比较，比如数字、字符串等。在比较时，Python 会将 True 视为 1，False 视为 0。 布尔类型可以和逻辑运算符一起使用，包括 and、or 和 not。这些运算符可以用来组合多个布尔表达式，生成一个新的布尔值。 布尔类型也可以被转换成其他数据类型，比如整数、浮点数和字符串。在转换时，True 会被转换成 1，False 会被转换成 0。 可以使用 bool() 函数将其他类型的值转换为布尔值。以下值在转换为布尔值时为 False：None、False、零 (0、0.0、0j)、空序列（如 、()、[]）和空映射（如 ）。其他所有值转换为布尔值时均为 True。 # 布尔类型的值和类型a = Trueb = Falseprint(type(a)) # class boolprint(type(b)) # class bool# 布尔类型的整数表现print(int(True)) # 1print(int(False)) # 0# 使用 bool() 函数进行转换print(bool(0)) # Falseprint(bool(-1)) # Trueprint(bool(-1.1)) # Trueprint(bool(1.1)) # Trueprint(bool(42)) # Trueprint(bool()) # Falseprint(bool(Python)) # Trueprint(bool([])) # Falseprint(bool([1, 2, 3])) # True# 布尔逻辑运算print(True and False) # Falseprint(True or False) # Trueprint(not True) # False# 布尔比较运算print(5 3) # Trueprint(2 == 2) # Trueprint(7 4) # False# 布尔值在控制流中的应用if True: print(This will always print) if not False: print(This will also always print) x = 10if x: print(x is non-zero and thus True in a boolean context) 注意: 在 Python 中，所有非零的数字和非空的字符串、列表、元组等数据类型都被视为 True，只有 0、空字符串、空列表、空元组 等被视为 False。因此，在进行布尔类型转换时，需要注意数据类型的真假性。 List []List 基础List（列表） 是 Python 中使用最频繁的数据类型。 列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，列表中的元素是可以改变的。它支持数字，字符串甚至可以包含列表（所谓嵌套）。 列表是写在方括号 [] 之间、用逗号分隔开的元素列表。 和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。 列表截取的语法格式如下： 变量[头下标:尾下标] 索引值以 0 为开始值，**-1** 为从末尾的开始位置。 加号 + 是列表连接运算符，星号 * 是重复操作。如下示例： #!/usr/bin/python3lst = [] * 3list = [ abcd, 786 , 2.23, runoob, 70.2 ] # 定义一个列表tinylist = [123, runoob]print(lst) # 初始化全0列表 []print (list) # 打印整个列表 [abcd, 786, 2.23, runoob, 70.2]print (list[0]) # 打印列表的第一个元素 abcdprint (list[1:3]) # 打印列表第二到第四个元素（不包含第四个元素）[786, 2.23] print (list[2:]) # 打印列表从第三个元素开始到末尾print (tinylist * 2) # 打印tinylist列表两次 [123, runoob, 123, runoob]print (list + tinylist) # 打印两个列表拼接在一起的结果 [abcd, 786, 2.23, runoob, 70.2, 123, runoob]print(list + tinylist * 2) # 先执行 * 再执行 + [abcd, 786, 2.23, runoob, 70.2, 123, runoob, 123, runoob]print((list + tinylist) * 2) # [abcd, 786, 2.23, runoob, 70.2, 123, runoob, abcd, 786, 2.23, runoob, 70.2, 123, runoob] [abcd, 786, 2.23, runoob, 70.2] abcd [786, 2.23] [2.23, runoob, 70.2] [123, runoob, 123, runoob] [abcd, 786, 2.23, runoob, 70.2, 123, runoob] [abcd, 786, 2.23, runoob, 70.2, 123, runoob, 123, runoob] [abcd, 786, 2.23, runoob, 70.2, 123, runoob, abcd, 786, 2.23, runoob, 70.2, 123, runoob] 与字符串不一样的是，列表中的元素是可以改变的： a = [1, 2, 3, 4, 5, 6] a[0] = 9 a[2:5] = [13, 14, 15] a[9, 2, 13, 14, 15, 6] a[2:5] = [] # 将对应的元素值设置为 [] a[9, 2, 6] List 内置了有很多方法，例如 append()、pop() 等等，这在后面会讲到。 1、列表写在方括号之间，元素用逗号隔开。2、和字符串一样，列表可以被索引和切片。3、列表可以使用 + 操作符进行拼接。4、列表中的元素是可以改变的。 Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串： 如果第三个参数为负数表示逆向读取，以下示例用于翻转字符串： def reverseWords(input): # 通过空格将字符串分隔符，把各个单词分隔为列表 inputWords = input.split( ) # 翻转字符串 # 假设列表 list = [1,2,3,4], # list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样) # inputWords[-1::-1] 有三个参数 # 第一个参数 -1 表示最后一个元素 # 第二个参数为空，表示移动到列表末尾 # 第三个参数为步长，-1 表示逆向 inputWords=inputWords[-1::-1] # 重新组合字符串 output = .join(inputWords) return output if __name__ == __main__: input = I like runoob rw = reverseWords(input) print(rw) # runoob like I 更新列表你可以对列表的数据项进行修改或更新，你也可以使用 append() 方法来添加列表项，如下所示： #!/usr/bin/python3list = [Google, Runoob, 1997, 2000]print (第三个元素为 : , list[2])list[2] = 2001print (更新后的第三个元素为 : , list[2])list1 = [Google, Runoob, Taobao]list1.append(Baidu)print (更新后的列表 : , list1) 第三个元素为 : 1997更新后的第三个元素为 : 2001更新后的列表 : [Google, Runoob, Taobao, Baidu] 删除列表元素可以使用 del 语句来删除列表中的元素： #!/usr/bin/python3 list = [Google, Runoob, 1997, 2000] print (原始列表 : , list)del list[2]print (删除第三个元素 : , list) 原始列表 : [Google, Runoob, 1997, 2000]删除第三个元素 : [Google, Runoob, 2000] 列表脚本操作符列表对 + 和 的操作符与字符串相似。+ 号用于组合列表， 号用于重复列表。 Python 表达式 结果 描述 len([1, 2, 3]) 3 长度 [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] 组合 [‘Hi!’] * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 重复 3 in [1, 2, 3] True 元素是否存在于列表中 for x in [1, 2, 3]: print(x, end” “) 1 2 3 迭代 列表截取与拼接Python 的列表截取与字符串操作类似，如下所示： Python 表达式 结果 描述 L [2] ‘Taobao’ 读取第三个元素 L [-2] ‘Runoob’ 从右侧开始读取倒数第二个元素: count from the right L [1:] [‘Runoob’, ‘Taobao’] 输出从第二个元素开始后的所有元素 L=[Google, Runoob, Taobao] L[2]Taobao L[-2]Runoob L[1:][Runoob, Taobao] 列表还支持拼接操作： squares = [1, 4, 9, 16, 25] squares += [36, 49, 64, 81, 100] squares[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 嵌套列表 a = [a, b, c] n = [1, 2, 3] x = [a, n] x[[a, b, c], [1, 2, 3]] x[0][a, b, c] x[0][1]b 列表比较列表比较需要引入 operator 模块的 eq 方法 # 导入 operator 模块import operatora = [1, 2]b = [2, 3]c = [2, 3]print(operator.eq(a,b): , operator.eq(a,b))print(operator.eq(c,b): , operator.eq(c,b)) operator.eq(a,b): Falseoperator.eq(c,b): True 列表函数方法 序号 函数 1 len(list) 列表元素个数 2 max(list) 返回列表元素最大值 3 min(list) 返回列表元素最小值 4 list(seq) 将元组转换为列表 序号 方法 1 list.append(obj) 在列表末尾添加新的对象 2 list.count(obj) 统计某个元素在列表中出现的次数 3 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） 4 list.index(obj) 从列表中找出某个值第一个匹配项的索引位置 5 list.insert(index, obj) 将对象插入列表 6 list.pop(index -1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 7 list.remove(obj) 移除列表中某个值的第一个匹配项 8 list.reverse() 反向列表中元素 9 list.sort( key None, reverse False) 对原列表进行排序 10 list.clear() 清空列表 11 list.copy() 复制列表 Tuple ()Tuple 基础元组（tuple）与列表类似，不同之处在于 元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。 元组中的元素类型也可以不相同： #!/usr/bin/python3tuple = (ab, 1 , 1.2, )tinytuple = (3, c, 3.1)tup2 = ()tup3 = a,b,c # 可以不需要括号print (tuple) # 输出完整元组print (tuple[0]) # 输出元组的第一个元素print (tuple[1:3]) # 输出从第二个元素开始到第三个元素print (tuple[2:]) # 输出从第三个元素开始的所有元素print (tinytuple * 2) # 输出两次元组print (tuple + tinytuple) # 连接元组 (‘ab’, 1, 1.2)ab(1, 1.2)(1.2,)(3, ‘c’, 3.1, 3, ‘c’, 3.1)(‘ab’, 1, 1.2, 3, ‘c’, 3.1) 元组与字符串类似，可以被索引且下标索引从 0 开始，-1 为从末尾开始的位置，也可以进行截取。 其实，可以把字符串看作一种特殊的元组。 tup = (1, 2, 3, 4, 5, 6) print(tup[0])1 print(tup[1:5])(2, 3, 4, 5) tup[0] = 11 # 修改元组元素的操作是非法的Traceback (most recent call last): File stdin, line 1, in moduleTypeError: tuple object does not support item assignment 虽然 tuple 的元素不可改变，但它可以包含可变的对象，比如 list 列表。 构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则： tup1 = () # 空元组tup2 = (20,) # 一个元素，需要在元素后添加逗号 如果你想创建只有一个元素的元组，需要注意在元素后面添加一个逗号，以区分它是一个元组而不是一个普通的值，这是因为在没有逗号的情况下，Python 会将括号解释为数学运算中的括号，而不是元组的表示。 如果不添加逗号，如下所示，它将被解释为一个普通的值而不是元组： not_a_tuple = (1)print(type(not_a_tuple)) # class inttuple = (1,)print(type(tuple)) # class tuple 这样的话，not_a_tuple 将是整数类型而不是元组类型。 string、list 和 tuple 都属于 sequence（序列）。 1、与字符串一样，元组的元素不能修改。2、元组也可以被索引和切片，方法一样。3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。4、元组也可以使用 + 操作符进行拼接。 访问元组元组可以使用下标索引来访问元组中的值，如下示例: #!/usr/bin/python3 tup1 = (Google, Runoob, 1997, 2000)tup2 = (1, 2, 3, 4, 5, 6, 7 ) print (tup1[0]: , tup1[0]) # tup1[0]: Googleprint (tup2[1:5]: , tup2[1:5]) # tup2[1:5]: (2, 3, 4, 5) 修改元组元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下示例: #!/usr/bin/python3 tup1 = (12, 34.56)tup2 = (abc, xyz) # 以下修改元组元素操作是非法的# tup1[0] = 100 # 创建一个新的元组tup3 = tup1 + tup2print (tup3) # (12, 34.56, abc, xyz) 删除元组元组中的元素值是不允许删除的，但我们可以使用 del 语句来删除整个元组，如下示例: tup = (Google, Runoob, 1997, 2000) del tup[0]Traceback (most recent call last): File python-input-66, line 1, in module del tup[0] ~~~^^^TypeError: tuple object doesnt support item deletion #!/usr/bin/python3 tup = (Google, Runoob, 1997, 2000) print (tup)del tupprint (删除后的元组 tup : )print (tup) 以上示例元组被删除后，输出变量会有异常信息，输出如下所示： 删除后的元组 tup : Traceback (most recent call last): File test.py, line 8, in module print (tup)NameError: name tup is not defined 元组运算符与字符串一样，元组之间可以使用 +、+= 和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。 Python 表达式 结果 描述 len((1, 2, 3)) 3 计算元素个数 a = (1, 2, 3) b = (4, 5, 6) c = a+b c (1, 2, 3, 4, 5, 6) (1, 2, 3, 4, 5, 6) 连接，c 就是一个新的元组，它包含了 a 和 b 中的所有元素。 a = (1, 2, 3) b = (4, 5, 6) a += b a (1, 2, 3, 4, 5, 6) (1, 2, 3, 4, 5, 6) 连接，a 就变成了一个新的元组，它包含了 a 和 b 中的所有元素。 (Hi!,) * 4 (‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’) 复制 3 in (1, 2, 3) True 元素是否存在 for x in (1, 2, 3): print (x, end= ) 1 2 3 迭代 元组索引，截取因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示： tup = (Google, Runoob, Taobao, Wiki, Weibo,Weixin) Python 表达式 结果 描述 tup [1] ‘Runoob’ 读取第二个元素 tup [-2] ‘Weibo’ 反向读取，读取倒数第二个元素 tup [1:] (‘Runoob’, ‘Taobao’, ‘Wiki’, ‘Weibo’, ‘Weixin’) 截取元素，从第二个开始后的所有元素。 tup [1:4] (‘Runoob’, ‘Taobao’, ‘Wiki’) 截取元素，从第二个开始到第四个元素（索引为 3）。 tup = (Google, Runoob, Taobao, Wiki, Weibo,Weixin) tup[1]Runoob tup[-2]Weibo tup[1:](Runoob, Taobao, Wiki, Weibo, Weixin) tup[1:4](Runoob, Taobao, Wiki) 元组内置函数Python 元组包含了以下内置函数 序号 方法及描述 实例 1 len(tuple) 计算元组元素个数。 tuple1 = (Google, Runoob, Taobao) len(tuple1) 3 2 max(tuple) 返回元组中元素最大值。 tuple2 = (5, 4, 8) max(tuple2) 8 3 min(tuple) 返回元组中元素最小值。 tuple2 = (5, 4, 8) min(tuple2) 4 4 tuple(iterable) 将可迭代系列转换为元组。 list1= [Google, Taobao, Runoob, Baidu] tuple1=tuple(list1) tuple1 (Google, Taobao, Runoob, Baidu) 关于元组是不可变的所谓元组的不可变指的是元组所指向的内存中的内容不可变。 tup = (r, u, n, o, o, b) tup[0] = g # 不支持修改元素Traceback (most recent call last): File stdin, line 1, in moduleTypeError: tuple object does not support item assignment id(tup) # 查看内存地址4440687904 tup = (1,2,3) id(tup)4441088800 # 内存地址不一样了 从以上示例可以看出，重新赋值的元组 tup，绑定到新的对象了，不是修改了原来的对象。 Set Set 基础Python 中的集合（Set）是一种 无序、可变 的数据类型，用于存储 唯一 的元素。 集合中的元素 不会重复，并且可以进行交集、并集、差集等常见的集合操作。 在 Python 中，集合使用大括号 表示，元素之间用逗号 , 分隔。 另外，也可以使用 set() 函数创建集合。 注意： 创建一个空集合必须用 set() 而不是 **{ }**，因为 { } 是用来创建一个空字典。 创建格式： parame = value01,value02,...或者set(value)param = 1,2,2print(param) # 1, 2print(set(1,2)) # 1, 2print(set(1233)) # 3, 2, 1 #!/usr/bin/python3sites = Google, Google, Taobao, Taobao, Runoob, Facebook, Zhihu, Baiduprint(sites) # 输出集合，重复的元素被自动去掉 Zhihu, Baidu, Taobao, Runoob, Google, Facebook# 成员测试 if Runoob in sites : print(Runoob 在集合中) else : print(Runoob 不在集合中)# Runoob 在集合中# set可以进行集合运算a = set(abracadabra)b = set(alacazam)print(a) # b, c, a, r, dprint(a - b) # a 和 b 的差集 r, b, dprint(a | b) # a 和 b 的并集 b, c, a, z, m, r, l, dprint(a b) # a 和 b 的交集 c, aprint(a ^ b) # a 和 b 中不同时存在的元素 z, b, m, r, l, d 添加元素s.add( x ) 将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。 s = set([1,2,老王])s.add(3)print(s) # 1, 2, 3, 老王 还有一个方法，也可以添加元素，且参数可以是列表，元组，字典等。 s.update( x ) x 可以有多个，用逗号分开。 s = set([老王])s.update([5,6])s.update((3,4))s.update(1,2)print(s) # 老王, 2, 3, 4, 1, 5, 6 移除元素s.remove( x ) 将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。 s = set((1,2,3))s.remove(1)print(s) # 2, 3# 删除不存在的元素会报错s.remove(老王)Traceback (most recent call last): File d:\\work\\styspace\\sty_python\\test.py, line 2, in module s.remove(老王) ~~~~~~~~^^^^^^^^KeyError: 老王 此外还有一个方法也是移除集合中的元素，且如果元素不存在，不会发生错误。 s.discard( x ) s = set((1,2,3))s.discard(老王) # 不会报错print(s) # 1, 2, 3 我们也可以设置随机删除集合中的一个元素： s.pop() s = set((1,2,3))s.pop()print(s) # 2, 3 set 集合的 pop 方法会对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除。 计算集合元素个数len(s) 计算集合 s 元素个数。 thisset = set((Google, Runoob, Taobao)) len(thisset)3 清空集合s.clear() 清空集合 s。 thisset = set((Google, Runoob, Taobao)) thisset.clear() print(thisset)set() 判断元素是否在集合中存在x in s 判断元素 x 是否在集合 s 中，存在返回 True，不存在返回 False。 thisset = set((Google, Runoob, Taobao)) Runoob in thissetTrue Facebook in thissetFalse 集合内置方法完整列表 方法 描述 add() 为集合添加元素 clear() 移除集合中的所有元素 copy() 拷贝一个集合 difference() 返回多个集合的差集 difference_update() 移除集合中的元素，该元素在指定的集合也存在。 discard() 删除集合中指定的元素 intersection() 返回集合的交集 intersection_update() 返回集合的交集。 isdisjoint() 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。 issubset() 判断指定集合是否为该方法参数集合的子集。 issuperset() 判断该方法的参数集合是否为指定集合的子集 pop() 随机移除元素 remove() 移除指定元素 symmetric_difference() 返回两个集合中不重复的元素集合。 symmetric_difference_update() 移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。 union() 返回两个集合的并集 update() 给集合添加元素 len() 计算集合元素个数 Dictionary k:vDictionary 基础字典（dictionary）是 Python 中另一个非常有用的内置数据类型。 列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。 键(key)必须使用不可变类型。 在同一个字典中，键(key)必须是唯一的。 dict = 0:2dict[one] = 1dict[2] = twotinydict = 1:张三, sex:2print(dict) # 0: 2, one: 1, 2: twoprint(dict[2]) # twoprint(tinydict) # 1: 张三, sex: 2print(tinydict.keys()) # dict_keys([1, sex])print(tinydict.values()) # dict_values([张三, 2]) 构造函数 dict() 可以直接从键值对序列中构建字典如下： dict([(Runoob, 1), (Google, 2), (Taobao, 3)])Runoob: 1, Google: 2, Taobao: 3 dict(Runoob=1, Google=2, Taobao=3)Runoob: 1, Google: 2, Taobao: 3 1、字典是一种映射类型，它的元素是键值对。2、字典的关键字必须为不可变类型，且不能重复。3、创建空字典使用 **{ }**。 访问字典#!/usr/bin/python tinydict = Name: Zara, Age: 7, Class: First print(tinydict[Name]: , tinydict[Name]) # tinydict[Name]: Zaraprint(tinydict[Age]: , tinydict[Age]) # tinydict[Age]: 7 如果用字典里没有的键访问数据，会输出错误如下： print tinydict[Alice]: , tinydict[Alice]tinydict[Alice]: Traceback (most recent call last): File test.py, line 5, in module print tinydict[Alice]: , tinydict[Alice]KeyError: Alice 修改字典常用向字典添加新内容的方法是增加新的键值对，修改或删除已有键值对: tinydict = name: runoob, code: 1, site: www.runoob.comtinydict[name] = 老王 # 更新tinydict[sex] = 1 # 添加print(tinydict[name]: , tinydict[name]) # tinydict[name]: 老王print(tinydict[sex]) # 1 updatePython中的字典（dict）的update()方法用于将一个字典或其他可迭代对象的键值对更新到当前字典中。 dict.update([other]) other（可选）：可以是另一个字典、包含键值对的可迭代对象（如列表、元组），或关键字参数。 功能： ‌覆盖或添加键值对‌：如果当前字典中存在相同的键，则更新对应的值；否则添加新的键值对。 ‌支持多种参数类型‌：接受字典、可迭代对象或关键字参数。 参数类型： ‌字典或映射对象： d1 = a: 1, b: 2d2 = b: 3, c: 4d1.update(d2) # d1变为 a:1, b:3, c:4 ‌可迭代的键值对： d = d.update([(a, 1), (b, 2)]) # d变为 a:1, b:2 ‌关键字参数*： d = a: 1d.update(b=2, c=3) # d变为 a:1, b:2, c:3 处理顺序： 先处理位置参数（字典或可迭代对象），再处理关键字参数。 ‌重复键的值会被覆盖‌，后出现的值优先级更高。 d = x: 0d.update(x: 1, y: 2, x=3, z=4)# 结果：x:3, y:2, z:4 返回值： update()是原地操作，直接修改原字典，返回None。 错误情况： ‌无效的键值对结构‌： d.update([(a, 1, 2)]) # 抛出 ValueError（元素长度不符） ‌不可哈希的键‌： d.update([key]: 1) # 抛出 TypeError（列表不可作为键） ‌非可迭代或非映射对象‌： d.update(None) # 抛出 TypeError（对象无效） 注意事项： 若需合并多个字典，可先合并再更新： d.update(dict1, dict2) 避免链式操作（因返回None）： # 错误示例d = d.update(other_dict) # d 变为 None 示例代码： # 基本用法d = a: 1, b: 2d.update(b: 3, c: 4)print(d) # 输出: a:1, b:3, c:4# 混合参数类型d = x: 0d.update([(x, 1)], x=2, y=3)print(d) # 输出: x:2, y:3# 错误处理try: d.update([(invalid,)])except ValueError as e: print(e) # 输出: dictionary update sequence element #0 has length 1; 2 is required 通过update()方法，可以灵活地合并字典、覆盖值或添加新键值对，适用于需要动态更新字典的场景。 删除字典元素能删单一的元素也能清空字典，清空只需一项操作。 显示删除一个字典用 del 命令： tinydict = name: runoob, code: 1, site: www.runoob.comdel tinydict[name] # 删除键是Name的条目print (tinydict) # code: 1, site: www.runoob.comtinydict.clear() # 清空字典所有条目print (tinydict) # del tinydict # 删除字典print(tinydict) # 删除后字典不可用，会报错Traceback (most recent call last): File d:\\work\\styspace\\sty_python\\test.py, line 7, in module print(tinydict) ^^^^^^^^NameError: name tinydict is not defined 字典键的特性字典值可以没有限制地取任何 Python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。 两个重要的点需要记住： 1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会覆盖前一个值： tinydict = name:老王print (tinydict[name]) # 老王tinydict[name]=老李print (tinydict[name]) # 老李 2）键必须不可变，所以可以用数字，字符串或元组充当，用列表就不行： tinydict = name:老王, 1:老李,(1,2):老码字print(tinydict.keys()) # dict_keys([name, 1, (1, 2)])print(tinydict[(1,2)]) # 老码字 tinydict = [1,2]: hello worldprint (tinydict)Traceback (most recent call last): File d:\\work\\styspace\\sty_python\\test.py, line 1, in module tinydict = [1,2]: hello world ^^^^^^^^^^^^^^^^^^^^^^TypeError: unhashable type: list 字典内置函数方法Python 字典包含了以下内置函数： 序号 函数及描述 1 cmp(dict1, dict2) 比较两个字典元素。 2 len(dict) 计算字典元素个数，即键的总数。 3 str(dict) 输出字典可打印的字符串表示。 4 type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。 Python 字典包含了以下内置方法： 序号 函数及描述 1 dict.clear() 删除字典内所有元素 2 dict.copy() 返回一个字典的浅复制 3 dict.fromkeys(seq , val]) 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值 4 dict.get(key, default None) 返回指定键的值，如果值不在字典中返回 default 值 6 dict.items() 以列表返回可遍历的(键, 值) 元组数组 7 dict.keys() 以列表返回一个字典所有的键 8 dict.setdefault(key, default None) 和 get()类似, 但如果键不存在于字典中，将会添加键并将值设为 default 9 dict.update(dict2) 把字典 dict2 的键值对更新到 dict 里 10 dict.values() 以列表返回字典中的所有值 11 [pop(key, default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key 值必须给出。 否则，返回 default 值。 12 popitem() 返回并删除字典中的最后一对键和值。 defaultdict基本概念： defaultdict 是 dict 的子类，在访问不存在的键时自动生成默认值，避免 KeyError 错误‌。 通过指定 ‌工厂函数‌ 初始化，常见类型包括 int、list、set 等‌。 初始化： from collections import defaultdict# 示例1：默认值为0（适用于计数场景）count_dict = defaultdict(int) # 示例2：默认值为空列表（适用于分组场景）group_dict = defaultdict(list) # 示例3：默认值为空集合（适用于去重场景）unique_dict = defaultdict(set) # 示例4：自定义默认值（如空张量）import torchcustom_dict = defaultdict(lambda: torch.tensor([])) # ‌:ml-citationref=6 data=citationList 注意事项： ‌工厂函数需为可调用对象‌例如 defaultdict(list) 正确，而 defaultdict([]) 错误‌。 ‌性能权衡‌ 优势：处理大量缺失键时效率高于普通字典‌。 劣势：初始化时需额外内存开销，数据量较小时可能不如普通字典高效‌。 ‌序列化兼容性‌序列化（如转 JSON）前需将 defaultdict 转为普通字典：dict(defaultdict_obj)‌。 示例： 题目：给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。例如:输入:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]输出:2解释:两个元组如下:(0, 0, 0, 1) - A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0(1, 1, 0, 0) - A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0from collections import defaultdict class Solution: def fourSumCount(self, nums1: list, nums2: list, nums3: list, nums4: list) - int: rec, cnt = defaultdict(lambda : 0), 0 for i in nums1: for j in nums2: rec[i+j] += 1 for i in nums3: for j in nums4: cnt += rec.get(-(i+j), 0) return cnt bytes在 Python3 中，bytes 类型表示的是不可变的二进制序列（byte sequence）。 与字符串类型不同的是，bytes 类型中的元素是整数值（0 到 255 之间的整数），而不是 Unicode 字符。 bytes 类型通常用于处理二进制数据，比如图像文件、音频文件、视频文件等等。在网络编程中，也经常使用 bytes 类型来传输二进制数据。 创建 bytes 对象的方式有多种，最常见的方式是使用 b 前缀： 此外，也可以使用 bytes() 函数将其他类型的对象转换为 bytes 类型。bytes() 函数的第一个参数是要转换的对象，第二个参数是编码方 式，如果省略第二个参数，则默认使用 UTF-8 编码： x = bytes(hello, encoding=utf-8) 与字符串类型类似，bytes 类型也支持许多操作和方法，如切片、拼接、查找、替换等等。同时，由于 bytes 类型是不可变的，因此在进 行修改操作时需要创建一个新的 bytes 对象。例如： x = bhelloy = x[1:3] # 切片操作，得到 belz = x + bworld # 拼接操作，得到 bhelloworld 需要注意的是，bytes 类型中的元素是整数值，因此在进行比较操作时需要使用相应的整数值。例如： x = bhelloif x[0] == ord(h): print(The first element is h) x = bhprint(x[0]) # 104 其中 ord() 函数用于将字符转换为相应的整数值。 遍历技巧在字典中遍历时，关键字和对应的值可以使用 items() 方法同时解读出来： dic = key1:v1, key2:2, 3:v3for k, v in dic.items(): print(k, v) 输出结果： key1 v1key2 23 v3 在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到： list_demo = [a,b,3]for i, v in enumerate(list_demo): print(i, v) 输出结果： 0 a1 b2 3 同时遍历两个或更多的序列，可以使用 zip() 组合： list1 = [a,b,c]list2 = [d,e,f]for v1, v2 in zip(list1, list2): print(flist1 value v1, list2 value v2) 输出结果： list1 value a, list2 value dlist1 value b, list2 value elist1 value c, list2 value f 要反向遍历一个序列，首先指定这个序列，然后调用 reversed() 函数： list = range(1,10,2)for i in reversed(list): print(i) 输出结果： 97531 要按顺序遍历一个序列，使用 sorted() 函数返回一个已排序的序列，并不修改原值： list = [3,1,9,5,7,5]for v in sorted(set(list)): print(v) 输出结果： 13579 数据类型转换有时候，我们需要对数据内置的类型进行转换，数据类型的转换，一般情况下你只需要将数据类型作为函数名即可。 Python 数据类型转换可以分为两种： 隐式类型转换 - 自动完成 显式类型转换 - 需要使用类型函数来转换 隐式转换在隐式类型转换中，Python 会自动将一种数据类型转换为另一种数据类型，不需要我们去干预。 以下示例中，我们对两种不同类型的数据进行运算，较低数据类型（整数）就会转换为较高数据类型（浮点数）以避免数据丢失。 num_int = 123num_float = 12.3num_new = num_int + num_floatprint(num_new) # 135.3print(type(num_new)) # class float num_int = 123num_str = 456print(num_int + num_str)Traceback (most recent call last): File d:\\work\\sty_project\\sty_python\\01.basic\\str.py, line 4, in module print(num_int + num_str) ~~~~~~~~^~~~~~~~~TypeError: unsupported operand type(s) for +: int and str 从输出中可以看出，整型和字符串类型运算结果会报错，输出 TypeError。 Python 在这种情况下无法使用隐式转换。 显示转换在显式类型转换中，用户将对象的数据类型转换为所需的数据类型。 我们使用 int()、float()、str() 等预定义函数来执行显式类型转换。 int() 强制转换为整型： x = int(1) # x 输出结果为 1y = int(2.8) # y 输出结果为 2z = int(3) # z 输出结果为 3 float() 强制转换为浮点型： x = float(1) # x 输出结果为 1.0y = float(2.8) # y 输出结果为 2.8z = float(3) # z 输出结果为 3.0w = float(4.2) # w 输出结果为 4.2 整型和字符串类型进行运算，就可以用强制类型转换来完成： num_int = 123num_str = 456print(num_int 数据类型为:,type(num_int)) # num_int 数据类型为: class intprint(类型转换前，num_str 数据类型为:,type(num_str)) # 类型转换前，num_str 数据类型为: class strnum_str = int(num_str) # 强制转换为整型print(类型转换后，num_str 数据类型为:,type(num_str)) # 类型转换后，num_str 数据类型为: class intnum_sum = num_int + num_strprint(num_int 与 num_str 相加结果为:,num_sum) # num_int 与 num_str 相加结果为: 579print(sum 数据类型为:,type(num_sum)) # sum 数据类型为: class int","tags":[null],"categories":[null]},{"title":"Python面向对象","path":"/wiki/Python/面向对象.html","content":"类定义class ClassName: statement-1 . . . statement-N 类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。 类对象类对象支持两种操作：属性引用和实例化。 属性引用使用和 Python 中所有的属性引用一样的标准语法：obj.name。 类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样： #!/usr/bin/python3 class MyClass: 一个简单的类实例 i = 12345 def f(self): return hello world # 实例化类x = MyClass() # 访问类的属性和方法print(MyClass 类的属性 i 为：, x.i)print(MyClass 类的方法 f 输出为：, x.f()) 以上创建了一个新的类实例并将该对象赋给局部变量 x，x 为空的对象。 执行以上程序输出结果为： MyClass 类的属性 i 为： 12345MyClass 类的方法 f 输出为： hello world 类有一个名为 __init__() 的特殊方法（构造方法），该方法在类实例化时会自动调用，像下面这样： def __init__(self): self.data = [] 类定义了 __init__() 方法，类的实例化操作会自动调用 __init__() 方法。如下实例化类 MyClass，对应的 __init__() 方法就会被调用： x = MyClass() 当然， __init__() 方法可以有参数，参数通过 __init__() 传递到类的实例化操作上。例如: #!/usr/bin/python3 class Complex: def __init__(self, realpart, imagpart): self.r = realpart self.i = imagpartx = Complex(3.0, -4.5)print(x.r, x.i) # 输出结果：3.0 -4.5 selfself 代表类的实例，而非类。 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的 第一个参数名称, 按照惯例它的名称是 self。 class Test: def prt(self): print(self) print(self.__class__) t = Test()t.prt() 输出结果： **main**.Test object at 0x000002A70E826900class ‘**main**.Test’ 从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。 self 不是 Python 关键字，我们把他换成 runoob 也是可以正常执行的： class Test: def prt(laowang): print(laowang) print(laowang.__class__) t = Test()t.prt() 输出结果： **main**.Test object at 0x0000025B6BD46900class ‘**main**.Test’ 在 Python 中，self 是一个惯用的名称，用于表示类的实例（对象）自身。它是一个指向实例的引用，使得类的方法能够访问和操作实例的属性。 当你定义一个类，并在类中定义方法时，第一个参数通常被命名为 self，尽管你可以使用其他名称，但强烈建议使用 self，以保持代码的一致性和可读性。 class MyClass: def __init__(self, value): self.value = value def display_value(self): print(self.value)# 创建一个类的实例obj = MyClass(42) # 调用实例的方法obj.display_value() # 输出 42 在上面的例子中，self 是一个指向类实例的引用，它在 __init__ 构造函数中用于初始化实例的属性，也在 display_value 方法中用于访问实例的属性。通过使用 self，你可以在类的方法中访问和操作实例的属性，从而实现类的行为。 类的方法在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例。 #!/usr/bin/python3 #类定义class people: #定义基本属性 name = age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(%s 说: 我 %d 岁。 %(self.name,self.age)) # 实例化类p = people(runoob,10,30)p.speak() # runoob 说: 我 10 岁。 继承Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示： class DerivedClassName(BaseClassName): statement-1 . . . statement-N 子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的 属性和方法。 BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用： class DerivedClassName(modname.BaseClassName): #!/usr/bin/python3 #类定义class people: #定义基本属性 name = age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(%s 说: 我 %d 岁。 %(self.name,self.age)) #单继承示例class student(people): grade = def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(%s 说: 我 %d 岁了，我在读 %d 年级%(self.name,self.age,self.grade)) s = student(ken,10,60,3)s.speak() 输出结果： ken 说: 我 10 岁了，我在读 3 年级 多继承Python 同样有限的支持多继承形式。多继承的类定义形如下： class DerivedClassName(Base1, Base2, Base3): statement-1 . . . statement-N 需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，Python 从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。 #!/usr/bin/python3 #类定义class people: #定义基本属性 name = age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(%s 说: 我 %d 岁。 %(self.name,self.age)) #单继承示例class student(people): grade = def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(%s 说: 我 %d 岁了，我在读 %d 年级%(self.name,self.age,self.grade)) #另一个类，多继承之前的准备class speaker(): topic = name = def __init__(self,n,t): self.name = n self.topic = t def speak(self): print(我叫 %s，我是一个演说家，我演讲的主题是 %s%(self.name,self.topic)) #多继承class sample(speaker,student): a = def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t) test = sample(Tim,25,80,4,Python)test.speak() #方法名同，默认调用的是在括号中参数位置排前父类的方法 输出结果： 我叫 Tim，我是一个演说家，我演讲的主题是 Python # 修改sameple中继承顺序class sample(student, speaker): a = def __init__(self,n, a, w, g, t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t)test = sample(Tim,25,80,4,Python)test.speak() #方法名同，默认调用的是在括号中参数位置排前父类的方法 输出结果： ken 说: 我 10 岁了，我在读 3 年级 方法重写如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，示例如下： #!/usr/bin/python3 class Parent: # 定义父类 def myMethod(self): print (调用父类方法) class Child(Parent): # 定义子类 def myMethod(self): print (调用子类方法) c = Child() # 子类实例c.myMethod() # 子类调用重写方法super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法 super() 函数 是用于调用父类(超类)的一个方法。 输出结果： 调用子类方法调用父类方法 子类重写父类 __init__()方法场景 子类需要自动调用父类的方法： 子类不重写 __init__() 方法，实例化子类后，会自动调用父类的 __init__() 的方法。 子类不需要自动调用父类的方法： 子类重写 __init__() 方法，实例化子类后，将不会自动调用父类的 __init__() 的方法。 子类重写 __init__() 方法又需要调用父类的 __init__() 方法： 使用 super 关键词： super(子类，self).__init__(参数1，参数2，....)class Son(Father): def __init__(self, name): super(Son, self).__init__(name) 类的属性与方法 类的私有属性 __private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。 类的方法 在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。 self 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定使用 self。 类的私有方法 __private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。 类的私有属性示例: #!/usr/bin/python3 class JustCounter: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount += 1 self.publicCount += 1 print (self.__secretCount) counter = JustCounter()counter.count()counter.count()print (counter.publicCount)print (counter.__secretCount) # 报错，实例不能访问私有变量 输出结果： 122Traceback (most recent call last):File “test.py”, line 16, in moduleprint (counter.__secretCount) # 报错，实例不能访问私有变量AttributeError: ‘JustCounter’ object has no attribute ‘__secretCount’ 类的私有方法示例： #!/usr/bin/python3 class Site: def __init__(self, name, url): self.name = name # public self.__url = url # private def who(self): print(name : , self.name) print(url : , self.__url) def __foo(self): # 私有方法 print(这是私有方法) def foo(self): # 公共方法 print(这是公共方法) self.__foo() x = Site(菜鸟教程, www.runoob.com)x.who() # 正常输出x.foo() # 正常输出x.__foo() # 报错 输出结果： D:worktoolsPythonPython.exe d:worksty_projectsty_Python01.basichello.pyname : 菜鸟教程url : www.runoob.com这是公共方法这是私有方法Traceback (most recent call last):File “d:\\work\\sty_project\\sty_Python\\01.basic\\hello.py”, line 22, in modulex.__foo() # 报错^^^^^^^AttributeError: ‘Site’ object has no attribute ‘__foo’ 类的专有方法: __init__ : 构造函数，在生成对象时调用__del__ : 析构函数，释放对象时使用__repr__ : 打印，转换__setitem__ : 按照索引赋值__getitem__: 按照索引获取值__len__: 获得长度__cmp__: 比较运算__call__: 函数调用__add__: 加运算__sub__: 减运算__mul__: 乘运算__truediv__: 除运算__mod__: 求余运算__pow__: 乘方","tags":[null],"categories":[null]},{"title":"RocketMQ快速安装","path":"/wiki/RocketMQ/RocketMQ1.html","content":"1. 直接安装RocketMQ1.1 安装JDKvi /etc/profileJAVA_HOME=/home/jdk/jvm/jre-1.6.0-openjdk.x86_64PATH=$PATH:$JAVA_HOME/binCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME CLASSPATH PATH 1.1 下载二进制包官网下载地址：https://rocketmq.apache.org/download/ https://dist.apache.org/repos/dist/release/rocketmq/4.9.8/rocketmq-all-4.9.8-bin-release.zip 1.2 配置环境变量vim /etc/profile# 末尾添加 export NAMESRV_ADDR=阿里云公网IP:9876export NAMESRV_ADDR=117.72.71.187:9876 1.3 修改NameServer的运行脚本进入bin目录下，修改runserver.sh文件,将71行和76行的Xms和Xmx等改小一点 vim runserver.shJAVA_OPT=$JAVA_OPT -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320mJAVA_OPT=$JAVA_OPT -server -Xms256m -Xmx256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m 1.4 修改Broker运行脚本进入bin目录下，修改runbroker.sh文件,修改85行 JAVA_OPT=$JAVA_OPT -server -Xms256m -Xmx256m 1.5 修改Broker配置brokerClusterName = DefaultClusterbrokerName = broker-abrokerId = 0deleteWhen = 04fileReservedTime = 48brokerRole = ASYNC_MASTERflushDiskType = ASYNC_FLUSHnamesrvAddr=117.72.71.187:9876autoCreateTopicEnable=true#brokerIP1=阿里云公网IPbrokerIP1=117.72.71.187 1.6 启动NameServer### 在安装目录下创建一个logs文件夹，用于存放日志cd /home/soft/rocketmq4.9.8mkdir logs### 启动namesrvnohup sh /home/soft/rocketmq4.9.8/bin/mqnamesrv /home/soft/rocketmq4.9.8/logs/namesrv.log ### 验证namesrv是否启动成功tail -f /home/soft/rocketmq4.9.8/logs/namesrv.logThe Name Server boot success... 我们可以在namesrv.log 中看到 ‘The Name Server boot success..’， 表示NameServer 已成功启动。 1.7 启动BrokerNameServer成功启动后，我们启动Broker ### 先启动brokernohup sh /home/soft/rocketmq4.9.8/bin/mqbroker -c /home/soft/rocketmq4.9.8/conf/broker.conf /home/soft/rocketmq4.9.8/logs/broker.log ### 验证broker是否启动成功, 比如, broker的ip是192.168.1.2 然后名字是broker-atail f /home/soft/rocketmq4.9.8/logs/broker.log The broker[broker-a,192.169.1.2:10911] boot success... 2. Docker安装RocketMQ2.1 拉取镜像docker pull apache/rocketmq:4.9.7 2.2 启动NameServerdocker run -d --restart=always --name namesrv -p 9876:9876 \\-v /home/rocketmq/data/namesrv/logs:/home/rocketmq/logs \\-v /home/rocketmq/data/namesrv/store:/home/rocketmq/store \\-e MAX_POSSIBLE_HEAP=100000000 apache/rocketmq:4.9.7 sh mqnamesrv 2.3 配置broker.conf# 所属集群名称，如果节点较多可以配置多个brokerClusterName = DefaultCluster#broker名称，master和slave使用相同的名称，表明他们的主从关系brokerName = broker-a#0表示Master，大于0表示不同的slavebrokerId = 0#表示几点做消息删除动作，默认是凌晨4点deleteWhen = 04#在磁盘上保留消息的时长，单位是小时fileReservedTime = 48#有三个值：SYNC_MASTER，ASYNC_MASTER，SLAVE；同步和异步表示Master和Slave之间同步数据的机制；brokerRole = ASYNC_MASTER#刷盘策略，取值为：ASYNC_FLUSH，SYNC_FLUSH表示同步刷盘和异步刷盘；SYNC_FLUSH消息写入磁盘后才返回成功状态，ASYNC_FLUSH不需要；flushDiskType = ASYNC_FLUSH#设置broker节点所在服务器的ip地址（**这个非常重要,主从模式下，从节点会根据主节点的brokerIP2来同步数据，如果不配置，主从无法同步，brokerIP1设置为自己外网能访问的ip，服务器双网卡情况下必须配置，比如阿里云这种，主节点需要配置ip1和ip2，从节点只需要配置ip1即可）brokerIP1 = 117.72.71.187#nameServer地址，分号分割namesrvAddr=117.72.71.187:9876#Broker 对外服务的监听端口,#listenPort = 10911#是否允许Broker自动创建Topic 上线为false 测试可开启autoCreateTopicEnable = true#是否允许 Broker 自动创建订阅组 上线为false 测试可开启autoCreateSubscriptionGroup = true#开启鉴权aclEnable=false 2.4 启动Brokerdocker run -d --restart=always --name rocketmq-broker-a -p 10909:10909 -p 10911:10911 \\-v /home/rocketmq/broker/broker-a/logs:/home/rocketmq/logs \\-v /home/rocketmq/broker/broker-a/store:/home/rocketmq/store \\-v /home/rocketmq/broker/broker-a/conf:/home/rocketmq/rocketmq-4.9.7/conf \\-e MAX_POSSIBLE_HEAP=200000000 apache/rocketmq:4.9.7 sh mqbroker -c /home/rocketmq/conf/broker.conf 3. 安装RocketMQ DashboardRocketMQ Dashboard 是 RocketMQ 的管控利器，为用户提供客户端和应用程序的各种事件、性能的统计信息，支持以可视化工具代替 Topic 配置、Broker 管理等命令行操作。 拉取镜像 docker pull apacherocketmq/rocketmq-dashboard:latest 启动 docker run -d --name rocketmq-dashboard \\-e JAVA_OPTS=-Drocketmq.namesrv.addr=127.0.0.1:9876 \\-p 8080:8080 \\-t apacherocketmq/rocketmq-dashboard:latestdocker run -d --name rocketmq-dashboard \\-e JAVA_OPTS=-Drocketmq.namesrv.addr=117.72.71.187:9876 \\-p 8080:8080 \\-t apacherocketmq/rocketmq-dashboard:latest 启动时IP修改为自己主机的IP namesrv.addr:port 替换为 rocketmq 中配置的 nameserver 地址：端口号 默认端口配置下，需开放端口号：控制台：8080；namesrv：9876；broker：10909、10911。 云服务器：设置安全组访问规则 本地虚拟机：关闭防火墙，或 -add-port","tags":[null],"categories":[null]},{"title":"Spring IOC容器加载流程原理","path":"/wiki/Spring/Spring容器加载流程原理.html","content":"1. 手写Spring先来思考下如何自己手写一个简单的Spring。 扫描 我们要让Spring管理我们的类，首先需要在类上添加注解如@Component（这里默认已注解方式使用Spring）。这里就有个问题了Spring怎么知道添加了@Component的类，所以需要一个配置类去配置扫描路径（这个配置可以从xml文件来，也可以时JavaConfig配置类）。 加载 扫描对应路径下的文件我们能够得到所有的类文件，只需遍历文件判断是否对应类上有没有相应注解就可以判断是否需要Spring管理。 这里我们思考一个问题？ 我们拿到所有注解标注的类信息后直接实例化放入Spring容器会怎么样？ 如果这么设计对与Bean对象我们就不能使用很多特性例如单例、多例、懒加载等。 所以我们需要引入个中间层来描述类信息（BeanDefinition），BeanDefinition中可以描述类类型、是否单例、是否懒加载等特性，这样能够更加灵活使用类。 我们将所有扫描到需要Spring管理的类封装成BeanDefinition，并放入一个MapString, BeanDefinition beanDefinitionMap中。 实例化 根据上面步骤我们已经拿到了beanDefinitionMap，遍历beanDefinitionMap我们可以创建一个一个Bean对象（通过反射构造函数来实例化创建相应类对象）。属性注入 创建了实例对象，此时类中属性（@Autowire标注的）还是null需要完成属性注入。类中的属性（@Autowire标注的）其实还是Spring管理的对象，直接去Spring容器中拿这个对象就行。如果没有就根据BeanDefinition去创建对象然后注入进来。 回调 为了扩展，这个阶段包含了各种回调方法。例如各种Aware回调、BeanPostProcessor回调、InitializingBean回调等。 2. Bean生命周期2.1 Bean的创建大致过程先来看下Spring的简单使用 @ComponentScan(org.springframework.demo)public class AppConfig @Componentpublic class UserService public class Main public static void main(String[] args) AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); System.out.println(context.getBean(userService)); 思考一下？为什么通过调用context.getBean(userService)就能得到UserService对象？ 在创建AnnotationConfigApplicationContext容器对象时，会根据传入的AppConfig类拿到@ComponentScan注解标注的扫描路径。 根据路径扫描这个包路径下的所有class类，如果发现某个类上存在@Component、@Service等注解，那么Spring就把这个类记录下来，存入BeanDefinitionMap。 Spring会根据某个规则生成当前类对应的beanName，作为key存入Map，当前类作为value。 那Spring到底是如何来创建一个Bean的呢，这个就是Bean创建的生命周期，大致过程如下： 利用该类的构造方法来实例化得到一个对象（但是如何一个类中有多个构造方法，Spring则会进行选择，这个叫做推断构造方法） 得到一个对象后，Spring会判断该对象中是否存在被@Autowired注解了的属性，把这些属性找出来并由Spring进行赋值（依赖注入） 依赖注入后，Spring会判断该对象是否实现了BeanNameAware接口、BeanClassLoaderAware接口、BeanFactoryAware接口，如果实现了，就表示当前对象必须实现该接口中所定义的setBeanName()、setBeanClassLoader()、setBeanFactory()方法，那Spring就会调用这些方法并传入相应的参数（Aware回调） Aware回调后，Spring会判断该对象中是否存在某个方法被@PostConstruct注解了，如果存在，Spring会调用当前对象的此方法（初始化前） 紧接着，Spring会判断该对象是否实现了InitializingBean接口，如果实现了，就表示当前对象必须实现该接口中的afterPropertiesSet()方法，那Spring就会调用当前对象中的afterPropertiesSet()方法（初始化） 最后，Spring会判断当前对象需不需要进行AOP，如果不需要那么Bean就创建完了，如果需要进行AOP，则会进行动态代理并生成一个代理对象做为Bean（初始化后） 2.2 生成BeanDefinition这里我们根据源码来详细了解上述Bean创建的步骤： 第一步根据路径扫描生成beanDefinition并放入beanDefinitionMap ClassPathBeanDefinitionScanner.doScan protected SetBeanDefinitionHolder doScan(String... basePackages) Assert.notEmpty(basePackages, At least one base package must be specified); // 定义一个Set存放BeanDefinitionHolder，这个类里面存放 beanDefinition、beanName; SetBeanDefinitionHolder beanDefinitions = new LinkedHashSet(); for (String basePackage : basePackages) // 扫描basePackage下的类文件将符合条件的类封装成BeanDefinition SetBeanDefinition candidates = findCandidateComponents(basePackage); for (BeanDefinition candidate : candidates) // 处理@Scope注解 ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition abstractBeanDefinition) postProcessBeanDefinition(abstractBeanDefinition, beanName); if (candidate instanceof AnnotatedBeanDefinition annotatedBeanDefinition) // 处理通用注解@Lazy、@Primary、@DependsOn、@Role AnnotationConfigUtils.processCommonDefinitionAnnotations(annotatedBeanDefinition); // 检查BeanDefinition是否重复，不重复直接返回true if (checkCandidate(beanName, candidate)) BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); // this.beanDefinitionMap.put(beanName, beanDefinition); // 将beanDefinition放入beanDefinitionMap registerBeanDefinition(definitionHolder, this.registry); return beanDefinitions; private SetBeanDefinition scanCandidateComponents(String basePackage) SetBeanDefinition candidates = new LinkedHashSet(); try // 获取包路径下.class文件信息 String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + / + this.resourcePattern; Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath); boolean traceEnabled = logger.isTraceEnabled(); boolean debugEnabled = logger.isDebugEnabled(); for (Resource resource : resources) String filename = resource.getFilename(); if (filename != null filename.contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) // Ignore CGLIB-generated classes in the classpath continue; if (traceEnabled) logger.trace(Scanning + resource); try // 读取类元数据信息：例如类名、注解、接口等 MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource); if (isCandidateComponent(metadataReader)) ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setSource(resource); // 判断是否接口、抽象类、内部类和处理@Lookup注解 if (isCandidateComponent(sbd)) if (debugEnabled) logger.debug(Identified candidate component class: + resource); // 将BeanDefinition放入集合 candidates.add(sbd); ... else if (traceEnabled) logger.trace(Ignored because not matching any filter: + resource); ... catch (IOException ex) throw new BeanDefinitionStoreException(I/O failure during classpath scanning, ex); return candidates; 总结： 通过ResourcePatternResolver获得指定包路径下的所有.class文件（Spring源码中将类文件包装成了Resource对象） 读取类元数据信息：例如类名、注解、接口等，设置source属性 根据读取到的元数据信息根据excludeFilters和includeFilters进行过滤及条件注解@Conditional的筛选 处理通用注解@Lazy、@Primary、@DependsOn、@Role 检查BeanDefinition是否重复 将beanDefinition放入beanDefinitionMap 2.3 合并BeanDefinition在2.1中拿到所有BeanDefinition之后，就可以根据BeanDefinition创建Bean对象了。在Spring中支持父子BeanDefinition，及有下列这种情况。 bean id=userServiceParent scope=prototype /beanbean id=userService parent=userServiceParent/bean userServiceParent对象是userService的父类，这个时候子类是需要继承父类中的属性所以不能直接拿userService的BeanDefinition去进行实例化对象，需要将userService的BeanDefinition和userServiceParent的BeanDefinition合并后根据合并后的BeanDefinition再去进行实例化。 DefaultListableBeanFactory.preInstantiateSingletons() public void preInstantiateSingletons() throws BeansException ... for (String beanName : beanNames) // 获取合并后的BeanDefinition // 处理这种情况： // bean id=userServiceParent scope=prototype /bean // bean id=userService parent=userServiceParent/bean // 创建子类Bean时需要将父BeanDefinition中的属性合并到子BeanDefinition中，生成RootBeanDefinition RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); ... ... 2.4 加载类根据合并后的RootBeanDefinition就可以创建Bean对象了，在实例化对象前需要加载类信息，这个时候就需要使用类加载器加载类。 AbstractAutowireCapableBeanFactory.createBean()// 加载类信息Class? resolvedClass = resolveBeanClass(mbd, beanName); @Nullableprotected Class? resolveBeanClass(RootBeanDefinition mbd, String beanName, Class?... typesToMatch) throws CannotLoadBeanClassException try if (mbd.hasBeanClass()) return mbd.getBeanClass(); // 1. 优先返回当前线程中的ClassLoader // 2. 线程中类加载器为null的情况下，返回ClassUtils类的类加载器 // 3. 如果ClassUtils类的类加载器为空，那么则表示是Bootstrap类加载器加载的ClassUtils类，那么则返回系统类加载器 Class? beanClass = doResolveBeanClass(mbd, typesToMatch); if (mbd.hasBeanClass()) mbd.prepareMethodOverrides(); return beanClass; ... 2.5 实例化前类信息加载完成后就可以进行实例化了，Spring在实例化Bean对象前提供了扩展点，通过继承InstantiationAwareBeanPostProcessor接口实现postProcessBeforeInstantiation方法，就可以在实例化前调用该方法。 AbstractAutowireCapableBeanFactory.createBean() // 处理实例化前回调 InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiationObject bean = resolveBeforeInstantiation(beanName, mbdToUse);@Nullableprotected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) Object bean = null;\tif (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) // Make sure bean class is actually resolved at this point. // hasInstantiationAwareBeanPostProcessors if (!mbd.isSynthetic() hasInstantiationAwareBeanPostProcessors()) Class? targetType = determineTargetType(beanName, mbd); if (targetType != null) bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName); if (bean != null) bean = applyBeanPostProcessorsAfterInitialization(bean, beanName); mbd.beforeInstantiationResolved = (bean != null); return bean; 需要注意的是postProcessBeforeInstantiation是有返回值的，如果返回不为null表示不需要Spring来实例化了，并且后续的Spring依赖注入也不会进行了，直接执行初始化后这一步。 2.6 实例化AbstractAutowireCapableBeanFactory.createBean() // 实例化Bean对象Object beanInstance = doCreateBean(beanName, mbdToUse, args); 2.7 BeanDefinition的后置处理在Bean对象实例化后，Spring在实例化Bean对象后提供了扩展点，通过继承MergedBeanDefinitionPostProcessor接口实现postProcessMergedBeanDefinition方法，就可以在实例化后调用该方法，这个方法可以对此时的BeanDefinition进行加工。 AutowiredAnnotationBeanPostProcessor就是一个MergedBeanDefinitionPostProcessor，中会去查找注入点，并缓存在AutowiredAnnotationBeanPostProcessor对象的一个Map中（injectionMetadataCache）。 2.8 实例化后Bean实例化后了，Spring在实例化Bean对象前提供了扩展点，通过继承InstantiationAwareBeanPostProcessor接口实现postProcessAfterInstantiation方法，就可以在实例化前调用该方法。 AbstractAutowireCapableBeanFactory.populateBean() // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the// state of the bean before properties are set. This can be used, for example,// to support styles of field injection.if (!mbd.isSynthetic() hasInstantiationAwareBeanPostProcessors()) for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) if (!bp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) return; 2.9 自动注入处理Spring的自动注入，详细看第三章节 2.10 处理属性这个步骤中，就会处理@Autowired、@Resource、@Value等注解，也是通过InstantiationAwareBeanPostProcessor.postProcessProperties()扩展点来实现的 AbstractAutowireCapableBeanFactory.populateBean() if (hasInstantiationAwareBeanPostProcessors()) if (pvs == null) pvs = mbd.getPropertyValues(); for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName); if (pvsToUse == null) return; pvs = pvsToUse; 2.11 执行Aware完成了属性赋值之后，Spring会执行一些回调，包括： BeanNameAware：回传beanName给bean对象。 BeanClassLoaderAware：回传classLoader给bean对象。 BeanFactoryAware：回传beanFactory给对象。 2.12 初始化前初始化前，也是Spring提供的一个扩展点：**BeanPostProcessor.postProcessBeforeInitialization()**，比如 利用初始化前，可以对进行了依赖注入的Bean进行处理。 AbstractAutowireCapableBeanFactory.initializeBean() if (mbd == null || !mbd.isSynthetic()) wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); 2.13 初始化 查看当前Bean对象是否实现了InitializingBean接口，如果实现了就调用其afterPropertiesSet()方法 执行BeanDefinition中指定的初始化方法 @Componentpublic class MyMergedBeanDefinitionPostProcessor implements MergedBeanDefinitionPostProcessor @Override\tpublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class? beanType, String beanName) if (beanName.equals(userService)) beanDefinition.setInitMethodNames(init); @Componentpublic class UserService public void init() System.out.println(UserService init); 2.14 总结 InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation() 实例化 MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition() InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation() 自动注入BY_TYPE、BY_NAME InstantiationAwareBeanPostProcessor.postProcessProperties() 回调Aware对象 BeanPostProcessor.postProcessBeforeInitialization() 初始化 BeanPostProcessor.postProcessAfterInitialization() 3. 依赖注入源码解析3.1 查询注入点实例化后的Bean对象只是new了一个对象，对象中的属性值还是null，这个时候需要对Bean对象中的属性赋值。 在Spring中我们可以使用@Autowired注解实现自动注入。 @Autowired注解可以写在： 属性上：先根据属性类型去找Bean，如果找到多个再根据属性名确定一个 构造方法上：先根据方法参数类型去找Bean，如果找到多个再根据参数名确定一个 set方法上：先根据方法参数类型去找Bean，如果找到多个再根据参数名确定一个 要往Bean中属性注入相应值时需要先找属性对应的注入点（@Autowired、@Value、@Inject所标注的地方），在Spring中利用AutowiredAnnotationBeanPostProcessor的**postProcessMergedBeanDefinition()**方法找出注入点并缓存，找注入点的流程为： 遍历当前类的所有的属性字段Field 获取类元数据信息判断字段上是否存在@Autowired、@Value、@Inject中的其中任意一个，存在则认为该字段是一个注入点 判断属性是否是静态的，静态的不进行注入 获取@Autowired中required属性值 将属性和required构造成AutowiredFieldElement对象放入fieldElements集合 遍历当前类的所有方法 判断当前Method是否是桥接方法，如果是找到原方法 查看方法上是否存在@Autowired、@Value、@Inject中的其中任意一个，存在则认为该方法是一个注入点 如果方法是static的，则不进行注入 获取@Autowired中的required属性的值 将方法信息构造成一个AutowiredMethodElement对象，作为一个注入点对象添加到currElements集合中。 遍历完当前类的字段和方法后，将遍历父类的，直到没有父类。 最后将currElements集合封装成一个InjectionMetadata对象，作为当前Bean对于的注入点集合对象，并缓存。 AutowiredAnnotationBeanPostProcessor.postProcessMergedBeanDefinition() @Overridepublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class? beanType, String beanName) // Register externally managed config members on bean definition.\t// 查找属性注入点\tfindInjectionMetadata(beanName, beanType, beanDefinition); ... AutowiredAnnotationBeanPostProcessor.findAutowiringMetadata()private InjectionMetadata findAutowiringMetadata(String beanName, Class? clazz, @Nullable PropertyValues pvs) // Fall back to class name as cache key, for backwards compatibility with custom callers.\tString cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());\t// Quick check on the concurrent map first, with minimal locking. // 在缓存中 MapString, InjectionMetadata injectionMetadataCache 查询是否存在注入点\tInjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);\tif (InjectionMetadata.needsRefresh(metadata, clazz)) synchronized (this.injectionMetadataCache) metadata = this.injectionMetadataCache.get(cacheKey); if (InjectionMetadata.needsRefresh(metadata, clazz)) if (metadata != null) metadata.clear(pvs); // 构建注入点 metadata = buildAutowiringMetadata(clazz); this.injectionMetadataCache.put(cacheKey, metadata); return metadata; AutowiredAnnotationBeanPostProcessor.buildAutowiringMetadata()private InjectionMetadata buildAutowiringMetadata(Class? clazz) // 判断class名是否是“java.”开头如果是直接返回\tif (!AnnotationUtils.isCandidateClass(clazz, this.autowiredAnnotationTypes)) return InjectionMetadata.EMPTY; // 注入点集合\tfinal ListInjectionMetadata.InjectedElement elements = new ArrayList();\tClass? targetClass = clazz;\tdo // 注入点字段集合 final ListInjectionMetadata.InjectedElement fieldElements = new ArrayList(); ReflectionUtils.doWithLocalFields(targetClass, field - // 判断字段是否存在@Autowired、@Value、@Inject中任意一个 MergedAnnotation? ann = findAutowiredAnnotation(field); if (ann != null) // 判断字段是否静态类型 if (Modifier.isStatic(field.getModifiers())) if (logger.isInfoEnabled()) logger.info(Autowired annotation is not supported on static fields: + field); return; // 获取@Autowired注解中required属性值 boolean required = determineRequiredStatus(ann); // 构造注入点放入集合 fieldElements.add(new AutowiredFieldElement(field, required)); ); final ListInjectionMetadata.InjectedElement methodElements = new ArrayList(); ReflectionUtils.doWithLocalMethods(targetClass, method - // 判断是否桥接方法，如果是桥接方法根据桥接方法找到实际的方法 Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method); if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) return; // 判断方法上是否有注入点 MergedAnnotation? ann = findAutowiredAnnotation(bridgedMethod); if (ann != null method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) // 判断是否静态方法 if (Modifier.isStatic(method.getModifiers())) if (logger.isInfoEnabled()) logger.info(Autowired annotation is not supported on static methods: + method); return; // 方法入参为0 if (method.getParameterCount() == 0) if (method.getDeclaringClass().isRecord()) // Annotations on the compact constructor arguments made available on accessors, ignoring. return; if (logger.isInfoEnabled()) logger.info(Autowired annotation should only be used on methods with parameters: + method); boolean required = determineRequiredStatus(ann); PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz); // 构造方法注入点放入集合 methodElements.add(new AutowiredMethodElement(method, required, pd)); ); elements.addAll(0, sortMethodElements(methodElements, targetClass)); elements.addAll(0, fieldElements); // 拿到父类类型 targetClass = targetClass.getSuperclass(); // 循环遍历父类获取父类注入点\twhile (targetClass != null targetClass != Object.class);\treturn InjectionMetadata.forElements(elements, clazz); static的字段或方法为什么不支持？ @Component@Scope(prototype)public class OrderService @Component@Scope(prototype)public class UserService @Autowired\tprivate static OrderService orderService;\tpublic void test() System.out.println(test); 如果UserService和OrderService都是原型Bean，假设Spring支持static字段进行自动注入，那么现在调用两次 UserService userService1 context.getBean(“userService”) UserService userService2 context.getBean(“userService”) 此时，userService1的orderService值是什么？还是它自己注入的值吗？ 一旦userService2 创建好了之后，因为orderService字段是一个静态的，静态属性是属于类的，那么在执行UserService userService2 = context.getBean(userService)代码后userService1中orderService就会被修改为userService2中的orderService，从而出现bug。 桥接方法 public interface UserServiceT void setOrderService(T t); @Componentpublic class UserServiceImpl implements UserServiceOrderService private OrderService orderService;\t@Override\t@Autowired\tpublic void setOrderService(OrderService orderService) this.orderService = orderService; public void test() System.out.println(test); UserServiceImpl对应的字节码为： 可以看到在UserSerivce的字节码中有两个setOrderService方法： public setOrderService(LcomzhouyuserviceOrderService;)V public synthetic bridge setOrderService(LjavalangObject;)V 并且都是存在@Autowired注解的。 所以在Spring中需要处理这种情况，当遍历到桥接方法时，得找到原方法。 3.2 注入点注入在上一步查询到注入点后，就可以根据注入点来进行依赖注入了。注入分为从字段注入及方法入参属性的注入。 3.2.1 字段注入InstantiationAwareBeanPostProcessor.postProcessPropertiesAutowiredAnnotationBeanPostProcessor.postProcessPropertiesAutowiredFieldElement.inject@Nullableprivate Object resolveFieldValue(Field field, Object bean, @Nullable String beanName) // 根据字段生成属性描述器\tDependencyDescriptor desc = new DependencyDescriptor(field, this.required);\tdesc.setContainingClass(bean.getClass());\tSetString autowiredBeanNames = new LinkedHashSet(2);\tAssert.state(beanFactory != null, No BeanFactory available);\tTypeConverter typeConverter = beanFactory.getTypeConverter();\tObject value;\ttry // 获取到属性对应Bean value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter); catch (BeansException ex) throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex); ...\treturn value;@Override@Nullablepublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName, @Nullable SetString autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException // 初始化方法参数的名称\tdescriptor.initParameterNameDiscovery(getParameterNameDiscoverer());\tif (Optional.class == descriptor.getDependencyType()) return createOptionalDependency(descriptor, requestingBeanName); else if (ObjectFactory.class == descriptor.getDependencyType() || ObjectProvider.class == descriptor.getDependencyType()) return new DependencyObjectProvider(descriptor, requestingBeanName); else if (javaxInjectProviderClass == descriptor.getDependencyType()) return new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName); else if (descriptor.supportsLazyResolution()) // 判断属性或方法参数上是否有@Lazy注解，如果有该注解直接先返回个代理对象 Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary( descriptor, requestingBeanName); if (result != null) return result; // descriptor表示某个属性或者某个set方法\t// requestingBeanName表示正在依赖注入的Bean\treturn doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);@Nullablepublic Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName, @Nullable SetString autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);\ttry ... // Step 2: pre-defined value or expression, e.g. from @Value // 获取@Value注解的值 Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor); if (value != null) if (value instanceof String strValue) // 占位符填充$ String resolvedValue = resolveEmbeddedValue(strValue); BeanDefinition bd = (beanName != null containsBean(beanName) ? getMergedBeanDefinition(beanName) : null); // 解析Spring表达式# value = evaluateBeanDefinitionString(resolvedValue, bd); ... // Step 3a: multiple beans as stream / array / standard collection / plain map // 根据type查到多个符合类型的Bean时 // MapString, OrderService/ListOrderService orderServices处理这种类型属性 Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter); if (multipleBeans != null) return multipleBeans; // Step 3b: direct bean matches, possibly direct beans of type Collection / Map // 找到所有的Bean,key是BeanName,value可能是bean对象也有可能是beanClass // 处理这种场景.例如根据类型找到了多个符合的Bean,有的Bean可能已经实例话了但是有的还没有实例化。（找出来的Bean可能并不是需要的Bean // 这个时候不需要提前去实例化它 MapString, Object matchingBeans = findAutowireCandidates(beanName, type, descriptor); if (matchingBeans.isEmpty()) // Step 3c (fallback): custom Collection / Map declarations for collecting multiple beans multipleBeans = resolveMultipleBeansFallback(descriptor, beanName, autowiredBeanNames, typeConverter); if (multipleBeans != null) return multipleBeans; // Raise exception if nothing found for required injection point // Required为true抛出异常 if (isRequired(descriptor)) raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor); return null; String autowiredBeanName; Object instanceCandidate; // Step 4: determine single candidate if (matchingBeans.size() 1) // 先根据@Primary、@Priority匹配符合的Bean再根据BeanName去匹配 autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor); if (autowiredBeanName == null) if (isRequired(descriptor) || !indicatesArrayCollectionOrMap(type)) // Raise exception if no clear match found for required injection point return descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans); else // In case of an optional Collection/Map, silently ignore a non-unique case: // possibly it was meant to be an empty collection of multiple regular beans // (before 4.3 in particular when we didnt even look for collection beans). return null; instanceCandidate = matchingBeans.get(autowiredBeanName); else // We have exactly one match. Map.EntryString, Object entry = matchingBeans.entrySet().iterator().next(); autowiredBeanName = entry.getKey(); instanceCandidate = entry.getValue(); // Step 5: validate single result if (autowiredBeanNames != null) autowiredBeanNames.add(autowiredBeanName); if (instanceCandidate instanceof Class) // 调用beanFactory.getBean(beanName)进行实例化 instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this); Object result = instanceCandidate; ... return result; ... 总结： 调用InstantiationAwareBeanPostProcessor.postProcessProperties进入AutowiredFieldElement.inject字段属性注入方法 判断属性上是否有@Lazy注解如果有直接返回一个代理对象 解析@Value注解、根据字段类型查询符合类型的Bean 判断字段属性是否是集合类型，且查询到符合类型的Bean，如果是直接返回 调用findAutowireCandidates()找出所有符合类型的Bean的名字或对象（已经实例化了） 判断查询是否有多个符合的Bean，再判断处理@Primary、@Priority匹配符合的Bean再根据BeanName去匹配 判断Bean是否是class，是就经行实例化返回Bean对象 将拿到的Bean通过反射注入到字段中 这个findAutowireCandidates()方法是查询Bean的核心实现： 找出BeanFactory中类型为type的所有的Bean的名字，注意是名字，而不是Bean对象，因为我们可以根据BeanDefinition就能判断和当前type是不是匹配，不用生成Bean对象 把resolvableDependencies中key为type的对象找出来并添加到result中 遍历根据type找出的beanName，判断当前beanName对应的Bean是不是能够被自动注入 先判断beanName对应的BeanDefinition中的autowireCandidate（@Bean中属性）属性，如果为false，表示不能用来进行自动注入，如果为true则继续进行判断 判断当前type是不是泛型，如果是泛型是会把容器中所有的beanName找出来的，如果是这种情况，那么在这一步中就要获取到泛型的真正类型，然后进行匹配，如果当前beanName和当前泛型对应的真实类型匹配，那么则继续判断 如果当前DependencyDescriptor上存在@Qualifier注解，那么则要判断当前beanName上是否定义了Qualifier，并且是否和当前DependencyDescriptor上的Qualifier相等，相等则匹配 经过上述验证之后，当前beanName才能成为一个可注入的，添加到result中 3.2.2 方法参数注入@Nullableprivate Object[] resolveMethodArguments(Method method, Object bean, @Nullable String beanName) // 方法参数个数\tint argumentCount = method.getParameterCount();\tObject[] arguments = new Object[argumentCount];\tDependencyDescriptor[] descriptors = new DependencyDescriptor[argumentCount];\tSetString autowiredBeanNames = new LinkedHashSet(argumentCount * 2);\tAssert.state(beanFactory != null, No BeanFactory available);\tTypeConverter typeConverter = beanFactory.getTypeConverter();\t// 遍历方法参数找到对应Bean对象\tfor (int i = 0; i arguments.length; i++) MethodParameter methodParam = new MethodParameter(method, i); DependencyDescriptor currDesc = new DependencyDescriptor(methodParam, this.required); currDesc.setContainingClass(bean.getClass()); descriptors[i] = currDesc; try // 获取Bean，这里的逻辑和字段属性一致 Object arg = beanFactory.resolveDependency(currDesc, beanName, autowiredBeanNames, typeConverter); if (arg == null !this.required !methodParam.isOptional()) arguments = null; break; arguments[i] = arg; catch (BeansException ex) throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(methodParam), ex); ...\treturn arguments; 3.3 @ResourceCommonAnnotationBeanPostProcessor.postProcessProperties @Overridepublic PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) // 查询@Resource注入点\tInjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs);\ttry // 属性注入 metadata.inject(bean, beanName, pvs); catch (Throwable ex) throw new BeanCreationException(beanName, Injection of resource dependencies failed, ex); return pvs;protected Object autowireResource(BeanFactory factory, LookupElement element, @Nullable String requestingBeanName) throws NoSuchBeanDefinitionException Object resource;\tSetString autowiredBeanNames;\tString name = element.name;\tif (factory instanceof AutowireCapableBeanFactory autowireCapableBeanFactory) // 判断BeanFactory中是否存在相应BeanName的Bean对象 if (this.fallbackToDefaultTypeMatch element.isDefaultName !factory.containsBean(name)) autowiredBeanNames = new LinkedHashSet(); // 不存在走resolveDependency，先byType再byName resource = autowireCapableBeanFactory.resolveDependency( element.getDependencyDescriptor(), requestingBeanName, autowiredBeanNames, null); if (resource == null) throw new NoSuchBeanDefinitionException(element.getLookupType(), No resolvable resource object); else // 存在直接根据name拿到Bean resource = autowireCapableBeanFactory.resolveBeanByName(name, element.getDependencyDescriptor()); autowiredBeanNames = Collections.singleton(name); ...\treturn resource; 4. 循环依赖@Componentpublic class OrderService @Autowired\tprivate UserService userService;@Componentpublic class UserService @Autowired\tprivate OrderService orderService;public class Main public static void main(String[] args) AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); UserService userService = (UserService) context.getBean(userService); OrderService orderService = (OrderService) context.getBean(orderService); System.out.println(userService); System.out.println(orderService); 可以看到执行结果是能够打印出userService和orderService对象，上面代码中userService和orderService互相依赖产生了循环依赖，怎么去解决这种循环依赖呢？ 我们想象下如果加入一个中间缓存，在创建A的过程中把A加入缓存，再创建B时依赖A只需要从缓存中把A取出就可以了。这样循环就很简单的打破了。 通过上面分析只要二级缓存就能结果循环依赖的问题那为什么Spirng引入三级缓存呢？因为Spring中有的Bean需要进行AOP处理，如果使用二级缓存那么注入的属性还是原始对象不是AOP后的代理对象。 Spring中怎么通过三级缓存实现AOP代理对象的注入呢？ 在实例化Bean后，会往singletonFactories中添加一个() - getEarlyBeanReference(beanName, mbd, bean) AbstractAutowireCapableBeanFactory.doCreateBean() protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException ...\tif (instanceWrapper == null) // 实例化Bean对象 instanceWrapper = createBeanInstance(beanName, mbd, args); ...\t// Eagerly cache singletons to be able to resolve circular references\t// even when triggered by lifecycle interfaces like BeanFactoryAware.\tboolean earlySingletonExposure = (mbd.isSingleton() this.allowCircularReferences isSingletonCurrentlyInCreation(beanName));\tif (earlySingletonExposure) if (logger.isTraceEnabled()) logger.trace(Eagerly caching bean + beanName + to allow for resolving potential circular references); // 所有单例Bean都会添加一个ObjectFactory? singletonFactory // this.singletonFactories.put(beanName, singletonFactory); addSingletonFactory(beanName, () - getEarlyBeanReference(beanName, mbd, bean)); // Initialize the bean instance.\tObject exposedObject = bean;\ttry // 属性注入 populateBean(beanName, mbd, instanceWrapper); // 初始化Bean exposedObject = initializeBean(beanName, exposedObject, mbd); ... @Nullableprotected Object getSingleton(String beanName, boolean allowEarlyReference) // Quick check for existing instance without full singleton lock // 假设A、B有循环依赖，且B需要AOP。创建A时需要拿到B对象,这里从单例池中第一次是找不到B的\tObject singletonObject = this.singletonObjects.get(beanName); // isSingletonCurrentlyInCreation()这个方法判断了是否产生了循环依赖\tif (singletonObject == null isSingletonCurrentlyInCreation(beanName)) // 第一次调用这里也是空 singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null allowEarlyReference) synchronized (this.singletonObjects) // Consistent creation of early reference within full singleton lock singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null) // 拿到三级缓存中lambda表达式 () - getEarlyBeanReference(beanName, mbd, bean) ObjectFactory? singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) // 执行lambda表达式-调用AbstractAutowireCapableBeanFactory.getEarlyBeanReference()拿到实例化的Bean，如果是代理代理返回代理对象 singletonObject = singletonFactory.getObject(); this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); return singletonObject; /** * Wrap the given bean if necessary, i.e. if it is eligible for being proxied. * @param bean the raw bean instance * @param beanName the name of the bean * @param cacheKey the cache key for metadata access * @return a proxy wrapping the bean, or the raw bean instance as-is */protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) ...\t// Create proxy if we have advice. // 判断是否有advice如果有就去创建代理对象，没有就直接返回普通对象\tObject[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);\tif (specificInterceptors != DO_NOT_PROXY) this.advisedBeans.put(cacheKey, Boolean.TRUE); Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; this.advisedBeans.put(cacheKey, Boolean.FALSE);\treturn bean; 总结： singletonObjects：缓存经过了完整生命周期的bean earlySingletonObjects：缓存未经过完整生命周期的bean，如果某个bean出现了循环依赖，就会提前把这个暂时未经过完整生命周期的bean放入earlySingletonObjects中，这个bean如果要经过AOP，那么就会把代理对象放入earlySingletonObjects中，否则就是把原始对象放入earlySingletonObjects。 singletonFactories：缓存的是一个ObjectFactory，也就是一个Lambda表达式。在每个Bean的生成过程中，经过实例化得到一个原始对象后，都会提前基于原始对象暴露一个Lambda表达式，并保存到三级缓存中，这个Lambda表达式可能用到，也可能用不到，如果当前Bean没有出现循环依赖，那么这个Lambda表达式没用，当前bean按照自己的生命周期正常执行，执行完后直接把当前bean放入singletonObjects中，如果当前bean在依赖注入时发现出现了循环依赖（当前正在创建的bean被其他bean依赖了），则从三级缓存中拿到Lambda表达式，并执行Lambda表达式得到一个对象，并把得到的对象放入二级缓存（(如果当前Bean需要AOP，那么执行lambda表达式，得到就是对应的代理对象，如果无需AOP，则直接得到一个原始对象)）。","tags":[null],"categories":[null]},{"title":"Spring源码编译","path":"/wiki/Spring/Spring源码编译.html","content":"1. 下载源码Spring官方文档编译源码步骤：https://github.com/spring-projects/spring-framework/wiki/Build-from-Source 基础环境 版本 操作系统 Windows 11 Spring源码 6.1.11 Java环境 JDK 17、JDK 21 编译工具 Gradle 8.9 开发工具 IDEA 2024.1.1 版本管理 Git git clone git@github.com:spring-projects/spring-framework.gitcd spring-framework 2. 修改配置配置Gradle下载加速 在gradle-8.9\\init.d文件夹下新增init.gradle文件 allprojects repositories maven url file:///D:/work/tools/gradle/repository // 本地仓库地址，如果没有依次向下寻找 maven url https://maven.aliyun.com/repository/public mavenLocal() mavenCentral() buildscript repositories maven url https://maven.aliyun.com/repository/public mavenLocal() mavenCentral() 修改idea中Gradle配置 maven url https://maven.aliyun.com/repository/public // 阿里云镜像仓库 配置镜像加速 pluginManagement repositories //新增阿里云镜像地址 maven url https://maven.aliyun.com/repository/public mavenCentral() gradlePluginPortal() maven url https://repo.spring.io/release 3. 编译源码根据import-into-idea.md文件指导，执行./gradlew :spring-oxm:compileTestJava 注意代理设置： 编译完成后刷新下 4. 排除spring-aspects 5. 新增demo模块引入spring-context依赖，进行测试。 git config –global http.proxy http://127.0.0.1:17890git config –global https.proxy ‘http://127.0.0.1:17890‘ ORgit config –global http.proxy ‘socks5:127.0.0.1:10808’git config –global https.proxy ‘socks5:127.0.0.1:10808’","tags":[null],"categories":[null]},{"title":"数组题解","path":"/wiki/leetcode/array.html","content":"704. 二分查找https://leetcode.com/problems/binary-search/ 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 class Solution public int search(int[] nums, int target) int len = nums.length; int left = 0; int right = len - 1; while (left = right) int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; else if (nums[mid] target) left = mid + 1; else if (nums[mid] target) right = mid - 1; return -1; func search(nums []int, target int) int left := 0 right := len(nums) - 1 for left = right mid := left + (right - left) / 2 if nums[mid] == target return mid else if nums[mid] target left = mid + 1 else right = mid - 1 return -1 27. 移除元素力扣题目链接(opens new window) 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums [3,2,2,3], val 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums [0,1,2,2,3,0,4,2], val 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 你不需要考虑数组中超出新长度后面的元素。 func removeElement(nums []int, val int) int slow := 0 len := len(nums) for fast:=0; fast len; fast++ if nums[fast] != val nums[slow] = nums[fast] slow++ return slow 26. 删除排序数组中的重复项https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/ Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums. Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things: Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge: The judge will test your solution with the following code: int[] nums = [...]; // Input arrayint[] expectedNums = [...]; // The expected answer with correct lengthint k = removeDuplicates(nums); // Calls your implementationassert k == expectedNums.length;for (int i = 0; i k; i++) assert nums[i] == expectedNums[i]; If all assertions pass, then your solution will be accepted. Example 1: Input: nums = [1,1,2]Output: 2, nums = [1,2,_]Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: Input: nums = [0,0,1,1,1,2,2,3,3,4]Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.It does not matter what you leave beyond the returned k (hence they are underscores). func removeDuplicates(nums []int) int slow := 0 len := len(nums) for fast := 1; fast len; fast++ // [0,1,2,3,4,2,2,3,3,4] if nums[slow] != nums[fast] slow++ nums[slow] = nums[fast] return slow + 1 283. 移除0Given an integer array nums, move all 0‘s to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. Example 1: Input: nums = [0,1,0,3,12]Output: [1,3,12,0,0] Example 2: Input: nums = [0]Output: [0] Constraints: 1 = nums.length = 104 -231 = nums[i] = 231 - 1 func moveZeroes(nums []int) slow := 0\tlen := len(nums)\tfor fast := 0; fast len; fast++ // [3,12,0,3,12,0] if nums[fast] != 0 nums[slow] = nums[fast] slow++ for i := slow; i len; i++ nums[i] = 0 977. 有序数组的平方https://leetcode.com/problems/squares-of-a-sorted-array/description/ Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order. Example 1: Input: nums = [-4,-1,0,3,10]Output: [0,1,9,16,100]Explanation: After squaring, the array becomes [16,1,0,9,100].After sorting, it becomes [0,1,9,16,100]. Example 2: Input: nums = [-7,-3,2,3,11]Output: [4,9,9,49,121] func sortedSquares(nums []int) []int left := 0\tlen := len(nums)\tright := len - 1 res := make([]int, len)\tfor i := len - 1; i = 0; i-- lr := nums[left] * nums[left] rr := nums[right] * nums[right] if lr rr res[i] = lr left++ else res[i] = rr right-- return res 209. 长度最小的子数组Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead. Example 1: Input: target = 7, nums = [2,3,1,2,4,3]Output: 2Explanation: The subarray [4,3] has the minimal length under the problem constraint. Example 2: Input: target = 4, nums = [1,4,4]Output: 1 Example 3: Input: target = 11, nums = [1,1,1,1,1,1,1,1]Output: 0 func minSubArrayLen(target int, nums []int) int slow := 0\tlen := len(nums)\tsum := 0\tres := math.MaxInt\tfor fast := 0; fast len; fast++ sum += nums[fast] for sum = target k := fast - slow + 1 if res k res = k sum = sum - nums[slow] slow++ if res == math.MaxInt res = 0 return res","tags":[null],"categories":[null]},{"title":"数组题解","path":"/wiki/leetcode/binary_tree.html","content":"二叉树基本定义基本概念‌二叉树‌是一种树形数据结构，满足： ‌每个节点最多有2个子节点‌，称为‌左子节点‌和‌右子节点‌。 ‌子树有严格顺序‌：左子树和右子树不可互换（即使某个子树为空）。 度定义‌：一个节点拥有的‌子节点数量‌。 二叉树中的度范围‌： ‌0‌（叶子节点，无子节点） ‌1‌（只有左或右子节点） ‌2‌（同时有左和右子节点） 示例‌： A（度=2） / \\B（度=1） C（度=0） \\ D（度=0） 二叉树种类满二叉树满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。 A / \\ B C/ \\ / \\D E F G 完全二叉树完全二叉树：除最后一层外，其他层节点全满，且最后一层节点‌向左对齐‌。 A / \\ B C/ \\ /D E F 二叉树的存储方式二叉树可以链式存储，也可以顺序存储。 那么链式存储方式就用指针， 顺序存储的方式就是用数组。 顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。 链式存储如图： 顺序存储其实就是用数组来存储二叉树，顺序存储的方式如图： 二叉树的遍历二叉树主要有两种遍历方式： 深度优先遍历：先往深走，遇到叶子节点再往回走。 广度优先遍历：一层一层的去遍历。 深度优先遍历： 前序遍历（递归法，迭代法） 中序遍历（递归法，迭代法） 后序遍历（递归法，迭代法） 这里前中后，其实指的就是中间节点的遍历顺序，只要大家记住 前中后序指的就是中间节点的位置就可以了。 看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式 前序遍历：中左右 中序遍历：左中右 后序遍历：左右中 广度优先遍历： 层次遍历（迭代法） 二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。 而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。 二叉树定义public class TreeNode int val; TreeNode left; TreeNode right; TreeNode() TreeNode(int val) this.val = val; TreeNode(int val, TreeNode left, TreeNode right) this.val = val; this.left = left; this.right = right; class TreeNode: def __init__(self, val, left = None, right = None): self.val = val self.left = left self.right = right type TreeNode struct Val int Left *TreeNode Right *TreeNode function TreeNode(val, left, right) this.val = (val===undefined ? 0 : val) this.left = (left===undefined ? null : left) this.right = (right===undefined ? null : right) docker run -d –name weaviate-dev -e AUTHENTICATION_APIKEY_ENABLED”true” -e AUTHENTICATION_APIKEY”your_api_key” -p 8080:8080 -p 50051:50051 semitechnologiesweaviate","tags":[null],"categories":[null]},{"title":"哈希表题解","path":"/wiki/leetcode/hash.html","content":"242.有效的字母异位词https://leetcode.com/problems/valid-anagram/description/ 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 示例 1: 输入: s “anagram”, t “nagaram” 输出: true 示例 2: 输入: s “rat”, t “car” 输出: false 说明: 你可以假设字符串只包含小写字母。 思路： 定义一个数组叫做record用来上记录字符串s里字符出现的次数。 需要把字符映射到数组也就是哈希表的索引下标上，因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。 再遍历 字符串s的时候，只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。 这样就将字符串s中字符出现的次数，统计出来了。 那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。 那么最后检查一下，record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。 最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true。 时间复杂度为O(n)，空间上因为定义是的一个常量大小的辅助数组，所以空间复杂度为O(1)。 class Solution public boolean isAnagram(String s, String t) int sLen = s.length(); int tLen = t.length(); if (sLen != tLen) return false; int[] records = new int[26]; for (int i = 0; i sLen; i++) records[s.charAt(i) - a]++; for (int i = 0; i tLen; i++) records[t.charAt(i) - a]--; for (int record : records) if (record != 0) return false; return true; func isAnagram(s string, t string) bool if len(s) != len(t) return false records := [26]int\tfor _, v := range s records[v-a]++ for _, v := range t records[(v-a)]-- for _, v := range records if v != 0 return false return true 349. 两个数组的交集https://leetcode.com/problems/intersection-of-two-arrays/ 题意：给定两个数组，编写一个函数来计算它们的交集。 说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 class Solution public int[] intersection(int[] nums1, int[] nums2) SetInteger set = new HashSet(); SetInteger resSet = new HashSet(); for (int num : nums1) set.add(num); for (int num : nums2) if (set.contains(num)) resSet.add(num); return resSet.stream().mapToInt(x - x).toArray(); func intersection(nums1 []int, nums2 []int) []int // 模拟set集合\tset := make(map[int]struct)\tres := make([]int, 0) // nums = 1,2,2,1 // nums2 = 2,2,2\tfor _, v := range nums1 if _, ok := set[v]; !ok // 1 : struct // 2 : struct set[v] = struct for _, v := range nums2 if _, ok := set[v]; ok res = append(res, v) // 注意要删除 delete(set, v) return res 202. 快乐数https://leetcode.com/problems/happy-number/submissions/1364131847/ 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。 如果 n 是快乐数就返回 True ；不是，则返回 False 。 示例： 输入：19输出：true解释：1^2 + 9^2 828^2 + 2^2 686^2 + 8^2 1001^2 + 0^2 + 0^2 1 func isHappy(n int) bool set := make(map[int]bool)\tfor !set[n] if n == 1 return true set[n] = true n = getSum(n) return falsefunc getSum(n int) int sum := 0\tfor n 0 digit := n % 10 sum += digit * digit n /= 10 return sum 1. 两数之和力扣题目链接(opens new window) 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 给定 nums [2, 7, 11, 15], target 9 因为 nums[0] + nums[1] 2 + 7 9 所以返回 [0, 1] func twoSum(nums []int, target int) []int m := make(map[int]int) for i, num := range nums m[num] = i for i, num := range nums v, ok := m[target - num] // 注意需要判断是否是本身 if ok v != i return []inti, v return nil","tags":[null],"categories":[null]},{"title":"链表题解","path":"/wiki/leetcode/link.html","content":"203.移除链表元素https://leetcode.com/problems/remove-linked-list-elements/ 题目： 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例 1: 输入：head = [1,2,6,3,4,5,6], val = 6输出：[1,2,3,4,5] 示例 2: 输入：head = [], val = 1输出：[] 示例 3: 输入：head = [7,7,7,7], val = 7输出：[] 思路： 判断链表中符合val值的数，只要遍历链表时获取链表值然后比对val值就可进行判断。 要移除链表中的一个节点，只要知道链表当前节点的上一个节点指针就行。让上一个节点指向当前节点的下一个节点就可删去当前节点。如果判断不符合删除条件，需要移动前置指针。当前指针无论是否删除都需移动下一位。 if (curNode.val == val) preNode.next = curNode.next else preNode = curNode;curNode = curNode.next; 考虑到头节点如果符合val值时，需要删除头节点。这个时候需要创建一个虚拟节点来指向头节点。 ListNode dummyNode = new ListNode(-1);dummyNode.next = head; 题解： /** * Definition for singly-linked list. * public class ListNode * int val; * ListNode next; * ListNode() * ListNode(int val) this.val = val; * ListNode(int val, ListNode next) this.val = val; this.next = next; * */class Solution public ListNode removeElements(ListNode head, int val) // 虚拟指针指向头节点 ListNode dummyNode = new ListNode(-1); dummyNode.next = head; // 当前指针 ListNode curNode = head; // 前置指针 ListNode preNode = dummyNode; // 判断链表是否遍历完成 while(curNode != null) if (curNode.val == val) // 删除当前节点 preNode.next = curNode.next; else // 移动前置指针 preNode = curNode; // 移动当前指针 curNode = curNode.next; return dummyNode.next; /** * Definition for singly-linked list. * type ListNode struct * Val int * Next *ListNode * */func removeElements(head *ListNode, val int) *ListNode dummyNode := ListNode dummyNode.Next = head cur := head pre := dummyNode for cur != nil next := cur.Next v := cur.Val if v == val pre.Next = next else pre = cur cur = next return dummyNode.Next 206.反转链表https://leetcode.com/problems/reverse-linked-list/description/ 题目：反转一个单链表。 示例: 输入: 1-2-3-4-5-NULL 输出: 5-4-3-2-1-NULL 思路: 要翻转链表，即要后一个节点指向前一个节点。但是修改后一个节点指向前一个节点的指针时要保存好后一个节点原先的指向，不要链表就遍历不了了。 可以使用双指针，一个指针指向当前节点，一个指针指向后一个节点。 后一个节点从head节点开始，当前节点为null。保证head节点指向null。 题解: /** * Definition for singly-linked list. * public class ListNode * int val; * ListNode next; * ListNode() * ListNode(int val) this.val = val; * ListNode(int val, ListNode next) this.val = val; this.next = next; * */class Solution public ListNode reverseList(ListNode head) // 后一个节点 ListNode post = head; // 当前节点 ListNode cur = null; while (post != null) // 保存后一个节点指向 ListNode next = post.next; // 后一个节点指向当前节点，翻转 post.next = cur; // 移动当前节点指针 cur = post; // 移动后一个节点指针 post = next; return cur; /** * Definition for singly-linked list. * type ListNode struct * Val int * Next *ListNode * */func reverseList(head *ListNode) *ListNode fast := head var slow *ListNode for fast != nil // 保留Next next := fast.Next fast.Next = slow slow = fast fast = next return slow 24.两两交换链表中的节点https://leetcode.com/problems/swap-nodes-in-pairs/description/ 题目： 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 思路： 考虑到头节点为空的情况，可以设置一个虚拟节点 可以使用双指针cur、post。cur指向虚拟节点，post指向头节点 重复节点交换 移动cur和post 注意：cur移动时是移动到post之前指向的位置 题解： /** * Definition for singly-linked list. * public class ListNode * int val; * ListNode next; * ListNode() * ListNode(int val) this.val = val; * ListNode(int val, ListNode next) this.val = val; this.next = next; * */class Solution public ListNode swapPairs(ListNode head) ListNode dummy = new ListNode(-1); dummy.next = head; ListNode cur = dummy; ListNode post = head; while (post != null post.next != null) ListNode next = post.next; ListNode nextnext = next.next; cur.next = next; next.next = post; post.next = nextnext; // 注意：cur指针指向post之前指向的位置 cur = post; post = nextnext; return dummy.next; /** * Definition for singly-linked list. * type ListNode struct * Val int * Next *ListNode * */func swapPairs(head *ListNode) *ListNode if head == nil || head.Next == nil return head dummy := ListNode\tslow := dummy\tfast := head\tfor fast != nil fast.Next != nil next := fast.Next next2 := fast.Next.Next slow.Next = next next.Next = fast fast.Next = next2 slow = fast fast = next2 return dummy.Next 19. 删除链表的倒数第N个节点https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/ 题目： 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 进阶：你能尝试使用一趟扫描实现吗？ 思路： 考虑到可能删除头节点那么就要创建一个虚拟头节点 删除某个节点可以考虑使用双指针 删除倒数节点，可以定义快、慢指针。删除倒数n个节点，快指针就先走n步。然后再同时遍历链表直到快指针走到链表尾部。这个时候慢指针停留在要删除的节点前一个节点。 题解： /** * Definition for singly-linked list. * public class ListNode * int val; * ListNode next; * ListNode() * ListNode(int val) this.val = val; * ListNode(int val, ListNode next) this.val = val; this.next = next; * */class Solution public ListNode removeNthFromEnd(ListNode head, int n) ListNode dummy = new ListNode(-1); dummy.next = head; ListNode fast = dummy; ListNode slow = dummy; // 快指针先走n步 for (int i = 0; i n; i++) fast = fast.next; // 快、慢指针同时走直到快指针走到链表尾部 while(fast.next != null) fast = fast.next; slow = slow.next; // 删除倒数n的节点 slow.next = slow.next.next; return dummy.next; /** * Definition for singly-linked list. * type ListNode struct * Val int * Next *ListNode * */func removeNthFromEnd(head *ListNode, n int) *ListNode if head == nil || head.Next == nil return nil dummy := ListNode dummy.Next = head\tfast := dummy\tslow := dummy\t// 快指针先走n步\tfor i := 0; i n; i++ fast = fast.Next for fast.Next != nil fast = fast.Next slow = slow.Next slow.Next = slow.Next.Next return dummy.Next 160. 链表相交https://leetcode.com/problems/intersection-of-two-linked-lists/description/ 题目： 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 图示两个链表在节点 c1 开始相交： 思路： 定义两个指针curA和curB分别指向A、B 让两个指针同时移动，curA移动到末端时。将curA指向B，并再次移动curA和curB。当curB移动到末端时将curB指向A。 同时移动curA和curB，并判断curA和curB是否相同。直到遍历到链表尾部。若无相同则返回null。 题解： /** * Definition for singly-linked list. * public class ListNode * int val; * ListNode next; * ListNode(int x) * val = x; * next = null; * * */public class Solution public ListNode getIntersectionNode(ListNode headA, ListNode headB) ListNode nodeA = headA; ListNode nodeB = headB; // 移动nodeA和nodeB while (nodeA != null nodeB != null) nodeA = nodeA.next; nodeB = nodeB.next; if (nodeA == null) // nodeA指向B nodeA = headB; while (nodeB != null) nodeB = nodeB.next; nodeA = nodeA.next; // nodeB指向A nodeB = headA; else if (nodeB == null) nodeB = headA; while (nodeA != null) nodeB = nodeB.next; nodeA = nodeA.next; nodeA = headB; while (nodeA != null) // 判断是否存在相交节点 if (nodeA == nodeB) return nodeA; nodeA = nodeA.next; nodeB = nodeB.next; return null; /** * Definition for singly-linked list. * type ListNode struct * Val int * Next *ListNode * */func getIntersectionNode(headA, headB *ListNode) *ListNode curA := headA curB := headB for curA != nil curB != nil curA = curA.Next curB = curB.Next if curA == nil curA = headB for curB != nil curA = curA.Next curB = curB.Next curB = headA if curB == nil curB = headA for curA != nil curA = curA.Next curB = curB.Next curA = headB for curA != nil if curA == curB return curA curA = curA.Next curB = curB.Next return nil","tags":[null],"categories":[null]},{"title":"字符串题解","path":"/wiki/leetcode/string.html","content":"344. 反转字符串https://leetcode.com/problems/reverse-string/description/ 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。不要给另外的数 组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。你可以假设数组中的所有字 符都是 ASCII 码表中的可打印字符。 示例 1：输入：[“h”,”e”,”l”,”l”,”o”]输出：[“o”,”l”,”l”,”e”,”h”] 示例 2：输入：[“H”,”a”,”n”,”n”,”a”,”h”]输出：[“h”,”a”,”n”,”n”,”a”,”H”] func reverseString(s []byte) l := len(s) - 1\tfor i := 0; i = l / 2; i++ tmp := s[i] s[i] = s[l - i] s[l - i] = tmp 541. 反转字符串IIhttps://leetcode.com/problems/reverse-string-ii/description/ 给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。 如果剩余字符少于 k 个，如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 示例: 输入: s “abcdefg”, k 2 输出: “bacdfeg” func reverseStr(s string, k int) string res := []byte(s)\tl := len(s)\tfor i := 0; i l; i += 2 * k if i+k = l reverse(res[i : i+k]) else reverse(res[i:l]) return string(res)func reverse(b []byte) left := 0 right := len(b) - 1 for left right b[left], b[right] = b[right], b[left] left++ right--","tags":[null],"categories":[null]},{"title":"RocketMQ基础概念","path":"/wiki/RocketMQ/RocketMQ2.html","content":"1. RocketMQ基础消息模型 上图就是一个基本的消息系统模型，包括生产者 (Producer)，消费者 (Consumer)，中间进行基于消息主题（Topic）的消息传送。 2. RocketMQ扩展模型在基于主题的系统中，消息被发布到主题或命名通道上。消费者将收到其订阅主题上的所有消息，生产者负责定义订阅者所订阅的消息类别。这是一个基础的概念模型，而在实际的应用中，结构会更复杂。例如为了支持高并发和水平扩展，中间的消息主题需要进行分区，同一个Topic会有多个生产者，同一个信息会有多个消费者，消费者之间要进行负载均衡等。 上图就是一个扩展后的消息模型，包括两个生产者，两个消息Topic，以及两组消费者 Comsumer。 存储消息Topic的 代理服务器( Broker )，是实际部署过程对应的代理服务器。 为了消息写入能力的水平扩展，RocketMQ 对 Topic进行了分区，这种操作被称为队列（MessageQueue）。 为了消费能力的水平扩展，ConsumerGroup的概念应运而生。 相同的ConsumerGroup下的消费者主要有两种负载均衡模式，即广播模式，和集群模式（图中是最常用的集群模式）。 在集群模式下，同一个 ConsumerGroup 中的 Consumer 实例是负载均衡消费，如图中 ConsumerGroupA 订阅 TopicA，TopicA 对应 3个队列，则 GroupA 中的 Consumer1 消费的是 MessageQueue 0和 MessageQueue 1的消息，Consumer2是消费的是MessageQueue2的消息。 在广播模式下，同一个 ConsumerGroup 中的每个 Consumer 实例都处理全部的队列。需要注意的是，广播模式下因为每个 Consumer 实例都需要处理全部的消息，因此这种模式仅推荐在通知推送、配置同步类小流量场景使用。 3. 生产者3.1 消息RocketMQ 消息构成非常简单，如下图所示。 topic，表示要发送的消息的主题。 body 表示消息的存储内容 properties 表示消息属性 transactionId 会在事务消息中使用。 Message 可以设置的属性值包括： 字段名 默认值 必要性 说明 Topic null 必填 消息所属 topic 的名称 Body null 必填 消息体 Tags null 选填 消息标签，方便服务器过滤使用。目前只支持每个消息设置一个 Keys null 选填 代表这条消息的业务关键词 Flag 0 选填 完全由应用来设置，RocketMQ 不做干预 DelayTimeLevel 0 选填 消息延时级别，0 表示不延时，大于 0 会延时特定的时间才会被消费 WaitStoreMsgOK true 选填 表示消息是否在服务器落盘后才返回应答。 Tag: 不管是 RocketMQ 的 Tag 过滤还是延迟消息等都会利用 Properties 消息属性机制，这些特殊信息使用了系统保留的属性Key，设置自定义属性时需要避免和系统属性Key冲突。 Keys: 服务器会根据 keys 创建哈希索引，设置后，可以在 Console 系统根据 Topic、Keys 来查询消息，由于是哈希索引，请尽可能保证 key 唯一，例如订单号，商品 Id 等。 3.2 TagTopic 与 Tag 都是业务上用来归类的标识，区别在于 Topic 是一级分类，而 Tag 可以理解为是二级分类。使用 Tag 可以实现对 Topic 中的消息进行过滤。 Topic：消息主题，通过 Topic 对不同的业务消息进行分类。 Tag：消息标签，用来进一步区分某个 Topic 下的消息分类，消息从生产者发出即带上的属性。 什么时候该用 Topic，什么时候该用 Tag？ 可以从以下几个方面进行判断： 消息类型是否一致：如普通消息、事务消息、定时（延时）消息、顺序消息，不同的消息类型使用不同的 Topic，无法通过 Tag 进行区分。 业务是否相关联：没有直接关联的消息，如淘宝交易消息，京东物流消息使用不同的 Topic 进行区分；而同样是天猫交易消息，电器类订单、女装类订单、化妆品类订单的消息可以用 Tag 进行区分。 消息优先级是否一致：如同样是物流消息，盒马必须小时内送达，天猫超市 24 小时内送达，淘宝物流则相对会慢一些，不同优先级的消息用不同的 Topic 进行区分。 消息量级是否相当：有些业务消息虽然量小但是实时性要求高，如果跟某些万亿量级的消息使用同一个 Topic，则有可能会因为过长的等待时间而“饿死”，此时需要将不同量级的消息进行拆分，使用不同的 Topic。 总的来说，针对消息分类，您可以选择创建多个 Topic，或者在同一个 Topic 下创建多个 Tag。但通常情况下，不同的 Topic 之间的消息没有必然的联系，而 Tag 则用来区分同一个 Topic 下相互关联的消息，例如全集和子集的关系、流程先后的关系。 3.3 KeysApache RocketMQ 每个消息可以在业务层面的设置唯一标识码 keys 字段，方便将来定位消息丢失问题。 Broker 端会为每个消息创建索引（哈希索引），应用可以通过 topic、key 来查询这条消息内容，以及消息被谁消费。由于是哈希索引，请务必保证 key 尽可能唯一，这样可以避免潜在的哈希冲突。 3.4 队列为了支持高并发和水平扩展，需要对 Topic 进行分区，在 RocketMQ 中这被称为队列，一个 Topic 可能有多个队列，并且可能分布在不同的 Broker 上。 一般来说一条消息，如果没有重复发送（比如因为服务端没有响应而进行重试），则只会存在在 Topic 的其中一个队列中，消息在队列中按照先进先出的原则存储，每条消息会有自己的位点，每个队列会统计当前消息的总条数，这个称为最大位点 MaxOffset；队列的起始位置对应的位置叫做起始位点 MinOffset。队列可以提升消息发送和消费的并发度。 3.5 生产者生产者（Producer）就是消息的发送者，Apache RocketMQ 拥有丰富的消息类型，可以支持不同的应用场景。 需要注意的是，生产环境中不同消息类型需要使用不同的主题，不要在同一个主题内使用多种消息类型，这样可以避免运维过程中的风险和错误。 4. 消息生产及消费4.1 普通消息Apache RocketMQ可用于以三种方式发送消息：同步、异步和单向传输。前两种消息类型是可靠的，因为无论它们是否成功发送都有响应。 4.1.1 同步消息同步发送是最常用的方式，是指消息发送方发出一条消息后，会在收到服务端同步响应之后才发下一条消息的通讯方式，可靠的同步传输被广泛应用于各种场景，如重要的通知消息、短消息通知等。 同步发送的整个代码流程如下： 首先会创建一个producer。普通消息可以创建 DefaultMQProducer，创建时需要填写生产组的名称，生产者组是指同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。 设置 NameServer 的地址。Apache RocketMQ很多方式设置NameServer地址(客户端配置中有介绍)，这里是在代码中调用producer的API setNamesrvAddr进行设置，如果有多个NameServer，中间以分号隔开，比如”127.0.0.2:9876;127.0.0.3:9876”。 第三步是构建消息。指定topic、tag、body等信息，tag可以理解成标签，对消息进行再归类，RocketMQ可以在消费端对tag进行过滤。 最后调用send接口将消息发送出去。同步发送等待结果最后返回SendResult，SendResult包含实际发送状态还包括SEND_OK（发送成功）, FLUSH_DISK_TIMEOUT（刷盘超时）, FLUSH_SLAVE_TIMEOUT（同步到备超时）, SLAVE_NOT_AVAILABLE（备不可用），如果发送失败会抛出异常。 /** * * * @author lm * @since 2024-05-24 09:12:17 * @version 1.0 */public class TestRocketMQ @Test public void testProducer() throws MQClientException, MQBrokerException, RemotingException, InterruptedException // 1.创建消息生产者producer，并制定生产者组名 DefaultMQProducer producer = new DefaultMQProducer(TestProducerGroup); // 2.指定Nameserver地址 producer.setNamesrvAddr(117.72.71.187:9876); // 3.启动producer producer.start(); // 4.创建消息对象，指定主题Topic、Tag和消息体等 String topic = TestTopic; String msg = Hello RocketMQ; String tag = TesTag; Message message = new Message(topic, tag, msg.getBytes()); // 5.发送消息 SendResult send = producer.send(message); System.out.println(send); // 6.关闭生产者producer producer.shutdown(); 同步发送方式请务必捕获发送异常，并做业务侧失败兜底逻辑，如果忽略异常则可能会导致消息未成功发送的情况。 发送成功显示 在仪表板可以看到生产的消息 消息消费 @Test public void testConsumer() throws MQClientException, IOException // 实例化消费者 DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(TestConsumerGroup); // 设置NameServer的地址 consumer.setNamesrvAddr(117.72.71.187:9876); // 订阅一个或者多个Topic，以及Tag来过滤需要消费的消息 consumer.subscribe(TestTopic, *); // 注册回调实现类来处理从broker拉取回来的消息 consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) - System.out.printf(%s Receive New Messages: %s %n, Thread.currentThread().getName(), msgs.toString()); // 标记该消息已经被成功消费 return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; ); // 启动消费者实例 consumer.start(); // 等待消息接收 System.in.read(); System.out.printf(Consumer Started.%n); 在仪表板中可以看到对应的消费者组及消费详情 4.1.2 异步消息异步发送是指发送方发出一条消息后，不等服务端返回响应，接着发送下一条消息的通讯方式。 异步发送需要实现异步发送回调接口（SendCallback）。 消息发送方在发送了一条消息后，不需要等待服务端响应即可发送第二条消息，发送方通过回调接口接收服务端响应，并处理响应结果。异步发送一般用于链路耗时较长，对响应时间较为敏感的业务场景。例如，视频上传后通知启动转码服务，转码完成后通知推送转码结果等。 @Test public void testAsyncMessage() throws MQClientException, MQBrokerException, RemotingException, InterruptedException // 初始化一个producer并设置Producer group name DefaultMQProducer producer = new DefaultMQProducer(TestProducerGroup); // 设置NameServer地址 producer.setNamesrvAddr(117.72.71.187:9876); // 启动producer producer.start(); producer.setRetryTimesWhenSendAsyncFailed(0); int messageCount = 10; final CountDownLatch countDownLatch = new CountDownLatch(messageCount); for (int i = 0; i messageCount; i++) try final int index = i; // 创建一条消息，并指定topic、tag、body等信息，tag可以理解成标签，对消息进行再归类，RocketMQ可以在消费端对tag进行过滤 Message msg = new Message(TestTopic, TagAsync, Hello world.getBytes(RemotingHelper.DEFAULT_CHARSET)); // 异步发送消息, 发送结果通过callback返回给客户端 producer.send(msg, new SendCallback() @Override public void onSuccess(SendResult sendResult) System.out.printf(%-10d OK %s %n, index, sendResult.getMsgId()); countDownLatch.countDown(); @Override public void onException(Throwable e) System.out.printf(%-10d Exception %s %n, index, e); e.printStackTrace(); countDownLatch.countDown(); ); catch (Exception e) e.printStackTrace(); countDownLatch.countDown(); //异步发送，如果要求可靠传输，必须要等回调接口返回明确结果后才能结束逻辑，否则立即关闭Producer可能导致部分消息尚未传输成功 countDownLatch.await(5, TimeUnit.SECONDS); // 一旦producer不再使用，关闭producer producer.shutdown(); 异步发送与同步发送代码唯一区别在于调用send接口的参数不同，异步发送不会等待发送返回，取而代之的是send方法需要传入 SendCallback 的实现，SendCallback 接口主要有onSuccess 和 onException 两个方法，表示消息发送成功和消息发送失败。 4.1.3 单项模式 发送方只负责发送消息，不等待服务端返回响应且没有回调函数触发，即只发送请求不等待应答。此方式发送消息的过程耗时非常短，一般在微秒级别。适用于某些耗时非常短，但对可靠性要求并不高的场景，例如日志收集。 @Test public void testOnewaySend() throws MQClientException, UnsupportedEncodingException, RemotingException, InterruptedException // 初始化一个producer并设置Producer group name DefaultMQProducer producer = new DefaultMQProducer(TestProducerGroup); // 设置NameServer地址 producer.setNamesrvAddr(117.72.71.187:9876); // 启动producer producer.start(); for (int i = 0; i 10; i++) // 创建一条消息，并指定topic、tag、body等信息，tag可以理解成标签，对消息进行再归类，RocketMQ可以在消费端对tag进行过滤 Message msg = new Message(TestTopic /* Topic */, TagOneway /* Tag */, (Hello RocketMQ + i).getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */ ); // 由于在oneway方式发送消息时没有请求应答处理，如果出现消息发送失败，则会因为没有重试而导致数据丢失。 // 若数据不可丢，建议选用可靠同步或可靠异步发送方式。 producer.sendOneway(msg); // 一旦producer不再使用，关闭producer producer.shutdown(); 4.2 顺序消息顺序消息是一种对消息发送和消费顺序有严格要求的消息。 对于一个指定的Topic，消息严格按照先进先出（FIFO）的原则进行消息发布和消费，即先发布的消息先消费，后发布的消息后消费。在 Apache RocketMQ 中支持分区顺序消息。我们可以按照某一个标准对消息进行分区（订单ID），同一个订单ID的消息会被分配到同一个队列中，并按照顺序被消费。 需要注意的是 RocketMQ 消息的顺序性分为两部分，生产顺序性和消费顺序性。只有同时满足了生产顺序性和消费顺序性才能达到上述的FIFO效果。 生产顺序性： RocketMQ 通过生产者和服务端的协议保障单个生产者串行地发送消息，并按序存储和持久化。如需保证消息生产的顺序性，则必须满足以下条件： 单一生产者： 消息生产的顺序性仅支持单一生产者，不同生产者分布在不同的系统，即使设置相同的分区键，不同生产者之间产生的消息也无法判定其先后顺序。 串行发送：生产者客户端支持多线程安全访问，但如果生产者使用多线程并行发送，则不同线程间产生的消息将无法判定其先后顺序。 满足以上条件的生产者，将顺序消息发送至服务端后，会保证设置了同一分区键的消息，按照发送顺序存储在同一队列中。服务端顺序存储逻辑如下： 模拟一个订单的发送流程，创建两个订单，发送的消息分别是 订单号111 消息流程 下订单-物流-签收 订单号112 消息流程 下订单-物流-拒收 @Test public void testOrderMessage() throws MQClientException // 创建默认的生产者 DefaultMQProducer producer = new DefaultMQProducer(TestProducerGroup); // 设置nameServer地址 producer.setNamesrvAddr(117.72.71.187:9876); // 启动实例 producer.start(); ListOrder orderList = Arrays.asList( new Order(1, 111, 59D, new Date(), 下订单), new Order(2, 111, 59D, new Date(), 物流), new Order(3, 111, 59D, new Date(), 签收), new Order(4, 112, 89D, new Date(), 下订单), new Order(5, 112, 89D, new Date(), 物流), new Order(6, 112, 89D, new Date(), 拒收) ); // 循环集合开始发送 orderList.forEach(order - Message message = new Message(TestTopic, TagOrder ,order.toString().getBytes()); try // 发送的时候 相同的订单号选择同一个队列 producer.send(message, new MessageQueueSelector() @Override public MessageQueue select(ListMessageQueue mqs, Message msg, Object arg) // 当前主题有多少个队列 int queueNumber = mqs.size(); // 这个arg就是后面传入的 order.getOrderNumber() Integer i = (Integer) arg; // 用这个值去%队列的个数得到一个队列 int index = i % queueNumber; // 返回选择的这个队列即可 ，那么相同的订单号 就会被放在相同的队列里 实现FIFO了 return mqs.get(index); , order.getOrderNumber()); catch (Exception e) System.out.println(发送异常); ); // 关闭实例 producer.shutdown(); 这里的区别主要是调用了SendResult send(Message msg, MessageQueueSelector selector, Object arg)方法，MessageQueueSelector 是队列选择器，arg 是一个 Java Object 对象，可以传入作为消息发送分区的分类标准。 MessageQueueSelector的接口如下： public interface MessageQueueSelector MessageQueue select(final ListMessageQueue mqs, final Message msg, final Object arg); 其中 mqs 是可以发送的队列，msg是消息，arg是上述send接口中传入的Object对象，返回的是该消息需要发送到的队列。上述例子里，是以orderNumber作为分区分类标准，对所有队列个数取余，来对将相同orderNumber的消息发送到同一个队列中。 生产环境中建议选择最细粒度的分区键进行拆分，例如，将订单ID、用户ID作为分区键关键字，可实现同一终端用户的消息按照顺序处理，不同用户的消息无需保证顺序。 如果一个Broker掉线，那么此时队列总数是否会发化？ 如果发生变化，那么同一个 ShardingKey 的消息就会发送到不同的队列上，造成乱序。如果不发生变化，那消息将会发送到掉线Broker的队列上，必然是失败的。因此 Apache RocketMQ 提供了两种模式，如果要保证严格顺序而不是可用性，创建 Topic 是要指定 -o 参数（–order）为true，表示顺序消息: $ sh bin/mqadmin updateTopic -c DefaultCluster -t TopicTest -o true -n 127.0.0.1:9876create topic to 127.0.0.1:10911 success.TopicConfig [topicName=TopicTest, readQueueNums=8, writeQueueNums=8, perm=RW-, topicFilterType=SINGLE_TAG, topicSysFlag=0, order=true, attributes=null] 其次要保证NameServer中的配置 orderMessageEnable 和 returnOrderTopicConfigToBroker 必须是 true。如果上述任意一个条件不满足，则是保证可用性而不是严格顺序。 4.3 延迟消息延迟消息发送是指消息发送到Apache RocketMQ后，并不期望立马投递这条消息，而是延迟一定时间后才投递到Consumer进行消费。 Apache RocketMQ 一共支持18个等级的延迟投递，具体时间如下： 投递等级（delay level） 延迟时间 投递等级（delay level） 延迟时间 1 1s 10 6min 2 5s 11 7min 3 10s 12 8min 4 30s 13 9min 5 1min 14 10min 6 2min 15 20min 7 3min 16 30min 8 4min 17 1h 9 5min 18 2h @Test public void testDelayMessage() throws Exception // 创建默认的生产者 DefaultMQProducer producer = new DefaultMQProducer(TestProducerGroup); // 设置nameServer地址 producer.setNamesrvAddr(117.72.71.187:9876); // 启动实例 producer.start(); Message msg = new Message(TestTopic, (延迟消息).getBytes()); // 给这个消息设定一个延迟等级 // messageDelayLevel = 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h msg.setDelayTimeLevel(3); // 发送单向消息 producer.send(msg); // 打印时间 System.out.println(new Date()); // 关闭实例 producer.shutdown(); 发送延迟消息 消费延迟消息 可以看到经过10s后才消费到消息 4.4 批量消息在对吞吐率有一定要求的情况下，Apache RocketMQ可以将一些消息聚成一批以后进行发送，可以增加吞吐率，并减少API和网络调用次数。 @Test public void testBatchMessage() throws Exception // 创建默认的生产者 DefaultMQProducer producer = new DefaultMQProducer(TestProducerGroup); // 设置nameServer地址 producer.setNamesrvAddr(117.72.71.187:9876); // 启动实例 producer.start(); ListMessage msgs = Arrays.asList( new Message(TestTopic, 我是一组消息的A消息.getBytes()), new Message(TestTopic, 我是一组消息的B消息.getBytes()), new Message(TestTopic, 我是一组消息的C消息.getBytes()) ); SendResult send = producer.send(msgs); System.out.println(send); // 关闭实例 producer.shutdown(); 这里调用非常简单，将消息打包成 CollectionMessage msgs 传入方法中即可，需要注意的是批量消息的大小不能超过 1MiB（否则需要自行分割），其次同一批 batch 中 topic 必须相同。 4.5 事务消息在一些对数据一致性有强需求的场景，可以用 Apache RocketMQ 事务消息来解决，从而保证上下游数据的一致性。 以电商交易场景为例，用户支付订单这一核心操作的同时会涉及到下游物流发货、积分变更、购物车状态清空等多个子系统的变更。当前业务的处理分支包括： 主分支订单系统状态更新：由未支付变更为支付成功。 物流系统状态新增：新增待发货物流记录，创建订单物流记录。 积分系统状态变更：变更用户积分，更新用户积分表。 购物车系统状态变更：清空购物车，更新用户购物车记录。 使用普通消息和订单事务无法保证一致的原因，本质上是由于普通消息无法像单机数据库事务一样，具备提交、回滚和统一协调的能力。 而基于 RocketMQ 的分布式事务消息功能，在普通消息基础上，支持二阶段的提交能力。将二阶段提交和本地事务绑定，实现全局提交结果的一致性。 事务消息发送分为两个阶段。第一阶段会发送一个半事务消息，半事务消息是指暂不能投递的消息，生产者已经成功地将消息发送到了 Broker，但是Broker 未收到生产者对该消息的二次确认，此时该消息被标记成“暂不能投递”状态，如果发送成功则执行本地事务，并根据本地事务执行成功与否，向 Broker 半事务消息状态（commit或者rollback），半事务消息只有 commit 状态才会真正向下游投递。 如果由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，Broker 端会通过扫描发现某条消息长期处于“半事务消息”时，需要主动向消息生产者询问该消息的最终状态（Commit或是Rollback）。 这样最终保证了本地事务执行成功，下游就能收到消息，本地事务执行失败，下游就收不到消息。总而保证了上下游数据的一致性。 整个事务消息的详细交互流程如下图所示： 事务消息发送步骤如下： 生产者将半事务消息发送至 RocketMQ Broker。 RocketMQ Broker 将消息持久化成功之后，向生产者返回 Ack 确认消息已经发送成功，此时消息暂不能投递，为半事务消息。 生产者开始执行本地事务逻辑。 生产者根据本地事务执行结果向服务端提交二次确认结果（Commit或是Rollback），服务端收到确认结果后处理逻辑如下： 二次确认结果为Commit：服务端将半事务消息标记为可投递，并投递给消费者。 二次确认结果为Rollback：服务端将回滚事务，不会将半事务消息投递给消费者。 在断网或者是生产者应用重启的特殊情况下，若服务端未收到发送者提交的二次确认结果，或服务端收到的二次确认结果为Unknown未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。 需要注意的是，服务端仅仅会按照参数尝试指定次数，超过次数后事务会强制回滚，因此未决事务的回查时效性非常关键，需要按照业务的实际风险来设置。 事务消息回查步骤如下： 7. 生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。 8. 生产者根据检查得到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行处理。 /** * TransactionalMessageCheckService的检测频率默认1分钟，可通过在broker.conf文件中设置transactionCheckInterval的值来改变默认值，单位为毫秒。 * 从broker配置文件中获取transactionTimeOut参数值。 * 从broker配置文件中获取transactionCheckMax参数值，表示事务的最大检测次数，如果超过检测次数，消息会默认为丢弃，即回滚消息。 * * @throws Exception */ @Test public void testTransactionProducer() throws Exception // 创建一个事务消息生产者 TransactionMQProducer producer = new TransactionMQProducer(TestProducerGroup); producer.setNamesrvAddr(117.72.71.187:9876); // 设置事务消息监听器 producer.setTransactionListener(new TransactionListener() // 这个是执行本地业务方法 @Override public LocalTransactionState executeLocalTransaction(Message msg, Object arg) System.out.println(new Date()); System.out.println(new String(msg.getBody())); // 这个可以使用try catch对业务代码进行性包裹 // COMMIT_MESSAGE 表示允许消费者消费该消息 // ROLLBACK_MESSAGE 表示该消息将被删除，不允许消费 // UNKNOW表示需要MQ回查才能确定状态 那么过一会 代码会走下面的checkLocalTransaction(msg)方法 return LocalTransactionState.UNKNOW; // 这里是回查方法 回查不是再次执行业务操作，而是确认上面的操作是否有结果 // 默认是1min回查 默认回查15次 超过次数则丢弃打印日志 可以通过参数设置 // transactionTimeOut 超时时间 // transactionCheckMax 最大回查次数 // transactionCheckInterval 回查间隔时间单位毫秒 // 触发条件 // 1.当上面执行本地事务返回结果UNKNOW时,或者下面的回查方法也返回UNKNOW时 会触发回查 // 2.当上面操作超过20s没有做出一个结果，也就是超时或者卡主了，也会进行回查 @Override public LocalTransactionState checkLocalTransaction(MessageExt msg) System.err.println(new Date()); System.err.println(new String(msg.getBody())); // 这里 return LocalTransactionState.UNKNOW; ); producer.start(); Message message = new Message(TestTopic2, 我是一个事务消息.getBytes()); // 发送消息 producer.sendMessageInTransaction(message, null); System.out.println(new Date()); System.in.read(); @Test public void testTransactionConsumer() throws Exception // 创建默认消费者组 DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(consumer-group); // 设置nameServer地址 consumer.setNamesrvAddr(117.72.71.187:9876); // 订阅一个主题来消费 *表示没有过滤参数 表示这个主题的任何消息 consumer.subscribe(TestTopic2, *); // 注册一个消费监听 MessageListenerConcurrently是并发消费 // 默认是20个线程一起消费，可以参看 consumer.setConsumeThreadMax() consumer.registerMessageListener(new MessageListenerConcurrently() @Override public ConsumeConcurrentlyStatus consumeMessage(ListMessageExt msgs, ConsumeConcurrentlyContext context) // 这里执行消费的代码 默认是多线程消费 System.out.println(Thread.currentThread().getName() + ---- + new String(msgs.get(0).getBody())); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; ); consumer.start(); System.in.read(); 可以看到当上面执行本地事务返回结果UNKNOW时，或者下面的回查方法也返回UNKNOW时会触发回查。 @Override public LocalTransactionState checkLocalTransaction(MessageExt msg) System.err.println(new Date()); System.err.println(new String(msg.getBody())); // 这里 return LocalTransactionState.COMMIT_MESSAGE; 当修改消息状态时消费者才能收到消息 事务消息的发送不再使用 DefaultMQProducer，而是使用 TransactionMQProducer 进行发送，会默认生成一个事务回查的线程池，最重要的是需要实现 TransactionListener 接口，并传入 TransactionMQProducer。 TransactionListener接口的定义如下： public interface TransactionListener /** * When send transactional prepare(half) message succeed, this method will be invoked to execute local transaction. * * @param msg Half(prepare) message * @param arg Custom business parameter * @return Transaction state */ LocalTransactionState executeLocalTransaction(final Message msg, final Object arg); /** * When no response to prepare(half) message. broker will send check message to check the transaction status, and this * method will be invoked to get local transaction status. * * @param msg Check message * @return Transaction state */ LocalTransactionState checkLocalTransaction(final MessageExt msg); executeLocalTransaction 是半事务消息发送成功后，执行本地事务的方法，具体执行完本地事务后，可以在该方法中返回以下三种状态： LocalTransactionState.COMMIT_MESSAGE：提交事务，允许消费者消费该消息 LocalTransactionState.ROLLBACK_MESSAGE：回滚事务，消息将被丢弃不允许消费。 LocalTransactionState.UNKNOW：暂时无法判断状态，等待固定时间以后Broker端根据回查规则向生产者进行消息回查。 checkLocalTransaction是由于二次确认消息没有收到，Broker端回查事务状态的方法。 回查规则：本地事务执行完成后，若Broker端收到的本地事务返回状态为LocalTransactionState.UNKNOW，或生产者应用退出导致本地事务未提交任何状态。则Broker端会向消息生产者发起事务回查，第一次回查后仍未获取到事务状态，则之后每隔一段时间会再次回查（默认间隔时间为1分钟）。 此外，需要注意的是事务消息的生产组名称 ProducerGroupName不能随意设置。事务消息有回查机制，回查时Broker端如果发现原始生产者已经崩溃，则会联系同一生产者组的其他生产者实例回查本地事务执行情况以Commit或Rollback半事务消息。 5. 消费者5.1 基础概念消息通过生产者发送到某一个Topic，如果需要订阅该Topic并消费里面的消息的话，就要创建对应的消费者进行消费。在介绍消费者的使用方法之前，我们先介绍消费组、消费位点、推和拉等概念。 5.1.1 消费者与消费组消息系统的重要作用之一是削峰填谷，但比如在电商大促的场景中，如果下游的消费者消费能力不足的话，大量的瞬时流量进入会后堆积在服务端。此时，消息的端到端延迟（从发送到被消费的时间）就会增加，对服务端而言，一直消费历史数据也会产生冷读。因此需要增加消费能力来解决这个问题，除了去优化消息消费的时间，最简单的方式就是扩容消费者。 但是否随意增加消费者就能提升消费能力？ 首先需要了解消费组的概念。在消费者中消费组的有非常重要的作用，如果多个消费者设置了相同的Consumer Group，我们认为这些消费者在同一个消费组内。 在 Apache RocketMQ 有两种消费模式，分别是： 集群消费模式：当使用集群消费模式时，RocketMQ 认为任意一条消息只需要被消费组内的任意一个消费者处理即可。 广播消费模式：当使用广播消费模式时，RocketMQ 会将每条消息推送给消费组所有的消费者，保证消息至少被每个消费者消费一次。 集群消费模式适用于每条消息只需要被处理一次的场景，也就是说整个消费组会Topic收到全量的消息，而消费组内的消费分担消费这些消息，因此可以通过扩缩消费者数量，来提升或降低消费能力，具体示例如下图所示，是最常见的消费方式。 广播消费模式适用于每条消息需要被消费组的每个消费者处理的场景，也就是说消费组内的每个消费者都会收到订阅Topic的全量消息，因此即使扩缩消费者数量也无法提升或降低消费能力，具体示例如下图所示。 5.1.2 负载均衡集群模式下，同一个消费组内的消费者会分担收到的全量消息，这里的分配策略是怎样的？如果扩容消费者是否一定能提升消费能力？ Apache RocketMQ 提供了多种集群模式下的分配策略，包括平均分配策略、机房优先分配策略、一致性hash分配策略等，可以通过如下代码进行设置相应负载均衡策略 consumer.setAllocateMessageQueueStrategy(new AllocateMessageQueueAveragely()); 默认的分配策略是平均分配，这也是最常见的策略。平均分配策略下消费组内的消费者会按照类似分页的策略均摊消费。 在平均分配的算法下，可以通过增加消费者的数量来提高消费的并行度。比如下图中，通过增加消费者来提高消费能力。 但也不是一味地增加消费者就能提升消费能力的，比如下图中Topic的总队列数小于消费者的数量时，消费者将分配不到队列，即使消费者再多也无法提升消费能力。 5.1.3 消费位点 如上图所示，在Apache RocketMQ中每个队列都会记录自己的最小位点、最大位点。针对于消费组，还有消费位点的概念，在集群模式下，消费位点是由客户端提给交服务端保存的，在广播模式下，消费位点是由客户端自己保存的。一般情况下消费位点正常更新，不会出现消息重复，但如果消费者发生崩溃或有新的消费者加入群组，就会触发重平衡，重平衡完成后，每个消费者可能会分配到新的队列，而不是之前处理的队列。为了能继续之前的工作，消费者需要读取每个队列最后一次的提交的消费位点，然后从消费位点处继续拉取消息。但在实际执行过程中，由于客户端提交给服务端的消费位点并不是实时的，所以重平衡就可能会导致消息少量重复。 5.1.4 推、拉和长轮询MQ的消费模式可以大致分为两种，一种是推Push，一种是拉Pull。 Push是服务端主动推送消息给客户端，优点是及时性较好，但如果客户端没有做好流控，一旦服务端推送大量消息到客户端时，就会导致客户端消息堆积甚至崩溃。 Pull是客户端需要主动到服务端取数据，优点是客户端可以依据自己的消费能力进行消费，但拉取的频率也需要用户自己控制，拉取频繁容易造成服务端和客户端的压力，拉取间隔长又容易造成消费不及时。 Apache RocketMQ既提供了Push模式也提供了Pull模式。 5.2 Push消费@Test public void testPushConsumer() throws MQClientException, IOException // 初始化consumer，并设置consumer group name DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(consumer-group); // 设置NameServer地址 consumer.setNamesrvAddr(117.72.71.187:9876); //订阅一个或多个topic，并指定tag过滤条件，这里指定*表示接收所有tag的消息 consumer.subscribe(TestTopic, *); //注册回调接口来处理从Broker中收到的消息 consumer.registerMessageListener(new MessageListenerConcurrently() @Override public ConsumeConcurrentlyStatus consumeMessage(ListMessageExt msgs, ConsumeConcurrentlyContext context) System.out.printf(%s Receive New Messages: %s %n, Thread.currentThread().getName(), msgs); // 返回消息消费状态，ConsumeConcurrentlyStatus.CONSUME_SUCCESS为消费成功 return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; ); // 启动Consumer consumer.start(); System.out.printf(Consumer Started.%n); System.in.read(); 首先需要初始化消费者，初始化消费者时，必须填写ConsumerGroupName，同一个消费组的ConsumerGroupName是相同的，这是判断消费者是否属于同一个消费组的重要属性。然后是设置NameServer地址，这里与Producer一样不再介绍。然后是调用subscribe方法订阅Topic，subscribe方法需要指定需要订阅的Topic名，也可以增加消息过滤的条件，比如TagA等，上述代码中指定[*]表示接收所有tag的消息。除了订阅之外，还需要注册回调接口编写消费逻辑来处理从Broker中收到的消息，调用registerMessageListener方法，需要传入MessageListener的实现，上述代码中是并发消费，因此是MessageListenerConcurrently的实现，其接口如下： /** * A MessageListenerConcurrently object is used to receive asynchronously delivered messages concurrently */public interface MessageListenerConcurrently extends MessageListener /** * It is not recommend to throw exception,rather than returning ConsumeConcurrentlyStatus.RECONSUME_LATER if * consumption failure * * @param msgs msgs.size() = 1br DefaultMQPushConsumer.consumeMessageBatchMaxSize=1,you can modify here * @return The consume status */ ConsumeConcurrentlyStatus consumeMessage(final ListMessageExt msgs, final ConsumeConcurrentlyContext context); 其中，msgs是从Broker端获取的需要被消费消息列表，用户实现该接口，并把自己对消息的消费逻辑写在consumeMessage方法中，然后返回消费状态，ConsumeConcurrentlyStatus.CONSUME_SUCCESS表示消费成功，或者表示RECONSUME_LATER表示消费失败，一段时间后再重新消费。 5.3 集群模式和广播模式我们可以通过以下代码来设置采用集群模式，RocketMQ Push Consumer默认为集群模式，同一个消费组内的消费者分担消费。 consumer.setMessageModel(MessageModel.CLUSTERING); 通过以下代码来设置采用广播模式，广播模式下，消费组内的每一个消费者都会消费全量消息。 consumer.setMessageModel(MessageModel.BROADCASTING); 5.4 顺序消费上面已经介绍设置Push Consumer并发消费的方法，通过在注册消费回调接口时传入MessageListenerConcurrently接口的实现来完成。在并发消费中，可能会有多个线程同时消费一个队列的消息，因此即使发送端通过发送顺序消息保证消息在同一个队列中按照FIFO的顺序，也无法保证消息实际被顺序消费。因此RocketMQ提供了顺序消费的方式， 顺序消费设置与并发消费API层面只有一处不同，在注册消费回调接口时传入MessageListenerOrderly接口的实现。 @Test public void testPushOrderConsumer() throws MQClientException, IOException // 初始化consumer，并设置consumer group name DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(consumer-group); // 设置NameServer地址 consumer.setNamesrvAddr(117.72.71.187:9876); consumer.setMessageModel(MessageModel.BROADCASTING); //订阅一个或多个topic，并指定tag过滤条件，这里指定*表示接收所有tag的消息 consumer.subscribe(TestTopic, *); //注册回调接口来处理从Broker中收到的消息 AtomicLong consumeTimes = new AtomicLong(0); consumer.registerMessageListener(new MessageListenerOrderly() @Override public ConsumeOrderlyStatus consumeMessage(ListMessageExt msgs, ConsumeOrderlyContext context) System.out.printf(%s Receive New Messages: %s %n, Thread.currentThread().getName(), msgs); consumeTimes.incrementAndGet(); if ((consumeTimes.get() % 2) == 0) return ConsumeOrderlyStatus.SUCCESS; else if ((consumeTimes.get() % 5) == 0) context.setSuspendCurrentQueueTimeMillis(3000); return ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT; return ConsumeOrderlyStatus.SUCCESS; ); // 启动Consumer consumer.start(); System.out.printf(Consumer Started.%n); System.in.read(); 顺序消费也有两种返回结果，ConsumeOrderlyStatus.SUCCESS表示消费成功，ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT表示消费失败。 修改Topic队列数为1 @Test public void testAsyncMessage() throws MQClientException, MQBrokerException, RemotingException, InterruptedException // 初始化一个producer并设置Producer group name DefaultMQProducer producer = new DefaultMQProducer(TestProducerGroup); // 设置NameServer地址 producer.setNamesrvAddr(117.72.71.187:9876); // 启动producer producer.start(); producer.setRetryTimesWhenSendAsyncFailed(0); int messageCount = 10; final CountDownLatch countDownLatch = new CountDownLatch(messageCount); for (int i = 0; i messageCount; i++) try final int index = i; // 创建一条消息，并指定topic、tag、body等信息，tag可以理解成标签，对消息进行再归类，RocketMQ可以在消费端对tag进行过滤 Message msg = new Message(TestTopic, TagAsync, (i + ).getBytes(RemotingHelper.DEFAULT_CHARSET)); // 异步发送消息, 发送结果通过callback返回给客户端 producer.send(msg, new SendCallback() @Override public void onSuccess(SendResult sendResult) System.out.printf(%-10d OK %s %n, index, sendResult.getMsgId()); countDownLatch.countDown(); @Override public void onException(Throwable e) System.out.printf(%-10d Exception %s %n, index, e); e.printStackTrace(); countDownLatch.countDown(); ); catch (Exception e) e.printStackTrace(); countDownLatch.countDown(); // 异步发送，如果要求可靠传输，必须要等回调接口返回明确结果后才能结束逻辑，否则立即关闭Producer可能导致部分消息尚未传输成功 countDownLatch.await(5, TimeUnit.SECONDS); // 一旦producer不再使用，关闭producer producer.shutdown(); 发送10条消息，并发消费 可以看到消息消费时消息顺序和发送顺序不一致。 顺序消费 可以看到消息消费时消息顺序和发送顺序一致。 5.5 消息过滤消息过滤是指消息生产者向Topic中发送消息时，设置消息属性对消息进行分类，消费者订阅Topic时，根据消息属性设置过滤条件对消息进行过滤，只有符合过滤条件的消息才会被投递到消费端进行消费。 消费者订阅Topic时若未设置过滤条件，无论消息发送时是否有设置过滤属性，Topic中的所有消息都将被投递到消费端进行消费。 RocketMQ支持的消息过滤方式有两种，Tag过滤和SQL92过滤。 过滤方式 说明 场景 Tag过滤 消费者订阅的Tag和发送者设置的消息Tag相互匹配，则消息被投递给消费端进行消费。 简单过滤场景。一条消息支持设置一个Tag，仅需要对Topic中的消息进行一级分类并过滤时可以使用此方式。 SQL92过滤 发送者设置Tag或消息属性，消费者订阅满足SQL92过滤表达式的消息被投递给消费端进行消费。 复杂过滤场景。一条消息支持设置多个属性，可根据SQL语法自定义组合多种类型的表达式对消息进行多级分类并实现多维度的过滤。 Tag过滤 Tag在生产者章节已经介绍过，用于对某个Topic下的消息进行分类。生产者在发送消息时，指定消息的Tag，消费者需根据已经指定的Tag来进行订阅。 以下图电商交易场景为例，从客户下单到收到商品这一过程会生产一系列消息，以如下消息为例： 订单消息 支付消息 物流消息 这些消息会发送到名称为Trade_Topic的Topic中，被各个不同的系统所订阅，以如下系统为例： 支付系统：只需订阅支付消息。 物流系统：只需订阅物流消息。 实时计算系统：需要订阅所有和交易相关的消息。 交易成功率分析系统：需订阅订单和支付消息。 过滤示意图如下所示 对于物流系统和支付系统来说，它们都只订阅单个Tag，此时只需要在调用subcribe接口时明确标明Tag即可。 consumer.subscribe(TagFilterTest, TagA); 对于实时计算系统来说，它订阅交易Topic下所有的消息，Tag用星号（*）表示即可。 consumer.subscribe(TagFilterTest, *); 对于交易成功率分析系统来说，它订阅了订单和支付两个Tag的消息，在多个Tag之间用两个竖线（||）分隔即可。 consumer.subscribe(TagFilterTest, TagA||TagB); 这里需要注意的是，如果同一个消费者多次订阅某个Topic下的Tag，以最后一次订阅为准。 //如下错误代码中，Consumer只能订阅到TagFilterTest下TagB的消息，而不能订阅TagA的消息。consumer.subscribe(TagFilterTest, TagA);consumer.subscribe(TagFilterTest, TagB); SQL92过滤 SQL92过滤是在消息发送时设置消息的Tag或自定义属性，消费者订阅时使用SQL语法设置过滤表达式，根据自定义属性或Tag过滤消息。 Tag属于一种特殊的消息属性，在SQL语法中，Tag的属性值为TAGS。 开启属性过滤首先要在Broker端设置配置enablePropertyFiltertrue，该值默认为false。 以下图电商交易场景为例，从客户下单到收到商品这一过程会生产一系列消息，按照类型将消息分为订单消息和物流消息，其中给物流消息定义地域属性，按照地域分为杭州和上海： 订单消息 物流消息 物流消息且地域为杭州 物流消息且地域为上海 这些消息会发送到名称为Trade_Topic的Topic中，被各个不同的系统所订阅，以如下系统为例： 物流系统1：只需订阅物流消息且消息地域为杭州。 物流系统2：只需订阅物流消息且消息地域为杭州或上海。 订单跟踪系统：只需订阅订单消息。 SQL92过滤示意图如下所示： 地域将作为自定义属性设置在消息中。 消息发送端： 设置消息的自定义属性。 Message msg = new Message(topic, tagA, Hello MQ.getBytes());// 设置自定义属性A，属性值为1。msg.putUserProperties(a, 1); 消息消费端： 使用SQL语法设置过滤表达式，并根据自定义属性过滤消息。 consumer.subscribe(SqlFilterTest, MessageSelector.bySql((TAGS is not null and TAGS in (TagA, TagB)) + and (a is not null and a between 0 and 3))); 5.6 消息重试和死信队列消息重试 若Consumer消费某条消息失败，则RocketMQ会在重试间隔时间后，将消息重新投递给Consumer消费，若达到最大重试次数后消息还没有成功被消费，则消息将被投递至死信队列。 消息重试只针对集群消费模式生效；广播消费模式不提供失败重试特性，即消费失败后，失败消息不再重试，继续消费新的消息 最大重试次数：消息消费失败后，可被重复投递的最大次数。 consumer.setMaxReconsumeTimes(10); 重试间隔：消息消费失败后再次被投递给Consumer消费的间隔时间，只在顺序消费中起作用。 consumer.setSuspendCurrentQueueTimeMillis(5000); 顺序消费和并发消费的重试机制并不相同，顺序消费消费失败后会先在客户端本地重试直到最大重试次数，这样可以避免消费失败的消息被跳过，消费下一条消息而打乱顺序消费的顺序，而并发消费消费失败后会将消费失败的消息重新投递回服务端，再等待服务端重新投递回来，在这期间会正常消费队列后面的消息。 并发消费失败后并不是投递回原Topic，而是投递到一个特殊Topic，其命名为%RETRY%ConsumerGroupName，集群模式下并发消费每一个ConsumerGroup会对应一个特殊Topic，并会订阅该Topic。 @Test public void testRetryQueueConsumer() throws MQClientException, IOException // 初始化consumer，并设置consumer group name DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(consumer-group); // 设置NameServer地址 consumer.setNamesrvAddr(117.72.71.187:9876); // 订阅一个或多个topic，并指定tag过滤条件，这里指定*表示接收所有tag的消息 consumer.subscribe(TestTopic, *); // 设置最大重试次数 consumer.setMaxReconsumeTimes(1); // 注册回调接口来处理从Broker中收到的消息 consumer.registerMessageListener(new MessageListenerConcurrently() @Override public ConsumeConcurrentlyStatus consumeMessage(ListMessageExt msgs, ConsumeConcurrentlyContext context) System.out.printf(%s Receive New Messages: %s %n, Thread.currentThread().getName(), msgs); return ConsumeConcurrentlyStatus.RECONSUME_LATER; ); // 启动Consumer consumer.start(); System.out.printf(Consumer Started.%n); System.in.read(); 可以看到消费失败时，会将消息传递到【%RETRY%ConsumerGroupName】Topic中 两者参数差别如下: 消费类型 重试间隔 最大重试次数 顺序消费 间隔时间可通过自定义设置，SuspendCurrentQueueTimeMillis 最大重试次数可通过自定义参数MaxReconsumeTimes取值进行配置。该参数取值无最大限制。若未设置参数值，默认最大重试次数为Integer.MAX 并发消费 间隔时间根据重试次数阶梯变化，取值范围：1秒～2小时。不支持自定义配置 最大重试次数可通过自定义参数MaxReconsumeTimes取值进行配置。默认值为16次，该参数取值无最大限制，建议使用默认值 并发消费重试间隔如下，可以看到与延迟消息第三个等级开始的时间完全一致。 第几次重试 与上次重试的间隔时间 第几次重试 与上次重试的间隔时间 1 10s 9 7min 2 30s 10 8min 3 1min 11 9min 4 2min 12 10min 5 3min 13 20min 6 4min 14 30min 7 5min 15 1h 8 6min 16 2h 死信队列 当一条消息初次消费失败，RocketMQ会自动进行消息重试，达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息。此时，该消息不会立刻被丢弃，而是将其发送到该消费者对应的特殊队列中，这类消息称为死信消息（Dead-Letter Message），存储死信消息的特殊队列称为死信队列（Dead-Letter Queue），死信队列是死信Topic下分区数唯一的单独队列。如果产生了死信消息，那对应的ConsumerGroup的死信Topic名称为%DLQ%ConsumerGroupName，死信队列的消息将不会再被消费。可以利用RocketMQ Admin工具或者RocketMQ Dashboard上查询到对应死信消息的信息。 @Test public void testDeadQueueConsumer() throws MQClientException, IOException // 初始化consumer，并设置consumer group name DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(consumer-group); // 设置NameServer地址 consumer.setNamesrvAddr(117.72.71.187:9876); //订阅一个或多个topic，并指定tag过滤条件，这里指定*表示接收所有tag的消息 consumer.subscribe(TestTopic, *); consumer.setMaxReconsumeTimes(0); //注册回调接口来处理从Broker中收到的消息 consumer.registerMessageListener(new MessageListenerOrderly() @Override public ConsumeOrderlyStatus consumeMessage(ListMessageExt msgs, ConsumeOrderlyContext context) System.out.printf(%s Receive New Messages: %s %n, Thread.currentThread().getName(), msgs); return ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT; ); // 启动Consumer consumer.start(); System.out.printf(Consumer Started.%n); System.in.read(); 可以看到达到最大重试次数后，消费依然失败会将消息传递到【%DLQ%ConsumerGroupName】Topic中。 5.7 Pull消费在RocketMQ中有两种Pull方式，一种是比较原始Pull Consumer，它不提供相关的订阅方法，需要调用pull方法时指定队列进行拉取，并需要自己更新位点。另一种是Lite Pull Consumer，它提供了Subscribe和Assign两种方式，使用起来更加方便。","tags":[null],"categories":[null]}]