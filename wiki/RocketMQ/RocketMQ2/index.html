
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.33.1" theme-name="Stellar" theme-version="1.33.1">
  
  
  <meta name="generator" content="Hexo 7.3.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  <meta name="theme-color" content="#f9fafb">
  <title>RocketMQ：RocketMQ基础概念 - Lianyutian</title>

  
    <meta name="description" content="🥧本文介绍了RocketMQ的基础概念">
<meta property="og:type" content="website">
<meta property="og:title" content="RocketMQ基础概念">
<meta property="og:url" content="http://example.com/wiki/RocketMQ/RocketMQ2/">
<meta property="og:site_name" content="Lianyutian">
<meta property="og:description" content="🥧本文介绍了RocketMQ的基础概念">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/assets/20240507174529.png">
<meta property="article:published_time" content="2025-08-29T09:51:59.909Z">
<meta property="article:modified_time" content="2025-08-29T09:51:59.909Z">
<meta property="article:author" content="lianyutian">
<meta property="article:tag" content="RocketMQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/assets/20240507174529.png">
  
  
  
  <meta name="keywords" content="">

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="Lianyutian" type="application/atom+xml">
  

  <link rel="stylesheet" href="/css/main.css?v=1.33.1">


  
    <link rel="shortcut icon" href="/assets/20240507174529.png">
  

  

  <script type="application/ld+json">{"@context":"https://schema.org","@type":"Website","@id":"http://example.com/wiki/RocketMQ/RocketMQ2/","author":{"@type":"Person","name":"lianyutian","sameAs":[],"image":"/assets/20240507174529.png"},"name":"RocketMQ基础概念","description":"🥧本文介绍了RocketMQ的基础概念","url":"http://example.com/wiki/RocketMQ/RocketMQ2/"}</script>
  
</head>
<body>



<div class="l_body content" id="start" layout="page" type="tech" ><aside class="l_left"><div class="sidebg"></div><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><div class="icon"><img no-lazy class="icon" src="/assets/wiki/RocketMQ/apache_rocketmq-ar21.svg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></div><a class="title" href="/wiki/RocketMQ/RocketMQ1"><div class="main">RocketMQ</div><div class="sub cap">RocketMQ介绍</div></a></div></header>

<div class="nav-area">

<nav class="menu dis-select"><a class="nav-item" title="文章" href="/" style="color:#1e6150"><span>文章</span></a><a class="nav-item active" title="wiki" href="/wiki/" style="color:#1e6150"><span>wiki</span></a></nav>
</div>
<div class="widgets">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" data-filter="/wiki/MyRocketMQSQL/" placeholder="在 RocketMQ 中搜索..."></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<widget class="widget-wrapper doc-tree post-list"><div class="widget-header dis-select"><span class="name">快速安装</span></div><div class="widget-body fs14"><a class="link" href="/wiki/RocketMQ/RocketMQ1/#start"><span class="toc-text">RocketMQ快速安装</span></a></div><div class="widget-header dis-select"><span class="name">基本概念</span></div><div class="widget-body fs14"><a class="link active" href="/wiki/RocketMQ/RocketMQ2/"><span class="toc-text">RocketMQ基础概念</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" id="menu" href="/wiki/">文档</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/wiki/RocketMQ/RocketMQ1/">RocketMQ</a></div>
<div class="flex-row" id="post-meta"><span class="text created">更新于：<time datetime="2025-08-29T09:51:59.909Z">2025-08-29</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>RocketMQ基础概念</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h3 id="1-RocketMQ基础消息模型"><a href="#1-RocketMQ基础消息模型" class="headerlink" title="1. RocketMQ基础消息模型"></a>1. RocketMQ基础消息模型</h3><p><img src="https://rocketmq.apache.org/zh/assets/images/RocketMQ%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B-db2c246ff6aa79016f880e2ca7a447e7.png" alt="RocketMQ概念模型"></p>
<p>上图就是一个基本的消息系统模型，包括<strong>生产者 (Producer)<strong>，</strong>消费者 (Consumer)<strong>，中间进行基于</strong>消息主题（Topic）</strong>的消息传送。</p>
<h3 id="2-RocketMQ扩展模型"><a href="#2-RocketMQ扩展模型" class="headerlink" title="2. RocketMQ扩展模型"></a>2. RocketMQ扩展模型</h3><p>在<strong>基于主题</strong>的系统中，消息被发布到主题或命名通道上。消费者将收到其订阅主题上的所有消息，生产者负责定义订阅者所订阅的消息类别。这是一个基础的概念模型，而在实际的应用中，结构会更复杂。例如为了<strong>支持高并发和水平扩展</strong>，中间的消息主题需要进行<strong>分区</strong>，同一个Topic会有多个生产者，同一个信息会有多个消费者，消费者之间要进行负载均衡等。</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/RocketMQ%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B-ebcf3458d04b36f47f4c9633c1e36bf7.png" alt="RocketMQ基本模型"></p>
<blockquote>
<p>上图就是一个扩展后的消息模型，包括<strong>两个生产者</strong>，<strong>两个消息Topic</strong>，以及<strong>两组消费者 Comsumer</strong>。</p>
<p>存储消息Topic的 <strong>代理服务器</strong>( <strong>Broker</strong> )，是实际部署过程对应的代理服务器。</p>
</blockquote>
<ul>
<li>为了消息写入能力的<strong>水平扩展</strong>，RocketMQ 对 Topic进行了分区，这种操作被称为<strong>队列</strong>（MessageQueue）。</li>
<li>为了消费能力的<strong>水平扩展</strong>，ConsumerGroup的概念应运而生。</li>
</ul>
<blockquote>
<p>相同的ConsumerGroup下的消费者主要有两种负载均衡模式，即<strong>广播模式</strong>，和<strong>集群模式</strong>（图中是最常用的集群模式）。</p>
<p>在集群模式下，同一个 ConsumerGroup 中的 Consumer 实例是负载均衡消费，如图中 ConsumerGroupA 订阅 TopicA，TopicA 对应 3个队列，则 GroupA 中的 Consumer1 消费的是 MessageQueue 0和 MessageQueue 1的消息，Consumer2是消费的是MessageQueue2的消息。</p>
<p>在广播模式下，同一个 ConsumerGroup 中的每个 Consumer 实例都处理全部的队列。需要注意的是，广播模式下因为每个 Consumer 实例都需要处理全部的消息，因此这种模式仅推荐在通知推送、配置同步类小流量场景使用。</p>
</blockquote>
<h3 id="3-生产者"><a href="#3-生产者" class="headerlink" title="3. 生产者"></a>3. 生产者</h3><h4 id="3-1-消息"><a href="#3-1-消息" class="headerlink" title="3.1 消息"></a>3.1 消息</h4><p>RocketMQ 消息构成非常简单，如下图所示。</p>
<ul>
<li><strong>topic</strong>，表示要发送的消息的主题。</li>
<li><strong>body</strong> 表示消息的存储内容</li>
<li><strong>properties</strong> 表示消息属性</li>
<li><strong>transactionId</strong> 会在事务消息中使用。</li>
</ul>
<p>Message 可以设置的属性值包括：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>默认值</th>
<th>必要性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Topic</td>
<td>null</td>
<td>必填</td>
<td>消息所属 topic 的名称</td>
</tr>
<tr>
<td>Body</td>
<td>null</td>
<td>必填</td>
<td>消息体</td>
</tr>
<tr>
<td>Tags</td>
<td>null</td>
<td>选填</td>
<td>消息标签，方便服务器过滤使用。目前只支持每个消息设置一个</td>
</tr>
<tr>
<td>Keys</td>
<td>null</td>
<td>选填</td>
<td>代表这条消息的业务关键词</td>
</tr>
<tr>
<td>Flag</td>
<td>0</td>
<td>选填</td>
<td>完全由应用来设置，RocketMQ 不做干预</td>
</tr>
<tr>
<td>DelayTimeLevel</td>
<td>0</td>
<td>选填</td>
<td>消息延时级别，0 表示不延时，大于 0 会延时特定的时间才会被消费</td>
</tr>
<tr>
<td>WaitStoreMsgOK</td>
<td>true</td>
<td>选填</td>
<td>表示消息是否在服务器落盘后才返回应答。</td>
</tr>
</tbody></table>
<blockquote>
<p>Tag: 不管是 RocketMQ 的 Tag 过滤还是延迟消息等都会利用 Properties 消息属性机制，这些特殊信息使用了系统保留的属性Key，设置自定义属性时需要避免和系统属性Key冲突。</p>
<p>Keys: 服务器会根据 keys 创建哈希索引，设置后，可以在 Console 系统根据 Topic、Keys 来查询消息，由于是哈希索引，请尽可能保证 key 唯一，例如订单号，商品 Id 等。</p>
</blockquote>
<h4 id="3-2-Tag"><a href="#3-2-Tag" class="headerlink" title="3.2 Tag"></a>3.2 Tag</h4><p>Topic 与 Tag 都是业务上用来归类的标识，区别在于 Topic 是一级分类，而 Tag 可以理解为是二级分类。使用 Tag 可以实现对 Topic 中的消息进行过滤。</p>
<blockquote>
<p>Topic：消息主题，通过 Topic 对不同的业务消息进行分类。</p>
<p>Tag：消息标签，用来进一步区分某个 Topic 下的消息分类，消息从生产者发出即带上的属性。</p>
</blockquote>
<p><strong>什么时候该用 Topic，什么时候该用 Tag？</strong></p>
<p>可以从以下几个方面进行判断：</p>
<ul>
<li>消息类型是否一致：如普通消息、事务消息、定时（延时）消息、顺序消息，不同的消息类型使用不同的 Topic，无法通过 Tag 进行区分。</li>
<li>业务是否相关联：没有直接关联的消息，如淘宝交易消息，京东物流消息使用不同的 Topic 进行区分；而同样是天猫交易消息，电器类订单、女装类订单、化妆品类订单的消息可以用 Tag 进行区分。</li>
<li>消息优先级是否一致：如同样是物流消息，盒马必须小时内送达，天猫超市 24 小时内送达，淘宝物流则相对会慢一些，不同优先级的消息用不同的 Topic 进行区分。</li>
<li>消息量级是否相当：有些业务消息虽然量小但是实时性要求高，如果跟某些万亿量级的消息使用同一个 Topic，则有可能会因为过长的等待时间而“饿死”，此时需要将不同量级的消息进行拆分，使用不同的 Topic。</li>
</ul>
<p>总的来说，针对消息分类，您可以选择创建多个 Topic，或者在同一个 Topic 下创建多个 Tag。但通常情况下，不同的 Topic 之间的消息没有必然的联系，而 Tag 则用来区分同一个 Topic 下相互关联的消息，例如全集和子集的关系、流程先后的关系。</p>
<h4 id="3-3-Keys"><a href="#3-3-Keys" class="headerlink" title="3.3 Keys"></a>3.3 Keys</h4><p>Apache RocketMQ 每个消息可以在业务层面的设置<strong>唯一标识码 keys 字段</strong>，方便将来<strong>定位消息丢失问题</strong>。 Broker 端会为每个消息创建索引（哈希索引），应用可以通过 topic、key 来查询这条消息内容，以及消息被谁消费。由于是哈希索引，请务必保证 key 尽可能唯一，这样可以避免潜在的哈希冲突。</p>
<h4 id="3-4-队列"><a href="#3-4-队列" class="headerlink" title="3.4 队列"></a>3.4 队列</h4><p>为了支持高并发和水平扩展，需要对 Topic 进行分区，在 RocketMQ 中这被称为<strong>队列</strong>，一个 Topic 可能有多个队列，并且可能分布在不同的 Broker 上。</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/MessageQueue-fb79728bdee77764e50382620552495d.png" alt="MessageQueue"></p>
<p>一般来说一条消息，如果没有重复发送（比如因为服务端没有响应而进行重试），则只会存在在 Topic 的其中一个队列中，消息在队列中按照先进先出的原则存储，每条消息会有自己的位点，<strong>每个队列会统计当前消息的总条数</strong>，这个称为最大位点 MaxOffset；队列的起始位置对应的位置叫做起始位点 MinOffset。队列可以提升消息发送和消费的并发度。</p>
<h4 id="3-5-生产者"><a href="#3-5-生产者" class="headerlink" title="3.5 生产者"></a>3.5 生产者</h4><p>生产者（Producer）就是消息的发送者，Apache RocketMQ 拥有丰富的消息类型，可以支持不同的应用场景。</p>
<p>需要注意的是，生产环境中不同消息类型需要使用不同的主题，<strong>不要在同一个主题内使用多种消息类型</strong>，这样可以避免运维过程中的风险和错误。</p>
<h3 id="4-消息生产及消费"><a href="#4-消息生产及消费" class="headerlink" title="4. 消息生产及消费"></a>4. 消息生产及消费</h3><h4 id="4-1-普通消息"><a href="#4-1-普通消息" class="headerlink" title="4.1 普通消息"></a>4.1 普通消息</h4><p>Apache RocketMQ可用于以三种方式发送消息：<strong>同步、异步和单向传输</strong>。前两种消息类型是可靠的，因为无论它们是否成功发送都有响应。</p>
<h5 id="4-1-1-同步消息"><a href="#4-1-1-同步消息" class="headerlink" title="4.1.1 同步消息"></a>4.1.1 同步消息</h5><p>同步发送是最常用的方式，是指消息发送方发出一条消息后，会在<strong>收到服务端同步响应之后</strong>才发下一条消息的通讯方式，可靠的同步传输被广泛应用于各种场景，如重要的通知消息、短消息通知等。</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/%E5%90%8C%E6%AD%A5%E5%8F%91%E9%80%81-6a8c78dae434afe4fbd970a2836f740c.png" alt="同步发送"></p>
<p>同步发送的整个代码流程如下：</p>
<ol>
<li><strong>首先会创建一个producer</strong>。普通消息可以创建 DefaultMQProducer，创建时需要填写生产组的名称，生产者组是指同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。</li>
<li><strong>设置 NameServer 的地址</strong>。Apache RocketMQ很多方式设置NameServer地址(客户端配置中有介绍)，这里是在代码中调用producer的API setNamesrvAddr进行设置，如果有多个NameServer，中间以分号隔开，比如”127.0.0.2:9876;127.0.0.3:9876”。</li>
<li><strong>第三步是构建消息</strong>。指定topic、tag、body等信息，tag可以理解成标签，对消息进行再归类，RocketMQ可以在消费端对tag进行过滤。</li>
<li><strong>最后调用send接口将消息发送出去</strong>。同步发送等待结果最后返回SendResult，SendResult包含实际发送状态还包括SEND_OK（发送成功）, FLUSH_DISK_TIMEOUT（刷盘超时）, FLUSH_SLAVE_TIMEOUT（同步到备超时）, SLAVE_NOT_AVAILABLE（备不可用），如果发送失败会抛出异常。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2024-05-24 09:12:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRocketMQ</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProducer</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException, MQBrokerException, RemotingException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1.创建消息生产者producer，并制定生产者组名</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;TestProducerGroup&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.指定Nameserver地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;117.72.71.187:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.启动producer</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="comment">// 4.创建消息对象，指定主题Topic、Tag和消息体等</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;TestTopic&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello RocketMQ&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="string">&quot;TesTag&quot;</span>;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(topic, tag, msg.getBytes());</span><br><span class="line">        <span class="comment">// 5.发送消息</span></span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.send(message);</span><br><span class="line">        System.out.println(send);</span><br><span class="line">        <span class="comment">// 6.关闭生产者producer</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>同步发送方式请务必捕获发送异常，并做业务侧失败兜底逻辑，如果忽略异常则可能会导致消息未成功发送的情况。</p>
</blockquote>
<p>发送成功显示</p>
<p><img src="https://raw.githubusercontent.com/lianyutian/tuchuang1/main/img/mysql20240524172402.png"></p>
<p>在仪表板可以看到生产的消息</p>
<p><img src="https://raw.githubusercontent.com/lianyutian/tuchuang1/main/img/mysql20240524172508.png"></p>
<p><strong>消息消费</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConsumer</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException, IOException &#123;</span><br><span class="line">       <span class="comment">// 实例化消费者</span></span><br><span class="line">       <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;TestConsumerGroup&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 设置NameServer的地址</span></span><br><span class="line">       consumer.setNamesrvAddr(<span class="string">&quot;117.72.71.187:9876&quot;</span>);</span><br><span class="line">       <span class="comment">// 订阅一个或者多个Topic，以及Tag来过滤需要消费的消息</span></span><br><span class="line">       consumer.subscribe(<span class="string">&quot;TestTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">       <span class="comment">// 注册回调实现类来处理从broker拉取回来的消息</span></span><br><span class="line">       consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -&gt; &#123;</span><br><span class="line">           System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs.toString());</span><br><span class="line">           <span class="comment">// 标记该消息已经被成功消费</span></span><br><span class="line">           <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="comment">// 启动消费者实例</span></span><br><span class="line">       consumer.start();</span><br><span class="line">       <span class="comment">// 等待消息接收</span></span><br><span class="line">       System.in.read();</span><br><span class="line">       System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在仪表板中可以看到对应的消费者组及消费详情</p>
<p><img src="https://raw.githubusercontent.com/lianyutian/tuchuang1/main/img/mysql20240524174800.png"></p>
<p><img src="C:\Users\lm\AppData\Roaming\Typora\typora-user-images\image-20240524174954669.png" alt="image-20240524174954669"></p>
<h5 id="4-1-2-异步消息"><a href="#4-1-2-异步消息" class="headerlink" title="4.1.2 异步消息"></a>4.1.2 异步消息</h5><p>异步发送是指发送方发出一条消息后，不等服务端返回响应，接着发送下一条消息的通讯方式。</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81-c05e8e1111d99d8b8b4626e419e9f8e5.png" alt="同步发送"></p>
<blockquote>
<p>异步发送需要实现<strong>异步发送回调接口</strong>（SendCallback）。</p>
</blockquote>
<p>消息发送方在发送了一条消息后，不需要等待服务端响应即可发送第二条消息，发送方通过回调接口接收服务端响应，并处理响应结果。异步发送一般用于链路耗时较长，对响应时间较为敏感的业务场景。例如，视频上传后通知启动转码服务，转码完成后通知推送转码结果等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAsyncMessage</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException, MQBrokerException, RemotingException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 初始化一个producer并设置Producer group name</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;TestProducerGroup&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置NameServer地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;117.72.71.187:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动producer</span></span><br><span class="line">        producer.start();</span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">messageCount</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(messageCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; messageCount; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="comment">// 创建一条消息，并指定topic、tag、body等信息，tag可以理解成标签，对消息进行再归类，RocketMQ可以在消费端对tag进行过滤</span></span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TestTopic&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;TagAsync&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;Hello world&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                <span class="comment">// 异步发送消息, 发送结果通过callback返回给客户端</span></span><br><span class="line">                producer.send(msg, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;%-10d OK %s %n&quot;</span>, index, sendResult.getMsgId());</span><br><span class="line">                        countDownLatch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;%-10d Exception %s %n&quot;</span>, index, e);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        countDownLatch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//异步发送，如果要求可靠传输，必须要等回调接口返回明确结果后才能结束逻辑，否则立即关闭Producer可能导致部分消息尚未传输成功</span></span><br><span class="line">        countDownLatch.await(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 一旦producer不再使用，关闭producer</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>异步发送与同步发送代码唯一区别在于调用send接口的参数不同，异步发送不会等待发送返回，取而代之的是send方法需要传入 SendCallback 的实现，SendCallback 接口主要有onSuccess 和 onException 两个方法，表示消息发送成功和消息发送失败。</p>
</blockquote>
<h5 id="4-1-3-单项模式"><a href="#4-1-3-单项模式" class="headerlink" title="4.1.3 单项模式"></a>4.1.3 单项模式</h5><p><img src="https://rocketmq.apache.org/zh/assets/images/Oneway%E5%8F%91%E9%80%81-bc1379bd3b8f382c23ff7abac1e0ed95.png" alt="同步发送"></p>
<p>发送方只负责发送消息，不等待服务端返回响应且没有回调函数触发，即只发送请求不等待应答。此方式发送消息的过程耗时非常短，一般在微秒级别。适用于某些耗时非常短，但对可靠性要求并不高的场景，例如日志收集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testOnewaySend</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException, UnsupportedEncodingException, RemotingException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 初始化一个producer并设置Producer group name</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;TestProducerGroup&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置NameServer地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;117.72.71.187:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动producer</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建一条消息，并指定topic、tag、body等信息，tag可以理解成标签，对消息进行再归类，RocketMQ可以在消费端对tag进行过滤</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TestTopic&quot;</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                    <span class="string">&quot;TagOneway&quot;</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                    (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">// 由于在oneway方式发送消息时没有请求应答处理，如果出现消息发送失败，则会因为没有重试而导致数据丢失。</span></span><br><span class="line">            <span class="comment">// 若数据不可丢，建议选用可靠同步或可靠异步发送方式。</span></span><br><span class="line">            producer.sendOneway(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一旦producer不再使用，关闭producer</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-2-顺序消息"><a href="#4-2-顺序消息" class="headerlink" title="4.2 顺序消息"></a>4.2 顺序消息</h4><p>顺序消息是一种对消息发送和消费顺序有严格要求的消息。</p>
<p>对于一个指定的Topic，消息严格按照先进先出（FIFO）的原则进行消息发布和消费，即先发布的消息先消费，后发布的消息后消费。在 Apache RocketMQ 中支持分区顺序消息。我们可以按照某一个标准对消息进行分区（订单ID），同一个订单ID的消息会被分配到同一个队列中，并按照顺序被消费。</p>
<p>需要注意的是 RocketMQ 消息的顺序性分为两部分，生产顺序性和消费顺序性。只有<strong>同时满足了生产顺序性和消费顺序性</strong>才能达到上述的FIFO效果。</p>
<p><strong>生产顺序性：</strong> RocketMQ 通过生产者和服务端的协议保障单个生产者串行地发送消息，并按序存储和持久化。如需保证消息生产的顺序性，则必须满足以下条件：</p>
<ul>
<li>单一生产者： 消息生产的顺序性仅支持单一生产者，不同生产者分布在不同的系统，即使设置相同的分区键，不同生产者之间产生的消息也无法判定其先后顺序。</li>
<li>串行发送：生产者客户端支持多线程安全访问，但如果生产者使用多线程并行发送，则不同线程间产生的消息将无法判定其先后顺序。</li>
</ul>
<p>满足以上条件的生产者，将顺序消息发送至服务端后，会保证设置了同一分区键的消息，按照发送顺序存储在同一队列中。服务端顺序存储逻辑如下：</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81-a80d08ef7dacd4e936c3f6992a1369e5.png" alt="顺序消息发送"></p>
<p>模拟一个订单的发送流程，创建两个订单，发送的消息分别是</p>
<ul>
<li><p>订单号111 消息流程 下订单-&gt;物流-&gt;签收</p>
</li>
<li><p>订单号112 消息流程 下订单-&gt;物流-&gt;拒收</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testOrderMessage</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">        <span class="comment">// 创建默认的生产者</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;TestProducerGroup&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置nameServer地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;117.72.71.187:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">        List&lt;Order&gt; orderList = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Order</span>(<span class="number">1</span>, <span class="number">111</span>, <span class="number">59D</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&quot;下订单&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Order</span>(<span class="number">2</span>, <span class="number">111</span>, <span class="number">59D</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&quot;物流&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Order</span>(<span class="number">3</span>, <span class="number">111</span>, <span class="number">59D</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&quot;签收&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Order</span>(<span class="number">4</span>, <span class="number">112</span>, <span class="number">89D</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&quot;下订单&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Order</span>(<span class="number">5</span>, <span class="number">112</span>, <span class="number">89D</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&quot;物流&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Order</span>(<span class="number">6</span>, <span class="number">112</span>, <span class="number">89D</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&quot;拒收&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 循环集合开始发送</span></span><br><span class="line">        orderList.forEach(order -&gt; &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TestTopic&quot;</span>, <span class="string">&quot;TagOrder&quot;</span> ,order.toString().getBytes());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 发送的时候 相同的订单号选择同一个队列</span></span><br><span class="line">                producer.send(message, <span class="keyword">new</span> <span class="title class_">MessageQueueSelector</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> MessageQueue <span class="title function_">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> &#123;</span><br><span class="line">                        <span class="comment">// 当前主题有多少个队列</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">queueNumber</span> <span class="operator">=</span> mqs.size();</span><br><span class="line">                        <span class="comment">// 这个arg就是后面传入的 order.getOrderNumber()</span></span><br><span class="line">                        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> (Integer) arg;</span><br><span class="line">                        <span class="comment">// 用这个值去%队列的个数得到一个队列</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i % queueNumber;</span><br><span class="line">                        <span class="comment">// 返回选择的这个队列即可 ，那么相同的订单号 就会被放在相同的队列里 实现FIFO了</span></span><br><span class="line">                        <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, order.getOrderNumber());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;发送异常&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 关闭实例</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的区别主要是调用了<code>SendResult send(Message msg, MessageQueueSelector selector, Object arg)</code>方法，MessageQueueSelector 是队列选择器，arg 是一个 Java Object 对象，可以传入作为消息发送分区的分类标准。</p>
<blockquote>
<p>MessageQueueSelector的接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageQueueSelector</span> &#123;</span><br><span class="line">    MessageQueue <span class="title function_">select</span><span class="params">(<span class="keyword">final</span> List&lt;MessageQueue&gt; mqs, <span class="keyword">final</span> Message msg, <span class="keyword">final</span> Object arg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中 mqs 是可以发送的队列，msg是消息，arg是上述send接口中传入的Object对象，返回的是该消息需要发送到的队列。上述例子里，是以orderNumber作为分区分类标准，对所有队列个数取余，来对将相同orderNumber的消息发送到同一个队列中。</p>
<p>生产环境中建议选择最细粒度的分区键进行拆分，例如，将订单ID、用户ID作为分区键关键字，可实现同一终端用户的消息按照顺序处理，不同用户的消息无需保证顺序。</p>
</blockquote>
<p><strong>如果一个Broker掉线，那么此时队列总数是否会发化？</strong></p>
<p>如果发生变化，那么同一个 ShardingKey 的消息就会发送到不同的队列上，造成乱序。如果不发生变化，那消息将会发送到掉线Broker的队列上，必然是失败的。因此 Apache RocketMQ 提供了两种模式，如果要保证严格顺序而不是可用性，创建 Topic 是要指定 <code>-o</code> 参数（–order）为true，表示顺序消息:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh bin/mqadmin updateTopic -c DefaultCluster -t TopicTest -o <span class="literal">true</span> -n 127.0.0.1:9876</span></span><br><span class="line"></span><br><span class="line">create topic to 127.0.0.1:10911 success.</span><br><span class="line">TopicConfig [topicName=TopicTest, readQueueNums=8, writeQueueNums=8, perm=RW-, topicFilterType=SINGLE_TAG, topicSysFlag=0, order=true, attributes=null]</span><br></pre></td></tr></table></figure>

<p>其次要保证NameServer中的配置 <code>orderMessageEnable</code> 和 <code>returnOrderTopicConfigToBroker</code> 必须是 true。如果上述任意一个条件不满足，则是保证可用性而不是严格顺序。</p>
<h4 id="4-3-延迟消息"><a href="#4-3-延迟消息" class="headerlink" title="4.3 延迟消息"></a>4.3 延迟消息</h4><p>延迟消息发送是指消息发送到Apache RocketMQ后，并不期望立马投递这条消息，而是延迟一定时间后才投递到Consumer进行消费。</p>
<p>Apache RocketMQ 一共支持18个等级的延迟投递，具体时间如下：</p>
<table>
<thead>
<tr>
<th>投递等级（delay level）</th>
<th>延迟时间</th>
<th>投递等级（delay level）</th>
<th>延迟时间</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1s</td>
<td>10</td>
<td>6min</td>
</tr>
<tr>
<td>2</td>
<td>5s</td>
<td>11</td>
<td>7min</td>
</tr>
<tr>
<td>3</td>
<td>10s</td>
<td>12</td>
<td>8min</td>
</tr>
<tr>
<td>4</td>
<td>30s</td>
<td>13</td>
<td>9min</td>
</tr>
<tr>
<td>5</td>
<td>1min</td>
<td>14</td>
<td>10min</td>
</tr>
<tr>
<td>6</td>
<td>2min</td>
<td>15</td>
<td>20min</td>
</tr>
<tr>
<td>7</td>
<td>3min</td>
<td>16</td>
<td>30min</td>
</tr>
<tr>
<td>8</td>
<td>4min</td>
<td>17</td>
<td>1h</td>
</tr>
<tr>
<td>9</td>
<td>5min</td>
<td>18</td>
<td>2h</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelayMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建默认的生产者</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;TestProducerGroup&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置nameServer地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;117.72.71.187:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TestTopic&quot;</span>, (<span class="string">&quot;延迟消息&quot;</span>).getBytes());</span><br><span class="line">        <span class="comment">// 给这个消息设定一个延迟等级</span></span><br><span class="line">        <span class="comment">// messageDelayLevel = &quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span></span><br><span class="line">        msg.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 发送单向消息</span></span><br><span class="line">        producer.send(msg);</span><br><span class="line">        <span class="comment">// 打印时间</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">// 关闭实例</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>发送延迟消息</p>
<p><img src="https://raw.githubusercontent.com/lianyutian/tuchuang1/main/img/mysql20240527135422.png"></p>
<p>消费延迟消息</p>
<p><img src="https://raw.githubusercontent.com/lianyutian/tuchuang1/main/img/mysql20240527135450.png"></p>
<p>可以看到经过10s后才消费到消息</p>
<h4 id="4-4-批量消息"><a href="#4-4-批量消息" class="headerlink" title="4.4 批量消息"></a>4.4 批量消息</h4><p>在对吞吐率有一定要求的情况下，Apache RocketMQ可以将一些消息聚成一批以后进行发送，可以增加吞吐率，并减少API和网络调用次数。</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/batch-241308ac9ed97b3a1fbf0e5e6417f74d.png" alt="batch"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBatchMessage</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="comment">// 创建默认的生产者</span></span><br><span class="line">      <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;TestProducerGroup&quot;</span>);</span><br><span class="line">      <span class="comment">// 设置nameServer地址</span></span><br><span class="line">      producer.setNamesrvAddr(<span class="string">&quot;117.72.71.187:9876&quot;</span>);</span><br><span class="line">      <span class="comment">// 启动实例</span></span><br><span class="line">      producer.start();</span><br><span class="line">      List&lt;Message&gt; msgs = Arrays.asList(</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TestTopic&quot;</span>, <span class="string">&quot;我是一组消息的A消息&quot;</span>.getBytes()),</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TestTopic&quot;</span>, <span class="string">&quot;我是一组消息的B消息&quot;</span>.getBytes()),</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TestTopic&quot;</span>, <span class="string">&quot;我是一组消息的C消息&quot;</span>.getBytes())</span><br><span class="line">      );</span><br><span class="line">      <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.send(msgs);</span><br><span class="line">      System.out.println(send);</span><br><span class="line">      <span class="comment">// 关闭实例</span></span><br><span class="line">      producer.shutdown();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里调用非常简单，将消息打包成 <code>Collection&lt;Message&gt; msgs</code> 传入方法中即可，需要注意的是批量消息的大小不能超过 1MiB（否则需要自行分割），其次同一批 batch 中 topic 必须相同。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/lianyutian/tuchuang1/main/img/mysql20240527140044.png"></p>
<h4 id="4-5-事务消息"><a href="#4-5-事务消息" class="headerlink" title="4.5 事务消息"></a>4.5 事务消息</h4><p>在一些对数据一致性有强需求的场景，可以用 Apache RocketMQ 事务消息来解决，从而保证上下游数据的一致性。</p>
<p>以电商交易场景为例，用户支付订单这一核心操作的同时会涉及到下游物流发货、积分变更、购物车状态清空等多个子系统的变更。当前业务的处理分支包括：</p>
<ul>
<li>主分支订单系统状态更新：由未支付变更为支付成功。</li>
<li>物流系统状态新增：新增待发货物流记录，创建订单物流记录。</li>
<li>积分系统状态变更：变更用户积分，更新用户积分表。</li>
<li>购物车系统状态变更：清空购物车，更新用户购物车记录。</li>
</ul>
<p>使用普通消息和订单事务无法保证一致的原因，本质上是由于普通消息无法像单机数据库事务一样，具备提交、回滚和统一协调的能力。 而基于 RocketMQ 的分布式事务消息功能，在普通消息基础上，支持二阶段的提交能力。将二阶段提交和本地事务绑定，实现全局提交结果的一致性。</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF1-15b51f54e4cb4280459be1df277c288e.png" alt="事务消息1"></p>
<p>事务消息发送分为两个阶段。第一阶段会发送一个<strong>半事务消息</strong>，半事务消息是指暂不能投递的消息，生产者已经成功地将消息发送到了 Broker，但是Broker 未收到生产者对该消息的二次确认，此时该消息被标记成“暂不能投递”状态，如果发送成功则执行本地事务，并根据本地事务执行成功与否，向 Broker 半事务消息状态（commit或者rollback），半事务消息只有 commit 状态才会真正向下游投递。</p>
<p>如果由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，Broker 端会通过扫描发现某条消息长期处于“半事务消息”时，需要主动向消息生产者询问该消息的最终状态（Commit或是Rollback）。</p>
<p>这样最终保证了本地事务执行成功，下游就能收到消息，本地事务执行失败，下游就收不到消息。总而保证了上下游数据的一致性。</p>
<p>整个事务消息的详细交互流程如下图所示：</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF2-2673a99678f13a471b8fc0bd4ab3bf3a.png" alt="事务消息2"></p>
<p>事务消息<strong>发送</strong>步骤如下：</p>
<ol>
<li>生产者将半事务消息发送至 <code>RocketMQ Broker</code>。</li>
<li><code>RocketMQ Broker</code> 将消息持久化成功之后，向生产者返回 Ack 确认消息已经发送成功，此时消息暂不能投递，为半事务消息。</li>
<li>生产者开始执行本地事务逻辑。</li>
<li>生产者根据本地事务执行结果向服务端提交二次确认结果（Commit或是Rollback），服务端收到确认结果后处理逻辑如下：</li>
</ol>
<ul>
<li>二次确认结果为Commit：服务端将半事务消息标记为可投递，并投递给消费者。</li>
<li>二次确认结果为Rollback：服务端将回滚事务，不会将半事务消息投递给消费者。</li>
</ul>
<ol>
<li>在断网或者是生产者应用重启的特殊情况下，若服务端未收到发送者提交的二次确认结果，或服务端收到的二次确认结果为Unknown未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。</li>
<li>需要注意的是，服务端仅仅会按照参数尝试指定次数，超过次数后事务会强制回滚，因此未决事务的回查时效性非常关键，需要按照业务的实际风险来设置。</li>
</ol>
<p>事务消息<strong>回查</strong>步骤如下： 7. 生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。 8. 生产者根据检查得到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行处理。</p>
<p><img src="https://raw.githubusercontent.com/lianyutian/tuchuang1/main/img/mysql20240527142559.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * TransactionalMessageCheckService的检测频率默认1分钟，可通过在broker.conf文件中设置transactionCheckInterval的值来改变默认值，单位为毫秒。</span></span><br><span class="line"><span class="comment">    * 从broker配置文件中获取transactionTimeOut参数值。</span></span><br><span class="line"><span class="comment">    * 从broker配置文件中获取transactionCheckMax参数值，表示事务的最大检测次数，如果超过检测次数，消息会默认为丢弃，即回滚消息。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransactionProducer</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">// 创建一个事务消息生产者</span></span><br><span class="line">       <span class="type">TransactionMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionMQProducer</span>(<span class="string">&quot;TestProducerGroup&quot;</span>);</span><br><span class="line">       producer.setNamesrvAddr(<span class="string">&quot;117.72.71.187:9876&quot;</span>);</span><br><span class="line">       <span class="comment">// 设置事务消息监听器</span></span><br><span class="line">       producer.setTransactionListener(<span class="keyword">new</span> <span class="title class_">TransactionListener</span>() &#123;</span><br><span class="line">           <span class="comment">// 这个是执行本地业务方法</span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> &#123;</span><br><span class="line">               System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">               System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">               <span class="comment">// 这个可以使用try catch对业务代码进行性包裹</span></span><br><span class="line">               <span class="comment">// COMMIT_MESSAGE 表示允许消费者消费该消息</span></span><br><span class="line">               <span class="comment">// ROLLBACK_MESSAGE 表示该消息将被删除，不允许消费</span></span><br><span class="line">               <span class="comment">// UNKNOW表示需要MQ回查才能确定状态 那么过一会 代码会走下面的checkLocalTransaction(msg)方法</span></span><br><span class="line">               <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 这里是回查方法 回查不是再次执行业务操作，而是确认上面的操作是否有结果</span></span><br><span class="line">           <span class="comment">// 默认是1min回查 默认回查15次 超过次数则丢弃打印日志 可以通过参数设置</span></span><br><span class="line">           <span class="comment">// transactionTimeOut 超时时间</span></span><br><span class="line">           <span class="comment">// transactionCheckMax 最大回查次数</span></span><br><span class="line">           <span class="comment">// transactionCheckInterval 回查间隔时间单位毫秒</span></span><br><span class="line">           <span class="comment">// 触发条件</span></span><br><span class="line">           <span class="comment">// 1.当上面执行本地事务返回结果UNKNOW时,或者下面的回查方法也返回UNKNOW时 会触发回查</span></span><br><span class="line">           <span class="comment">// 2.当上面操作超过20s没有做出一个结果，也就是超时或者卡主了，也会进行回查</span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> LocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> &#123;</span><br><span class="line">               System.err.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">               System.err.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">               <span class="comment">// 这里</span></span><br><span class="line">               <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       producer.start();</span><br><span class="line">       <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TestTopic2&quot;</span>, <span class="string">&quot;我是一个事务消息&quot;</span>.getBytes());</span><br><span class="line">       <span class="comment">// 发送消息</span></span><br><span class="line">       producer.sendMessageInTransaction(message, <span class="literal">null</span>);</span><br><span class="line">       System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">       System.in.read();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransactionConsumer</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">// 创建默认消费者组</span></span><br><span class="line">       <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;consumer-group&quot;</span>);</span><br><span class="line">       <span class="comment">// 设置nameServer地址</span></span><br><span class="line">       consumer.setNamesrvAddr(<span class="string">&quot;117.72.71.187:9876&quot;</span>);</span><br><span class="line">       <span class="comment">// 订阅一个主题来消费   *表示没有过滤参数 表示这个主题的任何消息</span></span><br><span class="line">       consumer.subscribe(<span class="string">&quot;TestTopic2&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">       <span class="comment">// 注册一个消费监听 MessageListenerConcurrently是并发消费</span></span><br><span class="line">       <span class="comment">// 默认是20个线程一起消费，可以参看 consumer.setConsumeThreadMax()</span></span><br><span class="line">       consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span><br><span class="line"><span class="params">                                                           ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">               <span class="comment">// 这里执行消费的代码 默认是多线程消费</span></span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(msgs.get(<span class="number">0</span>).getBody()));</span><br><span class="line">               <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       consumer.start();</span><br><span class="line">       System.in.read();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lianyutian/tuchuang1/main/img/mysql20240527143639.png"></p>
<p>可以看到当上面执行本地事务返回结果UNKNOW时，或者下面的回查方法也返回UNKNOW时会触发回查。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> LocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> &#123;</span><br><span class="line">                System.err.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                System.err.println(<span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                <span class="comment">// 这里</span></span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>当修改消息状态时消费者才能收到消息</p>
<p><img src="https://raw.githubusercontent.com/lianyutian/tuchuang1/main/img/mysql20240527144107.png"></p>
<p>事务消息的发送不再使用 DefaultMQProducer，而是使用 <code>TransactionMQProducer</code> 进行发送，会默认生成一个事务回查的线程池，最重要的是需要实现 <code>TransactionListener</code> 接口，并传入 <code>TransactionMQProducer</code>。</p>
<blockquote>
<p>TransactionListener接口的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionListener</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When send transactional prepare(half) message succeed, this method will be invoked to execute local transaction.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg Half(prepare) message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg Custom business parameter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Transaction state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> Object arg)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When no response to prepare(half) message. broker will send check message to check the transaction status, and this</span></span><br><span class="line"><span class="comment">     * method will be invoked to get local transaction status.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg Check message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Transaction state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    LocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(<span class="keyword">final</span> MessageExt msg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>executeLocalTransaction</code> 是半事务消息发送成功后，执行本地事务的方法，具体执行完本地事务后，可以在该方法中返回以下三种状态：</p>
<ul>
<li><code>LocalTransactionState.COMMIT_MESSAGE</code>：提交事务，允许消费者消费该消息</li>
<li><code>LocalTransactionState.ROLLBACK_MESSAGE</code>：回滚事务，消息将被丢弃不允许消费。</li>
<li><code>LocalTransactionState.UNKNOW</code>：暂时无法判断状态，等待固定时间以后Broker端根据回查规则向生产者进行消息回查。</li>
</ul>
<p><code>checkLocalTransaction</code>是由于二次确认消息没有收到，Broker端回查事务状态的方法。</p>
<p>回查规则：本地事务执行完成后，若Broker端收到的本地事务返回状态为LocalTransactionState.UNKNOW，或生产者应用退出导致本地事务未提交任何状态。则Broker端会向消息生产者发起事务回查，第一次回查后仍未获取到事务状态，则之后每隔一段时间会再次回查（默认间隔时间为1分钟）。</p>
<blockquote>
<p>此外，需要注意的是事务消息的生产组名称 ProducerGroupName不能随意设置。事务消息有回查机制，回查时Broker端如果发现原始生产者已经崩溃，则会联系同一生产者组的其他生产者实例回查本地事务执行情况以Commit或Rollback半事务消息。</p>
</blockquote>
<h3 id="5-消费者"><a href="#5-消费者" class="headerlink" title="5. 消费者"></a>5. 消费者</h3><h4 id="5-1-基础概念"><a href="#5-1-基础概念" class="headerlink" title="5.1 基础概念"></a>5.1 基础概念</h4><p>消息通过生产者发送到某一个Topic，如果需要订阅该Topic并消费里面的消息的话，就要创建对应的消费者进行消费。在介绍消费者的使用方法之前，我们先介绍<strong>消费组</strong>、<strong>消费位点</strong>、<strong>推和拉</strong>等概念。</p>
<h5 id="5-1-1-消费者与消费组"><a href="#5-1-1-消费者与消费组" class="headerlink" title="5.1.1 消费者与消费组"></a>5.1.1 消费者与消费组</h5><p>消息系统的重要作用之一是削峰填谷，但比如在电商大促的场景中，如果下游的消费者消费能力不足的话，大量的瞬时流量进入会后堆积在服务端。此时，消息的端到端延迟（从发送到被消费的时间）就会增加，对服务端而言，一直消费历史数据也会产生冷读。因此需要增加消费能力来解决这个问题，除了去优化消息消费的时间，最简单的方式就是扩容消费者。</p>
<p>但是否随意增加消费者就能提升消费能力？ 首先需要了解消费组的概念。在消费者中消费组的有非常重要的作用，如果多个消费者设置了相同的Consumer Group，我们认为这些消费者在同一个消费组内。</p>
<p>在 Apache RocketMQ 有两种消费模式，分别是：</p>
<ul>
<li>集群消费模式：当使用集群消费模式时，RocketMQ 认为任意一条消息只需要被消费组内的任意一个消费者处理即可。</li>
<li>广播消费模式：当使用广播消费模式时，RocketMQ 会将每条消息推送给消费组所有的消费者，保证消息至少被每个消费者消费一次。</li>
</ul>
<p>集群消费模式适用于每条消息只需要被处理一次的场景，也就是说整个消费组会Topic收到全量的消息，而消费组内的消费分担消费这些消息，因此可以通过扩缩消费者数量，来提升或降低消费能力，具体示例如下图所示，是最常见的消费方式。</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/%E9%9B%86%E7%BE%A4%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F-7f4462d200247db35ca90bb67df7c9b1.png" alt="集群消费模式"></p>
<p>广播消费模式适用于<strong>每条消息需要被消费组的每个消费者处理</strong>的场景，也就是说消费组内的每个消费者都会收到订阅Topic的全量消息，因此即使扩缩消费者数量也无法提升或降低消费能力，具体示例如下图所示。</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/%E5%B9%BF%E6%92%AD%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F-59abf13c1dfde37423a4b9ac552dc1f3.png" alt="广播消费模式"></p>
<h5 id="5-1-2-负载均衡"><a href="#5-1-2-负载均衡" class="headerlink" title="5.1.2 负载均衡"></a>5.1.2 负载均衡</h5><p>集群模式下，同一个消费组内的消费者会分担收到的全量消息，这里的分配策略是怎样的？如果扩容消费者是否一定能提升消费能力？</p>
<p>Apache RocketMQ 提供了多种集群模式下的分配策略，包括平均分配策略、机房优先分配策略、一致性hash分配策略等，可以通过如下代码进行设置相应负载均衡策略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.setAllocateMessageQueueStrategy(<span class="keyword">new</span> <span class="title class_">AllocateMessageQueueAveragely</span>());</span><br></pre></td></tr></table></figure>

<p>默认的分配策略是平均分配，这也是最常见的策略。平均分配策略下消费组内的消费者会按照类似分页的策略均摊消费。</p>
<p>在平均分配的算法下，可以通过增加消费者的数量来提高消费的并行度。比如下图中，通过增加消费者来提高消费能力。</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/%E6%B6%88%E8%B4%B9%E8%80%85%E6%89%A9%E5%AE%B91-2409cbfb4077f47f2e473b18eb78656b.jpeg" alt="消费者扩容1"></p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/%E6%B6%88%E8%B4%B9%E8%80%85%E6%89%A9%E5%AE%B92-7d9c1d1dd8caea665a4a74b91f017560.jpeg" alt="消费者扩容2"></p>
<p>但也不是一味地增加消费者就能提升消费能力的，比如下图中Topic的总队列数小于消费者的数量时，消费者将分配不到队列，即使消费者再多也无法提升消费能力。</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/%E6%B6%88%E8%B4%B9%E8%80%85%E6%89%A9%E5%AE%B93-65293ca6c2a01bf0a186821ba3432417.jpeg" alt="消费者扩容3"></p>
<h5 id="5-1-3-消费位点"><a href="#5-1-3-消费位点" class="headerlink" title="5.1.3 消费位点"></a>5.1.3 消费位点</h5><p><img src="https://raw.githubusercontent.com/lianyutian/tuchuang1/main/img/mysql20240527145552.png"></p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/%E6%B6%88%E8%B4%B9%E4%BD%8D%E7%82%B9-3b0320b183d4318d6b75e3504027e436.png" alt="消费位点"></p>
<p>如上图所示，在Apache RocketMQ中每个队列都会记录自己的最小位点、最大位点。针对于消费组，还有消费位点的概念，<strong>在集群模式下，消费位点是由客户端提给交服务端保存的，在广播模式下，消费位点是由客户端自己保存的</strong>。一般情况下消费位点正常更新，不会出现消息重复，但如果消费者发生崩溃或有新的消费者加入群组，就会触发重平衡，重平衡完成后，每个消费者可能会分配到新的队列，而不是之前处理的队列。为了能继续之前的工作，消费者需要读取每个队列最后一次的提交的消费位点，然后从消费位点处继续拉取消息。但在实际执行过程中，由于客户端提交给服务端的消费位点并不是实时的，所以重平衡就可能会导致消息少量重复。</p>
<h5 id="5-1-4-推、拉和长轮询"><a href="#5-1-4-推、拉和长轮询" class="headerlink" title="5.1.4 推、拉和长轮询"></a>5.1.4 推、拉和长轮询</h5><p>MQ的消费模式可以大致分为两种，一种是推Push，一种是拉Pull。</p>
<ul>
<li>Push是服务端主动推送消息给客户端，优点是及时性较好，但如果客户端没有做好流控，一旦服务端推送大量消息到客户端时，就会导致客户端消息堆积甚至崩溃。</li>
<li>Pull是客户端需要主动到服务端取数据，优点是客户端可以依据自己的消费能力进行消费，但拉取的频率也需要用户自己控制，拉取频繁容易造成服务端和客户端的压力，拉取间隔长又容易造成消费不及时。</li>
</ul>
<p>Apache RocketMQ既提供了Push模式也提供了Pull模式。</p>
<h4 id="5-2-Push消费"><a href="#5-2-Push消费" class="headerlink" title="5.2 Push消费"></a>5.2 Push消费</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPushConsumer</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException, IOException &#123;</span><br><span class="line">        <span class="comment">// 初始化consumer，并设置consumer group name</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;consumer-group&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置NameServer地址</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;117.72.71.187:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//订阅一个或多个topic，并指定tag过滤条件，这里指定*表示接收所有tag的消息</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TestTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">//注册回调接口来处理从Broker中收到的消息</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">                <span class="comment">// 返回消息消费状态，ConsumeConcurrentlyStatus.CONSUME_SUCCESS为消费成功</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动Consumer</span></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先需要初始化消费者，初始化消费者时，必须填写ConsumerGroupName，同一个消费组的ConsumerGroupName是相同的，这是判断消费者是否属于同一个消费组的重要属性。然后是设置NameServer地址，这里与Producer一样不再介绍。然后是调用subscribe方法订阅Topic，subscribe方法需要指定需要订阅的Topic名，也可以增加消息过滤的条件，比如TagA等，上述代码中指定[*]表示接收所有tag的消息。除了订阅之外，还需要注册回调接口编写消费逻辑来处理从Broker中收到的消息，调用registerMessageListener方法，需要传入MessageListener的实现，<strong>上述代码中是并发消费，因此是MessageListenerConcurrently的实现</strong>，其接口如下：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A MessageListenerConcurrently object is used to receive asynchronously delivered messages    concurrently</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageListenerConcurrently</span> <span class="keyword">extends</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * It is not recommend to throw exception,rather than returning ConsumeConcurrentlyStatus.RECONSUME_LATER if</span></span><br><span class="line"><span class="comment">     * consumption failure</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msgs msgs.size() &gt;= 1&lt;br&gt; DefaultMQPushConsumer.consumeMessageBatchMaxSize=1,you can modify here</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The consume status</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> ConsumeConcurrentlyContext context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>其中，msgs是从Broker端获取的需要被消费消息列表，用户实现该接口，并把自己对消息的消费逻辑写在consumeMessage方法中，然后返回消费状态，ConsumeConcurrentlyStatus.CONSUME_SUCCESS表示消费成功，或者表示RECONSUME_LATER表示消费失败，一段时间后再重新消费。</p>
<h4 id="5-3-集群模式和广播模式"><a href="#5-3-集群模式和广播模式" class="headerlink" title="5.3 集群模式和广播模式"></a>5.3 集群模式和广播模式</h4><p>我们可以通过以下代码来设置采用集群模式，RocketMQ Push Consumer默认为集群模式，同一个消费组内的消费者分担消费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.setMessageModel(MessageModel.CLUSTERING);</span><br></pre></td></tr></table></figure>

<p>通过以下代码来设置采用广播模式，广播模式下，消费组内的每一个消费者都会消费全量消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.setMessageModel(MessageModel.BROADCASTING);</span><br></pre></td></tr></table></figure>



<h4 id="5-4-顺序消费"><a href="#5-4-顺序消费" class="headerlink" title="5.4 顺序消费"></a>5.4 顺序消费</h4><p>上面已经介绍设置Push Consumer并发消费的方法，通过在注册消费回调接口时传入MessageListenerConcurrently接口的实现来完成。在并发消费中，可能会有多个线程同时消费一个队列的消息，因此即使发送端通过发送顺序消息保证消息在同一个队列中按照FIFO的顺序，也无法保证消息实际被顺序消费。因此RocketMQ提供了顺序消费的方式， 顺序消费设置与并发消费API层面只有一处不同，在注册消费回调接口时传入MessageListenerOrderly接口的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPushOrderConsumer</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException, IOException &#123;</span><br><span class="line">       <span class="comment">// 初始化consumer，并设置consumer group name</span></span><br><span class="line">       <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;consumer-group&quot;</span>);</span><br><span class="line">       <span class="comment">// 设置NameServer地址</span></span><br><span class="line">       consumer.setNamesrvAddr(<span class="string">&quot;117.72.71.187:9876&quot;</span>);</span><br><span class="line">       consumer.setMessageModel(MessageModel.BROADCASTING);</span><br><span class="line">       <span class="comment">//订阅一个或多个topic，并指定tag过滤条件，这里指定*表示接收所有tag的消息</span></span><br><span class="line">       consumer.subscribe(<span class="string">&quot;TestTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">       <span class="comment">//注册回调接口来处理从Broker中收到的消息</span></span><br><span class="line">       <span class="type">AtomicLong</span> <span class="variable">consumeTimes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">       consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerOrderly</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span> <span class="keyword">public</span> ConsumeOrderlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;</span><br><span class="line">               System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">               consumeTimes.incrementAndGet();</span><br><span class="line">               <span class="keyword">if</span> ((consumeTimes.get() % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((consumeTimes.get() % <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                   context.setSuspendCurrentQueueTimeMillis(<span class="number">3000</span>);</span><br><span class="line">                   <span class="keyword">return</span> ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="comment">// 启动Consumer</span></span><br><span class="line">       consumer.start();</span><br><span class="line">       System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">       System.in.read();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>顺序消费也有两种返回结果，ConsumeOrderlyStatus.SUCCESS表示消费成功，ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT表示消费失败。</p>
<p>修改Topic队列数为1</p>
<p><img src="https://raw.githubusercontent.com/lianyutian/tuchuang1/main/img/mysql20240528164852.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAsyncMessage</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException, MQBrokerException, RemotingException, InterruptedException &#123;</span><br><span class="line">       <span class="comment">// 初始化一个producer并设置Producer group name</span></span><br><span class="line">       <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;TestProducerGroup&quot;</span>);</span><br><span class="line">       <span class="comment">// 设置NameServer地址</span></span><br><span class="line">       producer.setNamesrvAddr(<span class="string">&quot;117.72.71.187:9876&quot;</span>);</span><br><span class="line">       <span class="comment">// 启动producer</span></span><br><span class="line">       producer.start();</span><br><span class="line">       producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">       <span class="type">int</span> <span class="variable">messageCount</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(messageCount);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; messageCount; i++) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">               <span class="comment">// 创建一条消息，并指定topic、tag、body等信息，tag可以理解成标签，对消息进行再归类，RocketMQ可以在消费端对tag进行过滤</span></span><br><span class="line">               <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TestTopic&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;TagAsync&quot;</span>,</span><br><span class="line">                       (i + <span class="string">&quot;&quot;</span>).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">               <span class="comment">// 异步发送消息, 发送结果通过callback返回给客户端</span></span><br><span class="line">               producer.send(msg, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                       System.out.printf(<span class="string">&quot;%-10d OK %s %n&quot;</span>, index, sendResult.getMsgId());</span><br><span class="line">                       countDownLatch.countDown();</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                       System.out.printf(<span class="string">&quot;%-10d Exception %s %n&quot;</span>, index, e);</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                       countDownLatch.countDown();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">               countDownLatch.countDown();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 异步发送，如果要求可靠传输，必须要等回调接口返回明确结果后才能结束逻辑，否则立即关闭Producer可能导致部分消息尚未传输成功</span></span><br><span class="line">       countDownLatch.await(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">       <span class="comment">// 一旦producer不再使用，关闭producer</span></span><br><span class="line">       producer.shutdown();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>发送10条消息，并发消费</p>
<p><img src="C:\Users\lm\AppData\Roaming\Typora\typora-user-images\image-20240528170123206.png" alt="image-20240528170123206"></p>
<p>可以看到消息消费时消息顺序和发送顺序不一致。</p>
<p>顺序消费</p>
<p><img src="https://raw.githubusercontent.com/lianyutian/tuchuang1/main/img/mysql20240528165755.png"></p>
<p>可以看到消息消费时消息顺序和发送顺序一致。</p>
<h4 id="5-5-消息过滤"><a href="#5-5-消息过滤" class="headerlink" title="5.5 消息过滤"></a>5.5 消息过滤</h4><p>消息过滤是指消息生产者向Topic中发送消息时，设置消息属性对消息进行分类，消费者订阅Topic时，根据消息属性设置过滤条件对消息进行过滤，只有符合过滤条件的消息才会被投递到消费端进行消费。</p>
<p><strong>消费者订阅Topic时若未设置过滤条件，无论消息发送时是否有设置过滤属性，Topic中的所有消息都将被投递到消费端进行消费。</strong></p>
<p>RocketMQ支持的消息过滤方式有两种，Tag过滤和SQL92过滤。</p>
<table>
<thead>
<tr>
<th>过滤方式</th>
<th>说明</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td>Tag过滤</td>
<td>消费者订阅的Tag和发送者设置的消息Tag相互匹配，则消息被投递给消费端进行消费。</td>
<td>简单过滤场景。一条消息支持设置一个Tag，仅需要对Topic中的消息进行一级分类并过滤时可以使用此方式。</td>
</tr>
<tr>
<td>SQL92过滤</td>
<td>发送者设置Tag或消息属性，消费者订阅满足SQL92过滤表达式的消息被投递给消费端进行消费。</td>
<td>复杂过滤场景。一条消息支持设置多个属性，可根据SQL语法自定义组合多种类型的表达式对消息进行多级分类并实现多维度的过滤。</td>
</tr>
</tbody></table>
<p><strong>Tag过滤</strong></p>
<p>Tag在生产者章节已经介绍过，用于对某个Topic下的消息进行分类。生产者在发送消息时，指定消息的Tag，消费者需根据已经指定的Tag来进行订阅。</p>
<p>以下图电商交易场景为例，从客户下单到收到商品这一过程会生产一系列消息，以如下消息为例：</p>
<ul>
<li>订单消息</li>
<li>支付消息</li>
<li>物流消息</li>
</ul>
<p>这些消息会发送到名称为Trade_Topic的Topic中，被各个不同的系统所订阅，以如下系统为例：</p>
<ul>
<li>支付系统：只需订阅支付消息。</li>
<li>物流系统：只需订阅物流消息。</li>
<li>实时计算系统：需要订阅所有和交易相关的消息。</li>
<li>交易成功率分析系统：需订阅订单和支付消息。</li>
</ul>
<p>过滤示意图如下所示</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/Tag%E8%BF%87%E6%BB%A4-844cfe6dd033746c7134bde843021ad6.png" alt="Tag过滤"></p>
<p>对于物流系统和支付系统来说，它们都只订阅单个Tag，此时只需要在调用subcribe接口时明确标明Tag即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(<span class="string">&quot;TagFilterTest&quot;</span>, <span class="string">&quot;TagA&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对于实时计算系统来说，它订阅交易Topic下所有的消息，Tag用星号（*）表示即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(<span class="string">&quot;TagFilterTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对于交易成功率分析系统来说，它订阅了订单和支付两个Tag的消息，在多个Tag之间用两个竖线（||）分隔即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(<span class="string">&quot;TagFilterTest&quot;</span>, <span class="string">&quot;TagA||TagB&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，如果同一个消费者多次订阅某个Topic下的Tag，以最后一次订阅为准。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如下错误代码中，Consumer只能订阅到TagFilterTest下TagB的消息，而不能订阅TagA的消息。</span></span><br><span class="line">consumer.subscribe(<span class="string">&quot;TagFilterTest&quot;</span>, <span class="string">&quot;TagA&quot;</span>);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;TagFilterTest&quot;</span>, <span class="string">&quot;TagB&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>SQL92过滤</strong></p>
<p>SQL92过滤是在消息发送时设置消息的Tag或自定义属性，消费者订阅时使用SQL语法设置过滤表达式，根据自定义属性或Tag过滤消息。</p>
<blockquote>
<p>Tag属于一种特殊的消息属性，在SQL语法中，Tag的属性值为TAGS。 开启属性过滤首先要在Broker端设置配置enablePropertyFilter&#x3D;true，该值默认为false。</p>
</blockquote>
<p>以下图电商交易场景为例，从客户下单到收到商品这一过程会生产一系列消息，按照类型将消息分为订单消息和物流消息，其中给物流消息定义地域属性，按照地域分为杭州和上海：</p>
<ul>
<li>订单消息</li>
<li>物流消息<ul>
<li>物流消息且地域为杭州</li>
<li>物流消息且地域为上海</li>
</ul>
</li>
</ul>
<p>这些消息会发送到名称为Trade_Topic的Topic中，被各个不同的系统所订阅，以如下系统为例：</p>
<ul>
<li>物流系统1：只需订阅物流消息且消息地域为杭州。</li>
<li>物流系统2：只需订阅物流消息且消息地域为杭州或上海。</li>
<li>订单跟踪系统：只需订阅订单消息。</li>
</ul>
<p>SQL92过滤示意图如下所示：</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/SQL92%E8%BF%87%E6%BB%A4-716732acb1aad27fc8e7a9e218ebaa65.png" alt="SQL92过滤"></p>
<p>地域将作为自定义属性设置在消息中。</p>
<ul>
<li>消息发送端： 设置消息的自定义属性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic&quot;</span>, <span class="string">&quot;tagA&quot;</span>, <span class="string">&quot;Hello MQ&quot;</span>.getBytes());</span><br><span class="line"><span class="comment">// 设置自定义属性A，属性值为1。</span></span><br><span class="line">msg.putUserProperties(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>消息消费端： 使用SQL语法设置过滤表达式，并根据自定义属性过滤消息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(<span class="string">&quot;SqlFilterTest&quot;</span>,</span><br><span class="line">    MessageSelector.bySql(<span class="string">&quot;(TAGS is not null and TAGS in (&#x27;TagA&#x27;, &#x27;TagB&#x27;))&quot;</span> +</span><br><span class="line">        <span class="string">&quot;and (a is not null and a between 0 and 3)&quot;</span>));</span><br></pre></td></tr></table></figure>



<h4 id="5-6-消息重试和死信队列"><a href="#5-6-消息重试和死信队列" class="headerlink" title="5.6 消息重试和死信队列"></a>5.6 消息重试和死信队列</h4><p><strong>消息重试</strong></p>
<p>若Consumer消费某条消息失败，则RocketMQ会在重试间隔时间后，将消息重新投递给Consumer消费，若达到最大重试次数后消息还没有成功被消费，则消息将被投递至死信队列。</p>
<blockquote>
<p>消息重试只针对集群消费模式生效；<strong>广播消费模式不提供失败重试特性</strong>，即消费失败后，失败消息不再重试，继续消费新的消息</p>
<ul>
<li>最大重试次数：消息消费失败后，可被重复投递的最大次数。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.setMaxReconsumeTimes(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>重试间隔：消息消费失败后再次被投递给Consumer消费的间隔时间，只在顺序消费中起作用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.setSuspendCurrentQueueTimeMillis(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>顺序消费和并发消费的重试机制并不相同，<strong>顺序消费消费失败后会先在客户端本地重试直到最大重试次数</strong>，这样可以避免消费失败的消息被跳过，消费下一条消息而打乱顺序消费的顺序，而<strong>并发消费消费失败后会将消费失败的消息重新投递回服务端</strong>，再等待服务端重新投递回来，在这期间会正常消费队列后面的消息。</p>
<blockquote>
<p>并发消费失败后并不是投递回原Topic，而是投递到一个特殊Topic，其命名为%RETRY%ConsumerGroupName，集群模式下并发消费每一个ConsumerGroup会对应一个特殊Topic，并会订阅该Topic。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRetryQueueConsumer</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException, IOException &#123;</span><br><span class="line">        <span class="comment">// 初始化consumer，并设置consumer group name</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;consumer-group&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置NameServer地址</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;117.72.71.187:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 订阅一个或多个topic，并指定tag过滤条件，这里指定*表示接收所有tag的消息</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TestTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置最大重试次数</span></span><br><span class="line">        consumer.setMaxReconsumeTimes(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 注册回调接口来处理从Broker中收到的消息</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动Consumer</span></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lianyutian/tuchuang1/main/img/mysql20240528174446.png"></p>
<p>可以看到消费失败时，会将消息传递到【%RETRY%ConsumerGroupName】Topic中</p>
<p>两者参数差别如下:</p>
<table>
<thead>
<tr>
<th>消费类型</th>
<th>重试间隔</th>
<th>最大重试次数</th>
</tr>
</thead>
<tbody><tr>
<td>顺序消费</td>
<td>间隔时间可通过自定义设置，SuspendCurrentQueueTimeMillis</td>
<td>最大重试次数可通过自定义参数MaxReconsumeTimes取值进行配置。该参数取值无最大限制。若未设置参数值，默认最大重试次数为Integer.MAX</td>
</tr>
<tr>
<td>并发消费</td>
<td>间隔时间根据重试次数阶梯变化，取值范围：1秒～2小时。不支持自定义配置</td>
<td>最大重试次数可通过自定义参数MaxReconsumeTimes取值进行配置。默认值为16次，该参数取值无最大限制，建议使用默认值</td>
</tr>
</tbody></table>
<p>并发消费重试间隔如下，可以看到与延迟消息第三个等级开始的时间完全一致。</p>
<table>
<thead>
<tr>
<th>第几次重试</th>
<th>与上次重试的间隔时间</th>
<th>第几次重试</th>
<th>与上次重试的间隔时间</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>10s</td>
<td>9</td>
<td>7min</td>
</tr>
<tr>
<td>2</td>
<td>30s</td>
<td>10</td>
<td>8min</td>
</tr>
<tr>
<td>3</td>
<td>1min</td>
<td>11</td>
<td>9min</td>
</tr>
<tr>
<td>4</td>
<td>2min</td>
<td>12</td>
<td>10min</td>
</tr>
<tr>
<td>5</td>
<td>3min</td>
<td>13</td>
<td>20min</td>
</tr>
<tr>
<td>6</td>
<td>4min</td>
<td>14</td>
<td>30min</td>
</tr>
<tr>
<td>7</td>
<td>5min</td>
<td>15</td>
<td>1h</td>
</tr>
<tr>
<td>8</td>
<td>6min</td>
<td>16</td>
<td>2h</td>
</tr>
</tbody></table>
<p><strong>死信队列</strong></p>
<p>当一条消息初次消费失败，RocketMQ会自动进行消息重试，达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息。此时，该消息不会立刻被丢弃，而是将其发送到该消费者对应的特殊队列中，这类消息称为死信消息（Dead-Letter Message），存储死信消息的特殊队列称为死信队列（Dead-Letter Queue），死信队列是死信Topic下分区数唯一的单独队列。如果产生了死信消息，那对应的ConsumerGroup的死信Topic名称为%DLQ%ConsumerGroupName，死信队列的消息将不会再被消费。可以利用RocketMQ Admin工具或者RocketMQ Dashboard上查询到对应死信消息的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeadQueueConsumer</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException, IOException &#123;</span><br><span class="line">        <span class="comment">// 初始化consumer，并设置consumer group name</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;consumer-group&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置NameServer地址</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;117.72.71.187:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//订阅一个或多个topic，并指定tag过滤条件，这里指定*表示接收所有tag的消息</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TestTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        consumer.setMaxReconsumeTimes(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//注册回调接口来处理从Broker中收到的消息</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerOrderly</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeOrderlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 启动Consumer</span></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lianyutian/tuchuang1/main/img/mysql20240528174847.png"></p>
<p>可以看到达到最大重试次数后，消费依然失败会将消息传递到【%DLQ%ConsumerGroupName】Topic中。</p>
<h4 id="5-7-Pull消费"><a href="#5-7-Pull消费" class="headerlink" title="5.7 Pull消费"></a>5.7 Pull消费</h4><p>在RocketMQ中有两种Pull方式，一种是比较原始<code>Pull Consumer</code>，它不提供相关的订阅方法，需要调用pull方法时指定队列进行拉取，并需要自己更新位点。另一种是<code>Lite Pull Consumer</code>，它提供了Subscribe和Assign两种方式，使用起来更加方便。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

</article>
<div class="article-footer">

</div>

<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">回顾上一篇</div><a href="/wiki/RocketMQ/RocketMQ1/">RocketMQ快速安装</a></div><div class="item" id="next"></div></section></div>




<footer class="page-footer footnote"><hr><div class="text"><div>
<span id="runtime_span"></span>
<script type="text/javascript">
function show_runtime() {
    window.setTimeout("show_runtime()", 1000);
    X = new Date("2023/11/20 17:00:00"); // 网站开始运行的日期和时间
    Y = new Date(); // 当前日期和时间
    T = (Y.getTime() - X.getTime()); // 网站运行的总毫秒数
    M = 24 * 60 * 60 * 1000; // 一天的毫秒数
    a = T / M; // 总天数
    A = Math.floor(a); // 总天数的整数部分
    b = (a - A) * 24; // 总小时数
    B = Math.floor(b); // 总小时数的整数部分
    c = (b - B) * 60; // 总分钟数
    C = Math.floor((b - B) * 60); // 总分钟数的整数部分
    D = Math.floor((c - C) * 60); // 总秒数
    runtime_span.innerHTML = "⏱️小破站至今运行 <span class='runtime'>" + A + "天" + B + "小时" + C + "分" + D + "秒</span>";
}
show_runtime();
</script> 
<img src="/assets/cat.gif" alt="" style="float: right; width: 30px;">
</div>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-RocketMQ%E5%9F%BA%E7%A1%80%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B"><span class="toc-text">1. RocketMQ基础消息模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-RocketMQ%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9E%8B"><span class="toc-text">2. RocketMQ扩展模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-text">3. 生产者</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%B6%88%E6%81%AF"><span class="toc-text">3.1 消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Tag"><span class="toc-text">3.2 Tag</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-Keys"><span class="toc-text">3.3 Keys</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E9%98%9F%E5%88%97"><span class="toc-text">3.4 队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-text">3.5 生产者</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E5%8F%8A%E6%B6%88%E8%B4%B9"><span class="toc-text">4. 消息生产及消费</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF"><span class="toc-text">4.1 普通消息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-1-%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF"><span class="toc-text">4.1.1 同步消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF"><span class="toc-text">4.1.2 异步消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-3-%E5%8D%95%E9%A1%B9%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.1.3 单项模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-text">4.2 顺序消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF"><span class="toc-text">4.3 延迟消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF"><span class="toc-text">4.4 批量消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-text">4.5 事务消息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">5. 消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-text">5.1 基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-1-%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E7%BB%84"><span class="toc-text">5.1.1 消费者与消费组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-2-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">5.1.2 负载均衡</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-3-%E6%B6%88%E8%B4%B9%E4%BD%8D%E7%82%B9"><span class="toc-text">5.1.3 消费位点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-4-%E6%8E%A8%E3%80%81%E6%8B%89%E5%92%8C%E9%95%BF%E8%BD%AE%E8%AF%A2"><span class="toc-text">5.1.4 推、拉和长轮询</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-Push%E6%B6%88%E8%B4%B9"><span class="toc-text">5.2 Push消费</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8F"><span class="toc-text">5.3 集群模式和广播模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9"><span class="toc-text">5.4 顺序消费</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4"><span class="toc-text">5.5 消息过滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95%E5%92%8C%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-text">5.6 消息重试和死信队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-Pull%E6%B6%88%E8%B4%B9"><span class="toc-text">5.7 Pull消费</span></a></li></ol></li></ol></div><div class="widget-footer"><a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ --><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5"><path stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/><path d="M7 3.338A9.95 9.95 0 0 1 12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12c0-1.821.487-3.53 1.338-5"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">


<script type="text/javascript">
  window.canonical = {"originalHost":null,"officialHosts":["localhost"],"encoded":""};
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
    tag_plugins: {
      chat: Object.assign({"api":"https://siteinfo.listentothewind.cn/api/v1"}),
    }
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"skip_search":null,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
    loading: `https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd`,
  };
  const deps = {
    jquery: `https://gcore.jsdelivr.net/npm/jquery@3.7/dist/jquery.min.js`,
    marked: `https://gcore.jsdelivr.net/npm/marked@13.0/lib/marked.umd.min.js`,
    lazyload: `/%5Bobject%20Object%5D`
  }
  

</script>

<script type="text/javascript">
  
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = () => {
          utils.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) => {
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index, 1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }

  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')) {
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function () {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },

    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      const maxRetry = 3;
      let retryCount = 0;

      return new Promise((resolve, reject) => {
        const load = () => {
          utils.onLoading?.(el);

          let timedOut = false;
          const timeout = setTimeout(() => {
            timedOut = true;
            console.warn('[request] 超时:', url);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject('请求超时');
            } else {
              setTimeout(load, 1000);
            }
          }, 5000);

          fetch(url).then(resp => {
            if (timedOut) return;
            clearTimeout(timeout);

            if (!resp.ok) throw new Error('响应失败');
            return resp;
          }).then(data => {
            if (timedOut) return;
            utils.onLoadSuccess?.(el);
            callback(data);
            resolve(data);
          }).catch(err => {
            clearTimeout(timeout);
            console.warn('[request] 错误:', err);

            if (++retryCount >= maxRetry) {
              utils.onLoadFailure?.(el);
              onFailure?.();
              reject(err);
            } else {
              setTimeout(load, 1000);
            }
          });
        };

        load();
      });
    },
    requestWithoutLoading: (url, options = {}, maxRetry = 2, timeout = 5000) => {
      return new Promise((resolve, reject) => {
        let retryCount = 0;

        const tryRequest = () => {
          let timedOut = false;
          const timer = setTimeout(() => {
            timedOut = true;
            if (++retryCount > maxRetry) reject('timeout');
            else tryRequest();
          }, timeout);

          fetch(url, options)
            .then(resp => {
              clearTimeout(timer);
              if (!resp.ok) throw new Error('bad response');
              resolve(resp);
            })
            .catch(err => {
              clearTimeout(timer);
              if (++retryCount > maxRetry) reject(err);
              else setTimeout(tryRequest, 500);
            });
        };

        tryRequest();
      });
    },
    /********************** requestAnimationFrame ********************************/
    // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
    // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
    requestAnimationFrame: (fn) => {
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
      }
      window.requestAnimationFrame(fn)
    },
    dark: {},
  };

  // utils.dark.mode 当前模式 dark or light
  // utils.dark.toggle() 暗黑模式触发器
  // utils.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  utils.dark.method = {
    toggle: new RunItem(),
  };
  utils.dark = Object.assign(utils.dark, {
    push: utils.dark.method.toggle.push,
  });
</script>
<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>
<script type="text/javascript">
  (() => {
    const tagSwitchers = document.querySelectorAll('.tag-subtree.parent-tag > a > .tag-switcher-wrapper')
    for (const tagSwitcher of tagSwitchers) {
      tagSwitcher.addEventListener('click', (e) => {
        const parent = e.target.closest('.tag-subtree.parent-tag')
        parent.classList.toggle('expanded')
        e.preventDefault()
      })
    }

    // Get active tag from query string, then activate it.
    const urlParams = new URLSearchParams(window.location.search)
    const activeTag = urlParams.get('tag')
    if (activeTag) {
      let tag = document.querySelector(`.tag-subtree[data-tag="${activeTag}"]`)
      if (tag) {
        tag.querySelector('a').classList.add('active')
        
        while (tag) {
          tag.classList.add('expanded')
          tag = tag.parentElement.closest('.tag-subtree.parent-tag')
        }
      }
    }
  })()
</script>

<script async src="https://gcore.jsdelivr.net/npm/vanilla-lazyload@19.1/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
    callback_loaded: (el) => {
      el.classList.add('loaded');
      const wrapper = el.closest('.lazy-box');
      const icon = wrapper?.querySelector('.lazy-icon');
      if (icon) icon.remove();
    }
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });

  window.wrapLazyloadImages = (container) => {
    if (typeof container === 'string') {
      container = document.querySelector(container);
    }
    if (!container) return;
    
    const images = container.querySelectorAll('img');
    images.forEach((img) => {
      if (img.classList.contains('lazy')) return;

      const src = img.getAttribute('src');
      if (!src) return;

      const wrapper = document.createElement('div');
      wrapper.className = 'lazy-box';

      const newImg = img.cloneNode();
      newImg.removeAttribute('src');
      newImg.setAttribute('data-src', src);
      newImg.classList.add('lazy');

      const icon = document.createElement('div');
      icon.className = 'lazy-icon';
      if (def.loading) {
        icon.style.backgroundImage = `url("${def.loading}")`;
      }

      wrapper.appendChild(newImg);
      wrapper.appendChild(icon);

      img.replaceWith(wrapper);
    });

    // 通知 LazyLoad 更新
    if (window.lazyLoadInstance?.update) {
      window.lazyLoadInstance.update();
    }
  }
  
</script>

<!-- required -->
<script src="/js/main.js?v=1.33.1" defer></script>

<script type="text/javascript">
  const applyTheme = (theme) => {
    if (theme === 'auto') {
      document.documentElement.removeAttribute('data-theme')
    } else {
      document.documentElement.setAttribute('data-theme', theme)
    }

    // applyThemeToGiscus(theme)
  }

  // FIXME: 这会导致无法使用 preferred_color_scheme 以外的主题
  const applyThemeToGiscus = (theme) => {
    // theme = theme === 'auto' ? 'preferred_color_scheme' : theme
    const cmt = document.getElementById('giscus')
    if (cmt) {
      // This works before giscus load.
      cmt.setAttribute('data-theme', theme)
    }

    const iframe = document.querySelector('#comments > section.giscus > iframe')
    if (iframe) {
      // This works after giscus loaded.
      const src = iframe.src
      const newSrc = src.replace(/theme=[\w]+/, `theme=${theme}`)
      iframe.src = newSrc
    }
  }

  const switchTheme = () => {
    // light -> dark -> auto -> light -> ...
    const currentTheme = document.documentElement.getAttribute('data-theme')
    let newTheme;
    switch (currentTheme) {
      case 'light':
        newTheme = 'dark'
        break
      case 'dark':
        newTheme = 'auto'
        break
      default:
        newTheme = 'light'
    }
    applyTheme(newTheme)
    window.localStorage.setItem('Stellar.theme', newTheme)
    utils.dark.mode = newTheme === 'auto' ? (window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light") : newTheme;
    utils.dark.method.toggle.start();

    const messages = {
      light: `切换到浅色模式`,
      dark: `切换到深色模式`,
      auto: `切换到跟随系统配色`,
    }
    hud?.toast?.(messages[newTheme])
  }

  (() => {
    // Apply user's preferred theme, if any.
    const theme = window.localStorage.getItem('Stellar.theme')
    if (theme !== null) {
      applyTheme(theme)
    } else {
      utils.dark.mode = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    utils.dark.method.toggle.start();
  })()
</script>


<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"rating":{"js":"/js/services/rating.js","api":"https://star-vote.xaox.cc/api/rating"},"vote":{"js":"/js/services/vote.js","api":"https://star-vote.xaox.cc/api/vote"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"friends_and_posts":{"js":"/js/services/friends_and_posts.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"},"voice":{"js":"/js/plugins/voice.js"},"video":{"js":"/js/plugins/video.js"},"download-file":{"js":"/js/plugins/download-file.js"},"twikoo":{"js":"/js/services/twikoo_latest_comment.js"},"waline":{"js":"/js/services/waline_latest_comment.js"},"artalk":{"js":"/js/services/artalk_latest_comment.js"},"giscus":{"js":"/js/services/giscus_latest_comment.js"},"contributors":{"edit_this_page":{"_posts/":null,"wiki/stellar/":"https://github.com/xaoxuu/hexo-theme-stellar-docs/blob/main/"},"js":"/js/services/contributors.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else if (id == 'voice') {
        ctx.voiceAudios = document.querySelectorAll('.voice>audio');
        if (ctx.voiceAudios?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            createVoiceDom(ctx.voiceAudios);
          });
        }
      } else if (id == 'video') {
        ctx.videos = document.querySelectorAll('.video>video');
        if (ctx.videos?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            videoEvents(ctx.videos);
          });
        }
      } else if (id == 'download-file') {
        ctx.files = document.querySelectorAll('.file');
        if (ctx.files?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            downloadFileEvent(ctx.files);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }

    // chat iphone time
    let phoneTimes = document.querySelectorAll('.chat .status-bar .time');

    if (phoneTimes.length > 0) {
      NowTime();
      var date = new Date();
      var sec = date.getSeconds();
      var firstAdjustInterval = setInterval(firstAdjustTime, 1000 * (60 - sec));
    }

    function firstAdjustTime() {
      NowTime();
      clearInterval(firstAdjustInterval);
      setInterval(NowTime, 1000 * 60);
    }

    function NowTime() {
      for (let i = 0; i < phoneTimes.length; ++i) {
        var timeSpan = phoneTimes[i];
        var date = new Date();
        var hour = date.getHours();
        var min = date.getMinutes();
        timeSpan.innerHTML = check(hour) + ":" + check(min);
      }
    };

    function check(val) {
      if (val < 10) {
        return ("0" + val);
      }
      return (val);
    }

    // chat quote
    const chat_quote_obverser = new IntersectionObserver((entries, observer) => {
      entries.filter((entry) => { return entry.isIntersecting }).sort((a, b) => a.intersectionRect.y !== b.intersectionRect.y ? a.intersectionRect.y - b.intersectionRect.y : a.intersectionRect.x - b.intersectionRect.x).forEach((entry, index) => {
          observer.unobserve(entry.target);
          setTimeout(() => {
            entry.target.classList.add('quote-blink');
            setTimeout(() => {
              entry.target.classList.remove('quote-blink');
            }, 1000);
          }, Math.max(100, 16) * (index + 1));
        });
    });

    var chatQuotes = document.querySelectorAll(".chat .talk .quote");
    chatQuotes.forEach((quote) => {
      quote.addEventListener('click', function () {
        var chatCellDom = document.getElementById("quote-" + quote.getAttribute("quotedCellTag"));
        if (chatCellDom) {
          var chatDiv = chatCellDom.parentElement;
          var mid = chatDiv.clientHeight / 2;
          var offsetTop = chatCellDom.offsetTop;
          if (offsetTop > mid - chatCellDom.clientHeight / 2) {
            chatDiv.scrollTo({
              top: chatCellDom.offsetTop - mid + chatCellDom.clientHeight / 2,
              behavior: "smooth"
            });
          } else {
            chatDiv.scrollTo({
              top: 0,
              behavior: "smooth"
            });
          }
          chat_quote_obverser.observe(chatCellDom);
        }
      });
    });
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://gcore.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js"></script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css`,
    js: `https://gcore.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js`
  };
  var selector = '[data-fancybox]:not(.error), .with-fancybox .atk-content img:not([atk-emoticon])';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const memos = document.getElementsByClassName('ds-memos');
    if (memos != undefined && memos.length > 0) {
      needFancybox = true;
    }
    const fancybox = document.getElementsByClassName('with-fancybox');
    if (fancybox != undefined && fancybox.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
